{"id": "de22566d-f706-45b1-b6f5-43885b62de76", "code": "# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=60):\n    \"\"\"\n    Given fixed center positions, find a set of radii that maximize\n    the sum while satisfying the non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the four walls of the unit square\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dists, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several random greedy orders to maximize the sum of radii\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Greedy allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            for j in range(n):\n                if r[j] > 0:\n                    r_limit = min(r_limit, dists[i, j] - r[j])\n            r[i] = max(0.0, r_limit)\n        # Phase 2: Iterative coordinate descent refinement to optimize slack\n        for _ in range(15):\n            for i in order:\n                r_limit = wall_dist[i]\n                for j in range(n):\n                    if i != j:\n                        r_limit = min(r_limit, dists[i, j] - r[j])\n                r[i] = max(0.0, r_limit)\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=2800, target_r=0.101):\n    \"\"\"\n    Apply a physics-inspired force-directed simulation to optimize\n    the placement of circle centers for maximizing available radius space.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.012\n    damping = 0.92\n\n    for step in range(n_steps):\n        # Pairwise repulsion calculation\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: push apart if centers are closer than 2*target_r\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        force_mag = overlap / (dists + 1e-9)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Square boundary constraints (push centers towards the inner bounds)\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Velocity-based momentum update for stability\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule for convergence\n        if (step + 1) % 500 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    Iterates over multiple diverse layout initializations and performs\n    physics-based relaxation to maximize the total sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    layouts = []\n    # Diverse staggered grid patterns to provide varied starting conditions\n    # Each list represents the number of circles per row\n    patterns = [[5, 5, 6, 5, 5], [6, 4, 6, 4, 6], [5, 6, 5, 6, 4], [4, 6, 6, 6, 4]]\n    for p in patterns:\n        coords = []\n        for i, count in enumerate(p):\n            y = (i + 0.5) / len(p)\n            x_range = np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count)\n            for x in x_range:\n                coords.append([x, y])\n        layouts.append(np.array(coords))\n\n    # Phyllotaxis-based sunflower layout for circular-ish symmetry\n    phi = (1.0 + 5.0**0.5) / 2.0\n    theta_step = 2.0 * np.pi / (phi**2)\n    sunflower = []\n    for i in range(n):\n        r_val = 0.485 * np.sqrt((i + 0.5) / n)\n        theta = i * theta_step\n        sunflower.append([0.5 + r_val * np.cos(theta), 0.5 + r_val * np.sin(theta)])\n    layouts.append(np.array(sunflower))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore each base layout with different target radii parameters\n    for base_layout in layouts:\n        for t_rad in [0.098, 0.101]:\n            # Apply slight jitter to break layout symmetries\n            start_pos = np.clip(base_layout + np.random.normal(0, 0.002, (n, 2)), 0.0, 1.0)\n            refined_centers = relax_centers(start_pos, n_steps=2800, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_centers, trials=60)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_centers\n                best_overall_radii = radii\n\n    # Safety margin subtraction to ensure strict non-overlap and boundary validity\n    final_radii = best_overall_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n\n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")", "changes_description": null, "language": "python", "parent_id": "f0fc702a-a6c9-47ac-bf84-0107e408fe2d", "generation": 3, "timestamp": 1771869756.683781, "iteration_found": 42, "metrics": {"validity": 1.0, "sum_radii": 2.484998819478653, "target_ratio": 0.943073555779375, "combined_score": 0.943073555779375, "radius_variance": 8.373763634976624e-05, "spatial_spread": 0.1914369976701, "eval_time": 4.981327772140503}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.357445510082761, "target_ratio": 0.8946662277353933, "combined_score": 0.8946662277353933, "radius_variance": 0.005258080680508341, "spatial_spread": 0.1918837658776338, "eval_time": 0.8748102188110352}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.8947\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.8947\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n0.87s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.357446/2.635 = 0.8947\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.3574, target_ratio: 0.8947, combined_score: 0.8947, radius_variance: 0.0053, spatial_spread: 0.1919, eval_time: 0.8748\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4421, target_ratio: 0.9268, combined_score: 0.9268, radius_variance: 0.0006, spatial_spread: 0.1949, eval_time: 0.5775\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4636, target_ratio: 0.9350, combined_score: 0.9350, radius_variance: 0.0003, spatial_spread: 0.1940, eval_time: 3.2277\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9350)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii.\n\n    The algorithm employs a physics-based relaxation routine across\n    multiple initial configurations, followed by a robust radius\n    maximization solver based on greedy coordinate descent with \n    multiple random permutations.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def get_max_radii(centers, num_trials=50):\n        \"\"\"\n        Maximizes the sum of radii for fixed center positions using\n        greedy allocation and iterative coordinate descent.\n        \"\"\"\n        num_circles = centers.shape[0]\n        # Precompute pairwise distances between all centers\n        diffs = centers[:, None, :] - centers[None, :, :]\n        dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dist_matrix, 1e9)\n        \n        # Precompute distances from each center to the four walls\n        wall_dist = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n        \n        best_sum = -1.0\n        best_r = np.zeros(num_circles)\n        \n        for _ in range(num_trials):\n            r = np.zeros(num_circles)\n            order = np.random.permutation(num_circles)\n            # Greedy allocation phase: assign maximum possible radius in random order\n            for i in order:\n                limit = wall_dist[i]\n                for j in range(num_circles):\n                    if i != j and r[j] > 0:\n                        limit = min(limit, dist_matrix[i, j] - r[j])\n                r[i] = max(0.0, limit)\n            \n            # Coordinate descent refinement: iteratively expand each radius\n            for _ in range(10):\n                for i in order:\n                    limit = wall_dist[i]\n                    for j in range(num_circles):\n                        if i != j:\n                            limit = min(limit, dist_matrix[i, j] - r[j])\n                    r[i] = max(0.0, limit)\n            \n            curr_sum = np.sum(r)\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_r = r.copy()\n        return best_r, best_sum\n\n    def relax_centers(initial_centers, n_iter=4000):\n        \"\"\"Physics-based simulation to optimize center placement.\"\"\"\n        centers = initial_centers.copy()\n        lr = 0.02\n        target_d = 0.198  # Targeted diameter based on n=26 packing density\n        \n        for step in range(n_iter):\n            diffs = centers[:, None, :] - centers[None, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            np.fill_diagonal(dists, 1e-9)\n            \n            # Repulsion if centers are closer than target_d\n            overlap = target_d - dists\n            mask = overlap > 0\n            \n            # Calculate repulsion forces\n            force_dir = diffs / dists[:, :, None]\n            forces = np.sum(force_dir * (overlap[:, :, None] * mask[:, :, None]), axis=1)\n            \n            # Soft wall forces to push circles into the unit square boundaries\n            r_sim = target_d / 2.0\n            forces[:, 0] += np.where(centers[:, 0] < r_sim, r_sim - centers[:, 0], 0)\n            forces[:, 0] -= np.where(centers[:, 0] > 1.0 - r_sim, centers[:, 0] - (1.0 - r_sim), 0)\n            forces[:, 1] += np.where(centers[:, 1] < r_sim, r_sim - centers[:, 1], 0)\n            forces[:, 1] -= np.where(centers[:, 1] > 1.0 - r_sim, centers[:, 1] - (1.0 - r_sim), 0)\n            \n            # Update center coordinates\n            centers += lr * forces\n            centers = np.clip(centers, 0.0, 1.0)\n            \n            # Annealing of parameters to stabilize the layout\n            if (step + 1) % 250 == 0:\n                lr *= 0.9\n                target_d += 0.0001\n        return centers\n\n    # Diverse initialization strategies to avoid local minima\n    layouts = []\n    \n    # 1. Staggered grid (5-5-6-5-5)\n    c1 = []\n    for i, count in enumerate([5, 5, 6, 5, 5]):\n        y = (i + 0.5) / 5.0\n        xs = np.linspace(1.0/(2*count), 1.0 - 1.0/(2*count), count)\n        for x in xs:\n            c1.append([x, y])\n    layouts.append(np.array(c1))\n    \n    # 2. Phyllotaxis (Sunflower) layout for circular boundary symmetry\n    c2 = []\n    phi = (1.0 + 5.0**0.5) / 2.0\n    for i in range(n):\n        r_val = 0.48 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * phi * (i + 0.5)\n        c2.append([0.5 + r_val * np.cos(theta), 0.5 + r_val * np.sin(theta)])\n    layouts.append(np.array(c2))\n    \n    # 3. Alternative distribution (6-4-6-4-6)\n    c3 = []\n    for i, count in enumerate([6, 4, 6, 4, 6]):\n        y = (i + 0.5) / 5.0\n        xs = np.linspace(1.0/(2*count), 1.0 - 1.0/(2*count), count)\n        for x in xs:\n            c3.append([x, y])\n    layouts.append(np.array(c3))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Evaluate each layout with stochastic jitter\n    for base_layout in layouts:\n        for _ in range(2):\n            # Apply initial random noise to break layout symmetry\n            start_pos = np.clip(base_layout + np.random.normal(0, 0.005, (n, 2)), 0.0, 1.0)\n            refined_centers = relax_centers(start_pos)\n            radii, current_sum = get_max_radii(refined_centers)\n            \n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_centers\n                best_overall_radii = radii\n                \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"Execution entry point for n=26 packing optimization.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4636), Performs well on target_ratio (0.9350), Performs well on combined_score (0.9350), Performs well on radius_variance (0.0003), Performs well on spatial_spread (0.1940), Performs well on eval_time (3.2277)\n\n### Program 2 (Score: 0.9268)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Given center positions, calculate radii to maximize the sum of radii\n    while ensuring no overlaps and staying within the unit square.\n    Uses a multi-pass randomized greedy expansion to maximize the total sum.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the four walls (left, bottom, right, top)\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pre-calculate pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.linalg.norm(diffs, axis=2)\n    # Use a large value on the diagonal to ignore self-distance\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try different randomized greedy orders to find a higher sum of radii\n    for _ in range(50):\n        radii = np.zeros(n)\n        # Randomized order of circles to expand\n        order = np.random.permutation(n)\n        \n        # Pass 1: Forward expansion (circles claim available space)\n        for i in order:\n            # Radius limited by square boundaries\n            r_i = wall_dist[i]\n            # Radius also limited by distances to already-expanded neighbors\n            for j in range(n):\n                if i != j:\n                    r_i = min(r_i, dists[i, j] - radii[j])\n            radii[i] = max(0.0, r_i)\n            \n        # Pass 2: Backward refinement to utilize any remaining slack\n        for i in reversed(order):\n            r_i = wall_dist[i]\n            for j in range(n):\n                if i != j:\n                    r_i = min(r_i, dists[i, j] - radii[j])\n            radii[i] = max(radii[i], r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    # Final robust safety pass for strict validity against floating point errors\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dists[i, j]\n                if best_radii[i] + best_radii[j] > d:\n                    overlap = (best_radii[i] + best_radii[j] - d) + 1e-14\n                    best_radii[i] = max(0.0, best_radii[i] - overlap / 2.0)\n                    best_radii[j] = max(0.0, best_radii[j] - overlap / 2.0)\n    \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    Uses a physics-based repulsion model to distribute centers efficiently.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # Initialization: Staggered grid layout (5-5-6-5-5 configuration)\n    centers_list = []\n    counts = [5, 5, 6, 5, 5]\n    y_coords = np.linspace(0.1, 0.9, 5)\n    for i, count in enumerate(counts):\n        x_coords = np.linspace(0.1, 0.9, count)\n        for x in x_coords:\n            centers_list.append([x, y_coords[i]])\n    \n    centers = np.array(centers_list)\n    # Add small random jitter to break initial grid symmetry\n    centers += np.random.normal(0, 0.002, (n, 2))\n    centers = np.clip(centers, 0, 1)\n\n    # Physics simulation parameters\n    n_iter = 5000\n    eta = 0.03  # Learning rate for center movement\n    r_phys = 0.098  # Target radius used for repulsion force calculation\n    \n    for step in range(n_iter):\n        # Calculate pairwise center distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.linalg.norm(diffs, axis=2)\n        np.fill_diagonal(dists, 1e10)\n        \n        # Calculate repulsion forces between circles within target distance\n        target_dist = 2 * r_phys\n        mask = (dists < target_dist) & (dists > 0)\n        \n        # Repulsion force magnitude (proportional to overlap)\n        f_mag = np.zeros_like(dists)\n        f_mag[mask] = (target_dist - dists[mask]) / dists[mask]\n        \n        # Aggregate pairwise repulsion forces\n        forces = np.sum(diffs * f_mag[:, :, np.newaxis], axis=1)\n        \n        # Add boundary repulsion forces to encourage circles to stay within the square\n        forces[:, 0] += np.maximum(0, r_phys - centers[:, 0])\n        forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_phys))\n        forces[:, 1] += np.maximum(0, r_phys - centers[:, 1])\n        forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_phys))\n        \n        # Update center positions\n        centers += eta * forces\n        # Simulated annealing: apply small decaying noise to escape local optima\n        if step < n_iter // 2:\n            centers += np.random.normal(0, 0.0001 * (1 - step / (n_iter // 2)), (n, 2))\n        \n        centers = np.clip(centers, 0, 1)\n        \n        # Gradually increase target radius and decay learning rate for convergence\n        if (step + 1) % 400 == 0:\n            eta *= 0.94\n            r_phys += 0.0005\n\n    # Compute final maximum valid radii for the optimized centers\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4421), Performs well on target_ratio (0.9268), Performs well on combined_score (0.9268), Performs well on radius_variance (0.0006), Performs well on spatial_spread (0.1949), Performs well on eval_time (0.5775)\n\n### Program 3 (Score: 0.8947)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Given center positions, calculate radii to maximize the sum of radii\n    while ensuring no overlaps and staying within the unit square.\n    Uses a multi-pass randomized greedy expansion and coordinate descent refinement.\n    \"\"\"\n    n = centers.shape[0]\n    # Pre-calculate distances to the four walls (left, bottom, right, top)\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pre-calculate pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a large value on the diagonal to ignore self-distance\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try different randomized greedy orders to find a higher sum of radii\n    for _ in range(40):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Greedy allocation\n        for i in order:\n            r_i = wall_dist[i]\n            for j in range(n):\n                if i != j and radii[j] > 0:\n                    r_i = min(r_i, dists[i, j] - radii[j])\n            radii[i] = max(0.0, r_i)\n            \n        # Refine radii iteratively using coordinate descent\n        for _ in range(15):\n            for i in range(n):\n                r_i = wall_dist[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dists[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    # Subtract a tiny epsilon to ensure strict validity against floating point noise\n    best_radii -= 1e-12\n    best_radii = np.maximum(best_radii, 0.0)\n    \n    return best_radii, np.sum(best_radii)\n\n\ndef relax_centers(centers, n_iter=3000):\n    \"\"\"\n    Physics-based simulation to optimize center placement.\n    Uses repulsion forces and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    velocity = np.zeros_like(centers)\n    r_target = 0.099  # Heuristic target radius for n=26\n    dt = 0.015\n    damping = 0.9\n    \n    for step in range(n_iter):\n        # Calculate pairwise forces\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1.0)\n        \n        # Repulsion force: push apart if closer than 2 * r_target\n        target_dist = 2 * r_target\n        overlap = np.maximum(0, target_dist - dists)\n        force_mag = (overlap / (dists + 1e-9))\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n        \n        # Boundary forces to keep centers within [r_target, 1-r_target]\n        forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n        forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n        forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n        forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n        \n        # Update velocities and positions (Momentum-based)\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Cooling schedule: reduce step size and adjust target distance\n        if (step + 1) % 500 == 0:\n            dt *= 0.8\n            r_target += 0.0002\n            \n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    \"\"\"\n    n = 26\n    np.random.seed(123)\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Initialization Strategy 1: Staggered grid (5-5-6-5-5)\n    c1 = []\n    counts = [5, 5, 6, 5, 5]\n    for i, count in enumerate(counts):\n        y = (i + 0.5) / 5.0\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            c1.append([x, y])\n    \n    # Initialization Strategy 2: Different staggered layout (4-5-4-5-4-4)\n    c2 = []\n    counts2 = [4, 5, 4, 5, 4, 4]\n    for i, count in enumerate(counts2):\n        y = (i + 0.5) / 6.0\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            c2.append([x, y])\n            \n    layouts = [np.array(c1), np.array(c2)]\n    \n    # Run optimization for each layout\n    for base_layout in layouts:\n        # Apply slight jitter to break symmetries\n        start_pos = np.clip(base_layout + np.random.normal(0, 0.005, (n, 2)), 0.0, 1.0)\n        refined_centers = relax_centers(start_pos)\n        radii, current_sum = compute_max_radii(refined_centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = refined_centers\n            best_overall_radii = radii\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"Entry point for evaluation.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.3574), Performs well on target_ratio (0.8947), Performs well on combined_score (0.8947), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.1919), Performs well on eval_time (0.8748)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.4412)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using a physics-based simulation with a staggered grid initialization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    centers_list = []\n    # Initialize 26 centers using a staggered grid (5-5-6-5-5 layout)\n    y_coords = [0.1, 0.29, 0.48, 0.67, 0.86]\n    counts = [5, 5, 6, 5, 5]\n    for i, count in enumerate(counts):\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            centers_list.append([x, y_coords[i]])\n    \n    centers = np.array(centers_list)\n\n    # Physics simulation parameters\n    n_iter = 2500\n    r_target = 0.098\n    eta = 0.02  # Initial learning rate\n    \n    # Run the simulation to relax the circles into a tight packing\n    for step in range(n_iter):\n        forces = np.zeros((n, 2))\n        # Circle-circle repulsion forces\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                target_dist = 2 * r_target\n                if dist < target_dist:\n                    force_mag = (target_dist - dist)\n                    direction = diff / (dist + 1e-9)\n                    forces[i] += direction * force_mag\n                    forces[j] -= direction * force_mag\n            \n            # Wall repulsion forces\n            for dim in range(2):\n                if centers[i, dim] < r_target:\n                    forces[i, dim] += (r_target - centers[i, dim])\n                elif centers[i, dim] > 1 - r_target:\n                    forces[i, dim] -= (centers[i, dim] - (1 - r_target))\n        \n        # Update centers based on forces\n        centers += eta * forces\n        centers = np.clip(centers, 0, 1)\n        \n        # Periodically increase target radius and decay learning rate\n        if (step + 1) % 500 == 0:\n            r_target += 0.001\n            eta *= 0.8\n\n    # Compute maximum valid radii for the final center configuration\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute maximum possible radii for fixed centers to maximize the sum.\n    Ensures circles stay within the unit square and do not overlap.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    # Initialize radii with distances to the square boundaries\n    radii = np.array([min(c[0], c[1], 1 - c[0], 1 - c[1]) for c in centers])\n    \n    # Pre-calculate distances between all pairs of centers\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist_matrix[i, j] = dist_matrix[j, i] = np.linalg.norm(centers[i] - centers[j])\n    \n    # Use iterative refinement to adjust radii so that they touch but do not overlap\n    # This greedy approach attempts to maximize the sum of radii for given centers.\n    for _ in range(150):\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                # If circles i and j overlap, shrink them equally to the point of contact\n                if radii[i] + radii[j] > dist_matrix[i, j]:\n                    overlap = (radii[i] + radii[j] - dist_matrix[i, j])\n                    shrink = overlap / 2.0\n                    radii[i] = max(0.0, radii[i] - shrink)\n                    radii[j] = max(0.0, radii[j] - shrink)\n                    \n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5, edgecolor=\"black\")\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\", fontsize=8)\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n    This version uses an initial scaling followed by a greedy expansion.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    # Initialize radii limited by distance to square boundaries\n    radii = np.zeros(n)\n    for i in range(n):\n        radii[i] = min(centers[i, 0], 1 - centers[i, 0],\n                       centers[i, 1], 1 - centers[i, 1])\n\n    # Iteratively scale radii proportionally to resolve pairwise overlaps\n    for _ in range(100):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist:\n                    scale = dist / (radii[i] + radii[j])\n                    radii[i] *= scale\n                    radii[j] *= scale\n\n    # Greedy expansion pass to further maximize the sum of radii\n    # We attempt to increase each radius until it touches a wall or neighbor\n    for i in range(n):\n        limit = min(centers[i, 0], 1 - centers[i, 0],\n                    centers[i, 1], 1 - centers[i, 1])\n        for j in range(n):\n            if i != j:\n                dist = np.linalg.norm(centers[i] - centers[j])\n                limit = min(limit, dist - radii[j])\n        if limit > radii[i]:\n            radii[i] = max(0.0, limit)\n\n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    Uses a physics-based repulsion model to optimize center placement.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Initialization: 5x5 grid plus one overlapping circle at the center\n    grid_centers = []\n    for i in range(5):\n        for j in range(5):\n            grid_centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n    grid_centers.append([0.5, 0.5])\n    centers = np.array(grid_centers)\n\n    # Break symmetry and separate overlapping points using small random noise\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.005, centers.shape)\n\n    # Simulation parameters for iterative refinement\n    r_target = 0.098  # Target radius to aim for near-optimal equal packing\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9268, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Given center positions, calculate radii to maximize the sum of radii\n    while ensuring no overlaps and staying within the unit square.\n    Uses a multi-pass randomized greedy expansion to maximize the total sum.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the four walls (left, bottom, right, top)\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pre-calculate pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.linalg.norm(diffs, axis=2)\n    # Use a large value on the diagonal to ignore self-distance\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try different randomized greedy orders to find a higher sum of radii\n    for _ in range(50):\n        radii = np.zeros(n)\n        # Randomized order of circles to expand\n        order = np.random.permutation(n)\n        \n        # Pass 1: Forward expansion (circles claim available space)\n        for i in order:\n            # Radius limited by square boundaries\n            r_i = wall_dist[i]\n            # Radius also limited by distances to already-expanded neighbors\n            for j in range(n):\n                if i != j:\n                    r_i = min(r_i, dists[i, j] - radii[j])\n            radii[i] = max(0.0, r_i)\n            \n        # Pass 2: Backward refinement to utilize any remaining slack\n        for i in reversed(order):\n            r_i = wall_dist[i]\n            for j in range(n):\n                if i != j:\n                    r_i = min(r_i, dists[i, j] - radii[j])\n            radii[i] = max(radii[i], r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    # Final robust safety pass for strict validity against floating point errors\n    for _ in range(10):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dists[i, j]\n                if best_radii[i] + best_radii[j] > d:\n                    overlap = (best_radii[i] + best_radii[j] - d) + 1e-14\n                    best_radii[i] = max(0.0, best_radii[i] - overlap / 2.0)\n                    best_radii[j] = max(0.0, best_radii[j] - overlap / 2.0)\n    \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    Uses a physics-based repulsion model to distribute centers efficiently.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # Initialization: Staggered grid layout (5-5-6-5-5 configuration)\n    centers_list = []\n    counts = [5, 5, 6, 5, 5]\n    y_coords = np.linspace(0.1, 0.9, 5)\n    for i, count in enumerate(counts):\n        x_coords = np.linspace(0.1, 0.9, count)\n        for x in x_coords:\n            centers_list.append([x, y_coords[i]])\n    \n    centers = np.array(centers_list)\n    # Add small random jitter to break initial grid symmetry\n    centers += np.random.normal(0, 0.002, (n, 2))\n    centers = np.clip(centers, 0, 1)\n\n    # Physics simulation parameters\n    n_iter = 5000\n    eta = 0.03  # Learning rate for center movement\n    r_phys = 0.098  # Target radius used for repulsion force calculation\n    \n    for step in range(n_iter):\n        # Calculate pairwise center distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.linalg.norm(diffs, axis=2)\n        np.fill_diagonal(dists, 1e10)\n        \n        # Calculate repulsion forces between circles within target distance\n        target_dist = 2 * r_phys\n        mask = (dists < target_dist) & (dists > 0)\n        \n        # Repulsion force magnitude (proportional to overlap)\n        f_mag = np.zeros_like(dists)\n        f_mag[mask] = (target_dist - dists[mask]) / dists[mask]\n        \n        # Aggregate pairwise repulsion forces\n        forces = np.sum(diffs * f_mag[:, :, np.newaxis], axis=1)\n        \n        # Add boundary repulsion forces to encourage circles to stay within the square\n        forces[:, 0] += np.maximum(0, r_phys - centers[:, 0])\n        forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_phys))\n        forces[:, 1] += np.maximum(0, r_phys - centers[:, 1])\n        forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_phys))\n        \n        # Update center positions\n        centers += eta * forces\n        # Simulated annealing: apply small decaying noise to escape local optima\n        if step < n_iter // 2:\n            centers += np.random.normal(0, 0.0001 * (1 - step / (n_iter // 2)), (n, 2))\n        \n        centers = np.clip(centers, 0, 1)\n        \n        # Gradually increase target radius and decay learning rate for convergence\n        if (step + 1) % 400 == 0:\n            eta *= 0.94\n            r_phys += 0.0005\n\n    # Compute final maximum valid radii for the optimized centers\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.4412, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using a physics-based simulation with a staggered grid initialization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    centers_list = []\n    # Initialize 26 centers using a staggered grid (5-5-6-5-5 layout)\n    y_coords = [0.1, 0.29, 0.48, 0.67, 0.86]\n    counts = [5, 5, 6, 5, 5]\n    for i, count in enumerate(counts):\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            centers_list.append([x, y_coords[i]])\n    \n    centers = np.array(centers_list)\n\n    # Physics simulation parameters\n    n_iter = 2500\n    r_target = 0.098\n    eta = 0.02  # Initial learning rate\n    \n    # Run the simulation to relax the circles into a tight packing\n    for step in range(n_iter):\n        forces = np.zeros((n, 2))\n        # Circle-circle repulsion forces\n        for i in range(n):\n            for j in range(i + 1, n):\n                diff = centers[i] - centers[j]\n                dist = np.linalg.norm(diff)\n                target_dist = 2 * r_target\n                if dist < target_dist:\n                    force_mag = (target_dist - dist)\n                    direction = diff / (dist + 1e-9)\n                    forces[i] += direction * force_mag\n                    forces[j] -= direction * force_mag\n            \n            # Wall repulsion forces\n            for dim in range(2):\n                if centers[i, dim] < r_target:\n                    forces[i, dim] += (r_target - centers[i, dim])\n                elif centers[i, dim] > 1 - r_target:\n                    forces[i, dim] -= (centers[i, dim] - (1 - r_target))\n        \n        # Update centers based on forces\n        centers += eta * forces\n        centers = np.clip(centers, 0, 1)\n        \n        # Periodically increase target radius and decay learning rate\n        if (step + 1) % 500 == 0:\n            r_target += 0.001\n            eta *= 0.8\n\n    # Compute maximum valid radii for the final center configuration\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute maximum possible radii for fixed centers to maximize the sum.\n    Ensures circles stay within the unit square and do not overlap.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    # Initialize radii with distances to the square boundaries\n    radii = np.array([min(c[0], c[1], 1 - c[0], 1 - c[1]) for c in centers])\n    \n    # Pre-calculate distances between all pairs of centers\n    dist_matrix = np.zeros((n, n))\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist_matrix[i, j] = dist_matrix[j, i] = np.linalg.norm(centers[i] - centers[j])\n    \n    # Use iterative refinement to adjust radii so that they touch but do not overlap\n    # This greedy approach attempts to maximize the sum of radii for given centers.\n    for _ in range(150):\n        for i in range(n):\n            for j in range(n):\n                if i == j:\n                    continue\n                # If circles i and j overlap, shrink them equally to the point of contact\n                if radii[i] + radii[j] > dist_matrix[i, j]:\n                    overlap = (radii[i] + radii[j] - dist_matrix[i, j])\n                    shrink = overlap / 2.0\n                    radii[i] = max(0.0, radii[i] - shrink)\n                    radii[j] = max(0.0, radii[j] - shrink)\n                    \n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5, edgecolor=\"black\")\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\", fontsize=8)\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Optimized circle packing for n=26 in a unit square to maximize the sum of radii.\n    The method uses a physics-based repulsion simulation to distribute centers efficiently\n    and then applies a randomized coordinate descent algorithm to maximize the sum\n    of radii subject to non-overlap and boundary constraints.\n    \"\"\"\n    n = 26\n    # Initialization: 5x5 grid + 1 extra circle.\n    # We place 25 circles in a 5x5 grid and a 26th circle slightly offset from the center\n    # to provide a better starting point for the optimization.\n    centers = []\n    for i in range(5):\n        for j in range(5):\n            centers.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n    # Add the 26th circle to a position likely to have space after repulsion.\n    centers.append([0.55, 0.55])\n    centers = np.array(centers)\n\n    # Break symmetry for the repulsion simulation.\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.01, centers.shape)\n    centers = np.clip(centers, 0, 1)\n\n    # Physics simulation: Move centers to balance boundary and pairwise repulsion.\n    # The goal is to maximize available space for radius expansion.\n    for _ in range(1000):\n        forces = np.zeros_like(centers)\n        \n        # Boundary forces: push centers away from the walls of the unit square.\n        # Uses an inverse-square relationship to keep centers within [0, 1].\n        forces[:, 0] += 0.002 / (centers[:, 0]**2 + 1e-5)\n        forces[:, 0] -= 0.002 / ((1 - centers[:, 0])**2 + 1e-5)\n        forces[:, 1] += 0.002 / (centers[:, 1]**2 + 1e-5)\n        forces[:, 1] -= 0.002 / ((1 - centers[:, 1])**2 + 1e-5)\n        \n        # Pairwise forces: push centers apart if they are closer than target distance.\n        # target_dist represents the typical diameter of circles in the packing.\n        target_dist = 0.208\n        for i in range(n):\n            diff = centers[i] - centers\n            dist = np.linalg.norm(diff, axis=1)\n            # Mask out self-interaction and distant neighbors.\n            mask = (dist < target_dist) & (dist > 0)\n            if np.any(mask):\n                # Repulsion force based on overlap magnitude.\n                overlap_force = (target_dist - dist[mask]) / (dist[mask] + 1e-7)\n                forces[i] += np.sum(diff[mask] * overlap_force[:, np.newaxis], axis=0)\n        \n        # Update center positions using capped step sizes to maintain stability.\n        mag = np.linalg.norm(forces, axis=1, keepdims=True)\n        max_step = 0.01\n        forces = np.where(mag > max_step, forces * max_step / mag, forces)\n        centers += forces\n        # Ensure centers remain strictly within the unit square\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Given center positions, calculate radii to maximize the sum of radii\n    while ensuring no overlaps and staying within the unit square.\n    Uses a multi-pass randomized greedy expansion and coordinate descent refinement.\n    \"\"\"\n    n = centers.shape[0]\n    # Pre-calculate distances to the four walls (left, bottom, right, top)\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pre-calculate pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a large value on the diagonal to ignore self-distance\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try different randomized greedy orders to find a higher sum of radii\n    for _ in range(40):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Greedy allocation\n        for i in order:\n            r_i = wall_dist[i]\n            for j in range(n):\n                if i != j and radii[j] > 0:\n                    r_i = min(r_i, dists[i, j] - radii[j])\n            radii[i] = max(0.0, r_i)\n            \n        # Refine radii iteratively using coordinate descent\n        for _ in range(15):\n            for i in range(n):\n                r_i = wall_dist[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dists[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    # Subtract a tiny epsilon to ensure strict validity against floating point noise\n    best_radii -= 1e-12\n    best_radii = np.maximum(best_radii, 0.0)\n    \n    return best_radii, np.sum(best_radii)\n\n\ndef relax_centers(centers, n_iter=3000):\n    \"\"\"\n    Physics-based simulation to optimize center placement.\n    Uses repulsion forces and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    velocity = np.zeros_like(centers)\n    r_target = 0.099  # Heuristic target radius for n=26\n    dt = 0.015\n    damping = 0.9\n    \n    for step in range(n_iter):\n        # Calculate pairwise forces\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1.0)\n        \n        # Repulsion force: push apart if closer than 2 * r_target\n        target_dist = 2 * r_target\n        overlap = np.maximum(0, target_dist - dists)\n        force_mag = (overlap / (dists + 1e-9))\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n        \n        # Boundary forces to keep centers within [r_target, 1-r_target]\n        forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n        forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n        forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n        forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n        \n        # Update velocities and positions (Momentum-based)\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Cooling schedule: reduce step size and adjust target distance\n        if (step + 1) % 500 == 0:\n            dt *= 0.8\n            r_target += 0.0002\n            \n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    \"\"\"\n    n = 26\n    np.random.seed(123)\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Initialization Strategy 1: Staggered grid (5-5-6-5-5)\n    c1 = []\n    counts = [5, 5, 6, 5, 5]\n    for i, count in enumerate(counts):\n        y = (i + 0.5) / 5.0\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            c1.append([x, y])\n    \n    # Initialization Strategy 2: Different staggered layout (4-5-4-5-4-4)\n    c2 = []\n    counts2 = [4, 5, 4, 5, 4, 4]\n    for i, count in enumerate(counts2):\n        y = (i + 0.5) / 6.0\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            c2.append([x, y])\n            \n    layouts = [np.array(c1), np.array(c2)]\n    \n    # Run optimization for each layout\n    for base_layout in layouts:\n        # Apply slight jitter to break symmetries\n        start_pos = np.clip(base_layout + np.random.normal(0, 0.005, (n, 2)), 0.0, 1.0)\n        refined_centers = relax_centers(start_pos)\n        radii, current_sum = compute_max_radii(refined_centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = refined_centers\n            best_overall_radii = radii\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"Entry point for evaluation.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=60):\n    \"\"\"\n    Given fixed center positions, find a set of radii that maximize\n    the sum while satisfying the non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the four walls of the unit square\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dists, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several random greedy orders to maximize the sum of radii\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Greedy allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            for j in range(n):\n                if r[j] > 0:\n                    r_limit = min(r_limit, dists[i, j] - r[j])\n            r[i] = max(0.0, r_limit)\n        # Phase 2: Iterative coordinate descent refinement to optimize slack\n        for _ in range(15):\n            for i in order:\n                r_limit = wall_dist[i]\n                for j in range(n):\n                    if i != j:\n                        r_limit = min(r_limit, dists[i, j] - r[j])\n                r[i] = max(0.0, r_limit)\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=2800, target_r=0.101):\n    \"\"\"\n    Apply a physics-inspired force-directed simulation to optimize\n    the placement of circle centers for maximizing available radius space.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.012\n    damping = 0.92\n\n    for step in range(n_steps):\n        # Pairwise repulsion calculation\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: push apart if centers are closer than 2*target_r\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        force_mag = overlap / (dists + 1e-9)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Square boundary constraints (push centers towards the inner bounds)\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Velocity-based momentum update for stability\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule for convergence\n        if (step + 1) % 500 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    Iterates over multiple diverse layout initializations and performs\n    physics-based relaxation to maximize the total sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    layouts = []\n    # Diverse staggered grid patterns to provide varied starting conditions\n    # Each list represents the number of circles per row\n    patterns = [[5, 5, 6, 5, 5], [6, 4, 6, 4, 6], [5, 6, 5, 6, 4], [4, 6, 6, 6, 4]]\n    for p in patterns:\n        coords = []\n        for i, count in enumerate(p):\n            y = (i + 0.5) / len(p)\n            x_range = np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count)\n            for x in x_range:\n                coords.append([x, y])\n        layouts.append(np.array(coords))\n\n    # Phyllotaxis-based sunflower layout for circular-ish symmetry\n    phi = (1.0 + 5.0**0.5) / 2.0\n    theta_step = 2.0 * np.pi / (phi**2)\n    sunflower = []\n    for i in range(n):\n        r_val = 0.485 * np.sqrt((i + 0.5) / n)\n        theta = i * theta_step\n        sunflower.append([0.5 + r_val * np.cos(theta), 0.5 + r_val * np.sin(theta)])\n    layouts.append(np.array(sunflower))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore each base layout with different target radii parameters\n    for base_layout in layouts:\n        for t_rad in [0.098, 0.101]:\n            # Apply slight jitter to break layout symmetries\n            start_pos = np.clip(base_layout + np.random.normal(0, 0.002, (n, 2)), 0.0, 1.0)\n            refined_centers = relax_centers(start_pos, n_steps=2800, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_centers, trials=60)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_centers\n                best_overall_radii = radii\n\n    # Safety margin subtraction to ensure strict non-overlap and boundary validity\n    final_radii = best_overall_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n\n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"4.98s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.484999/2.635 = 0.9431\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}