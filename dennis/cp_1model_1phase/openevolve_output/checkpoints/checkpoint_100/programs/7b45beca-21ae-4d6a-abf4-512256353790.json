{"id": "7b45beca-21ae-4d6a-abf4-512256353790", "code": "import numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    Employs a multi-start strategy with physics-inspired Adam optimization\n    to find center configurations and Linear Programming (HiGHS) to solve\n    for the exact optimal radii.\n    \"\"\"\n    n = 26\n\n    def optimize_arrangement(c_init, seed_val, iters=4000):\n        \"\"\"\n        Moves centers and expands radii using the Adam optimizer to maximize\n        the sum of radii while satisfying boundary and non-overlap constraints.\n        \"\"\"\n        np.random.seed(seed_val)\n        c = c_init + np.random.normal(0, 0.012, c_init.shape)\n        c = np.clip(c, 0.02, 0.98)\n        r = np.full(n, 0.08)\n\n        m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        lr = 0.0035\n\n        for t in range(1, iters + 1):\n            # Penalty coefficient grows slowly to allow centers to rearrange\n            penalty_coeff = 1.5 + (t / iters) * 600.0\n            dc = np.zeros_like(c)\n            dr = -np.ones(n)  # Minimize -sum(r) to maximize sum(r)\n\n            # 1. Boundary violations\n            for i in range(2):\n                # Low side: r_i - c_i <= 0\n                v_low = r - c[:, i]\n                mask_low = v_low > 0\n                grad_low = 2 * penalty_coeff * v_low[mask_low]\n                dr[mask_low] += grad_low\n                dc[mask_low, i] -= grad_low\n\n                # High side: c_i + r_i - 1 <= 0\n                v_high = c[:, i] + r - 1.0\n                mask_high = v_high > 0\n                grad_high = 2 * penalty_coeff * v_high[mask_high]\n                dr[mask_high] += grad_high\n                dc[mask_high, i] += grad_high\n\n            # 2. Pairwise overlaps: r_i + r_j - dist_ij <= 0\n            for i in range(n):\n                diff = c[i] - c[i + 1:]\n                dists_sq = np.sum(diff**2, axis=1)\n                dists = np.sqrt(dists_sq + 1e-12)\n                sum_r = r[i] + r[i + 1:]\n                overlap = sum_r - dists\n                mask = overlap > 0\n\n                if np.any(mask):\n                    idx = np.where(mask)[0] + i + 1\n                    ov = overlap[mask]\n                    di = dists[mask]\n                    df = diff[mask]\n\n                    grad_pair = 2 * penalty_coeff * ov\n                    dr[i] += np.sum(grad_pair)\n                    dr[idx] += grad_pair\n\n                    grad_c = (grad_pair / di)[:, np.newaxis] * df\n                    dc[i] -= np.sum(grad_c, axis=0)\n                    dc[idx] += grad_c\n\n            # Adam updates for centers\n            m_c = beta1 * m_c + (1 - beta1) * dc\n            v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n            c -= lr * (m_c / (1 - beta1**t)) / (np.sqrt(v_c / (1 - beta2**t)) + eps)\n\n            # Adam updates for radii\n            m_r = beta1 * m_r + (1 - beta1) * dr\n            v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n            r -= lr * (m_r / (1 - beta1**t)) / (np.sqrt(v_r / (1 - beta2**t)) + eps)\n\n            c = np.clip(c, 0.0, 1.0)\n            r = np.clip(r, 0.0, 0.5)\n\n        return c\n\n    # Phase 1: Strategic Initializations\n    initial_configs = []\n\n    # Layout A: 6x5 grid (30 slots), remove 4 corners\n    points_a = []\n    xs_a = np.linspace(0.1, 0.9, 6)\n    ys_a = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points_a.append([xs_a[i], ys_a[j]])\n    initial_configs.append((np.array(points_a)[:n], 42))\n\n    # Layout B: Staggered row layout [5, 6, 5, 6, 4]\n    points_b = []\n    rows = [5, 6, 5, 6, 4]\n    for r_idx, count in enumerate(rows):\n        xs_b = np.linspace(0.08, 0.92, count)\n        y_b = 0.08 + r_idx * 0.21\n        for x_b in xs_b:\n            points_b.append([x_b, y_b])\n    initial_configs.append((np.array(points_b)[:n], 777))\n\n    # Layout C: 7x4 grid (28 slots), remove 2 corners\n    points_c = []\n    xs_c = np.linspace(0.07, 0.93, 7)\n    ys_c = np.linspace(0.1, 0.9, 4)\n    for i in range(7):\n        for j in range(4):\n            if not ((i == 0 or i == 6) and (j == 0)):\n                points_c.append([xs_c[i], ys_c[j]])\n    initial_configs.append((np.array(points_c)[:n], 123))\n\n    best_total_sum = 0\n    best_c_found = None\n    best_r_found = None\n\n    # Phase 2: Run Optimizations and LP Refinement\n    for c_start, seed in initial_configs:\n        c_refined = optimize_arrangement(c_start, seed, iters=3500)\n\n        # Linear Programming to find the exact optimal radii for fixed centers\n        A_ub, b_ub, bounds = [], [], []\n        dist_to_edge = np.min([c_refined[:, 0], 1.0 - c_refined[:, 0],\n                               c_refined[:, 1], 1.0 - c_refined[:, 1]], axis=0)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c_refined[i] - c_refined[j])\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n            bounds.append((0, max(0.0, dist_to_edge[i])))\n\n        res = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub),\n                      bounds=bounds, method='highs')\n\n        if res.success:\n            current_sum = np.sum(res.x)\n            if current_sum > best_total_sum:\n                best_total_sum = current_sum\n                best_c_found = c_refined\n                best_r_found = res.x\n\n    # Phase 3: Post-processing for strict validity\n    final_c = best_c_found\n    final_r = best_r_found * (1.0 - 1e-12)\n\n    # Enforce boundary constraints strictly\n    for i in range(n):\n        final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0],\n                         final_c[i, 1], 1.0 - final_c[i, 1])\n\n    # Enforce non-overlap constraints strictly\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            if final_r[i] + final_r[j] > dist:\n                over = (final_r[i] + final_r[j]) - dist\n                final_r[i] -= over * 0.5 + 1e-15\n                final_r[j] -= over * 0.5 + 1e-15\n\n    final_r = np.maximum(final_r, 0.0)\n    final_sum = np.sum(final_r)\n\n    return final_c, final_r, final_sum\n\n\n# Produce result variables\ncenters, radii, sum_radii = run_packing()", "changes_description": null, "language": "python", "parent_id": "9d9f4b4f-fae7-40b2-876a-e5a79b0dc59d", "generation": 5, "timestamp": 1771870758.7910154, "iteration_found": 83, "metrics": {"validity": 1.0, "sum_radii": 2.598074771740089, "target_ratio": 0.9859866306414001, "combined_score": 0.9859866306414001, "radius_variance": 0.006268225936823157, "spatial_spread": 0.18285926571312464, "eval_time": 19.75981831550598}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.582548249109449, "target_ratio": 0.9800942121857493, "combined_score": 0.9800942121857493, "radius_variance": 0.00963506106172926, "spatial_spread": 0.1867252640646787, "eval_time": 5.993098974227905}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.9801\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9836 \u2192 0.9801. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n5.99s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.582548/2.635 = 0.9801\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 98.0% of target value\n```\n\n### radius_stats\n```\nMin: 0.063472, Max: 0.159442, Avg: 0.099329\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5918, target_ratio: 0.9836, combined_score: 0.9836, radius_variance: 0.0079, spatial_spread: 0.1879, eval_time: 14.7048\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5966, target_ratio: 0.9854, combined_score: 0.9854, radius_variance: 0.0052, spatial_spread: 0.1882, eval_time: 34.2547\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6142, target_ratio: 0.9921, combined_score: 0.9921, radius_variance: 0.0068, spatial_spread: 0.1935, eval_time: 8.9765\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9921)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    Employs a multi-start strategy with physics-inspired Adam optimization \n    to find center configurations and Linear Programming (HiGHS) to solve \n    for the exact optimal radii.\n    \"\"\"\n    n = 26\n\n    def optimize_arrangement(c_init, seed_val, iters=3000):\n        \"\"\"\n        Moves centers and expands radii using the Adam optimizer to maximize\n        the sum of radii while satisfying boundary and non-overlap constraints.\n        \"\"\"\n        np.random.seed(seed_val)\n        c = c_init + np.random.normal(0, 0.015, c_init.shape)\n        c = np.clip(c, 0.05, 0.95)\n        r = np.full(n, 0.06)\n\n        m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        lr = 0.0025\n\n        for t in range(1, iters + 1):\n            penalty_coeff = 2.0 + t * 0.22\n            dc = np.zeros_like(c)\n            dr = -np.ones(n)  # Minimize -sum(r) to maximize sum(r)\n\n            # 1. Boundary violations\n            for i in range(2):\n                # Low side: r - c_i <= 0\n                v_low = r - c[:, i]\n                mask_low = v_low > 0\n                grad_low = 2 * penalty_coeff * v_low[mask_low]\n                dr[mask_low] += grad_low\n                dc[mask_low, i] -= grad_low\n\n                # High side: c_i + r - 1 <= 0\n                v_high = c[:, i] + r - 1.0\n                mask_high = v_high > 0\n                grad_high = 2 * penalty_coeff * v_high[mask_high]\n                dr[mask_high] += grad_high\n                dc[mask_high, i] += grad_high\n\n            # 2. Pairwise overlaps: r_i + r_j - dist_ij <= 0\n            for i in range(n):\n                diff = c[i] - c[i + 1:]\n                dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n                sum_r = r[i] + r[i + 1:]\n                overlap = sum_r - dists\n                mask = overlap > 0\n\n                if np.any(mask):\n                    idx = np.where(mask)[0] + i + 1\n                    ov = overlap[mask]\n                    di = dists[mask]\n                    df = diff[mask]\n\n                    grad_pair = 2 * penalty_coeff * ov\n                    dr[i] += np.sum(grad_pair)\n                    dr[idx] += grad_pair\n\n                    # Center movement grads (pushing circles apart)\n                    grad_c = (grad_pair / di)[:, np.newaxis] * df\n                    dc[i] -= np.sum(grad_c, axis=0)\n                    dc[idx] += grad_c\n\n            # Adam updates for centers\n            m_c = beta1 * m_c + (1 - beta1) * dc\n            v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n            m_c_hat = m_c / (1 - beta1**t)\n            v_c_hat = v_c / (1 - beta2**t)\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n            # Adam updates for radii\n            m_r = beta1 * m_r + (1 - beta1) * dr\n            v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n            m_r_hat = m_r / (1 - beta1**t)\n            v_r_hat = v_r / (1 - beta2**t)\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n            c = np.clip(c, 0.0, 1.0)\n            r = np.clip(r, 0.0, 0.5)\n\n        return c, r\n\n    # Phase 1: Multiple Initializations\n    initial_configs = []\n    \n    # Init A: 6x5 grid (30 slots), remove 4 corners\n    points_a = []\n    xs_a = np.linspace(0.1, 0.9, 6)\n    ys_a = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points_a.append([xs_a[i], ys_a[j]])\n    initial_configs.append((np.array(points_a)[:n], 42, 3000))\n\n    # Init B: 7x4 grid (28 slots), remove 2 corners\n    points_b = []\n    xs_b = np.linspace(0.08, 0.92, 7)\n    ys_b = np.linspace(0.12, 0.88, 4)\n    for i in range(7):\n        for j in range(4):\n            if not ((i == 0 or i == 6) and (j == 0)):\n                points_b.append([xs_b[i], ys_b[j]])\n    initial_configs.append((np.array(points_b)[:n], 123, 2000))\n\n    best_total_sum = 0\n    best_c_found = None\n    best_r_found = None\n\n    # Phase 2: Run Optimizations and LP Refinement\n    for c_init, seed, iterations in initial_configs:\n        c_refined, r_adam = optimize_arrangement(c_init, seed, iterations)\n        \n        # Linear Programming to solve for exact optimal radii for these centers\n        A_ub, b_ub, bounds = [], [], []\n        dist_to_edge = np.min([c_refined[:, 0], 1.0 - c_refined[:, 0], \n                               c_refined[:, 1], 1.0 - c_refined[:, 1]], axis=0)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c_refined[i] - c_refined[j])\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n            bounds.append((0, max(0.0, dist_to_edge[i])))\n\n        res = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=bounds, method='highs')\n        \n        if res.success:\n            r_lp = res.x\n            current_sum = np.sum(r_lp)\n        else:\n            r_lp = r_adam\n            current_sum = np.sum(r_adam)\n\n        if current_sum > best_total_sum:\n            best_total_sum = current_sum\n            best_c_found = c_refined\n            best_r_found = r_lp\n\n    # Phase 3: Post-processing for strict validity\n    final_c = best_c_found\n    final_r = best_r_found * (1.0 - 1e-11)\n    \n    # Enforce boundary constraints strictly\n    for i in range(n):\n        final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0], \n                         final_c[i, 1], 1.0 - final_c[i, 1])\n    \n    # Enforce non-overlap constraints strictly\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            if final_r[i] + final_r[j] > dist:\n                over = (final_r[i] + final_r[j]) - dist\n                final_r[i] -= over * 0.5 + 1e-15\n                final_r[j] -= over * 0.5 + 1e-15\n\n    final_r = np.maximum(final_r, 0.0)\n    final_sum = np.sum(final_r)\n\n    return final_c, final_r, final_sum\n\n\n# Final execution variables\ncenters, radii, sum_radii = run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6142), Performs well on target_ratio (0.9921), Performs well on combined_score (0.9921), Performs well on radius_variance (0.0068), Performs well on spatial_spread (0.1935), Performs well on eval_time (8.9765)\n\n### Program 2 (Score: 0.9854)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef run_packing():\n    \"\"\"\n    Directly produces an arrangement of 26 circles in a unit square,\n    maximizing the sum of their radii using a multi-start optimization\n    followed by Linear Programming for exact radius refinement.\n    \"\"\"\n    n = 26\n    best_sum = 0\n    best_c = np.zeros((n, 2))\n    best_r = np.zeros(n)\n\n    # Multi-start optimization with diverse initializations\n    # 1. Perturbed 5x5 grid + 1 extra circle\n    # 2. Staggered hexagonal-style packing\n    # 3. Random distribution\n    seeds = [1, 42, 123, 777]\n    for seed in seeds:\n        np.random.seed(seed)\n\n        if seed == 1:\n            # 5x5 grid (25 circles) + 26th circle in the corner\n            gv = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(gv, gv)\n            c_init = np.vstack([np.column_stack([xv.ravel(), yv.ravel()]), [0.95, 0.05]])\n        elif seed == 42:\n            # Staggered hexagonal-ish: 5-6-5-6-4 row layout\n            c_init = []\n            for r_idx, count in enumerate([5, 6, 5, 6, 4]):\n                for c_idx in range(count):\n                    # Stagger every other row\n                    x = (c_idx + 0.5 + (0.3 if r_idx % 2 == 1 else 0)) / 6.5\n                    y = (r_idx + 0.5) / 5.5\n                    c_init.append([x, y])\n            c_init = np.array(c_init)\n        else:\n            # Random starting centers\n            c_init = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add jitter and enforce bounds\n        c_init += np.random.uniform(-0.02, 0.02, (n, 2))\n        c_init = np.clip(c_init, 0.0, 1.0)\n        r_init = np.full(n, 0.09)\n\n        # Optimization phase: Search for center configurations that allow large radii\n        def penalty_objective(params, weight):\n            curr_c = params[:2*n].reshape((n, 2))\n            curr_r = params[2*n:]\n\n            # Maximize sum(r_i)\n            obj_val = -np.sum(curr_r)\n\n            # Boundary constraints penalty: r_i <= distance to wall\n            dist_to_wall = np.minimum(np.minimum(curr_c[:, 0], 1.0 - curr_c[:, 0]),\n                                     np.minimum(curr_c[:, 1], 1.0 - curr_c[:, 1]))\n            b_pen = np.sum(np.maximum(0, curr_r - dist_to_wall)**2)\n\n            # Overlap constraints penalty: r_i + r_j <= distance between centers\n            diffs = curr_c[:, np.newaxis, :] - curr_c[np.newaxis, :, :]\n            # Stability constant 1e-12 avoids sqrt(0) issues\n            dists = np.sqrt(np.sum(diffs**2, axis=2) + 1e-12)\n            r_sum = curr_r[:, np.newaxis] + curr_r[np.newaxis, :]\n            o_violations = np.maximum(0, r_sum - dists)\n            np.fill_diagonal(o_violations, 0)\n            o_pen = 0.5 * np.sum(o_violations**2)\n\n            return obj_val + weight * (b_pen + o_pen)\n\n        # Optimization refined in two stages (soft constraints then hard)\n        init_params = np.concatenate([c_init.ravel(), r_init])\n        bnds = [(0.0, 1.0)] * (2 * n) + [(0.0, 0.5)] * n\n        \n        # Stage 1: Preliminary search\n        res = minimize(penalty_objective, init_params, args=(100.0,), method='L-BFGS-B', \n                       bounds=bnds, options={'maxiter': 500, 'ftol': 1e-6})\n        # Stage 2: Refined search\n        res = minimize(penalty_objective, res.x, args=(10000.0,), method='L-BFGS-B', \n                       bounds=bnds, options={'maxiter': 700, 'ftol': 1e-8})\n        \n        c_refined = res.x[:2*n].reshape((n, 2))\n        c_refined = np.clip(c_refined, 0.0, 1.0)\n\n        # Radii Refinement: Solve exact Linear Program for the sum of radii at fixed centers\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(np.linalg.norm(c_refined[i] - c_refined[j]))\n        \n        r_bounds = []\n        for i in range(n):\n            dist_w = min(c_refined[i, 0], 1.0 - c_refined[i, 0],\n                         c_refined[i, 1], 1.0 - c_refined[i, 1])\n            r_bounds.append((0.0, max(0.0, dist_w)))\n        \n        lp_res = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                         bounds=r_bounds, method='highs')\n        \n        if lp_res.success:\n            curr_sum = -lp_res.fun\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_c, best_r = c_refined, lp_res.x\n\n    # Ensure strict feasibility against precision limits\n    best_r *= (1.0 - 1e-12)\n    for i in range(n):\n        best_r[i] = min(best_r[i], best_c[i, 0], 1.0 - best_c[i, 0],\n                        best_c[i, 1], 1.0 - best_c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(best_c[i] - best_c[j])\n            if best_r[i] + best_r[j] > d:\n                overlap = (best_r[i] + best_r[j] - d)\n                best_r[i] -= overlap / 2.0 + 1e-15\n                best_r[j] -= overlap / 2.0 + 1e-15\n    \n    best_r = np.maximum(best_r, 0.0)\n    final_sum = np.sum(best_r)\n    \n    return best_c, best_r, final_sum\n\n\n# Execute the solver to generate the arrangement\ncenters, radii, sum_radii = run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5966), Performs well on target_ratio (0.9854), Performs well on combined_score (0.9854), Performs well on radius_variance (0.0052), Performs well on spatial_spread (0.1882), Performs well on eval_time (34.2547)\n\n### Program 3 (Score: 0.9836)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    This program utilizes a multi-start strategy with physics-inspired \n    Adam optimization to position circle centers and Linear Programming (LP) \n    to solve for the mathematically optimal radii for those center locations.\n    \"\"\"\n    n = 26\n\n    def solve_lp(c_fixed):\n        \"\"\"Solve for optimal radii given fixed center positions.\"\"\"\n        num = len(c_fixed)\n        # Linear Programming: Maximize sum(r) <=> Minimize sum(-r)\n        # Subject to: r_i + r_j <= distance(c_i, c_j)\n        # and r_i <= distance to nearest wall\n        A_ub, b_ub, bounds = [], [], []\n        for i in range(num):\n            for j in range(i + 1, num):\n                dist = np.linalg.norm(c_fixed[i] - c_fixed[j])\n                row = np.zeros(num)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n            # Wall constraints for each circle\n            dist_to_wall = min(c_fixed[i, 0], 1.0 - c_fixed[i, 0], \n                               c_fixed[i, 1], 1.0 - c_fixed[i, 1])\n            bounds.append((0, max(0.0, dist_to_wall)))\n\n        res = linprog(-np.ones(num), A_ub=A_ub, b_ub=b_ub, \n                      bounds=bounds, method='highs')\n        return res.x if res.success else None\n\n    def adam_optimize(c_init, iters=2800):\n        \"\"\"Moves centers to allow for larger radii using Adam optimization.\"\"\"\n        c = c_init.copy()\n        r = np.full(n, 0.08)\n        m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        beta1, beta2, eps, lr = 0.9, 0.999, 1e-8, 0.003\n        \n        for t in range(1, iters + 1):\n            penalty_coeff = 2.0 + t * 0.22\n            dc, dr = np.zeros_like(c), -np.ones(n)\n            \n            # Boundary penalties\n            for i in range(2):\n                v_lo, v_hi = r - c[:, i], c[:, i] + r - 1.0\n                m_lo, m_hi = v_lo > 0, v_hi > 0\n                dr[m_lo] += 2 * penalty_coeff * v_lo[m_lo]\n                dc[m_lo, i] -= 2 * penalty_coeff * v_lo[m_lo]\n                dr[m_hi] += 2 * penalty_coeff * v_hi[m_hi]\n                dc[m_hi, i] += 2 * penalty_coeff * v_hi[m_hi]\n            \n            # Pairwise overlap penalties\n            for i in range(n):\n                diff = c[i] - c[i+1:]\n                dist = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n                overlap = (r[i] + r[i+1:]) - dist\n                mask = overlap > 0\n                if np.any(mask):\n                    idx = np.where(mask)[0] + i + 1\n                    g_r = 2 * penalty_coeff * overlap[mask]\n                    dr[i] += np.sum(g_r)\n                    dr[idx] += g_r\n                    g_c = (g_r / dist[mask])[:, np.newaxis] * diff[mask]\n                    dc[i] -= np.sum(g_c, axis=0)\n                    dc[idx] += g_c\n            \n            # Adam optimizer updates\n            m_c = beta1 * m_c + (1 - beta1) * dc\n            v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n            c -= lr * (m_c / (1 - beta1**t)) / (np.sqrt(v_c / (1 - beta2**t)) + eps)\n            \n            m_r = beta1 * m_r + (1 - beta1) * dr\n            v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n            r -= lr * (m_r / (1 - beta1**t)) / (np.sqrt(v_r / (1 - beta2**t)) + eps)\n            \n            # Projections\n            c, r = np.clip(c, 0, 1), np.clip(r, 0, 0.5)\n        return c\n\n    # Initial arrangements to explore the search space\n    grids = []\n    \n    # 1. Staggered hex-like grid (5-6-5-6-4 configuration)\n    pts_hex = []\n    for r_idx, count in enumerate([5, 6, 5, 6, 4]):\n        for c_idx in range(count):\n            pts_hex.append([(c_idx + 0.5 + (0.2 if r_idx % 2 else 0)) / 6.5, \n                           (r_idx + 0.5) / 5.5])\n    grids.append(np.array(pts_hex))\n\n    # 2. Rectangular 6x5 grid (30 slots), removing 4 corners\n    pts_6x5 = []\n    xs_a, ys_a = np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                pts_6x5.append([xs_a[i], ys_a[j]])\n    grids.append(np.array(pts_6x5))\n\n    # 3. Rectangular 7x4 grid (28 slots), removing 2 corners\n    pts_7x4 = []\n    xs_b, ys_b = np.linspace(0.08, 0.92, 7), np.linspace(0.12, 0.88, 4)\n    for i in range(7):\n        for j in range(4):\n            if not ((i == 0 or i == 6) and (j == 0)):\n                pts_7x4.append([xs_b[i], ys_b[j]])\n    grids.append(np.array(pts_7x4))\n\n    best_c, best_r, best_sum = None, None, 0\n    for g in grids:\n        c_optimized = adam_optimize(g[:n])\n        r_lp = solve_lp(c_optimized)\n        if r_lp is not None and np.sum(r_lp) > best_sum:\n            best_sum, best_c, best_r = np.sum(r_lp), c_optimized, r_lp\n\n    # Ensure strict adherence to constraints (floating point precision)\n    best_r *= (1.0 - 1e-11)\n    for i in range(n):\n        best_r[i] = min(best_r[i], best_c[i, 0], 1.0 - best_c[i, 0], \n                        best_c[i, 1], 1.0 - best_c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(best_c[i] - best_c[j])\n            if best_r[i] + best_r[j] > d:\n                overlap = (best_r[i] + best_r[j]) - d\n                best_r[i] -= overlap / 2.0 + 1e-15\n                best_r[j] -= overlap / 2.0 + 1e-15\n    \n    best_r = np.maximum(best_r, 0.0)\n    final_sum = np.sum(best_r)\n    return best_c, best_r, final_sum\n\n\n# Execute the constructor\ncenters, radii, sum_radii = run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5918), Performs well on target_ratio (0.9836), Performs well on combined_score (0.9836), Performs well on radius_variance (0.0079), Performs well on spatial_spread (0.1879), Performs well on eval_time (14.7048)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9816)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    Employs a multi-start strategy with physics-inspired Adam optimization \n    to find center configurations and Linear Programming (HiGHS) to solve \n    for the exact optimal radii.\n    \"\"\"\n    n = 26\n\n    def optimize_arrangement(c_init, seed_val, iters=4000):\n        \"\"\"\n        Moves centers and expands radii using the Adam optimizer to maximize\n        the sum of radii while satisfying boundary and non-overlap constraints.\n        \"\"\"\n        np.random.seed(seed_val)\n        # Apply jitter to initial configuration to break symmetry\n        c = c_init + np.random.normal(0, 0.012, c_init.shape)\n        c = np.clip(c, 0.05, 0.95)\n        r = np.full(n, 0.07)\n\n        m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        lr = 0.003\n\n        for t in range(1, iters + 1):\n            # Penalty coefficient increases over time to enforce hard constraints\n            penalty_coeff = 2.0 + 850.0 * (t / iters)**1.5\n            dc = np.zeros_like(c)\n            dr = -np.ones(n)  # Minimize -sum(r) to maximize sum(r)\n\n            # 1. Boundary violations: enforce 0 <= c_i - r and c_i + r <= 1\n            for i in range(2):\n                # Low side (0.0): r - c_i <= 0\n                v_low = r - c[:, i]\n                mask_low = v_low > 0\n                grad_low = 2 * penalty_coeff * v_low[mask_low]\n                dr[mask_low] += grad_low\n                dc[mask_low, i] -= grad_low\n\n                # High side (1.0): c_i + r - 1 <= 0\n                v_high = c[:, i] + r - 1.0\n                mask_high = v_high > 0\n                grad_high = 2 * penalty_coeff * v_high[mask_high]\n                dr[mask_high] += grad_high\n                dc[mask_high, i] += grad_high\n\n            # 2. Pairwise overlaps: r_i + r_j - dist_ij <= 0\n            for i in range(n):\n                diff = c[i] - c[i + 1:]\n                dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n                sum_r = r[i] + r[i + 1:]\n                overlap = sum_r - dists\n                mask = overlap > 0\n\n                if np.any(mask):\n                    idx = np.where(mask)[0] + i + 1\n                    ov = overlap[mask]\n                    di = dists[mask]\n                    df = diff[mask]\n\n                    grad_pair = 2 * penalty_coeff * ov\n                    dr[i] += np.sum(grad_pair)\n                    dr[idx] += grad_pair\n\n                    # Push centers apart based on overlap magnitude\n                    grad_c = (grad_pair / di)[:, np.newaxis] * df\n                    dc[i] -= np.sum(grad_c, axis=0)\n                    dc[idx] += grad_c\n\n            # Adam optimizer updates for center coordinates\n            m_c = beta1 * m_c + (1 - beta1) * dc\n            v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n            m_c_hat = m_c / (1 - beta1**t)\n            v_c_hat = v_c / (1 - beta2**t)\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n            # Adam optimizer updates for radii\n            m_r = beta1 * m_r + (1 - beta1) * dr\n            v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n            m_r_hat = m_r / (1 - beta1**t)\n            v_r_hat = v_r / (1 - beta2**t)\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n            # Logical clipping\n            c = np.clip(c, 0.0, 1.0)\n            r = np.clip(r, 0.0, 0.4)\n\n        return c, r\n\n    # Phase 1: Define Multiple Strategic Initializations\n    initial_configs = []\n    \n    # Configuration A: 6x5 grid (30 slots), removing 4 corners to get 26 points\n    points_a = []\n    xs_a = np.linspace(0.1, 0.9, 6)\n    ys_a = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points_a.append([xs_a[i], ys_a[j]])\n    initial_configs.append((np.array(points_a)[:n], 42))\n\n    # Configuration B: 7x4 grid (28 slots), removing 2 corners\n    points_b = []\n    xs_b = np.linspace(0.08, 0.92, 7)\n    ys_b = np.linspace(0.12, 0.88, 4)\n    for i in range(7):\n        for j in range(4):\n            if not ((i == 0 or i == 6) and (j == 0)):\n                points_b.append([xs_b[i], ys_b[j]])\n    initial_configs.append((np.array(points_b)[:n], 123))\n\n    # Configuration C: Staggered hexagonal-style rows [5, 6, 5, 6, 4]\n    points_c = []\n    rows = [5, 6, 5, 6, 4]\n    for r_idx, count in enumerate(rows):\n        xs_c = np.linspace(0.1, 0.9, count)\n        y_c = 0.1 + r_idx * 0.2\n        for x_c in xs_c:\n            points_c.append([x_c, y_c])\n    initial_configs.append((np.array(points_c)[:n], 777))\n\n    best_total_sum = 0\n    best_c_found = None\n    best_r_found = None\n\n    # Phase 2: Run Optimizations and Mathematical Radii Refinement (LP)\n    for c_start, seed in initial_configs:\n        c_refined, _ = optimize_arrangement(c_start, seed, iters=4000)\n        \n        # Build Linear Programming problem for exact optimal radii\n        A_ub, b_ub, bounds = [], [], []\n        \n        # Radii are bounded by the distance from center to the closest wall\n        dist_to_edge = np.min([\n            c_refined[:, 0], 1.0 - c_refined[:, 0], \n            c_refined[:, 1], 1.0 - c_refined[:, 1]\n        ], axis=0)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                # r_i + r_j <= distance between centers\n                dist = np.linalg.norm(c_refined[i] - c_refined[j])\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n            bounds.append((0, max(0.0, dist_to_edge[i])))\n\n        # Solve the LP using HiGHS method for speed and precision\n        res = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=bounds, method='highs')\n        \n        if res.success:\n            current_sum = np.sum(res.x)\n            if current_sum > best_total_sum:\n                best_total_sum = current_sum\n                best_c_found = c_refined\n                best_r_found = res.x\n\n    # Phase 3: Post-processing to ensure strict validity against floating-point errors\n    final_c = best_c_found\n    final_r = best_r_found * (1.0 - 1e-12)\n    \n    # Force boundary adherence\n    for i in range(n):\n        final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0], \n                         final_c[i, 1], 1.0 - final_c[i, 1])\n    \n    # Force non-overlap adherence\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            if final_r[i] + final_r[j] > dist:\n                over = (final_r[i] + final_r[j]) - dist\n                final_r[i] -= over * 0.5 + 1e-15\n                final_r[j] -= over * 0.5 + 1e-15\n\n    final_r = np.maximum(final_r, 0.0)\n    final_sum = np.sum(final_r)\n\n    return final_c, final_r, final_sum\n\n\n# Produce the required result variables\ncenters, radii, sum_radii = run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9801)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of radii.\n    Employs a physics-inspired optimization (Adam) to locate centers and \n    Linear Programming (HiGHS) to determine the mathematically optimal radii.\n    The start is a refined 6x5 grid (minus corners) to ensure good coverage.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialization: 6x5 grid and remove 4 corners to get 26 points\n    points = []\n    for i in range(6):\n        for j in range(5):\n            # Remove corner indices to leave exactly 26 points\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points.append([0.1 + i * 0.16, 0.1 + j * 0.2])\n    c = np.array(points)[:n]\n    \n    # Break symmetry and jitter to help the optimizer find global trends\n    np.random.seed(42)\n    c += np.random.normal(0, 0.01, c.shape)\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initial radii guess\n    r = np.full(n, 0.08)\n    \n    # 2. Optimization Phase (Adam)\n    # This phase moves centers and radii to minimize overlaps and maximize growth.\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.002\n    \n    iters = 3000\n    for t in range(1, iters + 1):\n        # Penalty grows to transition from soft to hard constraints\n        penalty_coeff = 5.0 + t * 0.2\n        \n        # Gradients: dr objective is -1 (maximizing sum is minimizing negative sum)\n        dc = np.zeros_like(c)\n        dr = -np.ones(n)\n        \n        # Boundary constraints gradients (minimize square of violation)\n        for i in range(2):\n            # Low boundary: r_i - c_i <= 0\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            dr[mask_low] += 2 * penalty_coeff * v_low[mask_low]\n            dc[mask_low, i] -= 2 * penalty_coeff * v_low[mask_low]\n            \n            # High boundary: c_i + r_i - 1 <= 0\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            dr[mask_high] += 2 * penalty_coeff * v_high[mask_high]\n            dc[mask_high, i] += 2 * penalty_coeff * v_high[mask_high]\n            \n        # Pairwise overlap constraints gradients: r_i + r_j - dist_ij <= 0\n        for i in range(n):\n            diff = c[i] - c[i + 1:]\n            # Distance with stability constant to avoid division by zero\n            dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n            sum_r = r[i] + r[i + 1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n            \n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = dists[mask]\n                df = diff[mask]\n                \n                # Radii penalty gradients\n                grad_r = 2 * penalty_coeff * ov\n                dr[i] += np.sum(grad_r)\n                dr[idx] += grad_r\n                \n                # Center penalty gradients (pushing overlapping circles apart)\n                grad_c = (grad_r / di)[:, np.newaxis] * df\n                dc[i] -= np.sum(grad_c, axis=0)\n                dc[idx] += grad_c\n        \n        # Adam update for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam update for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Keeping centers and radii within logical bounds\n        c = np.clip(c, 0.0, 1.0)\n        r = np.clip(r, 0.0, 0.5)\n\n    # 3. Radius Refinement (Linear Programming)\n    # Fix center locations and solve for mathematically optimal radii values.\n    A_ub, b_ub, bounds = [], [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            b_ub.append(dist)\n        # Radius for circle i is limited by its distance to the 4 edges\n        dist_to_edge = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        bounds.append((0, max(0.0, dist_to_edge)))\n    \n    # Solve LP: Minimize -sum(r) to maximize sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bounds, method='highs')\n    \n    if res_lp.success:\n        r_final = res_lp.x\n    else:\n        r_final = r\n\n    # 4. Final Feasibility Check and Post-processing\n    # Ensure zero overlap and zero boundary violations under precision.\n    r_final *= (1.0 - 1e-10)\n    for i in range(n):\n        r_final[i] = min(r_final[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            if r_final[i] + r_final[j] > dist:\n                over = (r_final[i] + r_final[j]) - dist\n                r_final[i] -= over * 0.5\n                r_final[j] -= over * 0.5\n    \n    r_final = np.maximum(r_final, 0.0)\n    sum_r = np.sum(r_final)\n    \n    return c, r_final, sum_r\n\n\n# Execution to define required output variables\ncenters, radii, sum_radii = run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9921, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    Employs a multi-start strategy with physics-inspired Adam optimization \n    to find center configurations and Linear Programming (HiGHS) to solve \n    for the exact optimal radii.\n    \"\"\"\n    n = 26\n\n    def optimize_arrangement(c_init, seed_val, iters=3000):\n        \"\"\"\n        Moves centers and expands radii using the Adam optimizer to maximize\n        the sum of radii while satisfying boundary and non-overlap constraints.\n        \"\"\"\n        np.random.seed(seed_val)\n        c = c_init + np.random.normal(0, 0.015, c_init.shape)\n        c = np.clip(c, 0.05, 0.95)\n        r = np.full(n, 0.06)\n\n        m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        lr = 0.0025\n\n        for t in range(1, iters + 1):\n            penalty_coeff = 2.0 + t * 0.22\n            dc = np.zeros_like(c)\n            dr = -np.ones(n)  # Minimize -sum(r) to maximize sum(r)\n\n            # 1. Boundary violations\n            for i in range(2):\n                # Low side: r - c_i <= 0\n                v_low = r - c[:, i]\n                mask_low = v_low > 0\n                grad_low = 2 * penalty_coeff * v_low[mask_low]\n                dr[mask_low] += grad_low\n                dc[mask_low, i] -= grad_low\n\n                # High side: c_i + r - 1 <= 0\n                v_high = c[:, i] + r - 1.0\n                mask_high = v_high > 0\n                grad_high = 2 * penalty_coeff * v_high[mask_high]\n                dr[mask_high] += grad_high\n                dc[mask_high, i] += grad_high\n\n            # 2. Pairwise overlaps: r_i + r_j - dist_ij <= 0\n            for i in range(n):\n                diff = c[i] - c[i + 1:]\n                dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n                sum_r = r[i] + r[i + 1:]\n                overlap = sum_r - dists\n                mask = overlap > 0\n\n                if np.any(mask):\n                    idx = np.where(mask)[0] + i + 1\n                    ov = overlap[mask]\n                    di = dists[mask]\n                    df = diff[mask]\n\n                    grad_pair = 2 * penalty_coeff * ov\n                    dr[i] += np.sum(grad_pair)\n                    dr[idx] += grad_pair\n\n                    # Center movement grads (pushing circles apart)\n                    grad_c = (grad_pair / di)[:, np.newaxis] * df\n                    dc[i] -= np.sum(grad_c, axis=0)\n                    dc[idx] += grad_c\n\n            # Adam updates for centers\n            m_c = beta1 * m_c + (1 - beta1) * dc\n            v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n            m_c_hat = m_c / (1 - beta1**t)\n            v_c_hat = v_c / (1 - beta2**t)\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n            # Adam updates for radii\n            m_r = beta1 * m_r + (1 - beta1) * dr\n            v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n            m_r_hat = m_r / (1 - beta1**t)\n            v_r_hat = v_r / (1 - beta2**t)\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n            c = np.clip(c, 0.0, 1.0)\n            r = np.clip(r, 0.0, 0.5)\n\n        return c, r\n\n    # Phase 1: Multiple Initializations\n    initial_configs = []\n    \n    # Init A: 6x5 grid (30 slots), remove 4 corners\n    points_a = []\n    xs_a = np.linspace(0.1, 0.9, 6)\n    ys_a = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points_a.append([xs_a[i], ys_a[j]])\n    initial_configs.append((np.array(points_a)[:n], 42, 3000))\n\n    # Init B: 7x4 grid (28 slots), remove 2 corners\n    points_b = []\n    xs_b = np.linspace(0.08, 0.92, 7)\n    ys_b = np.linspace(0.12, 0.88, 4)\n    for i in range(7):\n        for j in range(4):\n            if not ((i == 0 or i == 6) and (j == 0)):\n                points_b.append([xs_b[i], ys_b[j]])\n    initial_configs.append((np.array(points_b)[:n], 123, 2000))\n\n    best_total_sum = 0\n    best_c_found = None\n    best_r_found = None\n\n    # Phase 2: Run Optimizations and LP Refinement\n    for c_init, seed, iterations in initial_configs:\n        c_refined, r_adam = optimize_arrangement(c_init, seed, iterations)\n        \n        # Linear Programming to solve for exact optimal radii for these centers\n        A_ub, b_ub, bounds = [], [], []\n        dist_to_edge = np.min([c_refined[:, 0], 1.0 - c_refined[:, 0], \n                               c_refined[:, 1], 1.0 - c_refined[:, 1]], axis=0)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c_refined[i] - c_refined[j])\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n            bounds.append((0, max(0.0, dist_to_edge[i])))\n\n        res = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                      bounds=bounds, method='highs')\n        \n        if res.success:\n            r_lp = res.x\n            current_sum = np.sum(r_lp)\n        else:\n            r_lp = r_adam\n            current_sum = np.sum(r_adam)\n\n        if current_sum > best_total_sum:\n            best_total_sum = current_sum\n            best_c_found = c_refined\n            best_r_found = r_lp\n\n    # Phase 3: Post-processing for strict validity\n    final_c = best_c_found\n    final_r = best_r_found * (1.0 - 1e-11)\n    \n    # Enforce boundary constraints strictly\n    for i in range(n):\n        final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0], \n                         final_c[i, 1], 1.0 - final_c[i, 1])\n    \n    # Enforce non-overlap constraints strictly\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            if final_r[i] + final_r[j] > dist:\n                over = (final_r[i] + final_r[j]) - dist\n                final_r[i] -= over * 0.5 + 1e-15\n                final_r[j] -= over * 0.5 + 1e-15\n\n    final_r = np.maximum(final_r, 0.0)\n    final_sum = np.sum(final_r)\n\n    return final_c, final_r, final_sum\n\n\n# Final execution variables\ncenters, radii, sum_radii = run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9773, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Directly produces an arrangement of 26 circles in a unit square to maximize\n    the sum of their radii. Uses a physics-inspired Adam optimization for center\n    placement followed by Linear Programming for mathematically optimal radii.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    # 1. Initialization: 6x5 grid (30 slots) minus 4 corners to get 26 points\n    points = []\n    xs = np.linspace(0.1, 0.9, 6)\n    ys = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            # Remove corner indices to reach exactly 26 points\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points.append([xs[i], ys[j]])\n    c = np.array(points)\n\n    # Add slight jitter to break symmetry and aid the gradient descent\n    c += np.random.normal(0, 0.01, c.shape)\n    c = np.clip(c, 0.01, 0.99)\n\n    # Initial radii guess\n    r = np.full(n, 0.08)\n\n    # 2. Optimization Phase (Adam)\n    # This phase moves centers to create space for larger circles.\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.003\n\n    iters = 2500\n    for t in range(1, iters + 1):\n        # Penalty coefficient increases to gradually enforce hard constraints\n        penalty_coeff = 2.0 + t * 0.15\n\n        dc = np.zeros_like(c)\n        dr = -np.ones(n)  # Gradient of objective -sum(r)\n\n        # Boundary constraints gradients (minimize square of violation: (r - dist_to_edge)^2)\n        for i in range(2):\n            # Lower boundary: r_i - c_i <= 0\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            grad_low = 2 * penalty_coeff * v_low[mask_low]\n            dr[mask_low] += grad_low\n            dc[mask_low, i] -= grad_low\n\n            # Upper boundary: c_i + r_i - 1 <= 0\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            grad_high = 2 * penalty_coeff * v_high[mask_high]\n            dr[mask_high] += grad_high\n            dc[mask_high, i] += grad_high\n\n        # Pairwise overlap constraints gradients: r_i + r_j - dist_ij <= 0\n        for i in range(n):\n            diff = c[i] - c[i + 1:]\n            # Distance with tiny epsilon for numerical stability\n            dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n            sum_r = r[i] + r[i + 1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n\n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = dists[mask]\n                df = diff[mask]\n\n                # Gradients w.r.t radii\n                grad_r = 2 * penalty_coeff * ov\n                dr[i] += np.sum(grad_r)\n                dr[idx] += grad_r\n\n                # Gradients w.r.t centers (pushing them apart)\n                grad_c = (grad_r / di)[:, np.newaxis] * df\n                dc[i] -= np.sum(grad_c, axis=0)\n                dc[idx] += grad_c\n\n        # Adam update for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam update for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Keep values within physically possible bounds\n        c = np.clip(c, 0.0, 1.0)\n        r = np.clip(r, 0.0, 0.5)\n\n    # 3. Radius Refinement (Linear Programming)\n    # Fix optimized center locations and solve for mathematically optimal radii.\n    A_ub, b_ub, bounds = [], [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            b_ub.append(dist)\n\n        # Radius for circle i is constrained by its distance to the 4 walls\n        dist_to_edge = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        bounds.append((0, max(0.0, dist_to_edge)))\n\n    # Minimize -sum(r) to maximize sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub),\n                     bounds=bounds, method='highs')\n\n    if res_lp.success:\n        r_final = res_lp.x\n    else:\n        r_final = r\n\n    # 4. Strict Feasibility Post-processing\n    # Ensure zero overlap and zero boundary violations under precision limits.\n    r_final *= (1.0 - 1e-12)\n    for i in range(n):\n        r_final[i] = min(r_final[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            if r_final[i] + r_final[j] > dist:\n                over = (r_final[i] + r_final[j]) - dist\n                # Correct by shrinking both circles slightly\n                r_final[i] -= over * 0.5 + 1e-15\n                r_final[j] -= over * 0.5 + 1e-15\n\n    r_final = np.maximum(r_final, 0.0)\n    sum_r = np.sum(r_final)\n\n    return c, r_final, sum_r\n\n\n# Generate the packing results for evaluation\ncenters, radii, sum_radii = run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef get_initial_layouts(n):\n    \"\"\"\n    Generate multiple diverse starting configurations for the optimization.\n    Returns a list of (n, 2) numpy arrays representing initial circle centers.\n    \"\"\"\n    layouts = []\n    \n    # 1. 5x5 grid + 1 extra in corner\n    grid = np.linspace(0.12, 0.88, 5)\n    xv, yv = np.meshgrid(grid, grid)\n    c1 = np.column_stack([xv.ravel(), yv.ravel()])\n    c1 = np.vstack([c1, [0.95, 0.95]])\n    layouts.append(c1)\n    \n    # 2. 6x5 grid minus 4 corners\n    c2 = []\n    xs = np.linspace(0.1, 0.9, 6)\n    ys = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                c2.append([xs[i], ys[j]])\n    layouts.append(np.array(c2))\n    \n    # 3. Staggered hexagonal-like (5-6-5-6-4)\n    c3 = []\n    for r_idx, count in enumerate([5, 6, 5, 6, 4]):\n        for c_idx in range(count):\n            x = (c_idx + 0.5 + (0.3 if r_idx % 2 == 1 else 0)) / 6.5\n            y = (r_idx + 0.5) / 5.0\n            c3.append([x, y])\n    layouts.append(np.array(c3))\n    \n    # 4. Dense row layout 6-7-6-7\n    c4 = []\n    for r_idx, count in enumerate([6, 7, 6, 7]):\n        for c_idx in range(count):\n            x = (c_idx + 0.5) / count\n            y = (r_idx + 0.5) / 4.0\n            c4.append([x, y])\n    layouts.append(np.array(c4))\n    \n    # 5. Alternate dense row layout 5-5-6-5-5\n    c5 = []\n    for r_idx, count in enumerate([5, 5, 6, 5, 5]):\n        for c_idx in range(count):\n            x = (c_idx + 0.5) / count\n            y = (r_idx + 0.5) / 5.0\n            c5.append([x, y])\n    layouts.append(np.array(c5))\n    \n    # 6. Tapered layout 3-5-5-5-5-3\n    c6 = []\n    for r_idx, count in enumerate([3, 5, 5, 5, 5, 3]):\n        for c_idx in range(count):\n            x = (c_idx + 0.5) / count\n            y = (r_idx + 0.5\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of radii.\n    Employs a physics-inspired optimization (Adam) to locate centers and \n    Linear Programming (HiGHS) to determine the mathematically optimal radii.\n    The start is a refined 6x5 grid (minus corners) to ensure good coverage.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialization: 6x5 grid and remove 4 corners to get 26 points\n    points = []\n    for i in range(6):\n        for j in range(5):\n            # Remove corner indices to leave exactly 26 points\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points.append([0.1 + i * 0.16, 0.1 + j * 0.2])\n    c = np.array(points)[:n]\n    \n    # Break symmetry and jitter to help the optimizer find global trends\n    np.random.seed(42)\n    c += np.random.normal(0, 0.01, c.shape)\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initial radii guess\n    r = np.full(n, 0.08)\n    \n    # 2. Optimization Phase (Adam)\n    # This phase moves centers and radii to minimize overlaps and maximize growth.\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.002\n    \n    iters = 3000\n    for t in range(1, iters + 1):\n        # Penalty grows to transition from soft to hard constraints\n        penalty_coeff = 5.0 + t * 0.2\n        \n        # Gradients: dr objective is -1 (maximizing sum is minimizing negative sum)\n        dc = np.zeros_like(c)\n        dr = -np.ones(n)\n        \n        # Boundary constraints gradients (minimize square of violation)\n        for i in range(2):\n            # Low boundary: r_i - c_i <= 0\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            dr[mask_low] += 2 * penalty_coeff * v_low[mask_low]\n            dc[mask_low, i] -= 2 * penalty_coeff * v_low[mask_low]\n            \n            # High boundary: c_i + r_i - 1 <= 0\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            dr[mask_high] += 2 * penalty_coeff * v_high[mask_high]\n            dc[mask_high, i] += 2 * penalty_coeff * v_high[mask_high]\n            \n        # Pairwise overlap constraints gradients: r_i + r_j - dist_ij <= 0\n        for i in range(n):\n            diff = c[i] - c[i + 1:]\n            # Distance with stability constant to avoid division by zero\n            dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n            sum_r = r[i] + r[i + 1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n            \n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = dists[mask]\n                df = diff[mask]\n                \n                # Radii penalty gradients\n                grad_r = 2 * penalty_coeff * ov\n                dr[i] += np.sum(grad_r)\n                dr[idx] += grad_r\n                \n                # Center penalty gradients (pushing overlapping circles apart)\n                grad_c = (grad_r / di)[:, np.newaxis] * df\n                dc[i] -= np.sum(grad_c, axis=0)\n                dc[idx] += grad_c\n        \n        # Adam update for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam update for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Keeping centers and radii within logical bounds\n        c = np.clip(c, 0.0, 1.0)\n        r = np.clip(r, 0.0, 0.5)\n\n    # 3. Radius Refinement (Linear Programming)\n    # Fix center locations and solve for mathematically optimal radii values.\n    A_ub, b_ub, bounds = [], [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            b_ub.append(dist)\n        # Radius for circle i is limited by its distance to the 4 edges\n        dist_to_edge = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        bounds.append((0, max(0.0, dist_to_edge)))\n    \n    # Solve LP: Minimize -sum(r) to maximize sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bounds, method='highs')\n    \n    if res_lp.success:\n        r_final = res_lp.x\n    else:\n        r_final = r\n\n    # 4. Final Feasibility Check and Post-processing\n    # Ensure zero overlap and zero boundary violations under precision.\n    r_final *= (1.0 - 1e-10)\n    for i in range(n):\n        r_final[i] = min(r_final[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            if r_final[i] + r_final[j] > dist:\n                over = (r_final[i] + r_final[j]) - dist\n                r_final[i] -= over * 0.5\n                r_final[j] -= over * 0.5\n    \n    r_final = np.maximum(r_final, 0.0)\n    sum_r = np.sum(r_final)\n    \n    return c, r_final, sum_r\n\n\n# Execution to define required output variables\ncenters, radii, sum_radii = run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    Employs a multi-start strategy with physics-inspired Adam optimization\n    to find center configurations and Linear Programming (HiGHS) to solve\n    for the exact optimal radii.\n    \"\"\"\n    n = 26\n\n    def optimize_arrangement(c_init, seed_val, iters=4000):\n        \"\"\"\n        Moves centers and expands radii using the Adam optimizer to maximize\n        the sum of radii while satisfying boundary and non-overlap constraints.\n        \"\"\"\n        np.random.seed(seed_val)\n        c = c_init + np.random.normal(0, 0.012, c_init.shape)\n        c = np.clip(c, 0.02, 0.98)\n        r = np.full(n, 0.08)\n\n        m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        lr = 0.0035\n\n        for t in range(1, iters + 1):\n            # Penalty coefficient grows slowly to allow centers to rearrange\n            penalty_coeff = 1.5 + (t / iters) * 600.0\n            dc = np.zeros_like(c)\n            dr = -np.ones(n)  # Minimize -sum(r) to maximize sum(r)\n\n            # 1. Boundary violations\n            for i in range(2):\n                # Low side: r_i - c_i <= 0\n                v_low = r - c[:, i]\n                mask_low = v_low > 0\n                grad_low = 2 * penalty_coeff * v_low[mask_low]\n                dr[mask_low] += grad_low\n                dc[mask_low, i] -= grad_low\n\n                # High side: c_i + r_i - 1 <= 0\n                v_high = c[:, i] + r - 1.0\n                mask_high = v_high > 0\n                grad_high = 2 * penalty_coeff * v_high[mask_high]\n                dr[mask_high] += grad_high\n                dc[mask_high, i] += grad_high\n\n            # 2. Pairwise overlaps: r_i + r_j - dist_ij <= 0\n            for i in range(n):\n                diff = c[i] - c[i + 1:]\n                dists_sq = np.sum(diff**2, axis=1)\n                dists = np.sqrt(dists_sq + 1e-12)\n                sum_r = r[i] + r[i + 1:]\n                overlap = sum_r - dists\n                mask = overlap > 0\n\n                if np.any(mask):\n                    idx = np.where(mask)[0] + i + 1\n                    ov = overlap[mask]\n                    di = dists[mask]\n                    df = diff[mask]\n\n                    grad_pair = 2 * penalty_coeff * ov\n                    dr[i] += np.sum(grad_pair)\n                    dr[idx] += grad_pair\n\n                    grad_c = (grad_pair / di)[:, np.newaxis] * df\n                    dc[i] -= np.sum(grad_c, axis=0)\n                    dc[idx] += grad_c\n\n            # Adam updates for centers\n            m_c = beta1 * m_c + (1 - beta1) * dc\n            v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n            c -= lr * (m_c / (1 - beta1**t)) / (np.sqrt(v_c / (1 - beta2**t)) + eps)\n\n            # Adam updates for radii\n            m_r = beta1 * m_r + (1 - beta1) * dr\n            v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n            r -= lr * (m_r / (1 - beta1**t)) / (np.sqrt(v_r / (1 - beta2**t)) + eps)\n\n            c = np.clip(c, 0.0, 1.0)\n            r = np.clip(r, 0.0, 0.5)\n\n        return c\n\n    # Phase 1: Strategic Initializations\n    initial_configs = []\n\n    # Layout A: 6x5 grid (30 slots), remove 4 corners\n    points_a = []\n    xs_a = np.linspace(0.1, 0.9, 6)\n    ys_a = np.linspace(0.1, 0.9, 5)\n    for i in range(6):\n        for j in range(5):\n            if not ((i == 0 or i == 5) and (j == 0 or j == 4)):\n                points_a.append([xs_a[i], ys_a[j]])\n    initial_configs.append((np.array(points_a)[:n], 42))\n\n    # Layout B: Staggered row layout [5, 6, 5, 6, 4]\n    points_b = []\n    rows = [5, 6, 5, 6, 4]\n    for r_idx, count in enumerate(rows):\n        xs_b = np.linspace(0.08, 0.92, count)\n        y_b = 0.08 + r_idx * 0.21\n        for x_b in xs_b:\n            points_b.append([x_b, y_b])\n    initial_configs.append((np.array(points_b)[:n], 777))\n\n    # Layout C: 7x4 grid (28 slots), remove 2 corners\n    points_c = []\n    xs_c = np.linspace(0.07, 0.93, 7)\n    ys_c = np.linspace(0.1, 0.9, 4)\n    for i in range(7):\n        for j in range(4):\n            if not ((i == 0 or i == 6) and (j == 0)):\n                points_c.append([xs_c[i], ys_c[j]])\n    initial_configs.append((np.array(points_c)[:n], 123))\n\n    best_total_sum = 0\n    best_c_found = None\n    best_r_found = None\n\n    # Phase 2: Run Optimizations and LP Refinement\n    for c_start, seed in initial_configs:\n        c_refined = optimize_arrangement(c_start, seed, iters=3500)\n\n        # Linear Programming to find the exact optimal radii for fixed centers\n        A_ub, b_ub, bounds = [], [], []\n        dist_to_edge = np.min([c_refined[:, 0], 1.0 - c_refined[:, 0],\n                               c_refined[:, 1], 1.0 - c_refined[:, 1]], axis=0)\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(c_refined[i] - c_refined[j])\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n            bounds.append((0, max(0.0, dist_to_edge[i])))\n\n        res = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub),\n                      bounds=bounds, method='highs')\n\n        if res.success:\n            current_sum = np.sum(res.x)\n            if current_sum > best_total_sum:\n                best_total_sum = current_sum\n                best_c_found = c_refined\n                best_r_found = res.x\n\n    # Phase 3: Post-processing for strict validity\n    final_c = best_c_found\n    final_r = best_r_found * (1.0 - 1e-12)\n\n    # Enforce boundary constraints strictly\n    for i in range(n):\n        final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0],\n                         final_c[i, 1], 1.0 - final_c[i, 1])\n\n    # Enforce non-overlap constraints strictly\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            if final_r[i] + final_r[j] > dist:\n                over = (final_r[i] + final_r[j]) - dist\n                final_r[i] -= over * 0.5 + 1e-15\n                final_r[j] -= over * 0.5 + 1e-15\n\n    final_r = np.maximum(final_r, 0.0)\n    final_sum = np.sum(final_r)\n\n    return final_c, final_r, final_sum\n\n\n# Produce result variables\ncenters, radii, sum_radii = run_packing()\n```"]}}, "artifacts_json": "{\"execution_time\": \"19.76s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.598075/2.635 = 0.9860\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 98.6% of target value\", \"radius_stats\": \"Min: 0.060157, Max: 0.153829, Avg: 0.099926\"}", "artifact_dir": null, "embedding": null}