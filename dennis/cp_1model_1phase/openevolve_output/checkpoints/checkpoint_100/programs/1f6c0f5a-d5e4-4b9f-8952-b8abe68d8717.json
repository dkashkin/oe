{"id": "1f6c0f5a-d5e4-4b9f-8952-b8abe68d8717", "code": "import numpy as np\n\n\ndef compute_max_radii(centers, trials=200):\n    \"\"\"\n    Given fixed center coordinates within a unit square, this function \n    maximizes the total sum of radii using coordinate descent with \n    many expansion orders. This efficiently approximates the global \n    optimum for the Linear Program: maximize sum(r_i) s.t. \n    r_i + r_j <= d_ij and r_i <= dist_to_boundary_i.\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary limits for each center: min(x, y, 1-x, 1-y)\n    b_limits = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    \n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints during expansion\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Strategic orders based on spatial placement and boundary proximity\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1])),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(np.sum(centers**2, axis=1)),\n        np.argsort(np.sum((centers - 1.0)**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([0, 1]))**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([1, 0]))**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Coordinate descent: multiple passes allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Max radius r_i = min(boundary, dist(i,j) - r_j for all j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square to maximize the sum of radii.\n    Uses multi-start force-directed relaxation with various target \n    separations and initial topologies followed by radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target diameters likely to yield efficient packings\n    target_dists = np.linspace(0.185, 0.225, 12)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible diversity across restarts\n        np.random.seed(123 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based, staggered rows, or random\n        if restart == 0:\n            # 5x5 grid plus one circle at center\n            centers = []\n            for i in range(5):\n                for j in range(5):\n                    centers.append([0.1 + 0.2 * i, 0.1 + 0.2 * j])\n            centers.append([0.5, 0.5])\n            centers = np.array(centers)\n        elif restart == 1:\n            # Staggered rows (5, 6, 5, 6, 4 pattern = 26)\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Vertical staggered pattern\n            centers = []\n            for c_idx, num in enumerate([6, 5, 6, 5, 4]):\n                x = (c_idx + 0.5) / 5.0\n                for r_idx in range(num):\n                    centers.append([x, (r_idx + 0.5) / num])\n            centers = np.array(centers)\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters: cooling and jitter\n        iters = 1800\n        dt_base = 0.05\n        \n        for k in range(iters):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            # Prevent division by zero\n            safe_dists = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n            \n            # Repulsion force if centers are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / safe_dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update positions with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Annealing: add decreasing stochastic noise early on\n            if k < iters * 0.6:\n                noise_scale = 0.003 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to solve for optimal radii\n        radii, current_sum = compute_max_radii(centers, trials=150)\n        \n        # Track the globally best arrangement found\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")", "changes_description": null, "language": "python", "parent_id": "06390adf-2191-4726-ac31-7142bec30835", "generation": 3, "timestamp": 1771870824.7496266, "iteration_found": 86, "metrics": {"validity": 1.0, "sum_radii": 2.453513483798563, "target_ratio": 0.9311246617831359, "combined_score": 0.9311246617831359, "radius_variance": 0.0022525882355603453, "spatial_spread": 0.19659405356513354, "eval_time": 2.5623269081115723}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.190124774314937, "target_ratio": 0.8311668972732209, "combined_score": 0.8311668972732209, "radius_variance": 0.0216769036735023, "spatial_spread": 0.18915878345556675, "eval_time": 3.999725103378296}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.8312\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9431 \u2192 0.8312. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n4.00s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.190125/2.635 = 0.8312\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4850, target_ratio: 0.9431, combined_score: 0.9431, radius_variance: 0.0002, spatial_spread: 0.1910, eval_time: 3.4374\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4864, target_ratio: 0.9436, combined_score: 0.9436, radius_variance: 0.0002, spatial_spread: 0.1903, eval_time: 7.9801\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4892, target_ratio: 0.9447, combined_score: 0.9447, radius_variance: 0.0008, spatial_spread: 0.1841, eval_time: 3.1322\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9447)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=180):\n    \"\"\"\n    Given a fixed set of center positions, this function determines the \n    radii that maximize the total sum of radii subject to no overlaps \n    and boundary constraints. It uses a coordinate descent approach \n    with multiple randomized greedy expansion orders.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        np.ndarray: (n,) array of optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders: boundary proximity, coordinate-based, and center-based\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Two passes of greedy expansion to ensure stability\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a force-directed physics \n    simulation with cooling and restarts. Each configuration is then \n    optimized for the maximum sum of radii.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    # This helps find different packing topologies (e.g., staggered rows)\n    target_dists = np.linspace(0.198, 0.218, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Set seed per restart for reproducible diversity\n        np.random.seed(42 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based or random\n        if restart == 0:\n            # 5x5 grid plus one circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Row-based staggered initialization\n            centers = []\n            rows = [5, 6, 5, 6, 4]\n            for r_idx, num_circles in enumerate(rows):\n                for c_idx in range(num_circles):\n                    centers.append([(c_idx + 0.5) / num_circles, (r_idx + 0.5) / 5])\n            centers = np.array(centers[:n])\n        else:\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        # Physics simulation: particles repel each other and square boundaries\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion force\n            overlap = np.maximum(0, t_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Boundary repulsion forces\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add decreasing noise early in the simulation\n            if k < iters * 0.6:\n                noise_scale = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process centers to solve for optimal radii\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Keep the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4892), Performs well on target_ratio (0.9447), Performs well on combined_score (0.9447), Performs well on radius_variance (0.0008), Performs well on spatial_spread (0.1841), Performs well on eval_time (3.1322)\n\n### Program 2 (Score: 0.9436)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center coordinates within \n    a unit square. Uses coordinate descent with various greedy expansion \n    orders and multiple trials to find an optimal set of radii that satisfy \n    all non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Vectorized precomputation of pairwise distances and boundary limits\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Boundary limits for each center: distance to nearest square edge\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Mask to ignore self-distance in calculations\n    mask = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: heuristic sorting and random permutations\n    orders = [\n        np.argsort(boundary_limits),\n        np.argsort(-boundary_limits),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Multiple passes ensure the radii converge to a stable local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(boundary_limits[i], np.min(dist_matrix[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a \n    force-directed physics simulation with cooling and jitter across \n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.222, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(800 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Shifted 5x5 grid with one extra circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-6-5-6-4 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Randomly jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.025, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters: iterations and initial step size\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion magnitude proportional to overlap\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Square boundary repulsion forces\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with linear cooling schedule\n            cooling = 1.0 - 0.9 * k / iters\n            dt = dt_base * cooling\n            centers += forces * dt\n\n            # Add decreasing stochastic noise to skip local minima\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Final greedy radius maximization for the current configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4864), Performs well on target_ratio (0.9436), Performs well on combined_score (0.9436), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1903), Performs well on eval_time (7.9801)\n\n### Program 3 (Score: 0.9431)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=220):\n    \"\"\"\n    Given fixed center coordinates within a unit square, this function maximizes \n    the total sum of radii. It uses greedy coordinate descent with a wide variety \n    of expansion orders to explore the solution space of radii assignments \n    subject to non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center: min(x, y, 1-x, 1-y)\n    b_limits = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints during expansion\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders based on spatial placement and boundary proximity\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1])),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(np.sum(centers**2, axis=1)),\n        np.argsort(np.sum((centers - 1.0)**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([0, 1]))**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([1, 0]))**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Multi-pass coordinate descent to reach a stable local maximum\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j for all j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed \n    physics simulation with cooling and jitter to find diverse packing \n    topologies. Each configuration is then optimized for the maximum sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Sweep across a range of target separation distances to discover optimal grids and clusters\n    target_dists = np.linspace(0.194, 0.228, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Unique seed per restart for reproducible diversity\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based, staggered rows, or random\n        if restart == 0:\n            # 5x5 grid plus one circle at center\n            centers = []\n            for i in range(5):\n                for j in range(5):\n                    centers.append([0.1 + 0.2 * i, 0.1 + 0.2 * j])\n            centers.append([0.5, 0.5])\n            centers = np.array(centers)\n        elif restart == 1:\n            # Staggered rows (5, 6, 5, 6, 4 pattern)\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, (r_idx + 0.5) / 5.0])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Alternate staggered rows (6, 5, 6, 5, 4 pattern)\n            centers = []\n            for r_idx, num in enumerate([6, 5, 6, 5, 4]):\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, (r_idx + 0.5) / 5.0])\n            centers = np.array(centers)\n        elif restart == 3:\n            # Vertical rows (6, 6, 6, 6, 2 pattern)\n            centers = []\n            for r_idx, num in enumerate([6, 6, 6, 6, 2]):\n                for c_idx in range(num):\n                    centers.append([(r_idx + 0.5) / 5.0, (c_idx + 0.5) / num])\n            centers = np.array(centers)\n        else:\n            # Uniform random distribution\n            centers = np.random.uniform(0.05, 0.95, (n, 2))\n\n        # Simulation parameters: power-based cooling and jitter\n        iters = 2000\n        dt_base = 0.05\n        \n        for k in range(iters):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2)) + 1e-12\n            \n            # Pairwise repulsion force magnitude proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Square boundary repulsion: push centers toward viable interior positions\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update with linear cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add stochastic noise in the early phases\n            if k < iters * 0.65:\n                noise_scale = 0.0025 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to solve for optimal radii\n        radii, current_sum = compute_max_radii(centers, 220)\n        \n        # Track the globally best arrangement\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4850), Performs well on target_ratio (0.9431), Performs well on combined_score (0.9431), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1910), Performs well on eval_time (3.4374)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9414)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=150):\n    \"\"\"\n    Maximizes the total sum of radii for fixed center positions within a unit square.\n    The problem of maximizing sum(r_i) subject to r_i + r_j <= d_ij and \n    r_i <= boundary_limit_i is a Linear Program. This function approximates the \n    optimal solution using coordinate descent with multiple expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary constraints: x, y, 1-x, 1-y\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Pairwise distances\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Mask to ignore self-interactions\n    mask = np.eye(n) * 1e10\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic and randomized orders for coordinate descent\n    # Strategic ordering allows some circles to grow large at the expense of others\n    heuristic_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(centers[:, 0] - centers[:, 1])\n    ]\n\n    for trial in range(trials):\n        if trial < len(heuristic_orders):\n            order = heuristic_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Multiple passes of expansion to converge towards a local optimum\n        for _ in range(12):\n            for i in order:\n                # Maximize r_i subject to all current neighbor constraints\n                # r_i <= d_ij - r_j  for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Finds a packing of 26 circles in a unit square that maximizes the sum of radii.\n    Uses multi-start force-directed relaxation with various target separation distances\n    and initial configurations to explore different packing topologies.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target distances (diameters) likely to yield good packing\n    target_dists = np.linspace(0.192, 0.228, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible diversity across restarts\n        np.random.seed(3000 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversified initial center layouts\n        if restart == 0:\n            # Shifted 5x5 grid + 1 circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered pattern (5-6-5-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Staggered pattern (4-6-6-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([4, 6, 6, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        else:\n            # Jittered grid or random initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n            \n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2500\n        dt_base = 0.075\n\n        for k in range(iters):\n            # Compute pairwise displacement and distance matrices\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            \n            # Repulsion force if circles overlap the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Boundary repulsion: keep centers at least r_target from edges\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Apply update with a power-based cooling schedule\n            cooling = (1.0 - k / iters) ** 1.3\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Annealing: Add decreasing stochastic noise early on\n            if k < iters * 0.6:\n                noise_scale = 0.0035 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to find maximized radii\n        radii, current_sum = compute_max_radii(centers)\n        \n        # Track the global best configuration\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9413)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=250):\n    \"\"\"\n    Maximizes the sum of radii for fixed center positions within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    and coordinate descent passes to find a high-performing radii distribution.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a mask to ignore self-distances in minimization\n    mask = np.eye(n) * 1e10\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 15:\n            # Sort by distance from the center of the square\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        # Multiple passes of expansion to allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Radius r_i limited by walls and currently set radii of others\n                # dist(i,j) >= r_i + r_j  =>  r_i <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed\n    physics simulation with cooling and jitter to find an optimal configuration\n    for maximizing the total sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to diversify configurations\n    target_dists = np.linspace(0.190, 0.220, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Specific seeds for reproducible diversity\n        np.random.seed(2024 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered hexagonal-style rows\n            centers = []\n            row_pattern = [5, 6, 5, 6, 4]\n            for r_idx, num_c in enumerate(row_pattern):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers[:n])\n        elif restart < 8:\n            # Randomly jittered grid\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Physics simulation loop\n        iters = 2200\n        dt_base = 0.06\n\n        for k in range(iters):\n            # Pairwise repulsion calculation\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n\n            # Repulsion force if circles are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Step update with cooling schedule\n            cooling = (1.0 - k / iters)**1.2\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Annealing: Add decreasing noise early in the simulation\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9436, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center coordinates within \n    a unit square. Uses coordinate descent with various greedy expansion \n    orders and multiple trials to find an optimal set of radii that satisfy \n    all non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Vectorized precomputation of pairwise distances and boundary limits\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Boundary limits for each center: distance to nearest square edge\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Mask to ignore self-distance in calculations\n    mask = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: heuristic sorting and random permutations\n    orders = [\n        np.argsort(boundary_limits),\n        np.argsort(-boundary_limits),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Multiple passes ensure the radii converge to a stable local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(boundary_limits[i], np.min(dist_matrix[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a \n    force-directed physics simulation with cooling and jitter across \n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.222, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(800 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Shifted 5x5 grid with one extra circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-6-5-6-4 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Randomly jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.025, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters: iterations and initial step size\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion magnitude proportional to overlap\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Square boundary repulsion forces\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with linear cooling schedule\n            cooling = 1.0 - 0.9 * k / iters\n            dt = dt_base * cooling\n            centers += forces * dt\n\n            # Add decreasing stochastic noise to skip local minima\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Final greedy radius maximization for the current configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\n\n\ndef optimize_with_adam(centers_init, iters=2800):\n    \"\"\"\n    Simultaneously optimizes both center positions and radii to maximize \n    the total sum of radii using Adam gradient descent. Overlap and \n    boundary constraints are enforced via an increasing penalty method.\n    \"\"\"\n    n = centers_init.shape[0]\n    var = np.zeros((n, 3))\n    var[:, :2] = centers_init\n    var[:, 2] = 0.05  # Initial guess for radii\n    \n    m = np.zeros_like(var)\n    v = np.zeros_like(var)\n    beta1 = 0.9\n    beta2 = 0.999\n    lr = 0.01\n    eps = 1e-8\n    \n    # Starting penalty multiplier\n    c_penalty = 2.0\n    \n    for t in range(1, iters + 1):\n        grad = np.zeros_like(var)\n        grad[:, 2] = -1.0  # Maximize sum of radii -> grad of loss is -1\n        \n        c = var[:, :2]\n        r = var[:, 2]\n        \n        # Pairwise distances\n        diff = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-12\n        np.fill_diagonal(dist, 1e12)  # Ignore self-interaction\n        \n        # Overlap penalty: r_i + r_j > dist\n        overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n        mask = overlap > 0\n        \n        if np.any(mask):\n            grad[:, 2] += np.sum(2 * c_penalty * overlap * mask, axis=1)\n            force_mag = 2 * c_penalty * overlap * mask / dist\n            grad[:, :2] += np.sum(-force_mag[:, :, np.newaxis] * diff, axis=1)\n            \n        # Boundary penalties\n        # Left wall\n        ox_left = r - c[:, 0]\n        mx_left = ox_left > 0\n        grad[mx_left, 2] += 2 * c_penalty * ox_left[mx_left]\n        grad[mx_left, 0] -= 2 * c_penalty * ox_left[mx_left]\n        \n        # Right wall\n        ox_right = r + c[:, 0] - 1.0\n        mx_right = ox_right > 0\n        grad[mx_right, 2] += 2 * c_penalty * ox_right[mx_right]\n        grad[mx_right, 0] += 2 * c_penalty * ox_right[mx_right]\n        \n        # Bottom wall\n        oy_bot = r - c[:, 1]\n        my_bot = oy_bot > 0\n        grad[my_bot, 2] += 2 * c_penalty * oy_bot[my_bot]\n        grad[my_bot, 1] -= 2 * c_penalty * oy_bot[my_bot]\n        \n        # Top wall\n        oy_top = r + c[:, 1] - 1.0\n        my_top =\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport time\nimport numpy as np\n\n\ndef init_rows(row_counts):\n    \"\"\"\n    Initializes a specific row-based topology for circle centers.\n    \"\"\"\n    centers = []\n    num_rows = len(row_counts)\n    for r_idx, num in enumerate(row_counts):\n        y = (r_idx + 0.5) / num_rows\n        for c_idx in range(num):\n            x = (c_idx + 0.5) / num\n            centers.append([x, y])\n    return np.array(centers)\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the exact radii\n    that maximize the total sum of radii subject to no overlaps and boundary\n    constraints. It uses scipy's Linear Programming for the exact global optimum,\n    with a robust, highly optimized multi-start greedy fallback.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the nearest square boundaries for each center\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    \n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dists, 1e10)\n\n    # Attempt exact Linear Programming solution\n    try:\n        from scipy.optimize import linprog\n        \n        c = -np.ones(n)\n        num_pairs = n * (n - 1) // 2\n        A_ub = np.zeros((num_pairs, n))\n        b_ub = np.zeros(num_pairs)\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_ub[idx, i] = 1.0\n                A_ub[idx, j] = 1.0\n                b_ub[idx] = dists[i, j]\n                idx += 1\n                \n        bounds = [(0, b_limits[i]) for i in range(n)]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success and res.x is not None:\n            # Deflate infinitesimally to strictly bypass floating-point overlaps\n            radii = res.x * 0.99999999\n            radii = np.clip(radii, 0.0, b_limits)\n            return radii, np.sum(radii)\n    except Exception:\n        pass\n\n    # Fallback: Intensive multi-start randomized greedy algorithm\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n    \n    for _ in range(1500):\n        order = np.random.permutation(n)\n        radii = np.zeros(n)\n        for i in order:\n            r_i = min(b_limits[i], np.min(dists[i] - radii))\n            radii[i] = max(0.0, r_i)\n            \n        c_sum = np.sum(radii)\n        if c_sum > best\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes the maximum possible radii for each circle position such that\n    no circles overlap and all stay within the unit square. Uses a greedy\n    iterative approach to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Maximum radius for each circle restricted only by the square boundaries\n    boundary_limits = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n    \n    best_radii = np.zeros(n)\n    best_sum = 0\n    \n    # Run multiple trials with different random greedy expansion orders\n    for trial in range(15):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Iteratively maximize each radius given the others\n        for _ in range(25):\n            for i in order:\n                # Radius must satisfy r_i <= boundary_limit and r_i + r_j <= dist_ij\n                limit = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        # Candidate radius given fixed neighbor j\n                        limit = min(limit, dist - radii[j])\n                radii[i] = max(0.0, limit)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize \n    the sum of radii using a force-directed physics simulation.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a structured pattern: 4 rows of 5 and 1 middle row of 6\n    centers_list = []\n    # Top and bottom rows (y=0.1, 0.3, 0.7, 0.9)\n    for y in [0.1, 0.3, 0.7, 0.9]:\n        for x in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            centers_list.append([x, y])\n    # Middle row (y=0.5) with 6 circles\n    for x in np.linspace(0.08, 0.92, 6):\n        centers_list.append([x, 0.5])\n        \n    centers = np.array(centers_list)\n    \n    # Add small jitter to break symmetry\n    centers += np.random.normal(0, 0.005, (n, 2))\n    \n    # Physics parameters: target separation distance and time step\n    dt = 0.1\n    target_dist = 0.203\n    \n    # Simulation loop to optimize center positions\n    for _ in range(3000):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            # Inter-circle repulsion\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d = np.linalg.norm(d_vec)\n                if d < target_dist:\n                    # Prevent division by zero\n                    if d < 1e-9:\n                        d_vec = np.array([0.001, 0.0])\n                        d = 0.001\n                    # Magnitude of repulsion proportional to overlap\n                    f_mag = (target_dist - d) / d\n                    forces[i] += d_vec * f_mag\n                    forces[j] -= d_vec * f_mag\n            \n            # Boundary repulsion: pushes centers away from square edges\n            r_est = target_dist / 2.0\n            if centers[i, 0] < r_est:\n                forces[i, 0] += (r_est - centers[i, 0])\n            elif centers[i, 0] > 1.0 - r_est:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - r_est))\n                \n            if centers[i, 1] < r_est:\n                forces[i, 1] += (r_est - centers[i, 1])\n            elif centers[i, 1] > 1.0 - r_est:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - r_est))\n        \n        # Apply force updates and constrain centers to the unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Annealing the step size\n        dt *= 0.999\n        \n    # Calculate optimal radii for final center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point for evaluating the packing of n=26 circles.\n    Returns (centers, radii, sum_radii).\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=200):\n    \"\"\"\n    Given fixed center coordinates within a unit square, this function \n    maximizes the total sum of radii using coordinate descent with \n    many expansion orders. This efficiently approximates the global \n    optimum for the Linear Program: maximize sum(r_i) s.t. \n    r_i + r_j <= d_ij and r_i <= dist_to_boundary_i.\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary limits for each center: min(x, y, 1-x, 1-y)\n    b_limits = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    \n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints during expansion\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Strategic orders based on spatial placement and boundary proximity\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1])),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(np.sum(centers**2, axis=1)),\n        np.argsort(np.sum((centers - 1.0)**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([0, 1]))**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([1, 0]))**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Coordinate descent: multiple passes allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Max radius r_i = min(boundary, dist(i,j) - r_j for all j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square to maximize the sum of radii.\n    Uses multi-start force-directed relaxation with various target \n    separations and initial topologies followed by radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target diameters likely to yield efficient packings\n    target_dists = np.linspace(0.185, 0.225, 12)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible diversity across restarts\n        np.random.seed(123 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based, staggered rows, or random\n        if restart == 0:\n            # 5x5 grid plus one circle at center\n            centers = []\n            for i in range(5):\n                for j in range(5):\n                    centers.append([0.1 + 0.2 * i, 0.1 + 0.2 * j])\n            centers.append([0.5, 0.5])\n            centers = np.array(centers)\n        elif restart == 1:\n            # Staggered rows (5, 6, 5, 6, 4 pattern = 26)\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Vertical staggered pattern\n            centers = []\n            for c_idx, num in enumerate([6, 5, 6, 5, 4]):\n                x = (c_idx + 0.5) / 5.0\n                for r_idx in range(num):\n                    centers.append([x, (r_idx + 0.5) / num])\n            centers = np.array(centers)\n        else:\n            # Random initialization\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters: cooling and jitter\n        iters = 1800\n        dt_base = 0.05\n        \n        for k in range(iters):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            # Prevent division by zero\n            safe_dists = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n            \n            # Repulsion force if centers are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / safe_dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update positions with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Annealing: add decreasing stochastic noise early on\n            if k < iters * 0.6:\n                noise_scale = 0.003 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to solve for optimal radii\n        radii, current_sum = compute_max_radii(centers, trials=150)\n        \n        # Track the globally best arrangement found\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"2.56s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.453513/2.635 = 0.9311\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}