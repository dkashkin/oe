{"id": "18730f41-663b-4637-b1a8-4b822a4a0a61", "code": "import numpy as np\n\n\ndef compute_max_radii(centers, trials=160):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center positions within \n    a unit square. Uses coordinate descent with various greedy expansion \n    orders and multiple trials to find an optimal set of radii that satisfy \n    all non-overlap and boundary constraints.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        tuple: (best_radii, best_sum)\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary limits: min distance to square edges (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with a large value to ignore self-overlap\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic and randomized orders for the greedy expansion\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Coordinate descent passes to ensure a stable local maximum\n        for _ in range(2):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed \n    physics simulation with cooling and jitter to find diverse packing \n    topologies, followed by a robust radii optimization for each configuration.\n\n    Returns:\n        tuple: (best_overall_centers, best_overall_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a fine-grained range of target separation distances\n    target_dists = np.linspace(0.188, 0.222, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Unique seed per restart for reproducible diversity\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: staggered patterns or random\n        if restart == 0:\n            # 5-6-5-6-4 staggered row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart == 1:\n            # Transposed 5-6-5-6-4 pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                x = (r_idx + 0.5) / 5.0\n                for c_idx in range(num):\n                    centers.append([x, (c_idx + 0.5) / num])\n            centers = np.array(centers)\n        else:\n            # Uniform random distribution\n            centers = np.random.uniform(0.05, 0.95, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Compute pairwise displacement and distance matrices\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            \n            # Pairwise repulsion force magnitude proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Square boundary repulsion: push centers toward viable interior positions\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step update with a linear/power-based cooling schedule\n            cooling = (1.0 - k / iters)**1.3\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add stochastic noise in the early phases\n            if k < iters * 0.65:\n                noise_scale = 0.0025 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to solve for optimal radii\n        radii, current_sum = compute_max_radii(centers, trials=150)\n        \n        # Track the globally best arrangement found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Target sum: 2.635\")\n    print(f\"Performance ratio: {s/2.635:.4f}\")", "changes_description": null, "language": "python", "parent_id": "eedc92cc-82f7-47cd-b691-2a896c51d435", "generation": 4, "timestamp": 1771871052.729559, "iteration_found": 93, "metrics": {"validity": 1.0, "sum_radii": 2.470158878369781, "target_ratio": 0.9374416995710745, "combined_score": 0.9374416995710745, "radius_variance": 0.0004115255028990326, "spatial_spread": 0.1931655765808718, "eval_time": 3.2618486881256104}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.4763602918366763, "target_ratio": 0.9397951771676192, "combined_score": 0.9397951771676192, "radius_variance": 0.0002044246117051477, "spatial_spread": 0.1883158106694716, "eval_time": 2.6044747829437256}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.9398\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9431 \u2192 0.9398. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n2.60s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.476360/2.635 = 0.9398\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4850, target_ratio: 0.9431, combined_score: 0.9431, radius_variance: 0.0002, spatial_spread: 0.1910, eval_time: 3.4374\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4864, target_ratio: 0.9436, combined_score: 0.9436, radius_variance: 0.0002, spatial_spread: 0.1903, eval_time: 7.9801\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4892, target_ratio: 0.9447, combined_score: 0.9447, radius_variance: 0.0008, spatial_spread: 0.1841, eval_time: 3.1322\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9447)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=180):\n    \"\"\"\n    Given a fixed set of center positions, this function determines the \n    radii that maximize the total sum of radii subject to no overlaps \n    and boundary constraints. It uses a coordinate descent approach \n    with multiple randomized greedy expansion orders.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        np.ndarray: (n,) array of optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders: boundary proximity, coordinate-based, and center-based\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Two passes of greedy expansion to ensure stability\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a force-directed physics \n    simulation with cooling and restarts. Each configuration is then \n    optimized for the maximum sum of radii.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    # This helps find different packing topologies (e.g., staggered rows)\n    target_dists = np.linspace(0.198, 0.218, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Set seed per restart for reproducible diversity\n        np.random.seed(42 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based or random\n        if restart == 0:\n            # 5x5 grid plus one circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Row-based staggered initialization\n            centers = []\n            rows = [5, 6, 5, 6, 4]\n            for r_idx, num_circles in enumerate(rows):\n                for c_idx in range(num_circles):\n                    centers.append([(c_idx + 0.5) / num_circles, (r_idx + 0.5) / 5])\n            centers = np.array(centers[:n])\n        else:\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        # Physics simulation: particles repel each other and square boundaries\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion force\n            overlap = np.maximum(0, t_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Boundary repulsion forces\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add decreasing noise early in the simulation\n            if k < iters * 0.6:\n                noise_scale = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process centers to solve for optimal radii\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Keep the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4892), Performs well on target_ratio (0.9447), Performs well on combined_score (0.9447), Performs well on radius_variance (0.0008), Performs well on spatial_spread (0.1841), Performs well on eval_time (3.1322)\n\n### Program 2 (Score: 0.9436)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center coordinates within \n    a unit square. Uses coordinate descent with various greedy expansion \n    orders and multiple trials to find an optimal set of radii that satisfy \n    all non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Vectorized precomputation of pairwise distances and boundary limits\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Boundary limits for each center: distance to nearest square edge\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Mask to ignore self-distance in calculations\n    mask = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: heuristic sorting and random permutations\n    orders = [\n        np.argsort(boundary_limits),\n        np.argsort(-boundary_limits),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Multiple passes ensure the radii converge to a stable local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(boundary_limits[i], np.min(dist_matrix[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a \n    force-directed physics simulation with cooling and jitter across \n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.222, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(800 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Shifted 5x5 grid with one extra circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-6-5-6-4 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Randomly jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.025, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters: iterations and initial step size\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion magnitude proportional to overlap\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Square boundary repulsion forces\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with linear cooling schedule\n            cooling = 1.0 - 0.9 * k / iters\n            dt = dt_base * cooling\n            centers += forces * dt\n\n            # Add decreasing stochastic noise to skip local minima\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Final greedy radius maximization for the current configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4864), Performs well on target_ratio (0.9436), Performs well on combined_score (0.9436), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1903), Performs well on eval_time (7.9801)\n\n### Program 3 (Score: 0.9431)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=220):\n    \"\"\"\n    Given fixed center coordinates within a unit square, this function maximizes \n    the total sum of radii. It uses greedy coordinate descent with a wide variety \n    of expansion orders to explore the solution space of radii assignments \n    subject to non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center: min(x, y, 1-x, 1-y)\n    b_limits = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints during expansion\n    np.fill_diagonal(dists, 1e10)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders based on spatial placement and boundary proximity\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1])),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(np.sum(centers**2, axis=1)),\n        np.argsort(np.sum((centers - 1.0)**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([0, 1]))**2, axis=1)),\n        np.argsort(np.sum((centers - np.array([1, 0]))**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Multi-pass coordinate descent to reach a stable local maximum\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j for all j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed \n    physics simulation with cooling and jitter to find diverse packing \n    topologies. Each configuration is then optimized for the maximum sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Sweep across a range of target separation distances to discover optimal grids and clusters\n    target_dists = np.linspace(0.194, 0.228, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Unique seed per restart for reproducible diversity\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based, staggered rows, or random\n        if restart == 0:\n            # 5x5 grid plus one circle at center\n            centers = []\n            for i in range(5):\n                for j in range(5):\n                    centers.append([0.1 + 0.2 * i, 0.1 + 0.2 * j])\n            centers.append([0.5, 0.5])\n            centers = np.array(centers)\n        elif restart == 1:\n            # Staggered rows (5, 6, 5, 6, 4 pattern)\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, (r_idx + 0.5) / 5.0])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Alternate staggered rows (6, 5, 6, 5, 4 pattern)\n            centers = []\n            for r_idx, num in enumerate([6, 5, 6, 5, 4]):\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, (r_idx + 0.5) / 5.0])\n            centers = np.array(centers)\n        elif restart == 3:\n            # Vertical rows (6, 6, 6, 6, 2 pattern)\n            centers = []\n            for r_idx, num in enumerate([6, 6, 6, 6, 2]):\n                for c_idx in range(num):\n                    centers.append([(r_idx + 0.5) / 5.0, (c_idx + 0.5) / num])\n            centers = np.array(centers)\n        else:\n            # Uniform random distribution\n            centers = np.random.uniform(0.05, 0.95, (n, 2))\n\n        # Simulation parameters: power-based cooling and jitter\n        iters = 2000\n        dt_base = 0.05\n        \n        for k in range(iters):\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2)) + 1e-12\n            \n            # Pairwise repulsion force magnitude proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Square boundary repulsion: push centers toward viable interior positions\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update with linear cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add stochastic noise in the early phases\n            if k < iters * 0.65:\n                noise_scale = 0.0025 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to solve for optimal radii\n        radii, current_sum = compute_max_radii(centers, 220)\n        \n        # Track the globally best arrangement\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4850), Performs well on target_ratio (0.9431), Performs well on combined_score (0.9431), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1910), Performs well on eval_time (3.4374)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9414)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=150):\n    \"\"\"\n    Maximizes the total sum of radii for fixed center positions within a unit square.\n    The problem of maximizing sum(r_i) subject to r_i + r_j <= d_ij and \n    r_i <= boundary_limit_i is a Linear Program. This function approximates the \n    optimal solution using coordinate descent with multiple expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary constraints: x, y, 1-x, 1-y\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Pairwise distances\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Mask to ignore self-interactions\n    mask = np.eye(n) * 1e10\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic and randomized orders for coordinate descent\n    # Strategic ordering allows some circles to grow large at the expense of others\n    heuristic_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(centers[:, 0] - centers[:, 1])\n    ]\n\n    for trial in range(trials):\n        if trial < len(heuristic_orders):\n            order = heuristic_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Multiple passes of expansion to converge towards a local optimum\n        for _ in range(12):\n            for i in order:\n                # Maximize r_i subject to all current neighbor constraints\n                # r_i <= d_ij - r_j  for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Finds a packing of 26 circles in a unit square that maximizes the sum of radii.\n    Uses multi-start force-directed relaxation with various target separation distances\n    and initial configurations to explore different packing topologies.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target distances (diameters) likely to yield good packing\n    target_dists = np.linspace(0.192, 0.228, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible diversity across restarts\n        np.random.seed(3000 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversified initial center layouts\n        if restart == 0:\n            # Shifted 5x5 grid + 1 circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered pattern (5-6-5-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Staggered pattern (4-6-6-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([4, 6, 6, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        else:\n            # Jittered grid or random initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n            \n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2500\n        dt_base = 0.075\n\n        for k in range(iters):\n            # Compute pairwise displacement and distance matrices\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            \n            # Repulsion force if circles overlap the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Boundary repulsion: keep centers at least r_target from edges\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Apply update with a power-based cooling schedule\n            cooling = (1.0 - k / iters) ** 1.3\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Annealing: Add decreasing stochastic noise early on\n            if k < iters * 0.6:\n                noise_scale = 0.0035 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to find maximized radii\n        radii, current_sum = compute_max_radii(centers)\n        \n        # Track the global best configuration\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9413)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=250):\n    \"\"\"\n    Maximizes the sum of radii for fixed center positions within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    and coordinate descent passes to find a high-performing radii distribution.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a mask to ignore self-distances in minimization\n    mask = np.eye(n) * 1e10\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 15:\n            # Sort by distance from the center of the square\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        # Multiple passes of expansion to allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Radius r_i limited by walls and currently set radii of others\n                # dist(i,j) >= r_i + r_j  =>  r_i <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed\n    physics simulation with cooling and jitter to find an optimal configuration\n    for maximizing the total sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to diversify configurations\n    target_dists = np.linspace(0.190, 0.220, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Specific seeds for reproducible diversity\n        np.random.seed(2024 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered hexagonal-style rows\n            centers = []\n            row_pattern = [5, 6, 5, 6, 4]\n            for r_idx, num_c in enumerate(row_pattern):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers[:n])\n        elif restart < 8:\n            # Randomly jittered grid\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Physics simulation loop\n        iters = 2200\n        dt_base = 0.06\n\n        for k in range(iters):\n            # Pairwise repulsion calculation\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n\n            # Repulsion force if circles are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Step update with cooling schedule\n            cooling = (1.0 - k / iters)**1.2\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Annealing: Add decreasing noise early in the simulation\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9362, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=40):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the total sum of radii subject to no overlaps and\n    boundary constraints. It uses coordinate descent with multiple\n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Distance to the nearest wall for each center [x, y, 1-x, 1-y]\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    for trial in range(trials):\n        # Specific heuristic orderings followed by random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Iterative coordinate descent to grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Calculate maximum possible radius r_i given current r_j\n                mask = np.ones(n, dtype=bool)\n                mask[i] = False\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i, mask] - radii[mask]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a force-directed physics simulation \n    with varying target distances and jitter across multiple restarts.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target diameters to explore across multiple restarts\n    target_dists = [0.198, 0.201, 0.204, 0.207, 0.210, 0.213, 0.216, 0.219]\n    \n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible search per restart\n        np.random.seed(600 + restart)\n        r_target = t_dist / 2.0\n        \n        # Initial layout: 5x5 grid plus one circle in the center\n        centers = np.zeros((n, 2))\n        for i in range(25):\n            centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter helps break grid symmetry and escape local minima\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Simulation parameters\n        iters = 1600\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Vectorized pairwise repulsion forces\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            np.fill_diagonal(dists, 1.0) # Avoid self-interaction\n            \n            # Repulsion proportional to overlap distance\n            f_mag = np.maximum(0, t_dist - dists) / (dists + 1e-10)\n            np.fill_diagonal(f_mag, 0)\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Repulsion from square boundaries\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Cooling schedule for simulation convergence\n            cooling = (1.0 - k / iters)**1.5\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.5:\n                noise_scale = 0.001 * (1.0 - k / (iters * 0.5))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Optimize radii for these center positions\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.3642, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9413, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=250):\n    \"\"\"\n    Maximizes the sum of radii for fixed center positions within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    and coordinate descent passes to find a high-performing radii distribution.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a mask to ignore self-distances in minimization\n    mask = np.eye(n) * 1e10\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 15:\n            # Sort by distance from the center of the square\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        # Multiple passes of expansion to allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Radius r_i limited by walls and currently set radii of others\n                # dist(i,j) >= r_i + r_j  =>  r_i <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed\n    physics simulation with cooling and jitter to find an optimal configuration\n    for maximizing the total sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to diversify configurations\n    target_dists = np.linspace(0.190, 0.220, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Specific seeds for reproducible diversity\n        np.random.seed(2024 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered hexagonal-style rows\n            centers = []\n            row_pattern = [5, 6, 5, 6, 4]\n            for r_idx, num_c in enumerate(row_pattern):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers[:n])\n        elif restart < 8:\n            # Randomly jittered grid\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Physics simulation loop\n        iters = 2200\n        dt_base = 0.06\n\n        for k in range(iters):\n            # Pairwise repulsion calculation\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n\n            # Repulsion force if circles are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Step update with cooling schedule\n            cooling = (1.0 - k / iters)**1.2\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Annealing: Add decreasing noise early in the simulation\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=160):\n    \"\"\"\n    Maximizes the sum of radii for a given set of centers within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    to find a high-performing radii distribution for fixed center positions.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e10)\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 12:\n            # Sort by distance from the center of the square to prioritize middle or edge circles\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        for i in order:\n            # The radius r_i is limited by its distance to walls and already set radii of neighbors\n            r_i = min(b_limits[i], np.min(dists[i] - radii))\n            radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the \n    total sum of radii using a force-directed physics simulation with \n    multiple restarts, diverse initial layouts, and annealing noise.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to find different packing topologies\n    target_dists = np.linspace(0.192, 0.218, 14)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions across restarts to explore the solution space\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Hexagonal-style staggered row pattern (5-6-5-6-4)\n            centers = []\n            for row_idx, num_cols in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + row_idx * 0.2\n                for col_idx in range(num_cols):\n                    centers.append([(col_idx + 0.5) / num_cols, y])\n            centers = np.array(centers)\n        elif restart < 9:\n            # Jittered grid initialization to break symmetry early\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.045, (n, 2))\n        else:\n            # Purely random initialization to find unconventional configurations\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2000\n        dt_base = 0.055\n\n        for k in range(iters):\n            # Calculate pairwise displacement vectors and distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            # Avoid self-interaction division errors\n            np.fill_diagonal(dists, 1.0)\n\n            # Inter-circle repulsion forces proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces to keep centers within viable packing regions\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update positions with power-based cooling schedule\n            cooling = (1.0 - k / iters)**1.15\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Stochastic jitter (simulated annealing) to escape local minima\n            if k < iters * 0.6:\n                noise_mag = 0.0028 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the current resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Update global best result if the current configuration is superior\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=160):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center positions within \n    a unit square. Uses coordinate descent with various greedy expansion \n    orders and multiple trials to find an optimal set of radii that satisfy \n    all non-overlap and boundary constraints.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        tuple: (best_radii, best_sum)\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary limits: min distance to square edges (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with a large value to ignore self-overlap\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic and randomized orders for the greedy expansion\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Coordinate descent passes to ensure a stable local maximum\n        for _ in range(2):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed \n    physics simulation with cooling and jitter to find diverse packing \n    topologies, followed by a robust radii optimization for each configuration.\n\n    Returns:\n        tuple: (best_overall_centers, best_overall_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a fine-grained range of target separation distances\n    target_dists = np.linspace(0.188, 0.222, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Unique seed per restart for reproducible diversity\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: staggered patterns or random\n        if restart == 0:\n            # 5-6-5-6-4 staggered row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart == 1:\n            # Transposed 5-6-5-6-4 pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                x = (r_idx + 0.5) / 5.0\n                for c_idx in range(num):\n                    centers.append([x, (c_idx + 0.5) / num])\n            centers = np.array(centers)\n        else:\n            # Uniform random distribution\n            centers = np.random.uniform(0.05, 0.95, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Compute pairwise displacement and distance matrices\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            \n            # Pairwise repulsion force magnitude proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Square boundary repulsion: push centers toward viable interior positions\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step update with a linear/power-based cooling schedule\n            cooling = (1.0 - k / iters)**1.3\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add stochastic noise in the early phases\n            if k < iters * 0.65:\n                noise_scale = 0.0025 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to solve for optimal radii\n        radii, current_sum = compute_max_radii(centers, trials=150)\n        \n        # Track the globally best arrangement found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Target sum: 2.635\")\n    print(f\"Performance ratio: {s/2.635:.4f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"3.26s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.470159/2.635 = 0.9374\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}