{"id": "eff55675-6c78-42cc-aa0b-8775867928a5", "code": "import numpy as np\n\n\ndef compute_max_radii(centers, trials=40):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the total sum of radii subject to no overlaps and\n    boundary constraints. It uses coordinate descent with multiple\n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Distance to the nearest wall for each center [x, y, 1-x, 1-y]\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    for trial in range(trials):\n        # Specific heuristic orderings followed by random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Iterative coordinate descent to grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Calculate maximum possible radius r_i given current r_j\n                mask = np.ones(n, dtype=bool)\n                mask[i] = False\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i, mask] - radii[mask]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a force-directed physics simulation \n    with varying target distances and jitter across multiple restarts.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target diameters to explore across multiple restarts\n    target_dists = [0.198, 0.201, 0.204, 0.207, 0.210, 0.213, 0.216, 0.219]\n    \n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible search per restart\n        np.random.seed(600 + restart)\n        r_target = t_dist / 2.0\n        \n        # Initial layout: 5x5 grid plus one circle in the center\n        centers = np.zeros((n, 2))\n        for i in range(25):\n            centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter helps break grid symmetry and escape local minima\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Simulation parameters\n        iters = 1600\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Vectorized pairwise repulsion forces\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            np.fill_diagonal(dists, 1.0) # Avoid self-interaction\n            \n            # Repulsion proportional to overlap distance\n            f_mag = np.maximum(0, t_dist - dists) / (dists + 1e-10)\n            np.fill_diagonal(f_mag, 0)\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Repulsion from square boundaries\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Cooling schedule for simulation convergence\n            cooling = (1.0 - k / iters)**1.5\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.5:\n                noise_scale = 0.001 * (1.0 - k / (iters * 0.5))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Optimize radii for these center positions\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")", "changes_description": null, "language": "python", "parent_id": "fbd983df-7ff5-4611-a019-06f45096f9e5", "generation": 2, "timestamp": 1771869775.3304539, "iteration_found": 43, "metrics": {"validity": 1.0, "sum_radii": 2.4668213101853294, "target_ratio": 0.9361750702790624, "combined_score": 0.9361750702790624, "radius_variance": 0.00031101091992162864, "spatial_spread": 0.18690000505151316, "eval_time": 1.6018779277801514}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.137730808269239, "target_ratio": 0.8112830391913621, "combined_score": 0.8112830391913621, "radius_variance": 0.007968683730014917, "spatial_spread": 0.18905484911586046, "eval_time": 0.5019717216491699}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.8113\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9319 \u2192 0.8113. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n0.50s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.137731/2.635 = 0.8113\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4557, target_ratio: 0.9319, combined_score: 0.9319, radius_variance: 0.0004, spatial_spread: 0.1948, eval_time: 0.5164\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4676, target_ratio: 0.9365, combined_score: 0.9365, radius_variance: 0.0005, spatial_spread: 0.1885, eval_time: 0.9098\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4694, target_ratio: 0.9371, combined_score: 0.9371, radius_variance: 0.0011, spatial_spread: 0.1952, eval_time: 2.2235\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9371)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square, ensuring no overlaps and respect for boundaries.\n    Uses coordinate descent with multiple greedy expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several expansion orders to maximize the sum of radii\n    for trial in range(13):\n        radii = np.zeros(n)\n        if trial == 0:\n            order = np.arange(n)\n        elif trial == 1:\n            order = np.argsort(boundary_limits)\n        else:\n            order = np.random.permutation(n)\n\n        # Coordinate descent to solve for optimal radii for fixed centers\n        for _ in range(25):\n            for i in order:\n                # Maximum radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dist_matrix[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter, followed\n    by a greedy radii optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    iters = 1600\n    dt_base = 0.05\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple restarts\n    target_dists = np.linspace(0.198, 0.208, 10)\n    \n    for restart in range(10):\n        # Set seed for reproducibility per restart\n        np.random.seed(200 + restart)\n        target_dist = target_dists[restart]\n        \n        # Initial layout: 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n        \n        # Placement of the 26th circle varies to diversify the search\n        if restart % 3 == 0:\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            centers[25] = [0.05, 0.05]\n        else:\n            centers[25] = [0.95, 0.95]\n            \n        # Add jitter to break initial symmetry and encourage exploration\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            # Magnitude proportional to overlap distance\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with a cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n            \n            # Add small noise early in the simulation to help skip local minima\n            if k < iters * 0.6:\n                noise_mag = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Compute maximized radii for these center positions\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to run the packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4694), Performs well on target_ratio (0.9371), Performs well on combined_score (0.9371), Performs well on radius_variance (0.0011), Performs well on spatial_spread (0.1952), Performs well on eval_time (2.2235)\n\n### Program 2 (Score: 0.9365)\n```python\n\"\"\"\nExpert-level circle packing implementation for n=26 in a unit square.\nThis constructor uses force-directed physics with annealing noise and \nmultiple restarts, combined with a highly robust coordinate ascent \nalgorithm to maximize the total sum of radii for fixed centers.\n\"\"\"\n\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=60):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the sum sum(r_i) subject to no overlaps and boundary\n    constraints. It uses multiple trials of coordinate ascent with \n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute distance matrix and distances to boundaries\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Diagonal set to large value to avoid self-constraint\n    np.fill_diagonal(dists, 1e9)\n    # Distance to the nearest wall for each circle\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    for trial in range(trials):\n        # Heuristic: try specific orders first, then random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Coordinate ascent passes: iteratively grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Set current radius to zero to re-evaluate its maximum possible size\n                radii[i] = 0.0\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        cur_sum = np.sum(radii)\n        if cur_sum > best_sum:\n            best_sum = cur_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the centers of 26 circles in a unit square to maximize the \n    sum of their radii. Uses a force-directed simulation with a variety \n    of target distances and jitter to escape local minima.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple starts\n    target_dists = [0.198, 0.202, 0.206, 0.210]\n    \n    for restart in range(len(target_dists)):\n        np.random.seed(100 + restart)\n        target_dist = target_dists[restart]\n        r_target = target_dist / 2.0\n        \n        # Initial layout: jittered 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter breaks symmetry and helps the simulation find tight packings\n        jitter_scale = [0.01, 0.03, 0.06, 0.08][restart]\n        centers += np.random.normal(0, jitter_scale, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop parameters\n        iters = 1800\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Calculate pairwise displacement vectors and Euclidean distances\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diff**2, axis=2)) + 1e-10\n            \n            # Pairwise repulsion forces for circles closer than the target distance\n            mask = (dists < target_dist) & (~np.eye(n, dtype=bool))\n            f_mag = np.zeros_like(dists)\n            f_mag[mask] = (target_dist - dists[mask]) / dists[mask]\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries (keeping centers away from edges)\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += (forces + b_forces) * dt\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.6:\n                noise_mag = 0.0012 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Final greedy radius maximization for this center configuration\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing constructor for n=26.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Final Sum of Radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4676), Performs well on target_ratio (0.9365), Performs well on combined_score (0.9365), Performs well on radius_variance (0.0005), Performs well on spatial_spread (0.1885), Performs well on eval_time (0.9098)\n\n### Program 3 (Score: 0.9319)\n```python\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using a force-directed\n    simulation and a greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Seed for reproducibility\n    np.random.seed(42)\n\n    # Initial layout: 5x5 grid plus one extra circle\n    centers = np.zeros((n, 2))\n    for i in range(5):\n        for j in range(5):\n            centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n    \n    # Place the 26th circle in the center and add jitter to break symmetry\n    centers[25] = [0.5, 0.5]\n    centers += np.random.uniform(-0.02, 0.02, (n, 2))\n\n    # Force-directed simulation parameters\n    # A target distance of ~0.203 aims for a sum of radii around 2.639\n    iters = 1200\n    dt = 0.05\n    target_dist = 0.203\n    target_radius = target_dist / 2.0\n\n    # Physics simulation loop\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        # Pairwise repulsion between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = (dx * dx + dy * dy)**0.5 + 1e-9\n                if dist < target_dist:\n                    f = (target_dist - dist) / dist\n                    forces[i, 0] += dx * f\n                    forces[i, 1] += dy * f\n                    forces[j, 0] -= dx * f\n                    forces[j, 1] -= dy * f\n        \n        # Repulsion from square boundaries\n        for i in range(n):\n            # Distance to left wall\n            if centers[i, 0] < target_radius:\n                forces[i, 0] += (target_radius - centers[i, 0])\n            # Distance to right wall\n            if centers[i, 0] > 1.0 - target_radius:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - target_radius))\n            # Distance to bottom wall\n            if centers[i, 1] < target_radius:\n                forces[i, 1] += (target_radius - centers[i, 1])\n            # Distance to top wall\n            if centers[i, 1] > 1.0 - target_radius:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - target_radius))\n        \n        # Update centers and constrain within unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final maximized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximize the sum of radii for fixed centers by solving the\n    overlap and boundary constraints iteratively.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii to the distance to the closest boundary\n    for i in range(n):\n        radii[i] = min(centers[i, 0], centers[i, 1], \n                       1.0 - centers[i, 0], 1.0 - centers[i, 1])\n\n    # 2. Proportionally scale down radii to eliminate overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = (dx * dx + dy * dy)**0.5\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j] + 1e-12)\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Iteratively expand circles greedily to maximize the sum of radii\n    # We alternate the order to ensure fair space distribution\n    for it in range(60):\n        order = range(n) if it % 2 == 0 else range(n - 1, -1, -1)\n        for i in order:\n            # Maximum radius is limited by distance to boundaries\n            r_limit = min(centers[i, 0], centers[i, 1], \n                          1.0 - centers[i, 0], 1.0 - centers[i, 1])\n            # And distance to every other already-sized circle\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = (dx * dx + dy * dy)**0.5\n                    r_limit = min(r_limit, dist - radii[j])\n            radii[i] = max(0.0, r_limit)\n\n    return radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4557), Performs well on target_ratio (0.9319), Performs well on combined_score (0.9319), Performs well on radius_variance (0.0004), Performs well on spatial_spread (0.1948), Performs well on eval_time (0.5164)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8312)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes the maximum possible radii for each circle position such that\n    no circles overlap and all stay within the unit square. Uses a greedy\n    iterative approach to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Maximum radius for each circle restricted only by the square boundaries\n    boundary_limits = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n    \n    best_radii = np.zeros(n)\n    best_sum = 0\n    \n    # Run multiple trials with different random greedy expansion orders\n    for trial in range(15):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Iteratively maximize each radius given the others\n        for _ in range(25):\n            for i in order:\n                # Radius must satisfy r_i <= boundary_limit and r_i + r_j <= dist_ij\n                limit = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        # Candidate radius given fixed neighbor j\n                        limit = min(limit, dist - radii[j])\n                radii[i] = max(0.0, limit)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize \n    the sum of radii using a force-directed physics simulation.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a structured pattern: 4 rows of 5 and 1 middle row of 6\n    centers_list = []\n    # Top and bottom rows (y=0.1, 0.3, 0.7, 0.9)\n    for y in [0.1, 0.3, 0.7, 0.9]:\n        for x in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            centers_list.append([x, y])\n    # Middle row (y=0.5) with 6 circles\n    for x in np.linspace(0.08, 0.92, 6):\n        centers_list.append([x, 0.5])\n        \n    centers = np.array(centers_list)\n    \n    # Add small jitter to break symmetry\n    centers += np.random.normal(0, 0.005, (n, 2))\n    \n    # Physics parameters: target separation distance and time step\n    dt = 0.1\n    target_dist = 0.203\n    \n    # Simulation loop to optimize center positions\n    for _ in range(3000):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            # Inter-circle repulsion\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d = np.linalg.norm(d_vec)\n                if d < target_dist:\n                    # Prevent division by zero\n                    if d < 1e-9:\n                        d_vec = np.array([0.001, 0.0])\n                        d = 0.001\n                    # Magnitude of repulsion proportional to overlap\n                    f_mag = (target_dist - d) / d\n                    forces[i] += d_vec * f_mag\n                    forces[j] -= d_vec * f_mag\n            \n            # Boundary repulsion: pushes centers away from square edges\n            r_est = target_dist / 2.0\n            if centers[i, 0] < r_est:\n                forces[i, 0] += (r_est - centers[i, 0])\n            elif centers[i, 0] > 1.0 - r_est:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - r_est))\n                \n            if centers[i, 1] < r_est:\n                forces[i, 1] += (r_est - centers[i, 1])\n            elif centers[i, 1] > 1.0 - r_est:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - r_est))\n        \n        # Apply force updates and constrain centers to the unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Annealing the step size\n        dt *= 0.999\n        \n    # Calculate optimal radii for final center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point for evaluating the packing of n=26 circles.\n    Returns (centers, radii, sum_radii).\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.8113)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using a \n    force-directed simulation and greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Initial layout: 5x5 grid plus one circle in the middle\n    centers = np.zeros((n, 2))\n    for i in range(25):\n        centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n    centers[25] = [0.5, 0.5]\n\n    # Add small jitter to break symmetry for better packing exploration\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.01, (n, 2))\n\n    # Parameters for the physics-based repulsion simulation\n    # Target distance corresponds to an average radius of ~0.1015\n    iters = 500\n    dt = 0.08\n    target_dist = 0.203\n\n    # Simulation loop: push overlapping circles apart\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = centers[i] - centers[j]\n                dist = np.sqrt(d[0]**2 + d[1]**2)\n                if dist < target_dist:\n                    # Prevent division by zero with small epsilon\n                    if dist < 1e-8:\n                        d = np.array([0.01, 0.0])\n                        dist = 0.01\n                    # Repulsion force proportional to overlap\n                    f = (target_dist - dist) / dist\n                    forces[i] += d * f\n                    forces[j] -= d * f\n        \n        centers += forces * dt\n        # Constrain centers to the unit square\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final optimized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    using proportional scaling followed by iterative greedy refinement.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii based on distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # 2. Proportionally scale radii to remove any circle-circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = np.sqrt(dx*dx + dy*dy)\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Greedy refinement to maximize the sum of radii\n    # In each step, maximize r_i given all other fixed radii\n    for _ in range(20):\n        for i in range(n):\n            # Distance to boundaries\n            m = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            # Distance to all other circles\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = np.sqrt(dx*dx + dy*dy)\n                    if dist - radii[j] < m:\n                        m = dist - radii[j]\n            radii[i] = max(0.0, m)\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9371, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square, ensuring no overlaps and respect for boundaries.\n    Uses coordinate descent with multiple greedy expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several expansion orders to maximize the sum of radii\n    for trial in range(13):\n        radii = np.zeros(n)\n        if trial == 0:\n            order = np.arange(n)\n        elif trial == 1:\n            order = np.argsort(boundary_limits)\n        else:\n            order = np.random.permutation(n)\n\n        # Coordinate descent to solve for optimal radii for fixed centers\n        for _ in range(25):\n            for i in order:\n                # Maximum radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dist_matrix[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter, followed\n    by a greedy radii optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    iters = 1600\n    dt_base = 0.05\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple restarts\n    target_dists = np.linspace(0.198, 0.208, 10)\n    \n    for restart in range(10):\n        # Set seed for reproducibility per restart\n        np.random.seed(200 + restart)\n        target_dist = target_dists[restart]\n        \n        # Initial layout: 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n        \n        # Placement of the 26th circle varies to diversify the search\n        if restart % 3 == 0:\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            centers[25] = [0.05, 0.05]\n        else:\n            centers[25] = [0.95, 0.95]\n            \n        # Add jitter to break initial symmetry and encourage exploration\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            # Magnitude proportional to overlap distance\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with a cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n            \n            # Add small noise early in the simulation to help skip local minima\n            if k < iters * 0.6:\n                noise_mag = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Compute maximized radii for these center positions\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to run the packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.8312, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes the maximum possible radii for each circle position such that\n    no circles overlap and all stay within the unit square. Uses a greedy\n    iterative approach to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Maximum radius for each circle restricted only by the square boundaries\n    boundary_limits = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n    \n    best_radii = np.zeros(n)\n    best_sum = 0\n    \n    # Run multiple trials with different random greedy expansion orders\n    for trial in range(15):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Iteratively maximize each radius given the others\n        for _ in range(25):\n            for i in order:\n                # Radius must satisfy r_i <= boundary_limit and r_i + r_j <= dist_ij\n                limit = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        # Candidate radius given fixed neighbor j\n                        limit = min(limit, dist - radii[j])\n                radii[i] = max(0.0, limit)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize \n    the sum of radii using a force-directed physics simulation.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a structured pattern: 4 rows of 5 and 1 middle row of 6\n    centers_list = []\n    # Top and bottom rows (y=0.1, 0.3, 0.7, 0.9)\n    for y in [0.1, 0.3, 0.7, 0.9]:\n        for x in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            centers_list.append([x, y])\n    # Middle row (y=0.5) with 6 circles\n    for x in np.linspace(0.08, 0.92, 6):\n        centers_list.append([x, 0.5])\n        \n    centers = np.array(centers_list)\n    \n    # Add small jitter to break symmetry\n    centers += np.random.normal(0, 0.005, (n, 2))\n    \n    # Physics parameters: target separation distance and time step\n    dt = 0.1\n    target_dist = 0.203\n    \n    # Simulation loop to optimize center positions\n    for _ in range(3000):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            # Inter-circle repulsion\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d = np.linalg.norm(d_vec)\n                if d < target_dist:\n                    # Prevent division by zero\n                    if d < 1e-9:\n                        d_vec = np.array([0.001, 0.0])\n                        d = 0.001\n                    # Magnitude of repulsion proportional to overlap\n                    f_mag = (target_dist - d) / d\n                    forces[i] += d_vec * f_mag\n                    forces[j] -= d_vec * f_mag\n            \n            # Boundary repulsion: pushes centers away from square edges\n            r_est = target_dist / 2.0\n            if centers[i, 0] < r_est:\n                forces[i, 0] += (r_est - centers[i, 0])\n            elif centers[i, 0] > 1.0 - r_est:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - r_est))\n                \n            if centers[i, 1] < r_est:\n                forces[i, 1] += (r_est - centers[i, 1])\n            elif centers[i, 1] > 1.0 - r_est:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - r_est))\n        \n        # Apply force updates and constrain centers to the unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Annealing the step size\n        dt *= 0.999\n        \n    # Calculate optimal radii for final center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point for evaluating the packing of n=26 circles.\n    Returns (centers, radii, sum_radii).\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9365, Type: High-Performer)\n```python\n\"\"\"\nExpert-level circle packing implementation for n=26 in a unit square.\nThis constructor uses force-directed physics with annealing noise and \nmultiple restarts, combined with a highly robust coordinate ascent \nalgorithm to maximize the total sum of radii for fixed centers.\n\"\"\"\n\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=60):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the sum sum(r_i) subject to no overlaps and boundary\n    constraints. It uses multiple trials of coordinate ascent with \n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute distance matrix and distances to boundaries\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Diagonal set to large value to avoid self-constraint\n    np.fill_diagonal(dists, 1e9)\n    # Distance to the nearest wall for each circle\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    for trial in range(trials):\n        # Heuristic: try specific orders first, then random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Coordinate ascent passes: iteratively grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Set current radius to zero to re-evaluate its maximum possible size\n                radii[i] = 0.0\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        cur_sum = np.sum(radii)\n        if cur_sum > best_sum:\n            best_sum = cur_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the centers of 26 circles in a unit square to maximize the \n    sum of their radii. Uses a force-directed simulation with a variety \n    of target distances and jitter to escape local minima.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple starts\n    target_dists = [0.198, 0.202, 0.206, 0.210]\n    \n    for restart in range(len(target_dists)):\n        np.random.seed(100 + restart)\n        target_dist = target_dists[restart]\n        r_target = target_dist / 2.0\n        \n        # Initial layout: jittered 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter breaks symmetry and helps the simulation find tight packings\n        jitter_scale = [0.01, 0.03, 0.06, 0.08][restart]\n        centers += np.random.normal(0, jitter_scale, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop parameters\n        iters = 1800\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Calculate pairwise displacement vectors and Euclidean distances\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diff**2, axis=2)) + 1e-10\n            \n            # Pairwise repulsion forces for circles closer than the target distance\n            mask = (dists < target_dist) & (~np.eye(n, dtype=bool))\n            f_mag = np.zeros_like(dists)\n            f_mag[mask] = (target_dist - dists[mask]) / dists[mask]\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries (keeping centers away from edges)\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += (forces + b_forces) * dt\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.6:\n                noise_mag = 0.0012 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Final greedy radius maximization for this center configuration\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing constructor for n=26.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Final Sum of Radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using a \n    force-directed simulation and greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Initial layout: 5x5 grid plus one circle in the middle\n    centers = np.zeros((n, 2))\n    for i in range(25):\n        centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n    centers[25] = [0.5, 0.5]\n\n    # Add small jitter to break symmetry for better packing exploration\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.01, (n, 2))\n\n    # Parameters for the physics-based repulsion simulation\n    # Target distance corresponds to an average radius of ~0.1015\n    iters = 500\n    dt = 0.08\n    target_dist = 0.203\n\n    # Simulation loop: push overlapping circles apart\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = centers[i] - centers[j]\n                dist = np.sqrt(d[0]**2 + d[1]**2)\n                if dist < target_dist:\n                    # Prevent division by zero with small epsilon\n                    if dist < 1e-8:\n                        d = np.array([0.01, 0.0])\n                        dist = 0.01\n                    # Repulsion force proportional to overlap\n                    f = (target_dist - dist) / dist\n                    forces[i] += d * f\n                    forces[j] -= d * f\n        \n        centers += forces * dt\n        # Constrain centers to the unit square\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final optimized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    using proportional scaling followed by iterative greedy refinement.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii based on distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # 2. Proportionally scale radii to remove any circle-circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = np.sqrt(dx*dx + dy*dy)\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Greedy refinement to maximize the sum of radii\n    # In each step, maximize r_i given all other fixed radii\n    for _ in range(20):\n        for i in range(n):\n            # Distance to boundaries\n            m = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            # Distance to all other circles\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = np.sqrt(dx*dx + dy*dy)\n                    if dist - radii[j] < m:\n                        m = dist - radii[j]\n            radii[i] = max(0.0, m)\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=40):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the total sum of radii subject to no overlaps and\n    boundary constraints. It uses coordinate descent with multiple\n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Distance to the nearest wall for each center [x, y, 1-x, 1-y]\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    for trial in range(trials):\n        # Specific heuristic orderings followed by random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Iterative coordinate descent to grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Calculate maximum possible radius r_i given current r_j\n                mask = np.ones(n, dtype=bool)\n                mask[i] = False\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i, mask] - radii[mask]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a force-directed physics simulation \n    with varying target distances and jitter across multiple restarts.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target diameters to explore across multiple restarts\n    target_dists = [0.198, 0.201, 0.204, 0.207, 0.210, 0.213, 0.216, 0.219]\n    \n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible search per restart\n        np.random.seed(600 + restart)\n        r_target = t_dist / 2.0\n        \n        # Initial layout: 5x5 grid plus one circle in the center\n        centers = np.zeros((n, 2))\n        for i in range(25):\n            centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter helps break grid symmetry and escape local minima\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Simulation parameters\n        iters = 1600\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Vectorized pairwise repulsion forces\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            np.fill_diagonal(dists, 1.0) # Avoid self-interaction\n            \n            # Repulsion proportional to overlap distance\n            f_mag = np.maximum(0, t_dist - dists) / (dists + 1e-10)\n            np.fill_diagonal(f_mag, 0)\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Repulsion from square boundaries\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Cooling schedule for simulation convergence\n            cooling = (1.0 - k / iters)**1.5\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.5:\n                noise_scale = 0.001 * (1.0 - k / (iters * 0.5))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Optimize radii for these center positions\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"1.60s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.466821/2.635 = 0.9362\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}