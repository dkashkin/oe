{"id": "8a503f3c-cf4c-437a-b740-8aa4c329ae2c", "code": "An elegant, highly optimized solution using a hybrid approach. It first runs a custom physics-based Adam optimizer with simulated annealing as a global search to explore many topological configurations (overcoming local maxima traps). It then polishes the best configurations found using SciPy's precise Sequential Least SQuares Programming (SLSQP) optimizer to perfectly enforce constraints and maximize the final sum of radii.\n\n```python\nimport numpy as np\nimport time\nfrom scipy.optimize import minimize, LinearConstraint, NonlinearConstraint\n\n\ndef compute_loss_and_grads(centers, radii, C):\n    \"\"\"\n    Computes a penalty-based loss and its analytical gradients for the Adam optimizer.\n    Penalizes boundary and overlap violations heavily to mimic physics repulsions.\n    \"\"\"\n    N = len(radii)\n    \n    grad_centers = np.zeros_like(centers)\n    grad_radii = np.full_like(radii, -1.0) # Base objective: maximize sum(r) -> minimize -sum(r)\n    loss = -np.sum(radii)\n    \n    # 1. Boundary x minimum (x >= r -> r - x <= 0)\n    viol_x_min = np.maximum(0, radii - centers[:, 0])\n    loss += C * np.sum(viol_x_min**2)\n    grad_radii += 2 * C * viol_x_min\n    grad_centers[:, 0] -= 2 * C * viol_x_min\n    \n    # 2. Boundary x maximum (x + r <= 1 -> x + r - 1 <= 0)\n    viol_x_max = np.maximum(0, centers[:, 0] + radii - 1.0)\n    loss += C * np.sum(viol_x_max**2)\n    grad_radii += 2 * C * viol_x_max\n    grad_centers[:, 0] += 2 * C * viol_x_max\n    \n    # 3. Boundary y minimum (y >= r -> r - y <= 0)\n    viol_y_min = np.maximum(0, radii - centers[:, 1])\n    loss += C * np.sum(viol_y_min**2)\n    grad_radii += 2 * C * viol_y_min\n    grad_centers[:, 1] -= 2 * C * viol_y_min\n    \n    # 4. Boundary y maximum (y + r <= 1 -> y + r - 1 <= 0)\n    viol_y_max = np.maximum(0, centers[:, 1] + radii - 1.0)\n    loss += C * np.sum(viol_y_max**2)\n    grad_radii += 2 * C * viol_y_max\n    grad_centers[:, 1] += 2 * C * viol_y_max\n    \n    # 5. Overlap constraints (r_i + r_j <= dist_ij)\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :] \n    dist_sq = np.sum(diff**2, axis=2)\n    dist = np.sqrt(dist_sq + 1e-16) # Add epsilon to avoid divide-by-zero\n    np.fill_diagonal(dist, 1.0) \n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    viol_overlap = np.maximum(0,", "changes_description": null, "language": "python", "parent_id": "18b84dc2-5cc9-4cf4-a96a-bce35531de3d", "generation": 3, "timestamp": 1771881454.9352303, "iteration_found": 37, "metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, initial_radii):\n    \"\"\"\n    Ensure all circles are strictly valid within the square and non-overlapping.\n    A single pass guarantees validity since radii are monotonically decreased.\n    \"\"\"\n    n = len(centers)\n    radii = np.copy(initial_radii)\n    \n    # Strictly limit by proximity to the square boundaries\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if max_r < 0: \n            max_r = 0\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    # Strictly limit by overlaps\n    # Processing each pair once is mathematically sufficient because radii only decrease\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                # Add a tiny safe margin to prevent floating point inaccuracies\n                scale = (dist - 1e-10) / (radii[i] + radii[j])\n                if scale < 0: \n                    scale = 0\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n\ndef optimize_packing_restarts(n=26, num_restarts=5, steps=4000):\n    \"\"\"\n    Optimize circle packing using gradient ascent with simulated annealing.\n    Multiple restarts are utilized to escape local maxima.\n    \"\"\"\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n\n    for restart in range(num_restarts):\n        np.random.seed(42 + restart)\n        \n        centers = []\n        # Seed initial positions strategically to maximize space utilization\n        # 4 corners\n        centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n        # 4 edge midpoints\n        centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n        \n        # Random distribution for the remaining circles, biased to fill gaps\n        num_random = n - 8\n        if num_random > 0:\n            rand_centers = np.random.uniform(0.1, 0.9, size=(num_random, 2))\n            centers.extend(rand_centers)\n            \n        centers = np.array(centers)\n        \n        # Break perfect symmetry: introduce slight random perturbations\n        centers += np.random.normal(0, 0.01, size=centers.shape)\n        centers = np.clip(centers, 0.02, 0.98)\n        \n        # Size placement: bias initialization to push larger circles toward the center\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 2 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport math\n\n_cache_N = None\n_idx_i = None\n_idx_j = None\n_row_idx = None\n_num_bounds = None\n_num_overlaps = None\n\ndef get_indices(N):\n    global _cache_N, _idx_i, _idx_j, _row_idx, _num_bounds, _num_overlaps\n    if _cache_N != N:\n        _cache_N = N\n        _idx_i, _idx_j = np.triu_indices(N, k=1)\n        _num_bounds = 4 * N\n        _num_overlaps = len(_idx_i)\n        _row_idx = _num_bounds + np.arange(_num_overlaps)\n    return _idx_i, _idx_j, _row_idx, _num_bounds, _num_overlaps\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    idx_i, idx_j, row_idx, num_bounds, num_overlaps = get_indices(N)\n    \n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(num_bounds)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    idx_i, idx_j, row_idx, num_bounds, num_overlaps = get_indices(N)\n    \n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, NonlinearConstraint\n\ndef overlap_constraints(x):\n    N = len(x) // 3\n    centers = x.reshape(-1, 3)[:, :2]\n    radii = x.reshape(-1, 3)[:, 2]\n    \n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_sq = np.sum(diff**2, axis=-1)\n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    r_sum_sq = r_sum**2\n    \n    i, j = np.triu_indices(N, k=1)\n    return dist_sq[i, j] - r_sum_sq[i, j]\n\ndef overlap_jacobian(x):\n    N = len(x) // 3\n    centers = x.reshape(-1, 3)[:, :2]\n    radii = x.reshape(-1, 3)[:, 2]\n    \n    i, j = np.triu_indices(N, k=1)\n    n_constraints = len(i)\n    \n    dx = centers[i, 0] - centers[j, 0]\n    dy = centers[i, 1] - centers[j, 1]\n    r_sum = radii[i] + radii[j]\n    \n    jac = np.zeros((n_constraints, 3 * N))\n    k = np.arange(n_constraints)\n    \n    jac[k, 3*i] = 2 * dx\n    jac[k, 3*i+1] = 2 * dy\n    jac[k, 3*i+2] = -2 * r_sum\n    \n    jac[k, 3*j] = -2 * dx\n    jac[k, 3*j+1] = -2 * dy\n    jac[k, 3*j+2] = -2 * r_sum\n    \n    return jac\n\ndef objective(x):\n    return -np.sum(x[2::3])\n\ndef objective_jac(x):\n    jac = np.zeros_like(x)\n    jac[2::3] = -1.0\n    return jac\n\ndef get_linear_constraints(N):\n    A = np.zeros((4*N, 3*N))\n    for k in range(N):\n        A[4*k, 3*k] = 1; A[4*k, 3*k+2] = -1\n        A[4*k+1, 3*k] = 1; A[4*k+1, 3*k+2] = 1\n        A[4*k+2, 3*k+1] = 1; A[4*k+2, 3*k+2] = -1\n        A[4*k+3, 3*k+1] = 1; A[4*k+3, 3*k+2] = 1\n    lb = np.array([0, -np.inf, 0, -np.inf] * N)\n    ub = np.array([np.inf, 1, np.inf, 1] * N)\n    return LinearConstraint(A, lb, ub)\n\ndef enforce_validity(centers, radii):\n    N = len\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based optimization for n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef apply_safety_shrink(centers, R_input):\n    \"\"\"Ensure absolute validity to avoid any floating point precision issues.\"\"\"\n    n = len(centers)\n    R = R_input.copy()\n    \n    # Absolute bounds constraint\n    for i in range(n):\n        R[i] = min(R[i], centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n        \n    # Iterative safety scaling to resolve cascading overlaps\n    for _ in range(20):\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if R[i] + R[j] > dist:\n                    scale = dist / (R[i] + R[j])\n                    # Shrink slightly more to be robust against floating point errors\n                    R[i] *= scale * 0.9999999\n                    R[j] *= scale * 0.9999999\n                    \n    # Final clamp to non-negative strictly valid bounds\n    for i in range(n):\n        R[i] = max(0.0, min(R[i], centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1]))\n    return R\n\n\ndef optimize_radii_lp(centers, R_adam):\n    \"\"\"Use Linear Programming to find the exact optimal radii for given centers.\"\"\"\n    try:\n        from scipy.optimize import linprog\n        n = len(centers)\n        c = -np.ones(n) # Maximize sum of R\n        A_ub = []\n        b_ub = []\n        \n        # Boundary constraints\n        for i in range(n):\n            # R_i <= x_i\n            A = np.zeros(n)\n            A[i] = 1\n            A_ub.append(A)\n            b_ub.append(centers[i, 0])\n            \n            # R_i <= 1 - x_i\n            A = np.zeros(n)\n            A[i] = 1\n            A_ub.append(A)\n            b_ub.append(1 - centers[i, 0])\n            \n            # R_i <= y_i\n            A = np.zeros(n)\n            A[i] = 1\n            A_ub.append(A)\n            b_ub.append(centers[i, 1])\n            \n            # R_i <= 1 - y_i\n            A = np.zeros(n)\n            A[i] = 1\n            A_ub.append(A)\n            b_ub.append(1 - centers[i, 1])\n            \n        # Overlap constraints: R_i + R_j <= dist_ij\n        for i in range(n):\n            for j in range(i + 1, n):\n                A = np.zeros(n)\n                A[i] = 1\n                A[j] = 1\n                dist = np.linalg.norm(centers[i] - centers[j])\n                A_ub.append(A)\n\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\n```python\nimport numpy as np\n\ndef compute_loss_and_grads(params, lambda_pen):\n    \"\"\"\n    Compute the loss and gradients for the current packing configuration.\n    The loss directly penalizes constraint violations and rewards larger radii.\n    \"\"\"\n    N = 26\n    centers = params[:2*N].reshape(N, 2)\n    radii = params[2*N:]\n    \n    grad_centers = np.zeros_like(centers)\n    # Gradient of the objective (maximize sum of radii -> minimize -sum(radii))\n    grad_radii = np.full_like(radii, -1.0)\n    \n    loss = -np.sum(radii)\n    \n    # --- Boundary Violations ---\n    # Boundary x min (radii <= x)\n    viol_x_min = np.maximum(0, radii - centers[:, 0])\n    loss += lambda_pen * np.sum(viol_x_min**2)\n    grad_radii += 2 * lambda_pen * viol_x_min\n    grad_centers[:, 0] -= 2 * lambda_pen * viol_x_min\n    \n    # Boundary x max (x + radii <= 1)\n    viol_x_max = np.maximum(0, centers[:, 0] + radii - 1)\n    loss += lambda_pen * np.sum(viol_x_max**2)\n    grad_radii += 2 * lambda_pen * viol_x_max\n    grad_centers[:, 0] += 2 * lambda_pen * viol_x_max\n    \n    # Boundary y min (radii <= y)\n    viol_y_min = np.maximum(0, radii - centers[:, 1])\n    loss += lambda_pen * np.sum(viol_y_min**2)\n    grad_radii += 2 * lambda_pen * viol_y_min\n    grad_centers[:, 1] -= 2 * lambda_pen * viol_y_min\n    \n    # Boundary y max (y + radii <= 1)\n    viol_y_max = np.maximum(0, centers[:, 1] + radii - 1)\n    loss += lambda_pen * np.sum(viol_y_max**2)\n    grad_radii += 2 * lambda_pen * viol_y_max\n    grad_centers[:, 1] += 2 * lambda_pen * viol_y_max\n    \n    # --- Overlap Violations ---\n    # Vectorized pairwise differences and distances\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :] \n    dist_sq = np.sum(diff**2, axis=2)\n    dist = np.sqrt(dist_sq + 1e-16) # Add epsilon to prevent div-by-zero\n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    viol_overlap = np.maximum(0, r_sum - dist)\n    np.fill_diagonal(viol_overlap, 0)\n    \n    # Divided by 2 because the matrix is symmetric and counts every pair twice\n    loss += lambda_pen * np.sum(viol_overlap**2) / 2\n    \n    # Gradients for overlap violations\n    grad_radii += np.sum(2 * lambda_pen * viol_overlap, axis=1)\n    \n    factor = np.where\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, LinearConstraint, NonlinearConstraint\n\ndef overlap_constraints(x):\n    N = len(x) // 3\n    centers = x.reshape(-1, 3)[:, :2]\n    radii = x.reshape(-1, 3)[:, 2]\n    \n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_sq = np.sum(diff**2, axis=-1)\n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    r_sum_sq = r_sum**2\n    \n    i, j = np.triu_indices(N, k=1)\n    return dist_sq[i, j] - r_sum_sq[i, j]\n\ndef overlap_jacobian(x):\n    N = len(x) // 3\n    centers = x.reshape(-1, 3)[:, :2]\n    radii = x.reshape(-1, 3)[:, 2]\n    \n    i, j = np.triu_indices(N, k=1)\n    n_constraints = len(i)\n    \n    dx = centers[i, 0] - centers[j, 0]\n    dy = centers[i, 1] - centers[j, 1]\n    r_sum = radii[i] + radii[j]\n    \n    jac = np.zeros((n_constraints, 3 * N))\n    k = np.arange(n_constraints)\n    \n    jac[k, 3*i] = 2 * dx\n    jac[k, 3*i+1] = 2 * dy\n    jac[k, 3*i+2] = -2 * r_sum\n    \n    jac[k, 3*j] = -2 * dx\n    jac[k, 3*j+1] = -2 * dy\n    jac[k, 3*j+2] = -2 * r_sum\n    \n    return jac\n\ndef objective(x):\n    return -np.sum(x[2::3])\n\ndef objective_jac(x):\n    jac = np.zeros_like(x)\n    jac[2::3] = -1.0\n    return jac\n\ndef get_linear_constraints(N):\n    A = np.zeros((4*N, 3*N))\n    for k in range(N):\n        A[4*k, 3*k] = 1; A[4*k, 3*k+2] = -1\n        A[4*k+1, 3*k] = 1; A[4*k+1, 3*k+2] = 1\n        A[4*k+2, 3*k+1] = 1; A[4*k+2, 3*k+2] = -1\n        A[4*k+3, 3*k+1] = 1; A[4*k+3, 3*k+2] = 1\n    lb = np.array([0, -np.inf, 0, -np.inf] * N)\n    ub = np.array([np.inf, 1, np.inf, 1] * N)\n    return LinearConstraint(A, lb, ub)\n\ndef enforce_validity(centers, radii):\n    N = len\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\n\ndef compute_loss_and_grads(params, lambda_pen):\n    \"\"\"\n    Compute the loss and gradients for the current packing configuration.\n    The loss directly penalizes constraint violations and rewards larger radii.\n    \"\"\"\n    N = 26\n    centers = params[:2*N].reshape(N, 2)\n    radii = params[2*N:]\n    \n    grad_centers = np.zeros_like(centers)\n    # Gradient of the objective (maximize sum of radii -> minimize -sum(radii))\n    grad_radii = np.full_like(radii, -1.0)\n    \n    loss = -np.sum(radii)\n    \n    # --- Boundary Violations ---\n    # Boundary x min (radii <= x)\n    viol_x_min = np.maximum(0, radii - centers[:, 0])\n    loss += lambda_pen * np.sum(viol_x_min**2)\n    grad_radii += 2 * lambda_pen * viol_x_min\n    grad_centers[:, 0] -= 2 * lambda_pen * viol_x_min\n    \n    # Boundary x max (x + radii <= 1)\n    viol_x_max = np.maximum(0, centers[:, 0] + radii - 1)\n    loss += lambda_pen * np.sum(viol_x_max**2)\n    grad_radii += 2 * lambda_pen * viol_x_max\n    grad_centers[:, 0] += 2 * lambda_pen * viol_x_max\n    \n    # Boundary y min (radii <= y)\n    viol_y_min = np.maximum(0, radii - centers[:, 1])\n    loss += lambda_pen * np.sum(viol_y_min**2)\n    grad_radii += 2 * lambda_pen * viol_y_min\n    grad_centers[:, 1] -= 2 * lambda_pen * viol_y_min\n    \n    # Boundary y max (y + radii <= 1)\n    viol_y_max = np.maximum(0, centers[:, 1] + radii - 1)\n    loss += lambda_pen * np.sum(viol_y_max**2)\n    grad_radii += 2 * lambda_pen * viol_y_max\n    grad_centers[:, 1] += 2 * lambda_pen * viol_y_max\n    \n    # --- Overlap Violations ---\n    # Vectorized pairwise differences and distances\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :] \n    dist_sq = np.sum(diff**2, axis=2)\n    dist = np.sqrt(dist_sq + 1e-16) # Add epsilon to prevent div-by-zero\n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    viol_overlap = np.maximum(0, r_sum - dist)\n    np.fill_diagonal(viol_overlap, 0)\n    \n    # Divided by 2 because the matrix is symmetric and counts every pair twice\n    loss += lambda_pen * np.sum(viol_overlap**2) / 2\n    \n    # Gradients for overlap violations\n    grad_radii += np.sum(2 * lambda_pen * viol_overlap, axis=1)\n    \n    factor = np.where\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport math\n\n_cache_N = None\n_idx_i = None\n_idx_j = None\n_row_idx = None\n_num_bounds = None\n_num_overlaps = None\n\ndef get_indices(N):\n    global _cache_N, _idx_i, _idx_j, _row_idx, _num_bounds, _num_overlaps\n    if _cache_N != N:\n        _cache_N = N\n        _idx_i, _idx_j = np.triu_indices(N, k=1)\n        _num_bounds = 4 * N\n        _num_overlaps = len(_idx_i)\n        _row_idx = _num_bounds + np.arange(_num_overlaps)\n    return _idx_i, _idx_j, _row_idx, _num_bounds, _num_overlaps\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    idx_i, idx_j, row_idx, num_bounds, num_overlaps = get_indices(N)\n    \n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(num_bounds)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    idx_i, idx_j, row_idx, num_bounds, num_overlaps = get_indices(N)\n    \n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    v_reshaped = v.reshape(N, 3)\n    x = v_reshaped[:, 0]\n    y = v_reshaped[:, 1]\n    r = v_reshaped[:, 2]\n    \n    c_bounds = np.empty(4 * N)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n    total_constraints = num_bounds + num_overlaps\n    \n    jac = np.zeros((total_constraints, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    row_idx = num_bounds + np.arange(num_overlaps)\n    \n    jac[row_idx, 3*idx_i] = 2 * dx\n    jac[row_idx, 3*idx_j] = -2 * dx\n    jac[row_idx, 3*idx_i+1] = 2 * dy\n    jac[row_idx, 3*idx_j+1] = -2 * dy\n    jac[row_idx, 3*idx_i+2] = -2 * sr\n    jac[row_idx, 3*idx_j+2] = -2 * sr\n    \n    return jac\n\ndef apply_safety_shrink(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3].copy()\n    \n    for i in range(N):\n        r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n        \n    for _ in range(100):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.hypot(x[i]-x[j], y[i]-y[j])\n                if r[i] + r[j] > dist:\n                    scale = (dist - 1e-12) / (r[i] + r[j])\n                    if scale < 0:\n                        scale = 0\n                    r[i] *= scale\n                    r[j] *= scale\n                    \n    for i in range(N):\n        r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n        \n    v_new = v.copy()\n    v_new[2::3] = r\n    return v_new\n\ndef get_initial_guess(N, seed):\n    np.random.seed(seed)\n    centers = []\n    \n    if seed % 3 == 0:\n        grid_dim = int(np.ceil(np.sqrt(N)))\n        for i in range(grid_dim):\n            for j in range(grid_dim):\n                if len(centers) < N:\n                    cx = (i + 0.5) / grid_dim\n                    cy = (j + 0.5) / grid_dim\n                    centers.append([cx, cy])\n    elif seed % 3 == 1:\n        centers.extend([[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]])\n        centers.extend([[0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5]])\n        while len(centers) < N:\n            centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n    else:\n        centers.append([0.5, 0.5])\n        for r_ring in [0.25, 0.45]:\n            count = int(2 * np.pi * r_ring * 10)\n            for i in range(count):\n                if len(centers) < N:\n                    angle = i * 2 * np.pi / count\n                    centers.append([0.5 + r_ring * np.cos(angle), 0.5 + r_ring * np.sin(angle)])\n        while len(centers) < N:\n            centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n    centers = np.array(centers)\n    centers += np.random.normal(0, 0.01, size=centers.shape)\n    centers = np.clip(centers, 0.05, 0.95)\n    \n    dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n    max_dist = np.max(dist_to_center) if np.max(dist_to_center) > 0 else 1.0\n    radii = 0.02 + 0.06 * (1.0 - dist_to_center / max_dist)\n    \n    v = np.zeros(3 * N)\n    v[0::3] = centers[:, 0]\n    v[1::3] = centers[:, 1]\n    v[2::3] = radii\n    return v\n\ndef solve():\n    N = 26\n    best_v = None\n    best_sum_r = -1.0\n    start_time = time.time()\n    \n    bounds = []\n    for _ in range(N):\n        bounds.append((0, 1))\n        bounds.append((0, 1))\n        bounds.append((0, 0.5))\n        \n    seed = 0\n    while time.time() - start_time < 500:\n        v0 = get_initial_guess(N, seed)\n        seed += 1\n        \n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints={'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac},\n            options={'maxiter': 500, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n        \n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n            \n        if seed % 5 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0, 1)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0, 1)\n            v_shake[2::3] *= 0.9  \n            \n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints={'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac},\n                options={'maxiter': 500, 'ftol': 1e-6, 'disp': False}\n            )\n            \n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n            \n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n        if seed >= 1000:\n            break\n\n    if best_v is not None:\n        for i in range(N):\n            print(f\"{best_v[3*i]} {best_v[3*i+1]} {best_v[3*i+2]}\")\n\nif __name__ == \"__main__\":\n    solve()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["An elegant, highly optimized solution using a hybrid approach. It first runs a custom physics-based Adam optimizer with simulated annealing as a global search to explore many topological configurations (overcoming local maxima traps). It then polishes the best configurations found using SciPy's precise Sequential Least SQuares Programming (SLSQP) optimizer to perfectly enforce constraints and maximize the final sum of radii.\n\n```python\nimport numpy as np\nimport time\nfrom scipy.optimize import minimize, LinearConstraint, NonlinearConstraint\n\n\ndef compute_loss_and_grads(centers, radii, C):\n    \"\"\"\n    Computes a penalty-based loss and its analytical gradients for the Adam optimizer.\n    Penalizes boundary and overlap violations heavily to mimic physics repulsions.\n    \"\"\"\n    N = len(radii)\n    \n    grad_centers = np.zeros_like(centers)\n    grad_radii = np.full_like(radii, -1.0) # Base objective: maximize sum(r) -> minimize -sum(r)\n    loss = -np.sum(radii)\n    \n    # 1. Boundary x minimum (x >= r -> r - x <= 0)\n    viol_x_min = np.maximum(0, radii - centers[:, 0])\n    loss += C * np.sum(viol_x_min**2)\n    grad_radii += 2 * C * viol_x_min\n    grad_centers[:, 0] -= 2 * C * viol_x_min\n    \n    # 2. Boundary x maximum (x + r <= 1 -> x + r - 1 <= 0)\n    viol_x_max = np.maximum(0, centers[:, 0] + radii - 1.0)\n    loss += C * np.sum(viol_x_max**2)\n    grad_radii += 2 * C * viol_x_max\n    grad_centers[:, 0] += 2 * C * viol_x_max\n    \n    # 3. Boundary y minimum (y >= r -> r - y <= 0)\n    viol_y_min = np.maximum(0, radii - centers[:, 1])\n    loss += C * np.sum(viol_y_min**2)\n    grad_radii += 2 * C * viol_y_min\n    grad_centers[:, 1] -= 2 * C * viol_y_min\n    \n    # 4. Boundary y maximum (y + r <= 1 -> y + r - 1 <= 0)\n    viol_y_max = np.maximum(0, centers[:, 1] + radii - 1.0)\n    loss += C * np.sum(viol_y_max**2)\n    grad_radii += 2 * C * viol_y_max\n    grad_centers[:, 1] += 2 * C * viol_y_max\n    \n    # 5. Overlap constraints (r_i + r_j <= dist_ij)\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :] \n    dist_sq = np.sum(diff**2, axis=2)\n    dist = np.sqrt(dist_sq + 1e-16) # Add epsilon to avoid divide-by-zero\n    np.fill_diagonal(dist, 1.0) \n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    viol_overlap = np.maximum(0,"]}}, "artifacts_json": "{\"stderr\": \"Stage 1 evaluation failed: Program execution failed: unterminated string literal (detected at line 1) (tmptaxjjwu3.py, line 1)\", \"traceback\": \"Traceback (most recent call last):\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 384, in evaluate_stage1\\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 172, in run_with_timeout\\n    raise RuntimeError(f\\\"Program execution failed: {results['error']}\\\")\\nRuntimeError: Program execution failed: unterminated string literal (detected at line 1) (tmptaxjjwu3.py, line 1)\\n\", \"failure_stage\": \"stage1_execution\", \"suggestion\": \"Check basic syntax and imports before attempting full evaluation\"}", "artifact_dir": null, "embedding": null}