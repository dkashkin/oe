{"id": "070caf0c-ac33-48ba-9697-674822d70e19", "code": "\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses a highly vectorized Adam optimizer with exact analytical gradients \nto strictly solve a simulated annealing physics model. \nFeatures diverse topology initializations, targeted perturbations, \nand mathematically rigorous post-processing to escape local minima \nand guarantee absolute validity.\n\"\"\"\nimport numpy as np\n\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # High batch size and iterations for deep convergence\n    B = 240\n    N = 26\n    iters = 3800\n    \n    np.random.seed(42)\n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically to explore diverse topologies\n    step = B // 6\n    \n    # Strategy 1: Uniform random\n    C[0:step] = np.random.uniform(0.1, 0.9, (step, N, 2))\n    \n    # Strategy 2: Centered normal (clusters in middle, leaves edges for expansion)\n    C[step:2*step] = np.random.normal(0.5, 0.15, (step, N, 2))\n    \n    # Strategy 3: Beta distribution (pushes to corners and edges)\n    C[2*step:3*step] = np.random.beta(0.4, 0.4, (step, N, 2))\n    \n    # Strategy 4: Concentric rings pattern A (1 + 8 + 17)\n    rings_A = [[0.5, 0.5]]\n    for i in range(8):\n        ang = 2 * np.pi * i / 8\n        rings_A.append([0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)])\n    for i in range(17):\n        ang = 2 * np.pi * i / 17\n        rings_A.append([0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)])\n    C[3*step:4*step] = np.array(rings_A) + np.random.normal(0, 0.01, (step, N, 2))\n    \n    # Strategy 5: Concentric rings pattern B (3 + 9 + 14) - Apollonian tendency\n    rings_B = []\n    for i in range(3):\n        ang = 2 * np.pi * i / 3\n        rings_B.append([0.5 + 0.1 * np.cos(ang), 0.5 + 0.1 * np.sin(ang)])\n    for i in range(9):\n        ang = 2 * np.pi * i / 9\n        rings_B.append([0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)])\n    for i in range(14):\n        ang = 2 * np.pi * i / 14\n        rings_B.append([0.5 + 0.46 * np.cos(ang), 0.5 + 0.46 * np.sin(ang)])\n    C[4*step:5*step] = np.array(rings_B) + np.random.normal(0, 0.01, (step, N, 2))\n    \n    # Strategy 6: Grid 5x5 + 1 interstitial center\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n    grid = np.vstack([grid, [0.2, 0.2]])  # 26th point off-center\n    C[5*step:6*step] = grid + np.random.normal(0, 0.01, (step, N, 2))\n    \n    # Anchor the corners explicitly for a fraction of the uniform batches\n    C[0:step//2, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    \n    # Apply global boundary enforcement for initialization\n    C = np.clip(C, 0.05, 0.95)\n    \n    # 2. Size placement bias: Push naturally larger expected radii towards the center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.03 + 0.04 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.01, 0.15)\n    \n    # Adam optimizer states\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    \n    # Precompute mask components for optimal vectorized distance calculations\n    eye = np.eye(N)[np.newaxis, :, :]\n    mask = 1.0 - eye\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        # Simulated annealing phase schedule for penalty parameters\n        phase_ratio = min(1.0, t / (iters * 0.8))\n        if t <= iters * 0.8:\n            lr = 0.012 * (1.0 - 0.6 * phase_ratio)\n            lam = 10.0 * (20000.0 ** phase_ratio)\n        else:\n            # Cool down phase: Lock in exact minima strictly\n            lr = 0.001\n            lam = 200000.0\n            \n        # Compute wall overlap violations\n        v_x0 = np.maximum(0.0, R - C[:, :, 0])\n        v_x1 = np.maximum(0.0, R + C[:, :, 0] - 1.0)\n        v_y0 = np.maximum(0.0, R - C[:, :, 1])\n        v_y1 = np.maximum(0.0, R + C[:, :, 1] - 1.0)\n        \n        # Compute pairwise overlap violations precisely without triggering NaNs on self-distance\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        v_pair = np.maximum(0.0, R_sum - dist) * mask\n        \n        # Exact analytical gradients for the physics penalty objective function\n        g_R = -1.0 + 2.0 * lam * (v_x0 + v_x1 + v_y0 + v_y1 + np.sum(v_pair, axis=2))\n        \n        g_C_x = 2.0 * lam * (-v_x0 + v_x1)\n        g_C_y = 2.0 * lam * (-v_y0 + v_y1)\n        g_C_bound = np.stack([g_C_x, g_C_y], axis=-1)\n        \n        direction = diff / dist[..., np.newaxis]\n        g_C_pair = 2.0 * lam * np.sum(v_pair[..., np.newaxis] * (-direction), axis=2)\n        g_C = g_C_bound + g_C_pair\n        \n        # Apply Adam updates for Centers\n        m_C = beta1 * m_C + (1.0 - beta1) * g_C\n        v_C = beta2 * v_C + (1.0 - beta2) * (g_C**2)\n        m_C_hat = m_C / (1.0 - beta1**t)\n        v_C_hat = v_C / (1.0 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam updates for Radii\n        m_R = beta1 * m_R + (1.0 - beta1) * g_R\n        v_R = beta2 * v_R + (1.0 - beta2) * (g_R**2)\n        m_R_hat = m_R / (1.0 - beta1**t)\n        v_R_hat = v_R / (1.0 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Jolt circles periodically out of local minima\n        if t % 250 == 0 and t < iters * 0.6:\n            C += np.random.randn(*C.shape) * 0.002\n            R += np.random.randn(*R.shape) * 0.001\n            \n        # Physical constraints to stabilize early erratic optimization states\n        C = np.clip(C, 0.0, 1.0)\n        R = np.clip(R, 0.0, 0.5)\n        \n    # 5. Post Processing Phase: Ensure mathematically impeccable valid constraints\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Establish structural boundaries explicitly with safety precision margin\n        safe_walls = np.min([Cb[:, 0], 1.0 - Cb[:, 0], Cb[:, 1], 1.0 - Cb[:, 1]], axis=0)\n        Rb = np.clip(Rb, 0.0, safe_walls - 1e-13)\n        \n        # Relax geometries iteratively via local greedy shrinking to resolve remaining overlaps\n        for _ in range(10):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    sum_R_ij = Rb[i] + Rb[j]\n                    if sum_R_ij > dist_ij:\n                        if dist_ij > 1e-13:\n                            scale = (dist_ij - 1e-13) / sum_R_ij\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0.0\n                            Rb[j] = 0.0\n                            \n        # Final pass boundary safety clip\n        safe_walls_final = np.min([Cb[:, 0], 1.0 - Cb[:, 0], Cb[:, 1], 1.0 - Cb[:, 1]], axis=0)\n        Rb = np.clip(Rb, 0.0, safe_walls_final - 1e-13)\n        \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")", "changes_description": null, "language": "python", "parent_id": "d1c45c64-350e-467d-ae10-0cd0267835e6", "generation": 6, "timestamp": 1771884435.7711737, "iteration_found": 94, "metrics": {"validity": 1.0, "sum_radii": 2.082791087709061, "target_ratio": 0.7904330503639702, "combined_score": 0.7904330503639702, "radius_variance": 0.0077005068481481925, "spatial_spread": 0.17083505091616713, "stage2_passed": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 1.6284978370028458, "target_ratio": 0.6180257445931104, "combined_score": 0.6180257445931104, "radius_variance": 0.008087794160469107, "spatial_spread": 0.186208106493049, "eval_time": 33.14669489860535}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.6180\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.6516 \u2192 0.6180. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n33.15s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 1.628498/2.635 = 0.6180\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 1.7170, target_ratio: 0.6516, combined_score: 0.6516, radius_variance: 0.0094, spatial_spread: 0.1773, eval_time: 39.0346\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1174, target_ratio: 0.8036, combined_score: 0.8036, radius_variance: 0.0099, spatial_spread: 0.2172, eval_time: 51.9083\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.2043, target_ratio: 0.8365, combined_score: 0.8365, radius_variance: 0.0149, spatial_spread: 0.1958, eval_time: 52.5517\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.8365)\n```python\n\"\"\"\nIterative optimization-based circle packing for n=26 circles.\nUses Adam optimizer with a custom physics-based objective to maximize \nthe sum of radii while strictly penalizing overlapping and boundary violations.\nRuns multiple restarts from diverse strategic initializations to escape local minima.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    B = 250  # Batch size for parallel topology exploration\n    N = 26\n    iters = 3500\n    \n    np.random.seed(42)\n    \n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically:\n    idx = 0\n    step = B // 6\n    \n    # Strategy A: Uniform random\n    C[idx:idx+step] = np.random.rand(step, N, 2)\n    idx += step\n    \n    # Strategy B: Centered normal (clusters in middle, leaves edges for expansion)\n    C[idx:idx+step] = np.random.normal(0.5, 0.15, size=(step, N, 2))\n    idx += step\n    \n    # Strategy C: Beta distribution (pushes to corners and edges)\n    C[idx:idx+step] = np.random.beta(0.4, 0.4, size=(step, N, 2))\n    idx += step\n    \n    # Strategy D: Concentric rings pattern\n    ring_centers = np.zeros((N, 2))\n    ring_centers[0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        ring_centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        ring_centers[i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n    C[idx:idx+step] = ring_centers + np.random.normal(0, 0.01, size=(step, N, 2))\n    idx += step\n    \n    # Strategy E: Grid-like patterns\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])[:N]\n    C[idx:idx+step] = grid + np.random.normal(0, 0.01, size=(step, N, 2))\n    idx += step\n    \n    # Strategy F: Uniform with corners explicitly anchored\n    rem = B - idx\n    if rem > 0:\n        C[idx:] = np.random.uniform(0.1, 0.9, size=(rem, N, 2))\n        C[idx:, :4] = [[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]]\n    \n    # Boundary enforcement for initialization\n    C = np.clip(C, 0.05, 0.95)\n    \n    # 2. Size placement bias: Push larger circles toward center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.03 + 0.04 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.01, 0.15)\n    \n    # Adam optimizer state\n    m_C = np.zeros_like(C)\n    v_C = np.zeros_like(C)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    mask = np.eye(N)[np.newaxis, :, :]\n    \n    # Optimization Loop\n    for t in range(1, iters + 1):\n        # 3. Tune optimization parameters: Simulated Annealing penalty phase\n        phase_ratio = min(1.0, t / (iters * 0.8))\n        if t <= iters * 0.8:\n            lr = 0.01 * (1.0 - 0.5 * phase_ratio)\n            lambda_val = 10.0 * (10000.0 ** phase_ratio)\n        else:\n            lr = 0.001\n            lambda_val = 100000.0\n            \n        # Calculate wall overlap violations\n        viol_x0 = np.maximum(0, R - C[:, :, 0])\n        viol_x1 = np.maximum(0, R + C[:, :, 0] - 1)\n        viol_y0 = np.maximum(0, R - C[:, :, 1])\n        viol_y1 = np.maximum(0, R + C[:, :, 1] - 1)\n        \n        # Calculate pairwise overlap violations safely\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + mask + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        viol_pair = np.maximum(0, R_sum - dist) * (1 - mask)\n        \n        # Compute exact analytical gradients\n        grad_R = -1.0 + 2 * lambda_val * (viol_x0 + viol_x1 + viol_y0 + viol_y1 + np.sum(viol_pair, axis=2))\n        \n        grad_C_x = 2 * lambda_val * (-viol_x0 + viol_x1)\n        grad_C_y = 2 * lambda_val * (-viol_y0 + viol_y1)\n        grad_C_bound = np.stack([grad_C_x, grad_C_y], axis=-1)\n        \n        dir = diff / dist[..., np.newaxis]\n        grad_C_pair = 2 * lambda_val * np.sum(viol_pair[..., np.newaxis] * (-dir), axis=2)\n        grad_C = grad_C_bound + grad_C_pair\n        \n        # Apply Adam update for Centers\n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * (grad_C**2)\n        m_C_hat = m_C / (1 - beta1**t)\n        v_C_hat = v_C / (1 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam update for Radii\n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * (grad_R**2)\n        m_R_hat = m_R / (1 - beta1**t)\n        v_R_hat = v_R / (1 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if t % 250 == 0 and t < iters * 0.6:\n            C += np.random.randn(*C.shape) * 0.002\n            \n        # Constrain variables logically\n        C = np.clip(C, 0, 1)\n        R = np.maximum(R, 0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Limit to boundaries explicitly (incorporating fp safety margin)\n        Rb = np.clip(Rb, 0, None)\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-12)\n        Rb = np.minimum(Rb, 1 - Cb[:, 0] - 1e-12)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-12)\n        Rb = np.minimum(Rb, 1 - Cb[:, 1] - 1e-12)\n        Rb = np.maximum(Rb, 0)\n        \n        # Iterate strict greedy shrink pass to resolve infinitesimal remaining overlaps\n        for _ in range(5):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if dist_ij > 0:\n                            scale = (dist_ij - 1e-12) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0\n                            Rb[j] = 0\n                            \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.2043), Performs well on target_ratio (0.8365), Performs well on combined_score (0.8365), Performs well on radius_variance (0.0149), Performs well on spatial_spread (0.1958), Performs well on eval_time (52.5517)\n\n### Program 2 (Score: 0.8036)\n```python\n\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses Adam optimizer with exact analytical gradients to strictly solve \na simulated annealing physics model. \nFeatures diverse topology initialization and symmetric constraints.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    B = 300\n    N = 26\n    iters = 3000\n    \n    np.random.seed(42)\n    C = np.random.uniform(0.1, 0.9, (B, N, 2))\n    \n    # 1. Diverse Initializations\n    # Gaussian centered\n    C[:B//4] = np.random.normal(0.5, 0.15, (B//4, N, 2))\n    \n    # Uniform with anchored corners\n    C[B//4:B//2, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    \n    # Grid initialization\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])[:N]\n    C[B//2:3*B//4] = grid + np.random.normal(0, 0.01, (B//4, N, 2))\n    \n    # Concentric rings\n    rings = [[0.5, 0.5]]\n    for i in range(8):\n        rings.append([0.5 + 0.25 * np.cos(2 * np.pi * i / 8), 0.5 + 0.25 * np.sin(2 * np.pi * i / 8)])\n    for i in range(17):\n        rings.append([0.5 + 0.45 * np.cos(2 * np.pi * i / 17), 0.5 + 0.45 * np.sin(2 * np.pi * i / 17)])\n    C[3*B//4:] = np.array(rings) + np.random.normal(0, 0.01, (B - 3*B//4, N, 2))\n    \n    C = np.clip(C, 0.05, 0.95)\n    \n    # 2. Size placement bias (push larger circles to the center)\n    R = 0.03 + 0.04 * (0.707 - np.linalg.norm(C - 0.5, axis=2))\n    R = np.clip(R, 0.01, 0.15)\n    \n    # Optimizer states\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n    \n    mask = np.eye(N)[np.newaxis, :, :]\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        prog = t / iters\n        \n        # Adaptive simulated annealing schedule\n        if prog <= 0.8:\n            lr = 0.01 * (1.0 - 0.5 * prog / 0.8)\n            lam = 10.0 * (10000.0 ** (prog / 0.8))\n        else:\n            lr = 0.001\n            lam = 100000.0\n            \n        # Calculate wall overlap violations\n        v_x0, v_x1 = np.maximum(0, R - C[..., 0]), np.maximum(0, R + C[..., 0] - 1)\n        v_y0, v_y1 = np.maximum(0, R - C[..., 1]), np.maximum(0, R + C[..., 1] - 1)\n        \n        # Calculate pairwise overlap violations safely\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1) + mask + 1e-12)\n        v_pair = np.maximum(0, R[:, :, np.newaxis] + R[:, np.newaxis, :] - dist) * (1 - mask)\n        \n        # Compute exact analytical gradients\n        g_R = -1.0 + 2 * lam * (v_x0 + v_x1 + v_y0 + v_y1 + np.sum(v_pair, axis=2))\n        g_C_bound = np.stack([2 * lam * (-v_x0 + v_x1), 2 * lam * (-v_y0 + v_y1)], axis=-1)\n        g_C_pair = 2 * lam * np.sum(v_pair[..., np.newaxis] * (-diff / dist[..., np.newaxis]), axis=2)\n        g_C = g_C_bound + g_C_pair\n        \n        # Apply Adam updates\n        m_C = 0.9 * m_C + 0.1 * g_C\n        v_C = 0.999 * v_C + 0.001 * (g_C**2)\n        m_C_hat = m_C / (1 - 0.9**t)\n        v_C_hat = v_C / (1 - 0.999**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + 1e-8)\n        \n        m_R = 0.9 * m_R + 0.1 * g_R\n        v_R = 0.999 * v_R + 0.001 * (g_R**2)\n        m_R_hat = m_R / (1 - 0.9**t)\n        v_R_hat = v_R / (1 - 0.999**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + 1e-8)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if t % 250 == 0 and prog < 0.6:\n            C += np.random.randn(*C.shape) * 0.002\n            \n        # Constrain variables logically\n        C = np.clip(C, 0, 1)\n        R = np.maximum(R, 0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Secure boundaries explicitly (incorporating precision safety margin)\n        safe_walls = np.min([Cb[:, 0], 1.0 - Cb[:, 0], Cb[:, 1], 1.0 - Cb[:, 1]], axis=0)\n        Rb = np.clip(Rb, 0.0, safe_walls - 1e-13)\n        \n        # Strict greedy shrink pass to resolve infinitesimal remaining overlaps\n        for _ in range(5):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if Rb[i] + Rb[j] > 0:\n                            scale = max(0.0, dist_ij - 1e-13) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                            \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1174), Performs well on target_ratio (0.8036), Performs well on combined_score (0.8036), Performs well on radius_variance (0.0099), Performs well on spatial_spread (0.2172), Performs well on eval_time (51.9083)\n\n### Program 3 (Score: 0.6516)\n```python\n\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses a highly vectorized Adam optimizer with a custom physics-based objective to maximize \nthe sum of radii while strictly penalizing overlapping and boundary violations.\nRuns multiple restarts from diverse strategic initial topologies to escape local minima,\nimplementing a smooth simulated annealing schedule and early symmetry-breaking perturbations.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    B = 180  # Batch size for parallel topology exploration\n    N = 26\n    iters = 3500\n    \n    np.random.seed(42)\n    \n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically:\n    idx = 0\n    step = B // 6\n    \n    # Strategy 1: Uniform random\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 2: Uniform with 4 corners explicitly anchored\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    C[idx:idx+step, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    idx += step\n    \n    # Strategy 3: Centered normal (clusters in middle, expands outward)\n    C[idx:idx+step] = np.random.normal(0.5, 0.15, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 4: 5x5 Grid + 1 interstitial gap circle\n    grid_pts = []\n    for r in range(5):\n        for c in range(5):\n            grid_pts.append([0.1 + 0.2 * c, 0.1 + 0.2 * r])\n    for i in range(step):\n        C[idx+i, :25] = grid_pts\n        C[idx+i, 25] = [np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)]\n    C[idx:idx+step] += np.random.normal(0, 0.005, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 5: Hexagonal-like staggered grid\n    pts5 = []\n    for r in range(6):\n        cols = 5 if r % 2 == 0 else 4\n        for c in range(cols):\n            x = (c + (0.5 if r % 2 == 1 else 0.0)) / 4.0 * 0.8 + 0.1\n            y = r / 5.0 * 0.8 + 0.1\n            pts5.append([x, y])\n    pts5 = np.array(pts5[:N])\n    for i in range(step):\n        C[idx+i] = pts5 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 6: Concentric rings pattern (1 + 8 + 17)\n    pts6 = [[0.5, 0.5]]\n    for i in range(8):\n        ang = 2 * np.pi * i / 8\n        pts6.append([0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)])\n    for i in range(17):\n        ang = 2 * np.pi * i / 17\n        pts6.append([0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)])\n    pts6 = np.array(pts6)\n    for i in range(step):\n        C[idx+i] = pts6 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Boundary enforcement for initial values\n    C = np.clip(C, 0.02, 0.98)\n    \n    # 2. Size placement bias: Push naturally larger expected radii towards the center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.04 + 0.05 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.02, 0.12)\n    \n    # Adam optimizer state\n    m_C = np.zeros_like(C)\n    v_C = np.zeros_like(C)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.99\n    eps = 1e-8\n    \n    eye = np.eye(N)[np.newaxis, :, :]\n    mask = 1.0 - eye\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        # Adaptive simulated annealing schedule\n        phase_ratio = min(1.0, t / (iters * 0.8))\n        if t <= iters * 0.8:\n            lr = 0.015 * (1.0 - 0.5 * phase_ratio)\n            lambda_val = 10.0 * (10000.0 ** phase_ratio)\n        else:\n            # Cool down phase for infinitesimal settling\n            cool_ratio = (t - iters * 0.8) / (iters * 0.2)\n            lr = 0.0075 * (1.0 - 0.8 * cool_ratio)\n            lambda_val = 100000.0 * (10.0 ** cool_ratio)\n            \n        # Calculate wall overlap violations\n        viol_x0 = np.maximum(0.0, R - C[:, :, 0])\n        viol_x1 = np.maximum(0.0, R + C[:, :, 0] - 1.0)\n        viol_y0 = np.maximum(0.0, R - C[:, :, 1])\n        viol_y1 = np.maximum(0.0, R + C[:, :, 1] - 1.0)\n        \n        # Calculate pairwise overlap violations safely (avoiding sqrt(0) NaNs)\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        viol_pair = np.maximum(0.0, R_sum - dist) * mask\n        \n        # Compute exact analytical gradients\n        grad_R = -1.0 + 2.0 * lambda_val * (\n            viol_x0 + viol_x1 + viol_y0 + viol_y1 + np.sum(viol_pair, axis=2)\n        )\n        \n        grad_C_x = 2.0 * lambda_val * (-viol_x0 + viol_x1)\n        grad_C_y = 2.0 * lambda_val * (-viol_y0 + viol_y1)\n        grad_C_bound = np.stack([grad_C_x, grad_C_y], axis=-1)\n        \n        direction = diff / dist[..., np.newaxis]\n        grad_C_pair = 2.0 * lambda_val * np.sum(viol_pair[..., np.newaxis] * (-direction), axis=2)\n        grad_C = grad_C_bound + grad_C_pair\n        \n        # Apply Adam update for Centers\n        m_C = beta1 * m_C + (1.0 - beta1) * grad_C\n        v_C = beta2 * v_C + (1.0 - beta2) * (grad_C**2)\n        m_C_hat = m_C / (1.0 - beta1**t)\n        v_C_hat = v_C / (1.0 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam update for Radii\n        m_R = beta1 * m_R + (1.0 - beta1) * grad_R\n        v_R = beta2 * v_R + (1.0 - beta2) * (grad_R**2)\n        m_R_hat = m_R / (1.0 - beta1**t)\n        v_R_hat = v_R / (1.0 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if t % 250 == 0 and t < iters * 0.5:\n            C += np.random.randn(*C.shape) * 0.002\n            R += np.random.randn(*R.shape) * 0.001\n            \n        # Constrain variables logically\n        C = np.clip(C, 0.0, 1.0)\n        R = np.maximum(R, 0.0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Initial bounds safety check explicitly incorporating a fp precision safety margin\n        Rb = np.clip(Rb, 0.0, None)\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-13)\n        \n        # Iterate strict greedy shrink pass to resolve infinitesimal remaining overlaps perfectly\n        for _ in range(3):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if dist_ij > 1e-13:\n                            scale = (dist_ij - 1e-13) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0.0\n                            Rb[j] = 0.0\n                            \n        # Final bounds safety check\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-13)\n        Rb = np.maximum(Rb, 0.0)\n        \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.7170), Performs well on target_ratio (0.6516), Performs well on combined_score (0.6516), Performs well on radius_variance (0.0094), Performs well on spatial_spread (0.1773), Performs well on eval_time (39.0346)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3642)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.6180)\n```python\n\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses a highly vectorized Adam optimizer with a custom physics-based objective to maximize \nthe sum of radii while strictly penalizing overlapping and boundary violations.\nRuns multiple restarts from diverse strategic initial topologies to escape local minima,\nimplementing a smooth simulated annealing schedule and early symmetry-breaking perturbations.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Batch size selected to confidently complete within standard hardware timeout limits\n    B = 160  \n    N = 26\n    iters = 3000\n    \n    np.random.seed(42)\n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically:\n    idx = 0\n    step = B // 8\n    \n    # Strategy 1: Uniform random\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 2: Uniform with 4 corners explicitly anchored\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    C[idx:idx+step, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    idx += step\n    \n    # Strategy 3: Centered normal (clusters in middle, expands outward)\n    C[idx:idx+step] = np.random.normal(0.5, 0.15, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 4: 5x5 Grid + 1 interstitial gap circle\n    grid_pts = []\n    for r in range(5):\n        for c in range(5):\n            grid_pts.append([0.1 + 0.2 * c, 0.1 + 0.2 * r])\n    for i in range(step):\n        C[idx+i, :25] = grid_pts\n        C[idx+i, 25] = [np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)]\n    C[idx-step:idx] += np.random.normal(0, 0.005, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 5: Hexagonal-like staggered grid perfectly fitting 26\n    pts5 = []\n    for r in range(6):\n        cols = 5 if r % 2 == 0 else 4\n        if r == 5: cols = 3\n        for c in range(cols):\n            x = (c + (0.5 if r % 2 == 1 else 0.0)) / 4.0 * 0.8 + 0.1\n            y = r / 5.0 * 0.8 + 0.1\n            pts5.append([x, y])\n    pts5 = np.array(pts5[:N])\n    for i in range(step):\n        C[idx+i] = pts5 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 6: Concentric rings pattern (1 + 8 + 17)\n    pts6 = [[0.5, 0.5]]\n    for i in range(8):\n        ang = 2 * np.pi * i / 8\n        pts6.append([0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)])\n    for i in range(17):\n        ang = 2 * np.pi * i / 17\n        pts6.append([0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)])\n    pts6 = np.array(pts6)\n    for i in range(step):\n        C[idx+i] = pts6 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 7: Concentric rings pattern (3 + 9 + 14)\n    pts7 = []\n    for i in range(3):\n        ang = 2 * np.pi * i / 3\n        pts7.append([0.5 + 0.12 * np.cos(ang), 0.5 + 0.12 * np.sin(ang)])\n    for i in range(9):\n        ang = 2 * np.pi * i / 9\n        pts7.append([0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)])\n    for i in range(14):\n        ang = 2 * np.pi * i / 14\n        pts7.append([0.5 + 0.46 * np.cos(ang), 0.5 + 0.46 * np.sin(ang)])\n    pts7 = np.array(pts7)\n    for i in range(step):\n        C[idx+i] = pts7 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 8: Beta distribution (pushes to corners and edges)\n    C[idx:idx+step] = np.random.beta(0.4, 0.4, size=(step, N, 2))\n    idx += step\n    \n    # Boundary constraint for initial values and zero-distance overlap prevention\n    C = np.clip(C, 0.02, 0.98)\n    C += np.random.normal(0, 1e-5, size=C.shape)\n    \n    # 2. Size placement bias: Push slightly larger expected radii towards center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.04 + 0.05 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.02, 0.12)\n    \n    # Adam optimizer state\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.99\n    eps = 1e-8\n    \n    eye = np.eye(N)[np.newaxis, :, :]\n    mask = 1.0 - eye\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        phase_ratio = t / iters\n        \n        # Adaptive simulated annealing schedule\n        if phase_ratio <= 0.8:\n            prog = phase_ratio / 0.8\n            lr = 0.015 * (1.0 - 0.5 * prog)\n            lambda_val = 10.0 * (10000.0 ** prog)\n        else:\n            # Cool down phase for infinitesimal settling\n            prog = (phase_ratio - 0.8) / 0.2\n            lr = 0.0075 * (1.0 - 0.8 * prog)\n            lambda_val = 100000.0 * (10.0 ** prog)\n            \n        # Calculate wall overlap violations\n        viol_x0 = np.maximum(0.0, R - C[:, :, 0])\n        viol_x1 = np.maximum(0.0, R + C[:, :, 0] - 1.0)\n        viol_y0 = np.maximum(0.0, R - C[:, :, 1])\n        viol_y1 = np.maximum(0.0, R + C[:, :, 1] - 1.0)\n        \n        # Calculate pairwise overlap violations safely (avoiding sqrt(0) NaNs)\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        viol_pair = np.maximum(0.0, R_sum - dist) * mask\n        \n        # Compute exact analytical gradients\n        grad_R = -1.0 + 2.0 * lambda_val * (\n            viol_x0 + viol_x1 + viol_y0 + viol_y1 + np.sum(viol_pair, axis=2)\n        )\n        \n        grad_C_x = 2.0 * lambda_val * (-viol_x0 + viol_x1)\n        grad_C_y = 2.0 * lambda_val * (-viol_y0 + viol_y1)\n        grad_C_bound = np.stack([grad_C_x, grad_C_y], axis=-1)\n        \n        direction = diff / dist[..., np.newaxis]\n        grad_C_pair = 2.0 * lambda_val * np.sum(viol_pair[..., np.newaxis] * (-direction), axis=2)\n        grad_C = grad_C_bound + grad_C_pair\n        \n        # Apply Adam update for Centers\n        m_C = beta1 * m_C + (1.0 - beta1) * grad_C\n        v_C = beta2 * v_C + (1.0 - beta2) * (grad_C**2)\n        m_C_hat = m_C / (1.0 - beta1**t)\n        v_C_hat = v_C / (1.0 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam update for Radii\n        m_R = beta1 * m_R + (1.0 - beta1) * grad_R\n        v_R = beta2 * v_R + (1.0 - beta2) * (grad_R**2)\n        m_R_hat = m_R / (1.0 - beta1**t)\n        v_R_hat = v_R / (1.0 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if phase_ratio < 0.5 and t % 250 == 0:\n            C += np.random.randn(*C.shape) * 0.002\n            R += np.random.randn(*R.shape) * 0.001\n            \n        # Constrain variables logically\n        C = np.clip(C, 0.0, 1.0)\n        R = np.maximum(R, 0.0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Initial bounds safety check explicitly incorporating a fp precision safety margin\n        Rb = np.clip(Rb, 0.0, None)\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-13)\n        Rb = np.maximum(Rb, 0.0)\n        \n        # Iterate strict greedy shrink pass to resolve infinitesimal remaining overlaps perfectly\n        for _ in range(4):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if dist_ij > 1e-13:\n                            scale = (dist_ij - 1e-13) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0.0\n                            Rb[j] = 0.0\n                            \n        # Final bounds safety check\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-13)\n        Rb = np.maximum(Rb, 0.0)\n        \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3333, Type: Exploratory)\n```python\n\"\"\"\nIterative optimization-based circle packing for n=26 circles.\nUses Adam optimizer with a custom physics-based objective to maximize \nthe sum of radii while strictly penalizing overlapping and boundary violations.\nRuns multiple restarts from diverse strategic initializations to escape local minima.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    B = 600  # Batch size for parallel topology exploration\n    N = 26\n    iters = 4000\n    \n    np.random.seed(42)\n    \n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically:\n    idx = 0\n    step = B // 6\n    \n    # Strategy A: Uniform random\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    idx += step\n    \n    # Strategy B: Centered normal (clusters in middle, leaves edges for expansion)\n    C[idx:idx+step] = np.random.normal(0.5, 0.15, size=(step, N, 2))\n    idx += step\n    \n    # Strategy C: Concentric rings pattern A (1 + 8 + 17)\n    ring_a = np.zeros((N, 2))\n    ring_a[0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        ring_a[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        ring_a[i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n    C[idx:idx+step] = ring_a + np.random.normal(0, 0.015, size=(step, N, 2))\n    idx += step\n    \n    # Strategy D: Concentric rings pattern B (3 + 9 + 14)\n    ring_b = np.zeros((N, 2))\n    for i in range(3):\n        angle = 2 * np.pi * i / 3\n        ring_b[i] = [0.5 + 0.12 * np.cos(angle), 0.5 + 0.12 * np.sin(angle)]\n    for i in range(9):\n        angle = 2 * np.pi * i / 9\n        ring_b[i + 3] = [0.5 + 0.30 * np.cos(angle), 0.5 + 0.30 * np.sin(angle)]\n    for i in range(14):\n        angle = 2 * np.pi * i / 14\n        ring_b[i + 12] = [0.5 + 0.46 * np.cos(angle), 0.5 + 0.46 * np.sin(angle)]\n    C[idx:idx+step] = ring_b + np.random.normal(0, 0.015, size=(step, N, 2))\n    idx += step\n    \n    # Strategy E: Hexagonal-like grid plus center\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n    grid = np.vstack([grid, [0.2, 0.2]])  # 26th point at interstitial space\n    C[idx:idx+step] = grid + np.random.normal(0, 0.01, size=(step, N, 2))\n    idx += step\n    \n    # Strategy F: Uniform with 4 corners explicitly anchored\n    rem = B - idx\n    C[idx:] = np.random.uniform(0.1, 0.9, size=(rem, N, 2))\n    C[idx:, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    \n    # Boundary enforcement for initialization\n    C = np.clip(C, 0.01, 0.99)\n    \n    # 2. Size placement bias: Push larger circles toward center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.03 + 0.05 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.02, 0.1)\n    \n    # Adam optimizer state\n    m_C = np.zeros_like(C)\n    v_C = np.zeros_like(C)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.99\n    eps = 1e-8\n    \n    mask = 1.0 - np.eye(N)[np.newaxis, :, :]\n    \n    # Optimization Loop\n    for t in range(1, iters + 1):\n        # 3. Tune optimization parameters: Simulated Annealing penalty phase\n        if t <= 3000:\n            lr = 0.01 * (1.0 - t / 4000.0) + 0.002\n            lambda_val = 5.0 * (10000.0 ** (t / 3000.0))\n        else:\n            lr = 0.001\n            lambda_val = 50000.0\n            \n        # Calculate wall overlap violations\n        viol_x0 = np.maximum(0, R - C[:, :, 0])\n        viol_x1 = np.maximum(0, R + C[:, :, 0] - 1.0)\n        viol_y0 = np.maximum(0, R - C[:, :, 1])\n        viol_y1 = np.maximum(0, R + C[:, :, 1] - 1.0)\n        \n        # Calculate pairwise overlap violations safely\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        viol_pair = np.maximum(0, R_sum - dist) * mask\n        \n        # Compute exact analytical gradients for squared penalties\n        grad_R = -1.0 + 2.0 * lambda_val * (\n            viol_x0 + viol_x1 + viol_y0 + viol_y1 + np.sum(viol_pair, axis=2)\n        )\n        \n        grad_C_x = 2.0 * lambda_val * (-viol_x0 + viol_x1)\n        grad_C_y = 2.0 * lambda_val * (-viol_y0 + viol_y1)\n        grad_C_bound = np.stack([grad_C_x, grad_C_y], axis=-1)\n        \n        direction = diff / dist[..., np.newaxis]\n        grad_C_pair = 2.0 * lambda_val * np.sum(viol_pair[..., np.newaxis] * (-direction), axis=2)\n        grad_C = grad_C_bound + grad_C_pair\n        \n        # Apply Adam update for Centers\n        m_C = beta1 * m_C + (1.0 - beta1) * grad_C\n        v_C = beta2 * v_C + (1.0 - beta2) * (grad_C**2)\n        m_C_hat = m_C / (1.0 - beta1**t)\n        v_C_hat = v_C / (1.0 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam update for Radii\n        m_R = beta1 * m_R + (1.0 - beta1) * grad_R\n        v_R = beta2 * v_R + (1.0 - beta2) * (grad_R**2)\n        m_R_hat = m_R / (1.0 - beta1**t)\n        v_R_hat = v_R / (1.0 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if t % 300 == 0 and t < 2500:\n            C += np.random.randn(*C.shape) * 0.002\n            R += np.random.randn(*R.shape) * 0.001\n            \n        # Constrain variables logically\n        C = np.clip(C, 0.0, 1.0)\n        R = np.maximum(R, 0.0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Limit to boundaries explicitly (incorporating fp safety margin)\n        Rb = np.clip(Rb, 0.0, None)\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-12)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-12)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-12)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-12)\n        Rb = np.maximum(Rb, 0.0)\n        \n        # Iterate strict greedy shrink pass to resolve infinitesimal remaining overlaps\n        for _ in range(10):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    sum_radii_ij = Rb[i] + Rb[j]\n                    if sum_radii_ij > dist_ij:\n                        if dist_ij > 1e-12:\n                            scale = (dist_ij - 1e-12) / sum_radii_ij\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0.0\n                            Rb[j] = 0.0\n                            \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.8036, Type: High-Performer)\n```python\n\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses Adam optimizer with exact analytical gradients to strictly solve \na simulated annealing physics model. \nFeatures diverse topology initialization and symmetric constraints.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    B = 300\n    N = 26\n    iters = 3000\n    \n    np.random.seed(42)\n    C = np.random.uniform(0.1, 0.9, (B, N, 2))\n    \n    # 1. Diverse Initializations\n    # Gaussian centered\n    C[:B//4] = np.random.normal(0.5, 0.15, (B//4, N, 2))\n    \n    # Uniform with anchored corners\n    C[B//4:B//2, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    \n    # Grid initialization\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])[:N]\n    C[B//2:3*B//4] = grid + np.random.normal(0, 0.01, (B//4, N, 2))\n    \n    # Concentric rings\n    rings = [[0.5, 0.5]]\n    for i in range(8):\n        rings.append([0.5 + 0.25 * np.cos(2 * np.pi * i / 8), 0.5 + 0.25 * np.sin(2 * np.pi * i / 8)])\n    for i in range(17):\n        rings.append([0.5 + 0.45 * np.cos(2 * np.pi * i / 17), 0.5 + 0.45 * np.sin(2 * np.pi * i / 17)])\n    C[3*B//4:] = np.array(rings) + np.random.normal(0, 0.01, (B - 3*B//4, N, 2))\n    \n    C = np.clip(C, 0.05, 0.95)\n    \n    # 2. Size placement bias (push larger circles to the center)\n    R = 0.03 + 0.04 * (0.707 - np.linalg.norm(C - 0.5, axis=2))\n    R = np.clip(R, 0.01, 0.15)\n    \n    # Optimizer states\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n    \n    mask = np.eye(N)[np.newaxis, :, :]\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        prog = t / iters\n        \n        # Adaptive simulated annealing schedule\n        if prog <= 0.8:\n            lr = 0.01 * (1.0 - 0.5 * prog / 0.8)\n            lam = 10.0 * (10000.0 ** (prog / 0.8))\n        else:\n            lr = 0.001\n            lam = 100000.0\n            \n        # Calculate wall overlap violations\n        v_x0, v_x1 = np.maximum(0, R - C[..., 0]), np.maximum(0, R + C[..., 0] - 1)\n        v_y0, v_y1 = np.maximum(0, R - C[..., 1]), np.maximum(0, R + C[..., 1] - 1)\n        \n        # Calculate pairwise overlap violations safely\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1) + mask + 1e-12)\n        v_pair = np.maximum(0, R[:, :, np.newaxis] + R[:, np.newaxis, :] - dist) * (1 - mask)\n        \n        # Compute exact analytical gradients\n        g_R = -1.0 + 2 * lam * (v_x0 + v_x1 + v_y0 + v_y1 + np.sum(v_pair, axis=2))\n        g_C_bound = np.stack([2 * lam * (-v_x0 + v_x1), 2 * lam * (-v_y0 + v_y1)], axis=-1)\n        g_C_pair = 2 * lam * np.sum(v_pair[..., np.newaxis] * (-diff / dist[..., np.newaxis]), axis=2)\n        g_C = g_C_bound + g_C_pair\n        \n        # Apply Adam updates\n        m_C = 0.9 * m_C + 0.1 * g_C\n        v_C = 0.999 * v_C + 0.001 * (g_C**2)\n        m_C_hat = m_C / (1 - 0.9**t)\n        v_C_hat = v_C / (1 - 0.999**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + 1e-8)\n        \n        m_R = 0.9 * m_R + 0.1 * g_R\n        v_R = 0.999 * v_R + 0.001 * (g_R**2)\n        m_R_hat = m_R / (1 - 0.9**t)\n        v_R_hat = v_R / (1 - 0.999**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + 1e-8)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if t % 250 == 0 and prog < 0.6:\n            C += np.random.randn(*C.shape) * 0.002\n            \n        # Constrain variables logically\n        C = np.clip(C, 0, 1)\n        R = np.maximum(R, 0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Secure boundaries explicitly (incorporating precision safety margin)\n        safe_walls = np.min([Cb[:, 0], 1.0 - Cb[:, 0], Cb[:, 1], 1.0 - Cb[:, 1]], axis=0)\n        Rb = np.clip(Rb, 0.0, safe_walls - 1e-13)\n        \n        # Strict greedy shrink pass to resolve infinitesimal remaining overlaps\n        for _ in range(5):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if Rb[i] + Rb[j] > 0:\n                            scale = max(0.0, dist_ij - 1e-13) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                            \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.8365, Type: High-Performer)\n```python\n\"\"\"\nIterative optimization-based circle packing for n=26 circles.\nUses Adam optimizer with a custom physics-based objective to maximize \nthe sum of radii while strictly penalizing overlapping and boundary violations.\nRuns multiple restarts from diverse strategic initializations to escape local minima.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    B = 250  # Batch size for parallel topology exploration\n    N = 26\n    iters = 3500\n    \n    np.random.seed(42)\n    \n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically:\n    idx = 0\n    step = B // 6\n    \n    # Strategy A: Uniform random\n    C[idx:idx+step] = np.random.rand(step, N, 2)\n    idx += step\n    \n    # Strategy B: Centered normal (clusters in middle, leaves edges for expansion)\n    C[idx:idx+step] = np.random.normal(0.5, 0.15, size=(step, N, 2))\n    idx += step\n    \n    # Strategy C: Beta distribution (pushes to corners and edges)\n    C[idx:idx+step] = np.random.beta(0.4, 0.4, size=(step, N, 2))\n    idx += step\n    \n    # Strategy D: Concentric rings pattern\n    ring_centers = np.zeros((N, 2))\n    ring_centers[0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        ring_centers[i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        ring_centers[i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n    C[idx:idx+step] = ring_centers + np.random.normal(0, 0.01, size=(step, N, 2))\n    idx += step\n    \n    # Strategy E: Grid-like patterns\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 6))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])[:N]\n    C[idx:idx+step] = grid + np.random.normal(0, 0.01, size=(step, N, 2))\n    idx += step\n    \n    # Strategy F: Uniform with corners explicitly anchored\n    rem = B - idx\n    if rem > 0:\n        C[idx:] = np.random.uniform(0.1, 0.9, size=(rem, N, 2))\n        C[idx:, :4] = [[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]]\n    \n    # Boundary enforcement for initialization\n    C = np.clip(C, 0.05, 0.95)\n    \n    # 2. Size placement bias: Push larger circles toward center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.03 + 0.04 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.01, 0.15)\n    \n    # Adam optimizer state\n    m_C = np.zeros_like(C)\n    v_C = np.zeros_like(C)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    mask = np.eye(N)[np.newaxis, :, :]\n    \n    # Optimization Loop\n    for t in range(1, iters + 1):\n        # 3. Tune optimization parameters: Simulated Annealing penalty phase\n        phase_ratio = min(1.0, t / (iters * 0.8))\n        if t <= iters * 0.8:\n            lr = 0.01 * (1.0 - 0.5 * phase_ratio)\n            lambda_val = 10.0 * (10000.0 ** phase_ratio)\n        else:\n            lr = 0.001\n            lambda_val = 100000.0\n            \n        # Calculate wall overlap violations\n        viol_x0 = np.maximum(0, R - C[:, :, 0])\n        viol_x1 = np.maximum(0, R + C[:, :, 0] - 1)\n        viol_y0 = np.maximum(0, R - C[:, :, 1])\n        viol_y1 = np.maximum(0, R + C[:, :, 1] - 1)\n        \n        # Calculate pairwise overlap violations safely\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + mask + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        viol_pair = np.maximum(0, R_sum - dist) * (1 - mask)\n        \n        # Compute exact analytical gradients\n        grad_R = -1.0 + 2 * lambda_val * (viol_x0 + viol_x1 + viol_y0 + viol_y1 + np.sum(viol_pair, axis=2))\n        \n        grad_C_x = 2 * lambda_val * (-viol_x0 + viol_x1)\n        grad_C_y = 2 * lambda_val * (-viol_y0 + viol_y1)\n        grad_C_bound = np.stack([grad_C_x, grad_C_y], axis=-1)\n        \n        dir = diff / dist[..., np.newaxis]\n        grad_C_pair = 2 * lambda_val * np.sum(viol_pair[..., np.newaxis] * (-dir), axis=2)\n        grad_C = grad_C_bound + grad_C_pair\n        \n        # Apply Adam update for Centers\n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * (grad_C**2)\n        m_C_hat = m_C / (1 - beta1**t)\n        v_C_hat = v_C / (1 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam update for Radii\n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * (grad_R**2)\n        m_R_hat = m_R / (1 - beta1**t)\n        v_R_hat = v_R / (1 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if t % 250 == 0 and t < iters * 0.6:\n            C += np.random.randn(*C.shape) * 0.002\n            \n        # Constrain variables logically\n        C = np.clip(C, 0, 1)\n        R = np.maximum(R, 0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Limit to boundaries explicitly (incorporating fp safety margin)\n        Rb = np.clip(Rb, 0, None)\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-12)\n        Rb = np.minimum(Rb, 1 - Cb[:, 0] - 1e-12)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-12)\n        Rb = np.minimum(Rb, 1 - Cb[:, 1] - 1e-12)\n        Rb = np.maximum(Rb, 0)\n        \n        # Iterate strict greedy shrink pass to resolve infinitesimal remaining overlaps\n        for _ in range(5):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if dist_ij > 0:\n                            scale = (dist_ij - 1e-12) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0\n                            Rb[j] = 0\n                            \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses a highly vectorized Adam optimizer with a custom physics-based objective to maximize \nthe sum of radii while strictly penalizing overlapping and boundary violations.\nRuns multiple restarts from diverse strategic initial topologies to escape local minima,\nimplementing a smooth simulated annealing schedule and early symmetry-breaking perturbations.\n\"\"\"\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Batch size selected to confidently complete within standard hardware timeout limits\n    B = 160  \n    N = 26\n    iters = 3000\n    \n    np.random.seed(42)\n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically:\n    idx = 0\n    step = B // 8\n    \n    # Strategy 1: Uniform random\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 2: Uniform with 4 corners explicitly anchored\n    C[idx:idx+step] = np.random.uniform(0.1, 0.9, size=(step, N, 2))\n    C[idx:idx+step, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    idx += step\n    \n    # Strategy 3: Centered normal (clusters in middle, expands outward)\n    C[idx:idx+step] = np.random.normal(0.5, 0.15, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 4: 5x5 Grid + 1 interstitial gap circle\n    grid_pts = []\n    for r in range(5):\n        for c in range(5):\n            grid_pts.append([0.1 + 0.2 * c, 0.1 + 0.2 * r])\n    for i in range(step):\n        C[idx+i, :25] = grid_pts\n        C[idx+i, 25] = [np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)]\n    C[idx-step:idx] += np.random.normal(0, 0.005, size=(step, N, 2))\n    idx += step\n    \n    # Strategy 5: Hexagonal-like staggered grid perfectly fitting 26\n    pts5 = []\n    for r in range(6):\n        cols = 5 if r % 2 == 0 else 4\n        if r == 5: cols = 3\n        for c in range(cols):\n            x = (c + (0.5 if r % 2 == 1 else 0.0)) / 4.0 * 0.8 + 0.1\n            y = r / 5.0 * 0.8 + 0.1\n            pts5.append([x, y])\n    pts5 = np.array(pts5[:N])\n    for i in range(step):\n        C[idx+i] = pts5 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 6: Concentric rings pattern (1 + 8 + 17)\n    pts6 = [[0.5, 0.5]]\n    for i in range(8):\n        ang = 2 * np.pi * i / 8\n        pts6.append([0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)])\n    for i in range(17):\n        ang = 2 * np.pi * i / 17\n        pts6.append([0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)])\n    pts6 = np.array(pts6)\n    for i in range(step):\n        C[idx+i] = pts6 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 7: Concentric rings pattern (3 + 9 + 14)\n    pts7 = []\n    for i in range(3):\n        ang = 2 * np.pi * i / 3\n        pts7.append([0.5 + 0.12 * np.cos(ang), 0.5 + 0.12 * np.sin(ang)])\n    for i in range(9):\n        ang = 2 * np.pi * i / 9\n        pts7.append([0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)])\n    for i in range(14):\n        ang = 2 * np.pi * i / 14\n        pts7.append([0.5 + 0.46 * np.cos(ang), 0.5 + 0.46 * np.sin(ang)])\n    pts7 = np.array(pts7)\n    for i in range(step):\n        C[idx+i] = pts7 + np.random.normal(0, 0.01, size=(N, 2))\n    idx += step\n    \n    # Strategy 8: Beta distribution (pushes to corners and edges)\n    C[idx:idx+step] = np.random.beta(0.4, 0.4, size=(step, N, 2))\n    idx += step\n    \n    # Boundary constraint for initial values and zero-distance overlap prevention\n    C = np.clip(C, 0.02, 0.98)\n    C += np.random.normal(0, 1e-5, size=C.shape)\n    \n    # 2. Size placement bias: Push slightly larger expected radii towards center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.04 + 0.05 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.02, 0.12)\n    \n    # Adam optimizer state\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.99\n    eps = 1e-8\n    \n    eye = np.eye(N)[np.newaxis, :, :]\n    mask = 1.0 - eye\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        phase_ratio = t / iters\n        \n        # Adaptive simulated annealing schedule\n        if phase_ratio <= 0.8:\n            prog = phase_ratio / 0.8\n            lr = 0.015 * (1.0 - 0.5 * prog)\n            lambda_val = 10.0 * (10000.0 ** prog)\n        else:\n            # Cool down phase for infinitesimal settling\n            prog = (phase_ratio - 0.8) / 0.2\n            lr = 0.0075 * (1.0 - 0.8 * prog)\n            lambda_val = 100000.0 * (10.0 ** prog)\n            \n        # Calculate wall overlap violations\n        viol_x0 = np.maximum(0.0, R - C[:, :, 0])\n        viol_x1 = np.maximum(0.0, R + C[:, :, 0] - 1.0)\n        viol_y0 = np.maximum(0.0, R - C[:, :, 1])\n        viol_y1 = np.maximum(0.0, R + C[:, :, 1] - 1.0)\n        \n        # Calculate pairwise overlap violations safely (avoiding sqrt(0) NaNs)\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        viol_pair = np.maximum(0.0, R_sum - dist) * mask\n        \n        # Compute exact analytical gradients\n        grad_R = -1.0 + 2.0 * lambda_val * (\n            viol_x0 + viol_x1 + viol_y0 + viol_y1 + np.sum(viol_pair, axis=2)\n        )\n        \n        grad_C_x = 2.0 * lambda_val * (-viol_x0 + viol_x1)\n        grad_C_y = 2.0 * lambda_val * (-viol_y0 + viol_y1)\n        grad_C_bound = np.stack([grad_C_x, grad_C_y], axis=-1)\n        \n        direction = diff / dist[..., np.newaxis]\n        grad_C_pair = 2.0 * lambda_val * np.sum(viol_pair[..., np.newaxis] * (-direction), axis=2)\n        grad_C = grad_C_bound + grad_C_pair\n        \n        # Apply Adam update for Centers\n        m_C = beta1 * m_C + (1.0 - beta1) * grad_C\n        v_C = beta2 * v_C + (1.0 - beta2) * (grad_C**2)\n        m_C_hat = m_C / (1.0 - beta1**t)\n        v_C_hat = v_C / (1.0 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam update for Radii\n        m_R = beta1 * m_R + (1.0 - beta1) * grad_R\n        v_R = beta2 * v_R + (1.0 - beta2) * (grad_R**2)\n        m_R_hat = m_R / (1.0 - beta1**t)\n        v_R_hat = v_R / (1.0 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Introduce small perturbations early on\n        if phase_ratio < 0.5 and t % 250 == 0:\n            C += np.random.randn(*C.shape) * 0.002\n            R += np.random.randn(*R.shape) * 0.001\n            \n        # Constrain variables logically\n        C = np.clip(C, 0.0, 1.0)\n        R = np.maximum(R, 0.0)\n        \n    # Post Processing Phase: Guarantee mathematically perfect validity\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Initial bounds safety check explicitly incorporating a fp precision safety margin\n        Rb = np.clip(Rb, 0.0, None)\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-13)\n        Rb = np.maximum(Rb, 0.0)\n        \n        # Iterate strict greedy shrink pass to resolve infinitesimal remaining overlaps perfectly\n        for _ in range(4):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    if Rb[i] + Rb[j] > dist_ij:\n                        if dist_ij > 1e-13:\n                            scale = (dist_ij - 1e-13) / (Rb[i] + Rb[j])\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0.0\n                            Rb[j] = 0.0\n                            \n        # Final bounds safety check\n        Rb = np.minimum(Rb, Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 0] - 1e-13)\n        Rb = np.minimum(Rb, Cb[:, 1] - 1e-13)\n        Rb = np.minimum(Rb, 1.0 - Cb[:, 1] - 1e-13)\n        Rb = np.maximum(Rb, 0.0)\n        \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"\nIterative optimization-based circle packing for N=26 circles.\nUses a highly vectorized Adam optimizer with exact analytical gradients \nto strictly solve a simulated annealing physics model. \nFeatures diverse topology initializations, targeted perturbations, \nand mathematically rigorous post-processing to escape local minima \nand guarantee absolute validity.\n\"\"\"\nimport numpy as np\n\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # High batch size and iterations for deep convergence\n    B = 240\n    N = 26\n    iters = 3800\n    \n    np.random.seed(42)\n    C = np.zeros((B, N, 2))\n    \n    # 1. Seed initial positions strategically to explore diverse topologies\n    step = B // 6\n    \n    # Strategy 1: Uniform random\n    C[0:step] = np.random.uniform(0.1, 0.9, (step, N, 2))\n    \n    # Strategy 2: Centered normal (clusters in middle, leaves edges for expansion)\n    C[step:2*step] = np.random.normal(0.5, 0.15, (step, N, 2))\n    \n    # Strategy 3: Beta distribution (pushes to corners and edges)\n    C[2*step:3*step] = np.random.beta(0.4, 0.4, (step, N, 2))\n    \n    # Strategy 4: Concentric rings pattern A (1 + 8 + 17)\n    rings_A = [[0.5, 0.5]]\n    for i in range(8):\n        ang = 2 * np.pi * i / 8\n        rings_A.append([0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)])\n    for i in range(17):\n        ang = 2 * np.pi * i / 17\n        rings_A.append([0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)])\n    C[3*step:4*step] = np.array(rings_A) + np.random.normal(0, 0.01, (step, N, 2))\n    \n    # Strategy 5: Concentric rings pattern B (3 + 9 + 14) - Apollonian tendency\n    rings_B = []\n    for i in range(3):\n        ang = 2 * np.pi * i / 3\n        rings_B.append([0.5 + 0.1 * np.cos(ang), 0.5 + 0.1 * np.sin(ang)])\n    for i in range(9):\n        ang = 2 * np.pi * i / 9\n        rings_B.append([0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)])\n    for i in range(14):\n        ang = 2 * np.pi * i / 14\n        rings_B.append([0.5 + 0.46 * np.cos(ang), 0.5 + 0.46 * np.sin(ang)])\n    C[4*step:5*step] = np.array(rings_B) + np.random.normal(0, 0.01, (step, N, 2))\n    \n    # Strategy 6: Grid 5x5 + 1 interstitial center\n    grid_x, grid_y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid = np.column_stack([grid_x.ravel(), grid_y.ravel()])\n    grid = np.vstack([grid, [0.2, 0.2]])  # 26th point off-center\n    C[5*step:6*step] = grid + np.random.normal(0, 0.01, (step, N, 2))\n    \n    # Anchor the corners explicitly for a fraction of the uniform batches\n    C[0:step//2, :4] = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    \n    # Apply global boundary enforcement for initialization\n    C = np.clip(C, 0.05, 0.95)\n    \n    # 2. Size placement bias: Push naturally larger expected radii towards the center\n    dist_to_center = np.linalg.norm(C - 0.5, axis=2)\n    R = 0.03 + 0.04 * (0.707 - dist_to_center)\n    R = np.clip(R, 0.01, 0.15)\n    \n    # Adam optimizer states\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    \n    # Precompute mask components for optimal vectorized distance calculations\n    eye = np.eye(N)[np.newaxis, :, :]\n    mask = 1.0 - eye\n    \n    # 3. Optimization Loop\n    for t in range(1, iters + 1):\n        # Simulated annealing phase schedule for penalty parameters\n        phase_ratio = min(1.0, t / (iters * 0.8))\n        if t <= iters * 0.8:\n            lr = 0.012 * (1.0 - 0.6 * phase_ratio)\n            lam = 10.0 * (20000.0 ** phase_ratio)\n        else:\n            # Cool down phase: Lock in exact minima strictly\n            lr = 0.001\n            lam = 200000.0\n            \n        # Compute wall overlap violations\n        v_x0 = np.maximum(0.0, R - C[:, :, 0])\n        v_x1 = np.maximum(0.0, R + C[:, :, 0] - 1.0)\n        v_y0 = np.maximum(0.0, R - C[:, :, 1])\n        v_y1 = np.maximum(0.0, R + C[:, :, 1] - 1.0)\n        \n        # Compute pairwise overlap violations precisely without triggering NaNs on self-distance\n        diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye + 1e-12)\n        \n        R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n        v_pair = np.maximum(0.0, R_sum - dist) * mask\n        \n        # Exact analytical gradients for the physics penalty objective function\n        g_R = -1.0 + 2.0 * lam * (v_x0 + v_x1 + v_y0 + v_y1 + np.sum(v_pair, axis=2))\n        \n        g_C_x = 2.0 * lam * (-v_x0 + v_x1)\n        g_C_y = 2.0 * lam * (-v_y0 + v_y1)\n        g_C_bound = np.stack([g_C_x, g_C_y], axis=-1)\n        \n        direction = diff / dist[..., np.newaxis]\n        g_C_pair = 2.0 * lam * np.sum(v_pair[..., np.newaxis] * (-direction), axis=2)\n        g_C = g_C_bound + g_C_pair\n        \n        # Apply Adam updates for Centers\n        m_C = beta1 * m_C + (1.0 - beta1) * g_C\n        v_C = beta2 * v_C + (1.0 - beta2) * (g_C**2)\n        m_C_hat = m_C / (1.0 - beta1**t)\n        v_C_hat = v_C / (1.0 - beta2**t)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n        \n        # Apply Adam updates for Radii\n        m_R = beta1 * m_R + (1.0 - beta1) * g_R\n        v_R = beta2 * v_R + (1.0 - beta2) * (g_R**2)\n        m_R_hat = m_R / (1.0 - beta1**t)\n        v_R_hat = v_R / (1.0 - beta2**t)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n        \n        # 4. Break perfect symmetry: Jolt circles periodically out of local minima\n        if t % 250 == 0 and t < iters * 0.6:\n            C += np.random.randn(*C.shape) * 0.002\n            R += np.random.randn(*R.shape) * 0.001\n            \n        # Physical constraints to stabilize early erratic optimization states\n        C = np.clip(C, 0.0, 1.0)\n        R = np.clip(R, 0.0, 0.5)\n        \n    # 5. Post Processing Phase: Ensure mathematically impeccable valid constraints\n    best_sum_R = -1.0\n    best_C = None\n    best_R = None\n    \n    for b in range(B):\n        Cb = C[b].copy()\n        Rb = R[b].copy()\n        \n        # Establish structural boundaries explicitly with safety precision margin\n        safe_walls = np.min([Cb[:, 0], 1.0 - Cb[:, 0], Cb[:, 1], 1.0 - Cb[:, 1]], axis=0)\n        Rb = np.clip(Rb, 0.0, safe_walls - 1e-13)\n        \n        # Relax geometries iteratively via local greedy shrinking to resolve remaining overlaps\n        for _ in range(10):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist_ij = np.linalg.norm(Cb[i] - Cb[j])\n                    sum_R_ij = Rb[i] + Rb[j]\n                    if sum_R_ij > dist_ij:\n                        if dist_ij > 1e-13:\n                            scale = (dist_ij - 1e-13) / sum_R_ij\n                            Rb[i] *= scale\n                            Rb[j] *= scale\n                        else:\n                            Rb[i] = 0.0\n                            Rb[j] = 0.0\n                            \n        # Final pass boundary safety clip\n        safe_walls_final = np.min([Cb[:, 0], 1.0 - Cb[:, 0], Cb[:, 1], 1.0 - Cb[:, 1]], axis=0)\n        Rb = np.clip(Rb, 0.0, safe_walls_final - 1e-13)\n        \n        sum_R = np.sum(Rb)\n        if sum_R > best_sum_R:\n            best_sum_R = sum_R\n            best_C = Cb\n            best_R = Rb\n            \n    return best_C, best_R, best_sum_R\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Optimal Sum of Radii achieved: {sum_radii:.6f}\")\n```"]}}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 60, \"failure_stage\": \"stage2\", \"error_type\": \"timeout\", \"execution_time\": \"55.80s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum: 2.082791, Ratio: 0.7904\", \"stage2_timeout\": true}", "artifact_dir": null, "embedding": null}