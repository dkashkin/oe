{"id": "ce02e561-b834-4351-b924-5bfcfc24fc52", "code": "import time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(4 * N)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    row_idx = num_bounds + np.arange(num_overlaps)\n    \n    jac[row_idx, 3*idx_i] = 2 * dx\n    jac[row_idx, 3*idx_j] = -2 * dx\n    jac[row_idx, 3*idx_i+1] = 2 * dy\n    jac[row_idx, 3*idx_j+1] = -2 * dy\n    jac[row_idx, 3*idx_i+2] = -2 * sr\n    jac[row_idx, 3*idx_j+2] = -2 * sr\n    \n    return jac\n\ndef get_initial_guess(seed, N):\n    np.random.seed(seed)\n    mode = seed % 3\n    \n    centers = []\n    if mode == 0:\n        centers.extend([[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]])\n        centers.extend([[0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5]])\n        for _ in range(N - 8):\n            centers.append(np.random.uniform(0.1, 0.9, 2))\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.02, (N, 2))\n    elif mode == 1:\n        grid_n = int(np.ceil(np.sqrt(N)))\n        for i in range(grid_n):\n            for j in range(grid_n):\n                if len(centers) < N:\n                    cx = (i + 0.5) / grid_n\n                    cy = (j + 0.5) / grid_n\n                    centers.append([cx, cy])\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.015, (N, 2))\n    else:\n        centers = np.random.uniform(0.05, 0.95, (N, 2))\n        \n    centers = np.clip(centers, 0.05, 0.95)\n    \n    dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n    radii = 0.02 + 0.03 * (1.0 - dist_to_center / (np.max(dist_to_center) + 1e-9))\n    \n    v0 = np.zeros(3 * N)\n    v0[0::3] = centers[:, 0]\n    v0[1::3] = centers[:, 1]\n    v0[2::3] = radii\n    \n    return v0\n\ndef solve():\n    N = 26\n    best_v = None\n    best_obj = float('inf')\n    \n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {\n        'type': 'ineq',\n        'fun': constraints_fun,\n        'jac': constraints_jac\n    }\n    \n    start_time = time.time()\n    \n    for attempt in range(25):\n        if time.time() - start_time > 500:\n            break\n            \n        v0 = get_initial_guess(attempt * 42 + 17, N)\n        \n        res = minimize(\n            objective, \n            v0, \n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        if res.success and res.fun < best_obj:\n            c_vals = constraints_fun(res.x)\n            if np.all(c_vals >= -1e-4):\n                best_obj = res.fun\n                best_v = res.x\n\n    if best_v is None:\n        best_v = get_initial_guess(42, N)\n        \n    v = best_v.copy()\n    centers = v.reshape(-1, 3)[:, :2]\n    radii = v.reshape(-1, 3)[:, 2]\n    \n    for i in range(N):\n        max_r = min(centers[i, 0], centers[i, 1], 1.0 - centers[i, 0], 1.0 - centers[i, 1])\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    for _ in range(20):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist:\n                    scale = (dist - 1e-10) / (radii[i] + radii[j])\n                    scale = max(0.0, min(1.0, scale))\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    \n    radii = np.maximum(radii, 0.0)\n    \n    return centers, radii, float(np.sum(radii))\n\ncenters, radii, sum_radii = solve()", "changes_description": null, "language": "python", "parent_id": "3b5c3214-cffd-4b16-99b9-05d9469c892d", "generation": 3, "timestamp": 1771882295.6624916, "iteration_found": 56, "metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: '[' was never closed (tmprrkm2n2p.py, line 70)\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: '[' was never closed (tmprrkm2n2p.py, line 70)\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(4 * N)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    row_idx = num_bounds + np.arange(num_overlaps)\n    \n    jac[row_idx, 3*idx_i] = 2 * dx\n    jac[row_idx, 3*idx_j] = -2 * dx\n    jac[row_idx, 3*idx_i+1] = 2 * dy\n    jac[row_idx, 3*idx_j+1] = -2 * dy\n    jac[row_idx, 3*idx_i+2] = -2 * sr\n    jac[row_idx, 3*idx_j+2] = -2 * sr\n    \n    return jac\n\ndef physics_layout(seed_val, N):\n    np.random.seed(seed_val)\n    pos = np.random.uniform(0.1, 0.9, (N, 2))\n    v = np.zeros((N, 2))\n    dt = 0.05\n    for _ in range(300):\n        force = np.zeros((N, 2))\n        for i in range(N):\n            for j in range(i + 1, N):\n                diff = pos[i] - pos[j]\n                dist = np.linalg.norm(diff)\n                if dist < 0.15:\n                    f = (0.15 - dist) * (diff / (dist + 1e-9))\n                    force[i] += f\n                    force[j] -= f\n        for i in range(N):\n            for dim in range(2):\n                if pos[i, dim] < 0.05:\n                    force[i, dim] += (0.05 - pos[i, dim]) * 2\n                elif pos[i, dim] > 0.95:\n                    force[i, dim] -= (pos[i, dim] - 0.95) * 2\n        v = 0.8 * v + force * dt\n        pos += v * dt\n        pos = np.clip(pos, 0.02, 0.98)\n    return pos\n\ndef solve():\n    N = 26\n    best_v = None\n    best_obj = float('inf')\n    \n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=80)\n    \n    for attempt in range(80):\n        np.random.seed(int(seeds[attempt]))\n        v0 = np.zeros(3 * N)\n        \n        if attempt < 20:\n            pos = physics_layout(int(seeds[attempt]), N)\n        elif attempt < 40:\n            pos = []\n            grid_n = 7\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(pos) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in pos):\n                        pos.append([px, py])\n                        break\n            while len(pos) < N:\n                pos.append(np.random.uniform(0.1, 0.9, 2))\n            pos = np.array(pos)\n        else:\n            pos = np.random.uniform(0.05, 0.95, (N, 2))\n            \n        radii = np.random.uniform(0.01, 0.04, N)\n        \n        v0[0::3] = pos[:, 0]\n        v0[1::3] = pos[:, 1]\n        v0[2::3] = radii\n        \n        bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n        \n        constraints = {\n            'type': 'ineq',\n            'fun': constraints_fun,\n            'jac': constraints_jac\n        }\n        \n        res = minimize(\n            objective, \n            v0, \n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 600, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        if res.success and res.fun < best_obj:\n            c_vals = constraints_fun(res.x)\n            if np.all(c_vals >= -1e-4):\n                best_obj = res.fun\n                best_v = res.x\n                \n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n            \n    v = best_v.copy()\n    centers = v.reshape(-1, 3)[:, :2]\n    radii = v.reshape(-1, 3)[:, 2]\n    \n    for i in range(N):\n        max_r = min(centers[i, 0], centers[i, 1], 1.0 - centers[i, 0], 1.0 - centers[i, 1])\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    for _ in range(15):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist:\n                    scale = (dist - 1e-10) / (radii[i] + radii[j])\n                    scale = max(0.0, min(1.0, scale))\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    \n    radii = np.maximum(radii, 0.0)\n    \n    return centers, radii, float(np.sum(radii))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 2 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, initial_radii):\n    \"\"\"\n    Ensure all circles are strictly valid within the square and non-overlapping.\n    A single pass guarantees validity since radii are monotonically decreased.\n    \"\"\"\n    n = len(centers)\n    radii = np.copy(initial_radii)\n    \n    # Strictly limit by proximity to the square boundaries\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if max_r < 0: \n            max_r = 0\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    # Strictly limit by overlaps\n    # Processing each pair once is mathematically sufficient because radii only decrease\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                # Add a tiny safe margin to prevent floating point inaccuracies\n                scale = (dist - 1e-10) / (radii[i] + radii[j])\n                if scale < 0: \n                    scale = 0\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n\ndef optimize_packing_restarts(n=26, num_restarts=5, steps=4000):\n    \"\"\"\n    Optimize circle packing using gradient ascent with simulated annealing.\n    Multiple restarts are utilized to escape local maxima.\n    \"\"\"\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n\n    for restart in range(num_restarts):\n        np.random.seed(42 + restart)\n        \n        centers = []\n        # Seed initial positions strategically to maximize space utilization\n        # 4 corners\n        centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n        # 4 edge midpoints\n        centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n        \n        # Random distribution for the remaining circles, biased to fill gaps\n        num_random = n - 8\n        if num_random > 0:\n            rand_centers = np.random.uniform(0.1, 0.9, size=(num_random, 2))\n            centers.extend(rand_centers)\n            \n        centers = np.array(centers)\n        \n        # Break perfect symmetry: introduce slight random perturbations\n        centers += np.random.normal(0, 0.01, size=centers.shape)\n        centers = np.clip(centers, 0.02, 0.98)\n        \n        # Size placement: bias initialization to push larger circles toward the center\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\nN = 26\nNUM_BOUNDS = 4 * N\nNUM_OVERLAPS = N * (N - 1) // 2\nIDX_I, IDX_J = np.triu_indices(N, k=1)\nROW_IDX = NUM_BOUNDS + np.arange(NUM_OVERLAPS)\n\nJAC_TEMPLATE = np.zeros((NUM_BOUNDS + NUM_OVERLAPS, 3 * N))\nfor i in range(N):\n    idx = 4 * i\n    JAC_TEMPLATE[idx, 3*i] = 1.0\n    JAC_TEMPLATE[idx, 3*i+2] = -1.0\n    \n    JAC_TEMPLATE[idx+1, 3*i] = -1.0\n    JAC_TEMPLATE[idx+1, 3*i+2] = -1.0\n    \n    JAC_TEMPLATE[idx+2, 3*i+1] = 1.0\n    JAC_TEMPLATE[idx+2, 3*i+2] = -1.0\n    \n    JAC_TEMPLATE[idx+3, 3*i+1] = -1.0\n    JAC_TEMPLATE[idx+3, 3*i+2] = -1.0\n\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\n\ndef constraints_fun(v):\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(NUM_BOUNDS)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    dx = x[IDX_I] - x[IDX_J]\n    dy = y[IDX_I] - y[IDX_J]\n    sr = r[IDX_I] + r[IDX_J]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\n\ndef constraints_jac(v):\n    jac = JAC_TEMPLATE.copy()\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    dx = x[IDX_I] - x[IDX_J]\n    dy = y[IDX_I] - y[IDX_J]\n    sr = r[IDX_I] + r[IDX_J]\n    \n    jac[ROW_IDX, 3*IDX_I] = 2 * dx\n    jac[ROW_IDX, 3*IDX_J] = -2 * dx\n    jac[ROW_IDX, 3*IDX_I+1] = 2 * dy\n    jac[ROW_IDX, 3*IDX_J+1] = -2 * dy\n    jac[ROW_IDX, 3*IDX_I+2] = -2 * sr\n    jac[ROW_IDX, 3*IDX_J+2] = -2 * sr\n    \n    return jac\n\n\ndef apply_safety_shrink(v):\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3].copy()\n    \n    for i in range(N):\n        max_r = min(x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n        if r[i] > max_r:\n            r[i] = max_r\n            \n    for _ in range(100):\n        moved = False\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                if r[i] + r[j] > dist:\n                    if r[i] + r[j] < 1e-15:\n                        r[i] = 0.0\n                        r[j] = 0.0\n                        moved = True\n                        continue\n                    scale = (dist - 1e-12) / (r[i] + r[j])\n                    if scale < 0:\n                        scale = 0.0\n                    r[i] *= scale\n                    r[j] *= scale\n                    moved = True\n        if not moved:\n            break\n            \n    for i in range(N):\n        r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n        \n    v_new = v.copy()\n    v_new[2::3] = r\n    return v_new\n\n\ndef optimize_radii_for_centers(v):\n    centers = v.reshape(N, 3)[:, :2]\n    c = -np.ones(N)\n    A_ub = []\n    b_ub = []\n    bounds_lp = []\n    \n    for i in range(N):\n        max_r = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])\n        bounds_lp.append((0.0, max(0.0, max_r)))\n        \n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            row[j]\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\nimport math\n\n_cache_N = None\n_idx_i = None\n_idx_j = None\n_row_idx = None\n_num_bounds = None\n_num_overlaps = None\n\ndef get_indices(N):\n    global _cache_N, _idx_i, _idx_j, _row_idx, _num_bounds, _num_overlaps\n    if _cache_N != N:\n        _cache_N = N\n        _idx_i, _idx_j = np.triu_indices(N, k=1)\n        _num_bounds = 4 * N\n        _num_overlaps = len(_idx_i)\n        _row_idx = _num_bounds + np.arange(_num_overlaps)\n    return _idx_i, _idx_j, _row_idx, _num_bounds, _num_overlaps\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    idx_i, idx_j, row_idx, num_bounds, num_overlaps = get_indices(N)\n    \n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(num_bounds)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    idx_i, idx_j, row_idx, num_bounds, num_overlaps = get_indices(N)\n    \n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef run_packing():\n    \"\"\"\n    Finds a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii without any overlapping or extending bounds.\n    Returns: centers (N x 2), radii (N), sum_radii (float)\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute structural indices for overlap conditions\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n    \n    # Precompute objective logic\n    jac_obj_vec = np.zeros(3 * N)\n    jac_obj_vec[2::3] = -1.0\n    \n    def objective(v):\n        return -np.sum(v[2::3])\n        \n    def jac_objective(v):\n        return jac_obj_vec\n        \n    # Precompute constant portions of the Constraints Jacobian\n    jac_base = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        # x_i - r_i >= 0\n        jac_base[idx, 3 * i] = 1.0\n        jac_base[idx, 3 * i + 2] = -1.0\n        \n        # 1.0 - x_i - r_i >= 0\n        jac_base[idx + 1, 3 * i] = -1.0\n        jac_base[idx + 1, 3 * i + 2] = -1.0\n        \n        # y_i - r_i >= 0\n        jac_base[idx + 2, 3 * i + 1] = 1.0\n        jac_base[idx + 2, 3 * i + 2] = -1.0\n        \n        # 1.0 - y_i - r_i >= 0\n        jac_base[idx + 3, 3 * i + 1] = -1.0\n        jac_base[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n        \n        c = np.empty(num_bounds + num_overlaps)\n        # Vectorized boundary conditions\n        c[0:num_bounds:4] = x - r\n        c[1:num_bounds:4] = 1.0 - x - r\n        c[2:num_bounds:4] = y - r\n        c[3:num_bounds:4] = 1.0 - y - r\n        \n        # Vectorized overlap conditions\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        \n        c[num_bounds:] = dx**2 + dy**2 - sr**2\n        return c\n\n    def constraints_jac(v):\n        jac = jac_base.copy()\n        x = v[0::3\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, initial_radii):\n    \"\"\"\n    Ensure all circles are strictly valid within the square and non-overlapping.\n    A single pass guarantees validity since radii are monotonically decreased.\n    \"\"\"\n    n = len(centers)\n    radii = np.copy(initial_radii)\n    \n    # Strictly limit by proximity to the square boundaries\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, y, 1 - x, 1 - y)\n        if max_r < 0: \n            max_r = 0\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    # Strictly limit by overlaps\n    # Processing each pair once is mathematically sufficient because radii only decrease\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                # Add a tiny safe margin to prevent floating point inaccuracies\n                scale = (dist - 1e-10) / (radii[i] + radii[j])\n                if scale < 0: \n                    scale = 0\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n\ndef optimize_packing_restarts(n=26, num_restarts=5, steps=4000):\n    \"\"\"\n    Optimize circle packing using gradient ascent with simulated annealing.\n    Multiple restarts are utilized to escape local maxima.\n    \"\"\"\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n\n    for restart in range(num_restarts):\n        np.random.seed(42 + restart)\n        \n        centers = []\n        # Seed initial positions strategically to maximize space utilization\n        # 4 corners\n        centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n        # 4 edge midpoints\n        centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n        \n        # Random distribution for the remaining circles, biased to fill gaps\n        num_random = n - 8\n        if num_random > 0:\n            rand_centers = np.random.uniform(0.1, 0.9, size=(num_random, 2))\n            centers.extend(rand_centers)\n            \n        centers = np.array(centers)\n        \n        # Break perfect symmetry: introduce slight random perturbations\n        centers += np.random.normal(0, 0.01, size=centers.shape)\n        centers = np.clip(centers, 0.02, 0.98)\n        \n        # Size placement: bias initialization to push larger circles toward the center\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nAn elegant, highly optimized solution using a hybrid approach. It first runs a custom physics-based Adam optimizer with simulated annealing as a global search to explore many topological configurations (overcoming local maxima traps). It then polishes the best configurations found using SciPy's precise Sequential Least SQuares Programming (SLSQP) optimizer to perfectly enforce constraints and maximize the final sum of radii.\n\n```python\nimport numpy as np\nimport time\nfrom scipy.optimize import minimize, LinearConstraint, NonlinearConstraint\n\n\ndef compute_loss_and_grads(centers, radii, C):\n    \"\"\"\n    Computes a penalty-based loss and its analytical gradients for the Adam optimizer.\n    Penalizes boundary and overlap violations heavily to mimic physics repulsions.\n    \"\"\"\n    N = len(radii)\n    \n    grad_centers = np.zeros_like(centers)\n    grad_radii = np.full_like(radii, -1.0) # Base objective: maximize sum(r) -> minimize -sum(r)\n    loss = -np.sum(radii)\n    \n    # 1. Boundary x minimum (x >= r -> r - x <= 0)\n    viol_x_min = np.maximum(0, radii - centers[:, 0])\n    loss += C * np.sum(viol_x_min**2)\n    grad_radii += 2 * C * viol_x_min\n    grad_centers[:, 0] -= 2 * C * viol_x_min\n    \n    # 2. Boundary x maximum (x + r <= 1 -> x + r - 1 <= 0)\n    viol_x_max = np.maximum(0, centers[:, 0] + radii - 1.0)\n    loss += C * np.sum(viol_x_max**2)\n    grad_radii += 2 * C * viol_x_max\n    grad_centers[:, 0] += 2 * C * viol_x_max\n    \n    # 3. Boundary y minimum (y >= r -> r - y <= 0)\n    viol_y_min = np.maximum(0, radii - centers[:, 1])\n    loss += C * np.sum(viol_y_min**2)\n    grad_radii += 2 * C * viol_y_min\n    grad_centers[:, 1] -= 2 * C * viol_y_min\n    \n    # 4. Boundary y maximum (y + r <= 1 -> y + r - 1 <= 0)\n    viol_y_max = np.maximum(0, centers[:, 1] + radii - 1.0)\n    loss += C * np.sum(viol_y_max**2)\n    grad_radii += 2 * C * viol_y_max\n    grad_centers[:, 1] += 2 * C * viol_y_max\n    \n    # 5. Overlap constraints (r_i + r_j <= dist_ij)\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :] \n    dist_sq = np.sum(diff**2, axis=2)\n    dist = np.sqrt(dist_sq + 1e-16) # Add epsilon to avoid divide-by-zero\n    np.fill_diagonal(dist, 1.0) \n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    viol_overlap = np.maximum(0,\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\n\ndef compute_loss_and_grads(params, lambda_pen):\n    \"\"\"\n    Compute the loss and gradients for the current packing configuration.\n    The loss directly penalizes constraint violations and rewards larger radii.\n    \"\"\"\n    N = 26\n    centers = params[:2*N].reshape(N, 2)\n    radii = params[2*N:]\n    \n    grad_centers = np.zeros_like(centers)\n    # Gradient of the objective (maximize sum of radii -> minimize -sum(radii))\n    grad_radii = np.full_like(radii, -1.0)\n    \n    loss = -np.sum(radii)\n    \n    # --- Boundary Violations ---\n    # Boundary x min (radii <= x)\n    viol_x_min = np.maximum(0, radii - centers[:, 0])\n    loss += lambda_pen * np.sum(viol_x_min**2)\n    grad_radii += 2 * lambda_pen * viol_x_min\n    grad_centers[:, 0] -= 2 * lambda_pen * viol_x_min\n    \n    # Boundary x max (x + radii <= 1)\n    viol_x_max = np.maximum(0, centers[:, 0] + radii - 1)\n    loss += lambda_pen * np.sum(viol_x_max**2)\n    grad_radii += 2 * lambda_pen * viol_x_max\n    grad_centers[:, 0] += 2 * lambda_pen * viol_x_max\n    \n    # Boundary y min (radii <= y)\n    viol_y_min = np.maximum(0, radii - centers[:, 1])\n    loss += lambda_pen * np.sum(viol_y_min**2)\n    grad_radii += 2 * lambda_pen * viol_y_min\n    grad_centers[:, 1] -= 2 * lambda_pen * viol_y_min\n    \n    # Boundary y max (y + radii <= 1)\n    viol_y_max = np.maximum(0, centers[:, 1] + radii - 1)\n    loss += lambda_pen * np.sum(viol_y_max**2)\n    grad_radii += 2 * lambda_pen * viol_y_max\n    grad_centers[:, 1] += 2 * lambda_pen * viol_y_max\n    \n    # --- Overlap Violations ---\n    # Vectorized pairwise differences and distances\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :] \n    dist_sq = np.sum(diff**2, axis=2)\n    dist = np.sqrt(dist_sq + 1e-16) # Add epsilon to prevent div-by-zero\n    \n    r_sum = radii[:, np.newaxis] + radii[np.newaxis, :]\n    viol_overlap = np.maximum(0, r_sum - dist)\n    np.fill_diagonal(viol_overlap, 0)\n    \n    # Divided by 2 because the matrix is symmetric and counts every pair twice\n    loss += lambda_pen * np.sum(viol_overlap**2) / 2\n    \n    # Gradients for overlap violations\n    grad_radii += np.sum(2 * lambda_pen * viol_overlap, axis=1)\n    \n    factor = np.where\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    v_reshaped = v.reshape(-1, 3)\n    x = v_reshaped[:, 0]\n    y = v_reshaped[:, 1]\n    r = v_reshaped[:, 2]\n    \n    c_bounds = np.empty(4 * len(x))\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    idx_i, idx_j = np.triu_indices(len(x), k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n    total_constraints = num_bounds + num_overlaps\n    \n    jac = np.zeros((total_constraints, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    row_idx = num_bounds + np.arange(num_overlaps)\n    \n    jac[row_idx, 3*idx_i] = 2 * dx\n    jac[row_idx, 3*idx_j] = -2 * dx\n    jac[row_idx, 3*idx_i+1] = 2 * dy\n    jac[row_idx, 3*idx_j+1] = -2 * dy\n    jac[row\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["import time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(4 * N)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    row_idx = num_bounds + np.arange(num_overlaps)\n    \n    jac[row_idx, 3*idx_i] = 2 * dx\n    jac[row_idx, 3*idx_j] = -2 * dx\n    jac[row_idx, 3*idx_i+1] = 2 * dy\n    jac[row_idx, 3*idx_j+1] = -2 * dy\n    jac[row_idx, 3*idx_i+2] = -2 * sr\n    jac[row_idx, 3*idx_j+2] = -2 * sr\n    \n    return jac\n\ndef get_initial_guess(seed, N):\n    np.random.seed(seed)\n    mode = seed % 3\n    \n    centers = []\n    if mode == 0:\n        centers.extend([[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]])\n        centers.extend([[0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5]])\n        for _ in range(N - 8):\n            centers.append(np.random.uniform(0.1, 0.9, 2))\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.02, (N, 2))\n    elif mode == 1:\n        grid_n = int(np.ceil(np.sqrt(N)))\n        for i in range(grid_n):\n            for j in range(grid_n):\n                if len(centers) < N:\n                    cx = (i + 0.5) / grid_n\n                    cy = (j + 0.5) / grid_n\n                    centers.append([cx, cy])\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.015, (N, 2))\n    else:\n        centers = np.random.uniform(0.05, 0.95, (N, 2))\n        \n    centers = np.clip(centers, 0.05, 0.95)\n    \n    dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n    radii = 0.02 + 0.03 * (1.0 - dist_to_center / (np.max(dist_to_center) + 1e-9))\n    \n    v0 = np.zeros(3 * N)\n    v0[0::3] = centers[:, 0]\n    v0[1::3] = centers[:, 1]\n    v0[2::3] = radii\n    \n    return v0\n\ndef solve():\n    N = 26\n    best_v = None\n    best_obj = float('inf')\n    \n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {\n        'type': 'ineq',\n        'fun': constraints_fun,\n        'jac': constraints_jac\n    }\n    \n    start_time = time.time()\n    \n    for attempt in range(25):\n        if time.time() - start_time > 500:\n            break\n            \n        v0 = get_initial_guess(attempt * 42 + 17, N)\n        \n        res = minimize(\n            objective, \n            v0, \n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        if res.success and res.fun < best_obj:\n            c_vals = constraints_fun(res.x)\n            if np.all(c_vals >= -1e-4):\n                best_obj = res.fun\n                best_v = res.x\n\n    if best_v is None:\n        best_v = get_initial_guess(42, N)\n        \n    v = best_v.copy()\n    centers = v.reshape(-1, 3)[:, :2]\n    radii = v.reshape(-1, 3)[:, 2]\n    \n    for i in range(N):\n        max_r = min(centers[i, 0], centers[i, 1], 1.0 - centers[i, 0], 1.0 - centers[i, 1])\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    for _ in range(20):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist:\n                    scale = (dist - 1e-10) / (radii[i] + radii[j])\n                    scale = max(0.0, min(1.0, scale))\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    \n    radii = np.maximum(radii, 0.0)\n    \n    return centers, radii, float(np.sum(radii))\n\ncenters, radii, sum_radii = solve()"]}}, "artifacts_json": "{\"stderr\": \"Stage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\", \"traceback\": \"Traceback (most recent call last):\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 384, in evaluate_stage1\\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 172, in run_with_timeout\\n    raise RuntimeError(f\\\"Program execution failed: {results['error']}\\\")\\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\\n\", \"failure_stage\": \"stage1_execution\", \"suggestion\": \"Check basic syntax and imports before attempting full evaluation\"}", "artifact_dir": null, "embedding": null}