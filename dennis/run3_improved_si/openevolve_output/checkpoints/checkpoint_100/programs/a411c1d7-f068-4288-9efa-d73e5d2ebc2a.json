{"id": "a411c1d7-f068-4288-9efa-d73e5d2ebc2a", "code": "```python\nimport time\nimport numpy as np\n\ntry:\n    from scipy.optimize import linprog\n    HAS_SCIPY = True\nexcept ImportError:\n    HAS_SCIPY = False\n\ndef get_optimal_radii(c, r_init):\n    \"\"\"\n    Given fixed center coordinates, compute the exact optimal radii\n    that maximize their sum without any pairwise or boundary overlaps\n    using Linear Programming.\n    \"\"\"\n    if not HAS_SCIPY:\n        return r_init\n        \n    n = len(c)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise non-overlapping constraints: r_i + r_j <= ||c_i - c_j||\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(np.linalg.norm(c[i] - c[j]))\n            \n    # Boundary constraints: r_i <= min_dist_to_boundary\n    bounds = []\n    for i in range(n):\n        max_r = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-11)\n    bounds_adj = [(0, max(0, b[1] - 1e-11)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n        if res.success:\n            return res.x\n    except Exception:\n        try:\n            # Fallback algorithm\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n            if res.success:\n                return res.x\n        except Exception:\n            pass\n    return r_init\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that globally maximizes the sum of their radii without any overlaps.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n    \n    num_restarts = 60\n    steps = 15000\n    \n    start_time = time.time()\n    \n    for attempt in range(num_restarts):\n        # Time budget enforcement\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 1001)\n        \n        c = np.random.rand(n, 2)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        # Diverse strategic initialization configurations\n        mode = attempt % 8\n        if mode == 0:\n            c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        elif mode == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n", "changes_description": null, "language": "python", "parent_id": "2f93aa9e-cc2f-4379-9b4f-9c2c53efa3a2", "generation": 4, "timestamp": 1771884263.9472206, "iteration_found": 93, "metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\n\n\ndef run():\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 15000\n\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 1001)\n        \n        c = np.random.rand(n, 2)\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        c = np.clip(c, 0.05, 0.95)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        if attempt == 0:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.25\n            c[1:5] = [[0.15, 0.15], [0.85, 0.15], [0.15, 0.85], [0.85, 0.85]]\n            r[1:5] = 0.15\n        elif attempt == 1:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]\n            r[0:2] = 0.2\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]\n                    r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]\n            r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 4:\n            c[0:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]\n            r[0:3] = 0.25\n        elif attempt == 5:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i+1] = [0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)]\n                r[i+1] = 0.08\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i+8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+8] = 0.05\n                \n        c += np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n            \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        lr_start = 0.01\n        lr_end = 0.0001\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        \n        penalty_start = 10.0\n        penalty_end = 50000.0\n        \n        for step in range(steps):\n            progress = step / steps\n            lr = lr_start * ((lr_end / lr_start) ** progress)\n            lambda_pen = penalty_start * ((penalty_end / penalty_start) ** progress)\n            \n            grad_c = np.zeros_like(c)\n            grad_r = np.full(n, -1.0)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            grad_r += lambda_pen * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = (2 * lambda_pen * overlap / safe_dist)[..., None] * diff\n            grad_c -= np.sum(force, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            grad_r += lambda_pen * 2 * (bx_min + bx_max + by_min + by_max)\n            grad_c[:, 0] += lambda_pen * 2 * (-bx_min + bx_max)\n            grad_c[:, 1] += lambda_pen * 2 * (-by_min + by_max)\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** (step + 1))\n            v_c_hat = v_c / (1 - beta2 ** (step + 1))\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** (step + 1))\n            v_r_hat = v_r / (1 - beta2 ** (step + 1))\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            c = np.clip(c, 1e-5, 1 - 1e-5)\n            r = np.maximum(r, 1e-5)\n            \n        for _ in range(5000):\n            r = np.minimum(r, c[:, 0])\n            r = np.minimum(r, 1 - c[:, 0])\n            r = np.minimum(r, c[:, 1])\n            r = np.minimum(r, 1 - c[:, 1])\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = sum_r - dist\n            \n            max_overlap = np.max(overlap)\n            if max_overlap <= 1e-9:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            total = r[i] + r[j]\n            if total > 1e-12:\n                shrink_i = max_overlap * (r[i] / total) + 1e-9\n                shrink_j = max_overlap * (r[j] / total) + 1e-9\n                r[i] = max(0, r[i] - shrink_i)\n                r[j] = max(0, r[j] - shrink_j)\n                \n        scale = 1.0\n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        sum_r_val_arr = r[:, None] + r[None, :]\n        \n        safe_sum_r = np.where(sum_r_val_arr < 1e-12, 1e-12, sum_r_val_arr)\n        ratios = dist / safe_sum_r\n        min_ratio = np.min(ratios)\n        if min_ratio < 1.0:\n            scale = min(scale, min_ratio)\n            \n        for i in range(n):\n            if r[i] > 1e-12:\n                if c[i, 0] / r[i] < scale: \n                    scale = c[i, 0] / r[i]\n                if (1 - c[i, 0]) / r[i] < scale: \n                    scale = (1 - c[i, 0]) / r[i]\n                if c[i, 1] / r[i] < scale: \n                    scale = c[i, 1] / r[i]\n                if (1 - c[i, 1]) / r[i] < scale: \n                    scale = (1 - c[i, 1]) / r[i]\n                \n        r *= scale * 0.999999\n        sum_r_val = float(np.sum(r))\n        \n        if sum_r_val > best_sum:\n            best_sum = sum_r_val\n            best_c = c.copy()\n            best_r = r.copy()\n            \n    return best_c.tolist(), best_r.tolist(), best_sum\n\n\ndef run_packing():\n    return run()\n\n\ndef solve():\n    return run()\n\n\nif __name__ == \"__main__\":\n    run()\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 2 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef get_fallback_packing(n=26):\n    \"\"\"\n    Generate a strictly valid baseline grid packing as a safety fallback.\n    \"\"\"\n    grid_dim = int(np.ceil(np.sqrt(n)))\n    c = []\n    r = []\n    idx = 0\n    step = 1.0 / grid_dim\n    for i in range(grid_dim):\n        for j in range(grid_dim):\n            if idx < n:\n                c.append([step / 2 + i * step, step / 2 + j * step])\n                r.append(step / 2 * 0.9)\n                idx += 1\n    return c, r, float(np.sum(r))\n\n\ndef get_initial_state(attempt, n):\n    \"\"\"\n    Generate diverse initial conditions to thoroughly explore the search space.\n    Different modes bias the random starting positions in strategic ways.\n    \"\"\"\n    np.random.seed(42 + attempt * 123)\n    c = np.random.rand(n, 2)\n    r = np.random.rand(n) * 0.03 + 0.01\n    \n    mode = attempt % 8\n    if mode == 0:\n        # Bias towards corners and edges\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n    elif mode == 1:\n        # Central clump bias\n        c[:, 0] = c[:, 0] * 0.8 + 0.1\n        c[:, 1] = c[:, 1] * 0.8 + 0.1\n    elif mode == 2:\n        # Concentric rings\n        c[0] = [0.5, 0.5]; r[0] = 0.2\n        for i in range(1, 8):\n            ang = (i - 1) * 2 * np.pi / 7\n            c[i] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n            r[i] = 0.1\n        for i in range(8, n):\n            ang = (i - 8) * 2 * np.pi / (n - 8)\n            c[i] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n            r[i] = 0.05\n    elif mode == 3:\n        # Extreme corner bias\n        c = np.where(c < 0.5, c ** 2, 1 - (1 - c) ** 2)\n    elif mode == 4:\n        # Hexagonal-like staggered grid\n        grid_dim_x = 5\n        grid_dim_y = 6\n        idx = 0\n        for i in range(grid_dim_x):\n            for j in range(grid_dim_y):\n                if idx < n:\n                    offset = 0.5 if j % 2 == 1 else 0.0\n                    c[idx] = [0.1 + (i + offset) * 0.8 / grid_dim_x, 0.\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n```python\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii without any overlaps.\n    \n    This implementation uses a physics-based iterative Adam optimizer\n    with dynamic barrier penalties (simulated annealing approach) to find\n    dense packings. Strategic initial placements, breaking of perfect symmetry,\n    and targeted local repair guarantee high-quality valid configurations.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Use 60 diverse initializations to thoroughly explore the search space.\n    # We do 20,000 steps of Adam per initialization.\n    num_restarts = 60\n    steps = 20000\n\n    for attempt in range(num_restarts):\n        c = np.zeros((n, 2))\n        r = np.zeros(n)\n        \n        # Strategic initializations: Seed shapes to naturally emerge in globally optimal packings\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            c[1:5] = [[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]]; r[1:5] = 0.1\n            for i in range(5, n):\n                c[i] = np.random.uniform(0.1, 0.9, 2); r[i] = 0.05\n        elif attempt == 1:\n            # Concentric\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 2:\n            # Grid layout\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.05\n        elif attempt == 3:\n            # Spiral\n            for i in range(n):\n                ang = i * 2.4\n                rad = 0.05 + 0.4 * (i / n)\n                c[i] = [0.5 + rad * np.cos(ang), 0.5 + rad * np.sin(ang)]\n                r\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef get_optimal_radii(centers):\n    \"\"\"\n    Given fixed center coordinates, calculate the exact optimal radii\n    that maximize their sum without causing any pairwise or boundary overlaps.\n    This dynamically perfectly packs the current center configuration.\n    \"\"\"\n    n = len(centers)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise non-overlapping constraints: r_i + r_j <= ||c_i - c_j||\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Boundary constraints: r_i <= min_dist_to_boundary\n    bounds = []\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-11)\n    bounds_adj = [(0, max(0, b[1] - 1e-11)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n    except Exception:\n        # Fallback if 'highs' method is unavailable\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n        \n    if res.success:\n        return res.x\n    return np.zeros(n)\n\n\ndef rigid_rescale(c, r):\n    \"\"\"\n    Final safety net: strictly scale down radii globally based on the worst-case \n    violation to guarantee 100% mathematical compliance with evaluation bounds.\n    \"\"\"\n    c = np.clip(c, 1e-6, 1 - 1e-6)\n    r = np.maximum(r, 0.0)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    mask = sum_r > 1e-9\n    \n    if np.any(mask):\n        ratio = dist[mask] / sum_r[mask]\n        scale = min(1.0, np.min(ratio))\n    else:\n        scale = 1.0\n    \n    for i in range(len(r)):\n        if r[i] > 1e-9:\n            b_scale = min(c[i, 0] / r[i], (1 - c[i, 0]) / r[i], \n                          c[i, 1] / r[i], (1 - c[i, 1]) / r[i])\n            scale = min(scale, b_scale)\n            \n    # Apply slightly below 1 multiplier to guarantee float clearance\n    return c, r * scale * 0.99999999\n\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii without any overlaps.\n    \n    This implementation uses a continuous physics-based Adam optimizer\n    with dynamic barrier penalties (simulated annealing approach) combined\n    with periodic exact Linear Programming injections to find incredibly dense packings.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 10000\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        # Time threshold defense to prevent execution timeouts\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 17)\n        \n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n        \n        # Strategic initializations to seed high quality packings\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.25\n            c[1:5] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i+1] = [0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(12):\n                ang = 2 * np.pi * i / 12\n                c[i+7] = [0.5 + 0.38 * np.cos(ang), 0.5 + 0.38 * np.sin(ang)]\n                r[i+7] = 0.08\n            for i in range(7):\n                ang = 2 * np.pi * i / 7\n                c[i+19] = [0.5 + 0.48 * np.cos(ang), 0.5 + 0.48 * np.sin(ang)]\n                r[i+19] = 0.05\n        elif attempt == 4:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.25\n        elif attempt == 5:\n            c[0:4] = [[0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:4] = 0.2\n        elif attempt == 6:\n            c[:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[:3] = 0.25\n        elif attempt == 7:\n            c[0] = [0.5, \n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef objective(x, n, penalty_weight):\n    \"\"\"\n    Computes the loss and gradient for a continuous physics-based penalty method.\n    The objective expands radii, while squared penalties enforce physical bounds.\n    \"\"\"\n    c = x[:n * 2].reshape((n, 2))\n    r = x[n * 2:]\n    \n    # Objective: minimize -sum(radii)\n    obj = -np.sum(r)\n    \n    # Calculate pairwise differences and distances\n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    overlap = np.maximum(0, sum_r - dist)\n    \n    # Calculate boundary violations\n    bx_min = np.maximum(0, r - c[:, 0])\n    bx_max = np.maximum(0, c[:, 0] + r - 1)\n    by_min = np.maximum(0, r - c[:, 1])\n    by_max = np.maximum(0, c[:, 1] + r - 1)\n    \n    # Squared penalty terms for continuous and smooth gradients\n    penalty = (np.sum(overlap**2) / 2 + \n               np.sum(bx_min**2) + np.sum(bx_max**2) + \n               np.sum(by_min**2) + np.sum(by_max**2))\n               \n    loss = obj + penalty_weight * penalty\n    \n    # Compute Exact Gradients\n    grad_c = np.zeros_like(c)\n    grad_r = np.full(n, -1.0)\n    \n    # Gradients from pairwise overlaps\n    grad_r += penalty_weight * 2 * np.sum(overlap, axis=1)\n    \n    safe_dist = np.where(dist < 1e-8, 1.0, dist)\n    force = penalty_weight * 2 * (overlap / safe_dist)[..., None] * diff\n    grad_c -= np.sum(force, axis=1)\n    \n    # Gradients from boundary violations\n    grad_r += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n    grad_c[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n    grad_c[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n    \n    return loss, np.concatenate([grad_c.flatten(), grad_r])\n\n\ndef make_valid_lp(c):\n    \"\"\"\n    Uses exact Linear Programming to perfectly squeeze the maximum valid radii \n    into a given set of fixed centers without any pairwise or boundary overlaps.\n    \"\"\"\n    n = len(c)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nbx_min = np.maximum(0, r - c[:, 0])\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii without any overlaps.\n    \n    This algorithm employs a physics-based optimizer using Adam, \n    with dynamic barrier penalties resembling simulated annealing. \n    It incorporates strategic symmetry breaking and targeted repair steps \n    to escape local minima and ensure mathematically perfect feasibility.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 12000\n\n    for attempt in range(num_restarts):\n        # Initialize randomly\n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n\n        # Strategic initial placements to seed optimal dense configurations\n        if attempt == 0:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            c[1:5] = [[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]]\n            r[1:5] = 0.1\n        elif attempt == 1:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]\n            r[0:2] = 0.15\n        elif attempt == 2:\n            c[0:4] = [[0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]]\n            r[0:4] = 0.15\n        elif attempt == 3:\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i] = [0.5 + 0.3 * np.cos(ang), 0.5 + 0.3 * np.sin(ang)]\n                r[i] = 0.15\n        elif attempt == 4:\n            # Concentric rings\n            c[0] = [0.5, 0.5]\n            r[0] = 0.18\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i + 1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i + 1] = 0.12\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i + 8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i + 8] = 0.06\n        elif attempt == 5:\n            # Grid layout\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]\n                    r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]\n            r[25] = 0.05\n\n        # Small random perturbation to break perfect symmetries\n        c += np.random.normal(0, 1e-4, c.shape)\n\n        # Initialize Adam optimizer moments\n        mc = np.zeros_like(c)\n        vc = np.zeros_like(c)\n        mr = np.zeros_like(r)\n        vr = np.zeros_like(r)\n\n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n\n        # Dynamic penalty scaling multiplier\n        penalty_start = np.random.uniform(5.0, 15.0)\n        penalty_end = np.random.uniform(5000.0, 15000.0)\n        mult = (penalty_end / penalty_start) ** (1.0 / steps)\n        penalty_weight = penalty_start\n\n        for step in range(steps):\n            # Smoothly decaying learning rate\n            lr = 0.005 * (0.1 ** (step / steps))\n\n            # Base gradient continually pushes radii to grow\n            gr = np.full(n, -1.0)\n            gc = np.zeros_like(c)\n\n            # Pairwise differences and distances\n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n\n            # Overlaps between circles\n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n\n            # Radii gradients from overlaps\n            gr += penalty_weight * np.sum(2 * overlap, axis=1)\n\n            # Center coordinate gradients from overlaps (repulsion forces)\n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = 2 * penalty_weight * overlap / safe_dist\n            gc -= np.sum(force[..., None] * diff, axis=1)\n\n            # Boundary violations\n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n\n            # Gradients from boundaries\n            gr += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n            gc[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n            gc[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n\n            # Adam updates for centers\n            mc = beta1 * mc + (1 - beta1) * gc\n            vc = beta2 * vc + (1 - beta2) * (gc ** 2)\n            mch = mc / (1 - beta1 ** (step + 1))\n            vch = vc / (1 - beta2 ** (step + 1))\n            c -= lr * mch / (np.sqrt(vch) + eps)\n\n            # Adam updates for radii\n            mr = beta1 * mr + (1 - beta1) * gr\n            vr = beta2 * vr + (1 - beta2) * (gr ** 2)\n            mrh = mr / (1 - beta1 ** (step + 1))\n            vrh = vr / (1 - beta2 ** (step + 1))\n            r -= lr * mrh / (np.sqrt(vrh) + eps)\n\n            # Enforce hard limits\n            c = np.clip(c, 0.0, 1.0)\n            r = np.maximum(r, 0.0001)\n\n            penalty_weight *= mult\n\n        # Post-optimization: Iterative targeted repair for tiny residual overlaps\n        for _ in range(200):\n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n\n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n\n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n\n            max_ov = np.max(overlap)\n            max_b = max(\n                np.max(bx_min),\n                np.max(bx_max),\n                np.max(by_min),\n                np.max(by_max)\n            )\n\n            if max_ov <= 1e-9 and max_b <= 1e-9:\n                break\n\n            if max_ov > max_b:\n                i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n                shrink = (overlap[i, j] / 2) + 1e-8\n                r[i] = max(1e-5, r[i] - shrink)\n                r[j] = max(1e-5, r[j] - shrink)\n            else:\n                if np.max(bx_min) == max_b:\n                    i = np.argmax(bx_min)\n                    r[i] = max(1e-5, r[i] - bx_min[i] - 1e-8)\n                elif np.max(bx_max) == max_b:\n                    i = np.argmax(bx_max)\n                    r[i] = max(1e-5, r[i] - bx_max[i] - 1e-8)\n                elif np.max(by_min) == max_b:\n                    i = np.argmax(by_min)\n                    r[i] = max(1e-5, r[i] - by_min[i] - 1e-8)\n                else:\n                    i = np.argmax(by_max)\n                    r[i] = max(1e-5, r[i] - by_max[i] - 1e-8)\n\n        # Final safety net: global rigid rescale to guarantee 100% strict compliance\n        c = np.clip(c, 1e-6, 1 - 1e-6)\n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        sum_r = r[:, None] + r[None, :]\n        ratio = dist / sum_r\n        scale = min(1.0, np.min(ratio))\n\n        scale = min(scale, np.min(c[:, 0] / r))\n        scale = min(scale, np.min((1 - c[:, 0]) / r))\n        scale = min(scale, np.min(c[:, 1] / r))\n        scale = min(scale, np.min((1 - c[:, 1]) / r))\n\n        # Apply a tiny buffer scale to handle floating point inaccuracies\n        r = r * scale * 0.999999\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c.copy()\n            best_r = r.copy()\n\n    return best_c, best_r\n\n\ndef solve_circle_packing(*args, **kwargs):\n    \"\"\"Entry point matching original signature format.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii = solve_circle_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef get_optimal_radii(centers):\n    \"\"\"\n    Given fixed center coordinates, calculate the exact optimal radii\n    that maximize their sum without causing any pairwise or boundary overlaps.\n    This dynamically perfectly packs the current center configuration.\n    \"\"\"\n    n = len(centers)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise non-overlapping constraints: r_i + r_j <= ||c_i - c_j||\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    # Boundary constraints: r_i <= min_dist_to_boundary\n    bounds = []\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-11)\n    bounds_adj = [(0, max(0, b[1] - 1e-11)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n    except Exception:\n        # Fallback if 'highs' method is unavailable\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n        \n    if res.success:\n        return res.x\n    return np.zeros(n)\n\n\ndef rigid_rescale(c, r):\n    \"\"\"\n    Final safety net: strictly scale down radii globally based on the worst-case \n    violation to guarantee 100% mathematical compliance with evaluation bounds.\n    \"\"\"\n    c = np.clip(c, 1e-6, 1 - 1e-6)\n    r = np.maximum(r, 0.0)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    mask = sum_r > 1e-9\n    \n    if np.any(mask):\n        ratio = dist[mask] / sum_r[mask]\n        scale = min(1.0, np.min(ratio))\n    else:\n        scale = 1.0\n    \n    for i in range(len(r)):\n        if r[i] > 1e-9:\n            b_scale = min(c[i, 0] / r[i], (1 - c[i, 0]) / r[i], \n                          c[i, 1] / r[i], (1 - c[i, 1]) / r[i])\n            scale = min(scale, b_scale)\n            \n    # Apply slightly below 1 multiplier to guarantee float clearance\n    return c, r * scale * 0.99999999\n\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii without any overlaps.\n    \n    This implementation uses a continuous physics-based Adam optimizer\n    with dynamic barrier penalties (simulated annealing approach) combined\n    with periodic exact Linear Programming injections to find incredibly dense packings.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 10000\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        # Time threshold defense to prevent execution timeouts\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 17)\n        \n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n        \n        # Strategic initializations to seed high quality packings\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.25\n            c[1:5] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i+1] = [0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(12):\n                ang = 2 * np.pi * i / 12\n                c[i+7] = [0.5 + 0.38 * np.cos(ang), 0.5 + 0.38 * np.sin(ang)]\n                r[i+7] = 0.08\n            for i in range(7):\n                ang = 2 * np.pi * i / 7\n                c[i+19] = [0.5 + 0.48 * np.cos(ang), 0.5 + 0.48 * np.sin(ang)]\n                r[i+19] = 0.05\n        elif attempt == 4:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.25\n        elif attempt == 5:\n            c[0:4] = [[0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:4] = 0.2\n        elif attempt == 6:\n            c[:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[:3] = 0.25\n        elif attempt == 7:\n            c[0] = [0.5, \n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport time\nimport numpy as np\n\ntry:\n    from scipy.optimize import linprog\n    HAS_SCIPY = True\nexcept ImportError:\n    HAS_SCIPY = False\n\ndef get_optimal_radii(c, r_init):\n    if not HAS_SCIPY:\n        return r_init\n    n = len(c)\n    c_obj = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(np.linalg.norm(c[i] - c[j]))\n    bounds = []\n    for i in range(n):\n        max_r = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-9)\n    bounds_adj = [(0, max(0, b[1] - 1e-9)) for b in bounds]\n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n        if res.success:\n            return res.x\n    except Exception:\n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n            if res.success:\n                return res.x\n        except Exception:\n            pass\n    return r_init\n\ndef run():\n    n = 26\n    best_sum_r = -1.0\n    best_c = None\n    best_r = None\n    \n    num_attempts = 40\n    steps = 4000\n    start_time = time.time()\n    \n    for attempt in range(num_attempts):\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 100)\n        c = np.random.rand(n, 2)\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            c[1:5] = [[0.15, 0.15], [0.85, 0.15], [0.15, 0.85], [0.85, 0.85]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.2\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    if idx < n:\n                        c[idx] = [0.1 + i*0.2, 0.1 + j*0.2]; r[idx] = 0.08\n                        idx += 1\n            if 25 < n:\n                c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                if i+1 < n:\n                    c[i+1] = [0.5 + 0.25*np.cos(ang), 0.5 + 0.25*np.sin(ang)]\n                    r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                if i+9 < n:\n                    c[i+9] = [0.5 + 0.45*np.cos(ang), 0.5 + 0.45*np.sin(ang)]\n                    r[i+9] = 0.05\n        elif attempt == 4:\n            c[0:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:3] = 0.25\n        else:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(1, 7):\n                ang = i * 2 * np.pi / 6 + np.random.rand()*0.2\n                if i < n:\n                    c[i] = [0.5 + 0.25*np.cos(ang), 0.5 + 0.25*np.sin(ang)]\n                    r[i] = 0.1\n            for i in range(7, n):\n                ang = i * 2 * np.pi / max(1, n - 7) + np.random.rand()*0.2\n                c[i] = [0.5 + 0.45*np.cos(ang), 0.5 + 0.45*np.sin(ang)]\n                r[i] = 0.05\n                \n        c += np.random.normal(0, 1e-4, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        lr_start = 0.01\n        lr_end = 0.001\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        pen_start = 10.0\n        pen_end = 100000.0\n        \n        for step in range(steps):\n            frac = step / max(1, steps - 1)\n            lr = lr_start * ((lr_end / lr_start) ** frac)\n            lambda_pen = pen_start * ((pen_end / pen_start) ** frac)\n            \n            grad_c = np.zeros_like(c)\n            grad_r = np.full(n, -1.0)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            grad_r += lambda_pen * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1e-8, dist)\n            force = (2 * lambda_pen * overlap / safe_dist)[..., None] * diff\n            grad_c -= np.sum(force, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            grad_r += lambda_pen * 2 * (bx_min + bx_max + by_min + by_max)\n            grad_c[:, 0] += lambda_pen * 2 * (-bx_min + bx_max)\n            grad_c[:, 1] += lambda_pen * 2 * (-by_min + by_max)\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** (step + 1))\n            v_c_hat = v_c / (1 - beta2 ** (step + 1))\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** (step + 1))\n            v_r_hat = v_r / (1 - beta2 ** (step + 1))\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            c = np.clip(c, 1e-5, 1 - 1e-5)\n            r = np.maximum(r, 1e-5)\n            \n        r = get_optimal_radii(c, r)\n        \n        r = np.minimum(r, c[:, 0])\n        r = np.minimum(r, 1 - c[:, 0])\n        r = np.minimum(r, c[:, 1])\n        r = np.minimum(r, 1 - c[:, 1])\n        r = np.maximum(r, 0)\n        \n        for _ in range(2000):\n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            sum_r = r[:, None] + r[None, :]\n            overlap = sum_r - dist\n            max_overlap = np.max(overlap)\n            if max_overlap <= 1e-9:\n                break\n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            total = r[i] + r[j]\n            if total > 0:\n                shrink_i = max_overlap * (r[i] / total) + 1e-9\n                shrink_j = max_overlap * (r[j] / total) + 1e-9\n                r[i] = max(0, r[i] - shrink_i)\n                r[j] = max(0, r[j] - shrink_j)\n                \n        scale = 1.0\n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        sum_r = r[:, None] + r[None, :]\n        safe_sum_r = np.where(sum_r < 1e-12, 1e-12, sum_r)\n        ratios = dist / safe_sum_r\n        min_ratio = np.min(ratios)\n        if min_ratio < 1.0:\n            scale = min(scale, min_ratio)\n            \n        for i in range(n):\n            if r[i] > 1e-12:\n                scale = min(scale, c[i, 0] / r[i])\n                scale = min(scale, (1 - c[i, 0]) / r[i])\n                scale = min(scale, c[i, 1] / r[i])\n                scale = min(scale, (1 - c[i, 1]) / r[i])\n                \n        r *= scale * 0.9999999\n        sum_r_val = np.sum(r)\n        \n        if sum_r_val > best_sum_r:\n            best_sum_r = sum_r_val\n            best_c = c.copy()\n            best_r = r.copy()\n            \n    return best_c.tolist(), best_r.tolist()\n\ndef solve():\n    return run()\n\ndef construct_packing():\n    return run()\n\nif __name__ == \"__main__\":\n    centers, radii = run()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport time\nimport numpy as np\n\ntry:\n    from scipy.optimize import linprog\n    HAS_SCIPY = True\nexcept ImportError:\n    HAS_SCIPY = False\n\ndef get_optimal_radii(c, r_init):\n    \"\"\"\n    Given fixed center coordinates, compute the exact optimal radii\n    that maximize their sum without any pairwise or boundary overlaps\n    using Linear Programming.\n    \"\"\"\n    if not HAS_SCIPY:\n        return r_init\n        \n    n = len(c)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise non-overlapping constraints: r_i + r_j <= ||c_i - c_j||\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(np.linalg.norm(c[i] - c[j]))\n            \n    # Boundary constraints: r_i <= min_dist_to_boundary\n    bounds = []\n    for i in range(n):\n        max_r = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-11)\n    bounds_adj = [(0, max(0, b[1] - 1e-11)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n        if res.success:\n            return res.x\n    except Exception:\n        try:\n            # Fallback algorithm\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n            if res.success:\n                return res.x\n        except Exception:\n            pass\n    return r_init\n\ndef run_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    that globally maximizes the sum of their radii without any overlaps.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n    \n    num_restarts = 60\n    steps = 15000\n    \n    start_time = time.time()\n    \n    for attempt in range(num_restarts):\n        # Time budget enforcement\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 1001)\n        \n        c = np.random.rand(n, 2)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        # Diverse strategic initialization configurations\n        mode = attempt % 8\n        if mode == 0:\n            c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        elif mode == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n"]}}, "artifacts_json": "{\"stderr\": \"Stage 1 evaluation failed: Program execution failed: invalid syntax (tmpcmsq04ge.py, line 1)\", \"traceback\": \"Traceback (most recent call last):\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 384, in evaluate_stage1\\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 172, in run_with_timeout\\n    raise RuntimeError(f\\\"Program execution failed: {results['error']}\\\")\\nRuntimeError: Program execution failed: invalid syntax (tmpcmsq04ge.py, line 1)\\n\", \"failure_stage\": \"stage1_execution\", \"suggestion\": \"Check basic syntax and imports before attempting full evaluation\"}", "artifact_dir": null, "embedding": null}