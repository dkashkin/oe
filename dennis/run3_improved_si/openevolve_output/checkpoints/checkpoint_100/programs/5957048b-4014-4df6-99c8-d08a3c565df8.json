{"id": "5957048b-4014-4df6-99c8-d08a3c565df8", "code": "import time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    attempt = 0\n    while time.time() - start_time < 540:\n        centers = []\n        mode = attempt % 5\n\n        if mode == 0:\n            cols = 5\n            rows = 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    if len(centers) < N:\n                        x = (c_idx + 0.5 + (r_idx % 2) * 0.5) / (cols + 0.5)\n                        y = (r_idx + 0.5) / rows\n                        centers.append([x, y])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif mode == 1:\n            centers.append([0.5, 0.5])\n            ring1 = 8\n            for i in range(ring1):\n                angle = 2 * np.pi * i / ring1\n                centers.append([0.5 + 0.2 * np.cos(angle), 0.5 + 0.2 * np.sin(angle)])\n            ring2 = 17\n            for i in range(ring2):\n                angle = 2 * np.pi * i / ring2\n                centers.append([0.5 + 0.42 * np.cos(angle), 0.5 + 0.42 * np.sin(angle)])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif mode == 2:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        elif mode == 3:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        else:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers[:N])\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.02 + 0.06 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 3 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            x_sh = v_shake[0::3]\n            y_sh = v_shake[1::3]\n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.hypot(x_sh[i] - x_sh[j], y_sh[i] - y_sh[j])\n                        if dist < 0.15:\n                            dx_ = (x_sh[i] - x_sh[j]) / (dist + 1e-9)\n                            dy_ = (y_sh[i] - y_sh[j]) / (dist + 1e-9)\n                            x_sh[i] += dx_ * 0.005\n                            y_sh[i] += dy_ * 0.005\n                            x_sh[j] -= dx_ * 0.005\n                            y_sh[j] -= dy_ * 0.005\n            \n            v_shake[0::3] = np.clip(x_sh, 0.01, 0.99)\n            v_shake[1::3] = np.clip(y_sh, 0.01, 0.99)\n            v_shake[2::3] *= 0.85 \n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n        attempt += 1\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2].tolist()\n    radii_out = v.reshape(-1, 3)[:, 2].tolist()\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()", "changes_description": null, "language": "python", "parent_id": "7b0634e2-68da-4ab9-a608-d3ecc39fdcc2", "generation": 6, "timestamp": 1771884775.047631, "iteration_found": 95, "metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: invalid syntax (tmpwlhhtkmk.py, line 1)\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: invalid syntax (tmpwlhhtkmk.py, line 1)\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        for _ in range(120):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        if scale < 0:\n                            scale = 0.0\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=300)\n\n    for attempt, seed in enumerate(seeds):\n        if time.time() - start_time > 540:\n            break\n\n        np.random.seed(int(seed))\n        \n        centers_list = []\n        mode = attempt % 4\n        \n        if mode == 0:\n            centers_list.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers_list.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            centers_list.extend(np.random.uniform(0.1, 0.9, size=(N - 8, 2)).tolist())\n            \n        elif mode == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(200):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.2:\n                            f = (0.2 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers_list = pos.tolist()\n            \n        elif mode == 2:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n + 1)\n                    gy = np.random.randint(1, grid_n + 1)\n                    px, py = (gx - 0.5) / grid_n, (gy - 0.5) / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers_list) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in centers_list):\n                        centers_list.append([px, py])\n                        break\n            while len(centers_list) < N:\n                centers_list.append(np.random.uniform(0.1, 0.9, 2).tolist())\n                \n        else:\n            centers_list.append([0.5, 0.5])\n            ring1 = 8\n            for i in range(ring1):\n                angle = 2 * np.pi * i / ring1\n                centers_list.append([0.5 + 0.2 * np.cos(angle), 0.5 + 0.2 * np.sin(angle)])\n            ring2 = N - 1 - ring1\n            for i in range(ring2):\n                angle = 2 * np.pi * i / ring2\n                centers_list.append([0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)])\n\n        centers_arr = np.array(centers_list[:N])\n        centers_arr += np.random.normal(0, 0.005, size=centers_arr.shape)\n        centers_arr = np.clip(centers_arr, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers_arr - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii_arr = 0.02 + 0.04 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers_arr[:, 0]\n        v0[1::3] = centers_arr[:, 1]\n        v0[2::3] = radii_arr\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 3 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            x_sh = v_shake[0::3]\n            y_sh = v_shake[1::3]\n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.hypot(x_sh[i] - x_sh[j], y_sh[i] - y_sh[j])\n                        if dist < 0.15:\n                            dx_ = (x_sh[i] - x_sh[j]) / (dist + 1e-9)\n                            dy_ = (y_sh[i] - y_sh[j]) / (dist + 1e-9)\n                            x_sh[i] += dx_ * 0.005\n                            y_sh[i] += dy_ * 0.005\n                            x_sh[j] -= dx_ * 0.005\n                            y_sh[j] -= dy_ * 0.005\n            \n            v_shake[0::3] = np.clip(x_sh, 0.01, 0.99)\n            v_shake[1::3] = np.clip(y_sh, 0.01, 0.99)\n            v_shake[2::3] *= 0.85 \n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2].tolist()\n    radii_out = v.reshape(-1, 3)[:, 2].tolist()\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 2 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Finds a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii without any overlapping or extending bounds.\n    \"\"\"\n    N = 26\n    start_time = time.perf_counter()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    for attempt in range(1000):\n        if time.perf_counter() - start_time > 550:\n            break\n\n        centers = []\n        if attempt % 4 == 0:\n            cols = 5\n            rows = 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    if len(centers) < N:\n                        x = (c_idx + 0.5 + (r_idx % 2) * 0.5) / (cols + 0.5)\n                        y = (r_idx + 0.5) / rows\n                        centers.append([x, y])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 4 == 1:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 4 == 2:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 5 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.9\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out.tolist(), radii_out.tolist(), float(np.sum(radii_out))\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 3 (Score: 0.0000)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    best_v = None\n    best_sum_r = -1.0\n    start_time = time.time()\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(100):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        if scale < 0:\n                            scale = 0.0\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=150)\n\n    for attempt, seed in enumerate(seeds):\n        if time.time() - start_time > 550:\n            break\n\n        np.random.seed(int(seed))\n\n        centers = []\n        if attempt % 3 == 0:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            centers.extend(np.random.uniform(0.1, 0.9, size=(N - 8, 2)).tolist())\n        elif attempt % 3 == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(200):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 800, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 4 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.8\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 800, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(4 * N)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n    \n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n    \n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3*i] = 1.0\n        jac[idx, 3*i+2] = -1.0\n        \n        jac[idx+1, 3*i] = -1.0\n        jac[idx+1, 3*i+2] = -1.0\n        \n        jac[idx+2, 3*i+1] = 1.0\n        jac[idx+2, 3*i+2] = -1.0\n        \n        jac[idx+3, 3*i+1] = -1.0\n        jac[idx+3, 3*i+2] = -1.0\n        \n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n    \n    row_idx = num_bounds + np.arange(num_overlaps)\n    \n    jac[row_idx, 3*idx_i] = 2 * dx\n    jac[row_idx, 3*idx_j] = -2 * dx\n    jac[row_idx, 3*idx_i+1] = 2 * dy\n    jac[row_idx, 3*idx_j+1] = -2 * dy\n    jac[row_idx, 3*idx_i+2] = -2 * sr\n    jac[row_idx, 3*idx_j+2] = -2 * sr\n    \n    return jac\n\ndef physics_layout(seed_val, N):\n    np.random.seed(seed_val)\n    pos = np.random.uniform(0.1, 0.9, (N, 2))\n    v = np.zeros((N, 2))\n    dt = 0.05\n    for _ in range(300):\n        force = np.zeros((N, 2))\n        for i in range(N):\n            for j in range(i + 1, N):\n                diff = pos[i] - pos[j]\n                dist = np.linalg.norm(diff)\n                if dist < 0.15:\n                    f = (0.15 - dist) * (diff / (dist + 1e-9))\n                    force[i] += f\n                    force[j] -= f\n        for i in range(N):\n            for dim in range(2):\n                if pos[i, dim] < 0.05:\n                    force[i, dim] += (0.05 - pos[i, dim]) * 2\n                elif pos[i, dim] > 0.95:\n                    force[i, dim] -= (pos[i, dim] - 0.95) * 2\n        v = 0.8 * v + force * dt\n        pos += v * dt\n        pos = np.clip(pos, 0.02, 0.98)\n    return pos\n\ndef solve():\n    N = 26\n    best_v = None\n    best_obj = float('inf')\n    \n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=80)\n    \n    for attempt in range(80):\n        np.random.seed(int(seeds[attempt]))\n        v0 = np.zeros(3 * N)\n        \n        if attempt < 20:\n            pos = physics_layout(int(seeds[attempt]), N)\n        elif attempt < 40:\n            pos = []\n            grid_n = 7\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(pos) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in pos):\n                        pos.append([px, py])\n                        break\n            while len(pos) < N:\n                pos.append(np.random.uniform(0.1, 0.9, 2))\n            pos = np.array(pos)\n        else:\n            pos = np.random.uniform(0.05, 0.95, (N, 2))\n            \n        radii = np.random.uniform(0.01, 0.04, N)\n        \n        v0[0::3] = pos[:, 0]\n        v0[1::3] = pos[:, 1]\n        v0[2::3] = radii\n        \n        bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n        \n        constraints = {\n            'type': 'ineq',\n            'fun': constraints_fun,\n            'jac': constraints_jac\n        }\n        \n        res = minimize(\n            objective, \n            v0, \n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 600, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        if res.success and res.fun < best_obj:\n            c_vals = constraints_fun(res.x)\n            if np.all(c_vals >= -1e-4):\n                best_obj = res.fun\n                best_v = res.x\n                \n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n            \n    v = best_v.copy()\n    centers = v.reshape(-1, 3)[:, :2]\n    radii = v.reshape(-1, 3)[:, 2]\n    \n    for i in range(N):\n        max_r = min(centers[i, 0], centers[i, 1], 1.0 - centers[i, 0], 1.0 - centers[i, 1])\n        if radii[i] > max_r:\n            radii[i] = max_r\n            \n    for _ in range(15):\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist:\n                    scale = (dist - 1e-10) / (radii[i] + radii[j])\n                    scale = max(0.0, min(1.0, scale))\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    \n    radii = np.maximum(radii, 0.0)\n    \n    return centers, radii, float(np.sum(radii))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(88)\n\n    for attempt in range(120):\n        if time.time() - start_time > 550:\n            break\n\n        centers = []\n        if attempt % 3 == 0:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 3 == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 4 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.8\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    best_v = None\n    best_sum_r = -1.0\n    start_time = time.time()\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        for _ in range(100):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        if scale < 0:\n                            scale = 0.0\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=200)\n\n    for attempt, seed in enumerate(seeds):\n        if time.time() - start_time > 550:\n            break\n\n        np.random.seed(int(seed))\n\n        centers = []\n        if attempt % 3 == 0:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            centers.extend(np.random.uniform(0.1, 0.9, size=(N - 8, 2)).tolist())\n        elif attempt % 3 == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(200):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n + 1)\n                    gy = np.random.randint(1, grid_n + 1)\n                    px, py = (gx - 0.5) / grid_n, (gy - 0.5) / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 800, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 4 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.8\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 800, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef run_packing():\n    \"\"\"\n    Finds a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii without any overlapping or extending bounds.\n    Returns: centers (N x 2), radii (N), sum_radii (float)\n    \"\"\"\n    N = 26\n    start_time = time.time()\n    \n    # Precompute structural indices for overlap conditions\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n    \n    # Precompute objective logic\n    jac_obj_vec = np.zeros(3 * N)\n    jac_obj_vec[2::3] = -1.0\n    \n    def objective(v):\n        return -np.sum(v[2::3])\n        \n    def jac_objective(v):\n        return jac_obj_vec\n        \n    # Precompute constant portions of the Constraints Jacobian\n    jac_base = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        # x_i - r_i >= 0\n        jac_base[idx, 3 * i] = 1.0\n        jac_base[idx, 3 * i + 2] = -1.0\n        \n        # 1.0 - x_i - r_i >= 0\n        jac_base[idx + 1, 3 * i] = -1.0\n        jac_base[idx + 1, 3 * i + 2] = -1.0\n        \n        # y_i - r_i >= 0\n        jac_base[idx + 2, 3 * i + 1] = 1.0\n        jac_base[idx + 2, 3 * i + 2] = -1.0\n        \n        # 1.0 - y_i - r_i >= 0\n        jac_base[idx + 3, 3 * i + 1] = -1.0\n        jac_base[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n        \n        c = np.empty(num_bounds + num_overlaps)\n        # Vectorized boundary conditions\n        c[0:num_bounds:4] = x - r\n        c[1:num_bounds:4] = 1.0 - x - r\n        c[2:num_bounds:4] = y - r\n        c[3:num_bounds:4] = 1.0 - y - r\n        \n        # Vectorized overlap conditions\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        \n        c[num_bounds:] = dx**2 + dy**2 - sr**2\n        return c\n\n    def constraints_jac(v):\n        jac = jac_base.copy()\n        x = v[0::3\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef solve():\n    N = 26\n    best_v = None\n    best_obj = float('inf')\n    start_time = time.time()\n    \n    # Pre-compute upper triangular indices for vectorization of overlaps\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    \n    def objective(v):\n        \"\"\"Maximize sum of radii => minimize negative sum\"\"\"\n        return -np.sum(v[2::3])\n        \n    def jac_objective(v):\n        \"\"\"Gradient of the objective function\"\"\"\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n        \n    def constraints_fun(v):\n        \"\"\"Evaluate geometric constraints (bounds and overlaps)\"\"\"\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        # Boundary constraints: non-negative values required by SLSQP\n        c_bounds = np.empty(4 * N)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n        \n        # Overlap constraints: distance^2 >= (r_i + r_j)^2\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        c_overlap = dx**2 + dy**2 - (r[idx_i] + r[idx_j])**2\n        \n        return np.concatenate((c_bounds, c_overlap))\n\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n    \n    # Pre-build constant terms of the constraint Jacobian\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx:idx+4, 3*i:3*i+3] = [\n            [ 1.0,  0.0, -1.0],\n            [-1.0,  0.0, -1.0],\n            [ 0.0,  1.0, -1.0],\n            [ 0.0, -1.0, -1.0]\n        ]\n\n    def constraints_jac(v):\n        \"\"\"Jacobian matrix of the geometric constraints\"\"\"\n        jac = jac_template.copy()\n        x, y, r = v[0::3], v[1::3], v[2::3]\n        \n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n        \n        row_idx = num_bounds + np.arange(num_overlaps)\n        \n        jac[row_idx, 3*idx_i] = 2 * dx\n        jac[row_idx, 3*idx_j] = -2 * dx\n        jac[row_idx, 3*idx_i+1] = 2 * dy\n        jac[row_idx, 3*idx_j+1] = -2 * dy\n        jac[row_idx, 3*idx_i+2] = -2 * sr\n        jac[row_idx, 3*idx_j+2] = -2 * sr\n        return jac\n\n    def apply_safety_shrink(v):\n        \"\"\"\n        Absolutely enforce mathematical validity to bypass minor precision drifts.\n        Decreasing radii monotonically guarantees safety without recurring conflicts.\n        \"\"\"\n        x, y, r = v[0::3].copy(), v[1::3].copy(), v[2::3].copy()\n        \n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n            \n        for _ in range(3):\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        scale = max(0.0, (dist - 1e-12) / max(1e-15, r[i] + r[j]))\n                        r[i] *= scale\n                        r[j] *= scale\n                        \n        r = np.maximum(0.0, r)\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n    \n    np.random.seed(42)\n    \n    for attempt in range(250):\n        if time.time() - start_time > 550:\n            break\n            \n        mode = attempt % 4\n        \n        if mode == 0:\n            # Seed strategically around the perimeter\n            base_centers = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95],\n                            [0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n            base_centers += np.random.uniform(0.1, 0.9, (N - 8, 2)).tolist()\n            centers = np.array(base_centers) + np.random.normal(0, 0.01, (N, 2))\n            \n        elif mode == 1:\n            # Physics-based repulsion to evenly distribute seeds\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(100):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.hypot(diff[0], diff[1])\n                        if dist < 0.20:\n                            f = (0.20 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for dim in range(2):\n                    force[:, dim] += np.where(pos[:, dim] < 0.05, (0.05 - pos[:, dim]) * 2, 0)\n                    force[:, dim] -= np.where(pos[:, dim] > 0.95, (pos[:, dim] - 0.95) * 2, 0)\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n            centers = pos\n            \n        elif mode == 2:\n            # Simulated annealing: randomly perturb the best found solution to escape local minima\n            if best_v is not None:\n                centers = best_v.reshape(N, 3)[:, :2] + np.random.normal(0, 0.005, (N, 2))\n            else:\n                centers = np.random.uniform(0.05, 0.95, (N, 2))\n                \n        else:\n            # Grid heuristic with noise\n            grid_n = int(np.ceil(np.sqrt(N)))\n            centers = []\n            for _ in range(N):\n                for _ in range(100):\n                    px = np.random.randint(1, grid_n) / grid_n + np.random.normal(0, 0.015)\n                    py = np.random.randint(1, grid_n) / grid_n + np.random.normal(0, 0.015)\n                    if not centers or min(np.hypot(px - c[0], py - c[1]) for c in centers) > 0.05:\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n            centers = np.array(centers)\n            \n        centers = np.clip(centers, 0.02, 0.98)\n        \n        # Bias the initialization radii size based on distance from the center \n        dist_center = np.hypot(centers[:, 0] - 0.5, centers[:, 1] - 0.5)\n        radii = 0.01 + 0.05 * (1.0 - dist_center / (np.max(dist_center) + 1e-9))\n        \n        v0 = np.zeros(3 * N)\n        v0[0::3], v0[1::3], v0[2::3] = centers[:, 0], centers[:, 1], radii\n        \n        # Perform nonlinear optimization\n        res = minimize(\n            objective, v0, method='SLSQP', jac=jac_objective,\n            bounds=bounds, constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        # Rigorously validate the solution\n        v_safe = apply_safety_shrink(res.x)\n        safe_obj = objective(v_safe)\n        \n        if safe_obj < best_obj:\n            best_obj = safe_obj\n            best_v = v_safe\n\n    # Default fallback to prevent crash in edge case of 0 successful optimizations\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i:3 * i + 3] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9), 0.001]\n\n    v_out = best_v.reshape(N, 3)\n    return v_out[:, :2], v_out[:, 2], float(np.sum(v_out[:, 2]))\n\n\ncenters, radii, sum_radii = solve()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    # Pre-allocate constraint Jacobian template\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        # x_i - r_i >= 0\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n        # 1 - x_i - r_i >= 0\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n        # y_i - r_i >= 0\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n        # 1 - y_i - r_i >= 0\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["import time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    attempt = 0\n    while time.time() - start_time < 540:\n        centers = []\n        mode = attempt % 5\n\n        if mode == 0:\n            cols = 5\n            rows = 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    if len(centers) < N:\n                        x = (c_idx + 0.5 + (r_idx % 2) * 0.5) / (cols + 0.5)\n                        y = (r_idx + 0.5) / rows\n                        centers.append([x, y])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif mode == 1:\n            centers.append([0.5, 0.5])\n            ring1 = 8\n            for i in range(ring1):\n                angle = 2 * np.pi * i / ring1\n                centers.append([0.5 + 0.2 * np.cos(angle), 0.5 + 0.2 * np.sin(angle)])\n            ring2 = 17\n            for i in range(ring2):\n                angle = 2 * np.pi * i / ring2\n                centers.append([0.5 + 0.42 * np.cos(angle), 0.5 + 0.42 * np.sin(angle)])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif mode == 2:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        elif mode == 3:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        else:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers[:N])\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.02 + 0.06 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 3 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            x_sh = v_shake[0::3]\n            y_sh = v_shake[1::3]\n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.hypot(x_sh[i] - x_sh[j], y_sh[i] - y_sh[j])\n                        if dist < 0.15:\n                            dx_ = (x_sh[i] - x_sh[j]) / (dist + 1e-9)\n                            dy_ = (y_sh[i] - y_sh[j]) / (dist + 1e-9)\n                            x_sh[i] += dx_ * 0.005\n                            y_sh[i] += dy_ * 0.005\n                            x_sh[j] -= dx_ * 0.005\n                            y_sh[j] -= dy_ * 0.005\n            \n            v_shake[0::3] = np.clip(x_sh, 0.01, 0.99)\n            v_shake[1::3] = np.clip(y_sh, 0.01, 0.99)\n            v_shake[2::3] *= 0.85 \n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n        attempt += 1\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2].tolist()\n    radii_out = v.reshape(-1, 3)[:, 2].tolist()\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()"]}}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 60, \"failure_stage\": \"stage1\", \"error_type\": \"timeout\"}", "artifact_dir": null, "embedding": null}