{"id": "0c9176bd-9302-4441-bf7b-e2e99817d651", "code": "import time\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef get_optimal_radii(centers):\n    \"\"\"\n    Computes exact mathematically optimal radii for fixed centers\n    using Linear Programming to maximize the sum of radii without any overlaps.\n    \"\"\"\n    n = len(centers)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    bounds = []\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-9)\n    bounds_adj = [(0, max(0, b[1] - 1e-9)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n    except Exception:\n        # Fallback to default if 'highs' is not available\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n        \n    if res.success:\n        return res.x\n    return np.zeros(n)\n\n\ndef rigid_rescale(c, r):\n    \"\"\"\n    Final safety net: rigorously ensure no intersections or out-of-bounds \n    violations exist due to float precision discrepancies.\n    \"\"\"\n    c = np.clip(c, 1e-6, 1 - 1e-6)\n    r = np.maximum(r, 0.0)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    mask = sum_r > 1e-12\n    \n    scale = 1.0\n    if np.any(mask):\n        ratio = dist[mask] / sum_r[mask]\n        scale = min(scale, np.min(ratio))\n        \n    for i in range(len(r)):\n        if r[i] > 1e-12:\n            b_scale = min(c[i, 0] / r[i], (1 - c[i, 0]) / r[i], \n                          c[i, 1] / r[i], (1 - c[i, 1]) / r[i])\n            scale = min(scale, b_scale)\n            \n    # Apply a tight multiplicative buffer\n    return c, r * scale * 0.9999999\n\n\ndef run_packing():\n    \"\"\"\n    Constructs an optimized layout of 26 circles in a unit square.\n    Applies simulated annealing over an Adam optimizer combined \n    with a Linear Programming corrector to perfectly lock bounds.\n    \"\"\"\n    n = 26\n    best_sum = 0.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 60\n    steps = 10000\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        # Time safety escape hatch\n        if time.time() - start_time > 540:\n            break\n            \n        np.random.seed(42 + attempt * 12345)\n        \n        c = np.random.uniform(0.05, 0.95, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n        \n        # Strategic Seed Initializations to help the optimizer\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.25\n            c[1:5] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i+8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+8] = 0.05\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i+1] = [0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(12):\n                ang = 2 * np.pi * i / 12\n                c[i+7] = [0.5 + 0.38 * np.cos(ang), 0.5 + 0.38 * np.sin(ang)]\n                r[i+7] = 0.08\n            for i in range(7):\n                ang = 2 * np.pi * i / 7\n                c[i+19] = [0.5 + 0.48 * np.cos(ang), 0.5 + 0.48 * np.sin(ang)]\n                r[i+19] = 0.05\n        elif attempt == 4:\n            # Corner and edge bias weighting\n            c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        elif attempt == 5:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(5):\n                ang = i * 2 * np.pi / 5\n                c[i+1] = [0.5 + 0.3 * np.cos(ang), 0.5 + 0.3 * np.sin(ang)]\n                r[i+1] = 0.15\n            for i in range(20):\n                ang = i * 2 * np.pi / 20\n                c[i+6] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+6] = 0.05\n        elif attempt == 6:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.25\n        elif attempt == 7:\n            c[0:4] = [[0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:4] = 0.2\n        elif attempt == 8:\n            c[:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[:3] = 0.25\n        elif attempt == 9:\n            c[0] = [0.2, 0.2]; r[0] = 0.2\n            c[1] = [0.8, 0.8]; r[1] = 0.2\n            idx = 2\n            for i in range(5):\n                for j in range(5):\n                    if idx < 26:\n                        c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.05\n                        idx += 1\n        else:\n            if attempt % 2 == 0:\n                c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n            elif attempt % 3 == 0:\n                c[:, 0] = c[:, 0] * 0.8 + 0.1\n                c[:, 1] = c[:, 1] * 0.8 + 0.1\n        \n        # Jitter to avoid local symmetry traps\n        c += np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        mc = np.zeros_like(c)\n        vc = np.zeros_like(c)\n        mr = np.zeros_like(r)\n        vr = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        \n        penalty_start = 10.0\n        penalty_end = 50000.0\n        mult = (penalty_end / penalty_start) ** (1.0 / steps)\n        penalty_weight = penalty_start\n        \n        for step in range(steps):\n            lr = 0.01 * (0.01 ** (step / steps))\n            \n            # Periodically inject exact LP solutions with slight overlap padding\n            # to provoke layout restructuring and escape local maxima.\n            if step in [2000, 4000, 6000, 8000]:\n                c_safe = np.clip(c, 1e-5, 1 - 1e-5)\n                r_lp = get_optimal_radii(c_safe)\n                r = r_lp + np.random.uniform(0.001, 0.005, n)\n                mc.fill(0)\n                vc.fill(0)\n                mr.fill(0)\n                vr.fill(0)\n            \n            gr = np.full(n, -1.0)\n            gc = np.zeros_like(c)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            gr += penalty_weight * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = 2 * penalty_weight * overlap / safe_dist\n            gc -= np.sum(force[..., None] * diff, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            gr += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n            gc[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n            gc[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n            \n            mc = beta1 * mc + (1 - beta1) * gc\n            vc = beta2 * vc + (1 - beta2) * (gc ** 2)\n            mch = mc / (1 - beta1 ** (step + 1))\n            vch = vc / (1 - beta2 ** (step + 1))\n            c -= lr * mch / (np.sqrt(vch) + eps)\n            \n            mr = beta1 * mr + (1 - beta1) * gr\n            vr = beta2 * vr + (1 - beta2) * (gr ** 2)\n            mrh = mr / (1 - beta1 ** (step + 1))\n            vrh = vr / (1 - beta2 ** (step + 1))\n            r -= lr * mrh / (np.sqrt(vrh) + eps)\n            \n            c = np.clip(c, 0.0, 1.0)\n            r = np.maximum(r, 0.0001)\n            \n            penalty_weight *= mult\n\n        # Use Linear Programming for final perfectly constrained radii solve\n        lp_r = get_optimal_radii(c)\n        c_rescaled, r_rescaled = rigid_rescale(c, lp_r)\n        \n        current_sum = np.sum(r_rescaled)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c_rescaled.copy()\n            best_r = r_rescaled.copy()\n\n    return best_c.tolist(), best_r.tolist(), float(best_sum)\n\n\ndef run():\n    return run_packing()\n\n\ndef solve():\n    return run_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run()", "changes_description": null, "language": "python", "parent_id": "c76b2ea4-464e-4f9a-bebb-164562a79205", "generation": 4, "timestamp": 1771884509.890174, "iteration_found": 97, "metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6257, target_ratio: 0.9965, combined_score: 0.9965, radius_variance: 0.0055, spatial_spread: 0.1863, eval_time: 50.2270\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9965)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef get_optimal_radii(centers):\n    \"\"\"\n    Computes exact mathematically optimal radii for fixed centers\n    using Linear Programming to maximize the sum of radii without any overlaps.\n    \"\"\"\n    n = len(centers)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    bounds = []\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-11)\n    bounds_adj = [(0, max(0, b[1] - 1e-11)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n    except Exception:\n        # Fallback to default if 'highs' is not available\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n        \n    if res.success:\n        return res.x\n    return np.zeros(n)\n\ndef rigid_rescale(c, r):\n    \"\"\"\n    Final safety net: rigorously ensure no intersections or out-of-bounds \n    violations exist due to float precision discrepancies.\n    \"\"\"\n    c = np.clip(c, 1e-6, 1 - 1e-6)\n    r = np.maximum(r, 0.0)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    mask = sum_r > 1e-12\n    \n    scale = 1.0\n    if np.any(mask):\n        ratio = dist[mask] / sum_r[mask]\n        scale = min(scale, np.min(ratio))\n        \n    for i in range(len(r)):\n        if r[i] > 1e-12:\n            b_scale = min(c[i, 0] / r[i], (1 - c[i, 0]) / r[i], \n                          c[i, 1] / r[i], (1 - c[i, 1]) / r[i])\n            scale = min(scale, b_scale)\n            \n    # Apply a tight multiplicative buffer\n    return c, r * scale * 0.9999999\n\ndef run_packing():\n    \"\"\"\n    Constructs an optimized layout of 26 circles in a unit square.\n    Applies simulated annealing over an Adam optimizer combined \n    with a Linear Programming corrector to perfectly lock bounds.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 50\n    steps = 8000\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        # Time safety escape hatch\n        if time.time() - start_time > 540:\n            break\n            \n        np.random.seed(42 + attempt * 123)\n        \n        c = np.random.uniform(0.05, 0.95, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n        \n        # Strategic Seed Initializations to help the optimizer\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.25\n            c[1:5] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i+8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+8] = 0.05\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i+1] = [0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(12):\n                ang = 2 * np.pi * i / 12\n                c[i+7] = [0.5 + 0.38 * np.cos(ang), 0.5 + 0.38 * np.sin(ang)]\n                r[i+7] = 0.08\n            for i in range(7):\n                ang = 2 * np.pi * i / 7\n                c[i+19] = [0.5 + 0.48 * np.cos(ang), 0.5 + 0.48 * np.sin(ang)]\n                r[i+19] = 0.05\n        elif attempt == 4:\n            # Corner and edge bias weighting\n            c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        elif attempt == 5:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(5):\n                ang = i * 2 * np.pi / 5\n                c[i+1] = [0.5 + 0.3 * np.cos(ang), 0.5 + 0.3 * np.sin(ang)]\n                r[i+1] = 0.15\n            for i in range(20):\n                ang = i * 2 * np.pi / 20\n                c[i+6] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+6] = 0.05\n        \n        # Jitter to avoid local symmetry traps\n        c += np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        mc = np.zeros_like(c)\n        vc = np.zeros_like(c)\n        mr = np.zeros_like(r)\n        vr = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        \n        penalty_start = 10.0\n        penalty_end = 50000.0\n        mult = (penalty_end / penalty_start) ** (1.0 / steps)\n        penalty_weight = penalty_start\n        \n        for step in range(steps):\n            lr = 0.01 * (0.01 ** (step / steps))\n            \n            gr = np.full(n, -1.0)\n            gc = np.zeros_like(c)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            gr += penalty_weight * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = 2 * penalty_weight * overlap / safe_dist\n            gc -= np.sum(force[..., None] * diff, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            gr += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n            gc[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n            gc[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n            \n            mc = beta1 * mc + (1 - beta1) * gc\n            vc = beta2 * vc + (1 - beta2) * (gc ** 2)\n            mch = mc / (1 - beta1 ** (step + 1))\n            vch = vc / (1 - beta2 ** (step + 1))\n            c -= lr * mch / (np.sqrt(vch) + eps)\n            \n            mr = beta1 * mr + (1 - beta1) * gr\n            vr = beta2 * vr + (1 - beta2) * (gr ** 2)\n            mrh = mr / (1 - beta1 ** (step + 1))\n            vrh = vr / (1 - beta2 ** (step + 1))\n            r -= lr * mrh / (np.sqrt(vrh) + eps)\n            \n            c = np.clip(c, 0.0, 1.0)\n            r = np.maximum(r, 0.0001)\n            \n            penalty_weight *= mult\n\n        # Use Linear Programming for final perfectly constrained radii solve\n        lp_r = get_optimal_radii(c)\n        c_rescaled, r_rescaled = rigid_rescale(c, lp_r)\n        \n        current_sum = np.sum(r_rescaled)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c_rescaled.copy()\n            best_r = r_rescaled.copy()\n\n    return best_c.tolist(), best_r.tolist(), float(best_sum)\n\ndef run():\n    return run_packing()\n\nif __name__ == \"__main__\":\n    c, r, s = run()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6257), Performs well on target_ratio (0.9965), Performs well on combined_score (0.9965), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1863), Performs well on eval_time (50.2270)\n\n### Program 2 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\n\n\ndef run():\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 15000\n\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 1001)\n        \n        c = np.random.rand(n, 2)\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        c = np.clip(c, 0.05, 0.95)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        if attempt == 0:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.25\n            c[1:5] = [[0.15, 0.15], [0.85, 0.15], [0.15, 0.85], [0.85, 0.85]]\n            r[1:5] = 0.15\n        elif attempt == 1:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]\n            r[0:2] = 0.2\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]\n                    r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]\n            r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 4:\n            c[0:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]\n            r[0:3] = 0.25\n        elif attempt == 5:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i+1] = [0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)]\n                r[i+1] = 0.08\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i+8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+8] = 0.05\n                \n        c += np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n            \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        lr_start = 0.01\n        lr_end = 0.0001\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        \n        penalty_start = 10.0\n        penalty_end = 50000.0\n        \n        for step in range(steps):\n            progress = step / steps\n            lr = lr_start * ((lr_end / lr_start) ** progress)\n            lambda_pen = penalty_start * ((penalty_end / penalty_start) ** progress)\n            \n            grad_c = np.zeros_like(c)\n            grad_r = np.full(n, -1.0)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            grad_r += lambda_pen * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = (2 * lambda_pen * overlap / safe_dist)[..., None] * diff\n            grad_c -= np.sum(force, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            grad_r += lambda_pen * 2 * (bx_min + bx_max + by_min + by_max)\n            grad_c[:, 0] += lambda_pen * 2 * (-bx_min + bx_max)\n            grad_c[:, 1] += lambda_pen * 2 * (-by_min + by_max)\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** (step + 1))\n            v_c_hat = v_c / (1 - beta2 ** (step + 1))\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** (step + 1))\n            v_r_hat = v_r / (1 - beta2 ** (step + 1))\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            c = np.clip(c, 1e-5, 1 - 1e-5)\n            r = np.maximum(r, 1e-5)\n            \n        for _ in range(5000):\n            r = np.minimum(r, c[:, 0])\n            r = np.minimum(r, 1 - c[:, 0])\n            r = np.minimum(r, c[:, 1])\n            r = np.minimum(r, 1 - c[:, 1])\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = sum_r - dist\n            \n            max_overlap = np.max(overlap)\n            if max_overlap <= 1e-9:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            total = r[i] + r[j]\n            if total > 1e-12:\n                shrink_i = max_overlap * (r[i] / total) + 1e-9\n                shrink_j = max_overlap * (r[j] / total) + 1e-9\n                r[i] = max(0, r[i] - shrink_i)\n                r[j] = max(0, r[j] - shrink_j)\n                \n        scale = 1.0\n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        sum_r_val_arr = r[:, None] + r[None, :]\n        \n        safe_sum_r = np.where(sum_r_val_arr < 1e-12, 1e-12, sum_r_val_arr)\n        ratios = dist / safe_sum_r\n        min_ratio = np.min(ratios)\n        if min_ratio < 1.0:\n            scale = min(scale, min_ratio)\n            \n        for i in range(n):\n            if r[i] > 1e-12:\n                if c[i, 0] / r[i] < scale: \n                    scale = c[i, 0] / r[i]\n                if (1 - c[i, 0]) / r[i] < scale: \n                    scale = (1 - c[i, 0]) / r[i]\n                if c[i, 1] / r[i] < scale: \n                    scale = c[i, 1] / r[i]\n                if (1 - c[i, 1]) / r[i] < scale: \n                    scale = (1 - c[i, 1]) / r[i]\n                \n        r *= scale * 0.999999\n        sum_r_val = float(np.sum(r))\n        \n        if sum_r_val > best_sum:\n            best_sum = sum_r_val\n            best_c = c.copy()\n            best_r = r.copy()\n            \n    return best_c.tolist(), best_r.tolist(), best_sum\n\n\ndef run_packing():\n    return run()\n\n\ndef solve():\n    return run()\n\n\nif __name__ == \"__main__\":\n    run()\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef get_fallback_packing(n=26):\n    \"\"\"\n    Generate a strictly valid baseline grid packing as a safety fallback.\n    \"\"\"\n    grid_dim = int(np.ceil(np.sqrt(n)))\n    c = []\n    r = []\n    idx = 0\n    step = 1.0 / grid_dim\n    for i in range(grid_dim):\n        for j in range(grid_dim):\n            if idx < n:\n                c.append([step / 2 + i * step, step / 2 + j * step])\n                r.append(step / 2 * 0.9)\n                idx += 1\n    return c, r, float(np.sum(r))\n\n\ndef get_initial_state(attempt, n):\n    \"\"\"\n    Generate diverse initial conditions to thoroughly explore the search space.\n    Different modes bias the random starting positions in strategic ways.\n    \"\"\"\n    np.random.seed(42 + attempt * 123)\n    c = np.random.rand(n, 2)\n    r = np.random.rand(n) * 0.03 + 0.01\n    \n    mode = attempt % 8\n    if mode == 0:\n        # Bias towards corners and edges\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n    elif mode == 1:\n        # Central clump bias\n        c[:, 0] = c[:, 0] * 0.8 + 0.1\n        c[:, 1] = c[:, 1] * 0.8 + 0.1\n    elif mode == 2:\n        # Concentric rings\n        c[0] = [0.5, 0.5]; r[0] = 0.2\n        for i in range(1, 8):\n            ang = (i - 1) * 2 * np.pi / 7\n            c[i] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n            r[i] = 0.1\n        for i in range(8, n):\n            ang = (i - 8) * 2 * np.pi / (n - 8)\n            c[i] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n            r[i] = 0.05\n    elif mode == 3:\n        # Extreme corner bias\n        c = np.where(c < 0.5, c ** 2, 1 - (1 - c) ** 2)\n    elif mode == 4:\n        # Hexagonal-like staggered grid\n        grid_dim_x = 5\n        grid_dim_y = 6\n        idx = 0\n        for i in range(grid_dim_x):\n            for j in range(grid_dim_y):\n                if idx < n:\n                    offset = 0.5 if j % 2 == 1 else 0.0\n                    c[idx] = [0.1 + (i + offset) * 0.8 / grid_dim_x, 0.\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n```python\nimport numpy as np\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii without any overlaps.\n    \n    This implementation uses a physics-based iterative Adam optimizer\n    with dynamic barrier penalties (simulated annealing approach) to find\n    dense packings. Strategic initial placements, breaking of perfect symmetry,\n    and targeted local repair guarantee high-quality valid configurations.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Use 60 diverse initializations to thoroughly explore the search space.\n    # We do 20,000 steps of Adam per initialization.\n    num_restarts = 60\n    steps = 20000\n\n    for attempt in range(num_restarts):\n        c = np.zeros((n, 2))\n        r = np.zeros(n)\n        \n        # Strategic initializations: Seed shapes to naturally emerge in globally optimal packings\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            c[1:5] = [[0.1, 0.1], [0.9, 0.1], [0.1, 0.9], [0.9, 0.9]]; r[1:5] = 0.1\n            for i in range(5, n):\n                c[i] = np.random.uniform(0.1, 0.9, 2); r[i] = 0.05\n        elif attempt == 1:\n            # Concentric\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 2:\n            # Grid layout\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.05\n        elif attempt == 3:\n            # Spiral\n            for i in range(n):\n                ang = i * 2.4\n                rad = 0.05 + 0.4 * (i / n)\n                c[i] = [0.5 + rad * np.cos(ang), 0.5 + rad * np.sin(ang)]\n                r\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef objective(x, n, penalty_weight):\n    \"\"\"\n    Computes the loss and gradient for a continuous physics-based penalty method.\n    The objective expands radii, while squared penalties enforce physical bounds.\n    \"\"\"\n    c = x[:n * 2].reshape((n, 2))\n    r = x[n * 2:]\n    \n    # Objective: minimize -sum(radii)\n    obj = -np.sum(r)\n    \n    # Calculate pairwise differences and distances\n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    overlap = np.maximum(0, sum_r - dist)\n    \n    # Calculate boundary violations\n    bx_min = np.maximum(0, r - c[:, 0])\n    bx_max = np.maximum(0, c[:, 0] + r - 1)\n    by_min = np.maximum(0, r - c[:, 1])\n    by_max = np.maximum(0, c[:, 1] + r - 1)\n    \n    # Squared penalty terms for continuous and smooth gradients\n    penalty = (np.sum(overlap**2) / 2 + \n               np.sum(bx_min**2) + np.sum(bx_max**2) + \n               np.sum(by_min**2) + np.sum(by_max**2))\n               \n    loss = obj + penalty_weight * penalty\n    \n    # Compute Exact Gradients\n    grad_c = np.zeros_like(c)\n    grad_r = np.full(n, -1.0)\n    \n    # Gradients from pairwise overlaps\n    grad_r += penalty_weight * 2 * np.sum(overlap, axis=1)\n    \n    safe_dist = np.where(dist < 1e-8, 1.0, dist)\n    force = penalty_weight * 2 * (overlap / safe_dist)[..., None] * diff\n    grad_c -= np.sum(force, axis=1)\n    \n    # Gradients from boundary violations\n    grad_r += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n    grad_c[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n    grad_c[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n    \n    return loss, np.concatenate([grad_c.flatten(), grad_r])\n\n\ndef make_valid_lp(c):\n    \"\"\"\n    Uses exact Linear Programming to perfectly squeeze the maximum valid radii \n    into a given set of fixed centers without any pairwise or boundary overlaps.\n    \"\"\"\n    n = len(c)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.3333, Type: Exploratory)\n```python\nimport time\nimport numpy as np\n\n\ndef run():\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 15000\n\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 1001)\n        \n        c = np.random.rand(n, 2)\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        c = np.clip(c, 0.05, 0.95)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        if attempt == 0:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.25\n            c[1:5] = [[0.15, 0.15], [0.85, 0.15], [0.15, 0.85], [0.85, 0.85]]\n            r[1:5] = 0.15\n        elif attempt == 1:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]\n            r[0:2] = 0.2\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]\n                    r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]\n            r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+9] = 0.05\n        elif attempt == 4:\n            c[0:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]\n            r[0:3] = 0.25\n        elif attempt == 5:\n            c[0] = [0.5, 0.5]\n            r[0] = 0.2\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i+1] = [0.5 + 0.28 * np.cos(ang), 0.5 + 0.28 * np.sin(ang)]\n                r[i+1] = 0.08\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i+8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+8] = 0.05\n                \n        c += np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n            \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        lr_start = 0.01\n        lr_end = 0.0001\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        \n        penalty_start = 10.0\n        penalty_end = 50000.0\n        \n        for step in range(steps):\n            progress = step / steps\n            lr = lr_start * ((lr_end / lr_start) ** progress)\n            lambda_pen = penalty_start * ((penalty_end / penalty_start) ** progress)\n            \n            grad_c = np.zeros_like(c)\n            grad_r = np.full(n, -1.0)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            grad_r += lambda_pen * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = (2 * lambda_pen * overlap / safe_dist)[..., None] * diff\n            grad_c -= np.sum(force, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            grad_r += lambda_pen * 2 * (bx_min + bx_max + by_min + by_max)\n            grad_c[:, 0] += lambda_pen * 2 * (-bx_min + bx_max)\n            grad_c[:, 1] += lambda_pen * 2 * (-by_min + by_max)\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** (step + 1))\n            v_c_hat = v_c / (1 - beta2 ** (step + 1))\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** (step + 1))\n            v_r_hat = v_r / (1 - beta2 ** (step + 1))\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            c = np.clip(c, 1e-5, 1 - 1e-5)\n            r = np.maximum(r, 1e-5)\n            \n        for _ in range(5000):\n            r = np.minimum(r, c[:, 0])\n            r = np.minimum(r, 1 - c[:, 0])\n            r = np.minimum(r, c[:, 1])\n            r = np.minimum(r, 1 - c[:, 1])\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = sum_r - dist\n            \n            max_overlap = np.max(overlap)\n            if max_overlap <= 1e-9:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            total = r[i] + r[j]\n            if total > 1e-12:\n                shrink_i = max_overlap * (r[i] / total) + 1e-9\n                shrink_j = max_overlap * (r[j] / total) + 1e-9\n                r[i] = max(0, r[i] - shrink_i)\n                r[j] = max(0, r[j] - shrink_j)\n                \n        scale = 1.0\n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        sum_r_val_arr = r[:, None] + r[None, :]\n        \n        safe_sum_r = np.where(sum_r_val_arr < 1e-12, 1e-12, sum_r_val_arr)\n        ratios = dist / safe_sum_r\n        min_ratio = np.min(ratios)\n        if min_ratio < 1.0:\n            scale = min(scale, min_ratio)\n            \n        for i in range(n):\n            if r[i] > 1e-12:\n                if c[i, 0] / r[i] < scale: \n                    scale = c[i, 0] / r[i]\n                if (1 - c[i, 0]) / r[i] < scale: \n                    scale = (1 - c[i, 0]) / r[i]\n                if c[i, 1] / r[i] < scale: \n                    scale = c[i, 1] / r[i]\n                if (1 - c[i, 1]) / r[i] < scale: \n                    scale = (1 - c[i, 1]) / r[i]\n                \n        r *= scale * 0.999999\n        sum_r_val = float(np.sum(r))\n        \n        if sum_r_val > best_sum:\n            best_sum = sum_r_val\n            best_c = c.copy()\n            best_r = r.copy()\n            \n    return best_c.tolist(), best_r.tolist(), best_sum\n\n\ndef run_packing():\n    return run()\n\n\ndef solve():\n    return run()\n\n\nif __name__ == \"__main__\":\n    run()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nimport time\nimport numpy as np\n\ntry:\n    from scipy.optimize import linprog\n    HAS_SCIPY = True\nexcept ImportError:\n    HAS_SCIPY = False\n\ndef get_optimal_radii(c, r_init):\n    if not HAS_SCIPY:\n        return r_init\n    n = len(c)\n    c_obj = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(np.linalg.norm(c[i] - c[j]))\n    bounds = []\n    for i in range(n):\n        max_r = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-9)\n    bounds_adj = [(0, max(0, b[1] - 1e-9)) for b in bounds]\n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n        if res.success:\n            return res.x\n    except Exception:\n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n            if res.success:\n                return res.x\n        except Exception:\n            pass\n    return r_init\n\ndef run():\n    n = 26\n    best_sum_r = -1.0\n    best_c = None\n    best_r = None\n    \n    num_attempts = 40\n    steps = 4000\n    start_time = time.time()\n    \n    for attempt in range(num_attempts):\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 100)\n        c = np.random.rand(n, 2)\n        c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        r = np.random.rand(n) * 0.03 + 0.01\n        \n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            c[1:5] = [[0.15, 0.15], [0.85, 0.15], [0.15, 0.85], [0.85, 0.85]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.2\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    if idx < n:\n                        c[idx] = [0.1 + i*0.2, 0.1 + j*0.2]; r[idx] = 0.08\n                        idx += 1\n            if 25 < n:\n                c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                if i+1 < n:\n                    c[i+1] = [0.5 + 0.25*np.cos(ang), 0.5 + 0.25*np.sin(ang)]\n                    r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                if i+9 < n:\n                    c[i+9] = [0.5 + 0.45*np.cos(ang), 0.5 + 0.45*np.sin(ang)]\n                    r[i+9] = 0.05\n        elif attempt == 4:\n            c[0:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:3] = 0.25\n        else:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(1, 7):\n                ang = i * 2 * np.pi / 6 + np.random.rand()*0.2\n                if i < n:\n                    c[i] = [0.5 + 0.25*np.cos(ang), 0.5 + 0.25*np.sin(ang)]\n                    r[i] = 0.1\n            for i in range(7, n):\n                ang = i * 2 * np.pi / max(1, n - 7) + np.random.rand()*0.2\n                c[i] = [0.5 + 0.45*np.cos(ang), 0.5 + 0.45*np.sin(ang)]\n                r[i] = 0.05\n                \n        c += np.random.normal(0, 1e-4, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        lr_start = 0.01\n        lr_end = 0.001\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        pen_start = 10.0\n        pen_end = 100000.0\n        \n        for step in range(steps):\n            frac = step / max(1, steps - 1)\n            lr = lr_start * ((lr_end / lr_start) ** frac)\n            lambda_pen = pen_start * ((pen_end / pen_start) ** frac)\n            \n            grad_c = np.zeros_like(c)\n            grad_r = np.full(n, -1.0)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            grad_r += lambda_pen * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1e-8, dist)\n            force = (2 * lambda_pen * overlap / safe_dist)[..., None] * diff\n            grad_c -= np.sum(force, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            grad_r += lambda_pen * 2 * (bx_min + bx_max + by_min + by_max)\n            grad_c[:, 0] += lambda_pen * 2 * (-bx_min + bx_max)\n            grad_c[:, 1] += lambda_pen * 2 * (-by_min + by_max)\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** (step + 1))\n            v_c_hat = v_c / (1 - beta2 ** (step + 1))\n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** (step + 1))\n            v_r_hat = v_r / (1 - beta2 ** (step + 1))\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            c = np.clip(c, 1e-5, 1 - 1e-5)\n            r = np.maximum(r, 1e-5)\n            \n        r = get_optimal_radii(c, r)\n        \n        r = np.minimum(r, c[:, 0])\n        r = np.minimum(r, 1 - c[:, 0])\n        r = np.minimum(r, c[:, 1])\n        r = np.minimum(r, 1 - c[:, 1])\n        r = np.maximum(r, 0)\n        \n        for _ in range(2000):\n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            sum_r = r[:, None] + r[None, :]\n            overlap = sum_r - dist\n            max_overlap = np.max(overlap)\n            if max_overlap <= 1e-9:\n                break\n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            total = r[i] + r[j]\n            if total > 0:\n                shrink_i = max_overlap * (r[i] / total) + 1e-9\n                shrink_j = max_overlap * (r[j] / total) + 1e-9\n                r[i] = max(0, r[i] - shrink_i)\n                r[j] = max(0, r[j] - shrink_j)\n                \n        scale = 1.0\n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        sum_r = r[:, None] + r[None, :]\n        safe_sum_r = np.where(sum_r < 1e-12, 1e-12, sum_r)\n        ratios = dist / safe_sum_r\n        min_ratio = np.min(ratios)\n        if min_ratio < 1.0:\n            scale = min(scale, min_ratio)\n            \n        for i in range(n):\n            if r[i] > 1e-12:\n                scale = min(scale, c[i, 0] / r[i])\n                scale = min(scale, (1 - c[i, 0]) / r[i])\n                scale = min(scale, c[i, 1] / r[i])\n                scale = min(scale, (1 - c[i, 1]) / r[i])\n                \n        r *= scale * 0.9999999\n        sum_r_val = np.sum(r)\n        \n        if sum_r_val > best_sum_r:\n            best_sum_r = sum_r_val\n            best_c = c.copy()\n            best_r = r.copy()\n            \n    return best_c.tolist(), best_r.tolist()\n\ndef solve():\n    return run()\n\ndef construct_packing():\n    return run()\n\nif __name__ == \"__main__\":\n    centers, radii = run()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef make_valid_lp(c):\n    \"\"\"\n    Given fixed center coordinates, calculate the absolutely optimal radii\n    that maximize their sum without causing any pairwise or boundary overlaps\n    using Linear Programming.\n    \"\"\"\n    n = len(c)\n    # Objective: maximize sum of radii -> minimize -sum(radii)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    # Pairwise non-overlapping constraints: r_i + r_j <= dist(c_i, c_j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(np.linalg.norm(c[i] - c[j]))\n            \n    # Boundary constraints: r_i <= min distance to any of the 4 edges\n    bounds = []\n    for i in range(n):\n        max_r = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        bounds.append((0, max(0, max_r)))\n        \n    b_ub = np.array(b_ub)\n    \n    # Subtract a tiny epsilon to ensure strict compliance against floating point noise\n    eps = 1e-10\n    b_ub = np.maximum(0, b_ub - eps)\n    bounds = [(0, max(0, b[1] - eps)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    except Exception:\n        # Fallback if highs method is somehow unavailable\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        \n    if res.success:\n        return res.x\n    else:\n        return np.zeros(n)\n\n\ndef rigid_rescale(c, r):\n    \"\"\"\n    Final safety net: slightly scale down radii globally based on the worst-case \n    violation to guarantee 100% compliance with evaluator strictness.\n    \"\"\"\n    c = np.clip(c, 1e-6, 1 - 1e-6)\n    r = np.maximum(r, 0.0)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    mask = sum_r > 1e-9\n    \n    ratio = np.ones_like(dist)\n    ratio[mask] = dist[mask] / sum_r[mask]\n    \n    scale = min(1.0, np.min(ratio))\n    \n    for i in range(len(r)):\n        if r[i] > 1e-9:\n            b_scale = min(c[i, 0] / r[i], (1 - c[i, 0]) / r[i], c[i, 1] / r[i], (1 - c[i, 1]) / r[i])\n            scale = min(scale, b_scale)\n            \n    # Apply 0.999999 to guarantee clearance\n    return c, r * scale * 0.999999\n\n\ndef get_gradients(c, r, penalty_weight):\n    \"\"\"\n    Compute physics-based repulsive forces and expansion gradients.\n    \"\"\"\n    n = len(r)\n    gr = np.full(n, -1.0)\n    gc = np.zeros_like(c)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    overlap = np.maximum(0, sum_r - dist)\n    \n    # Accumulate gradients for radii\n    gr += penalty_weight * np.sum(2 * overlap, axis=1)\n    \n    # Accumulate gradients for centers (pairwise repulsion)\n    safe_dist = np.where(dist < 1e-8, 1.0, dist)\n    force_mag = 2 * penalty_weight * overlap / safe_dist\n    gc -= np.sum(force_mag[..., None] * diff, axis=1)\n    \n    # Boundary violations\n    bx_min = np.maximum(0, r - c[:, 0])\n    bx_max = np.maximum(0, c[:, 0] + r - 1)\n    by_min = np.maximum(0, r - c[:, 1])\n    by_max = np.maximum(0, c[:, 1] + r - 1)\n    \n    gr += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n    gc[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n    gc[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n    \n    return gc, gr\n\n\ndef generate_initial_states(n=26, num_restarts=30):\n    \"\"\"\n    Seed initial positions strategically to maximize space utilization.\n    Provides a mix of patterned (rings, grids) and random starting configurations.\n    \"\"\"\n    states = []\n    for r_idx in range(num_restarts):\n        np.random.seed(42 + r_idx * 1337)\n        \n        # Base random configuration\n        c = np.random.rand(n, 2) * 0.8 + 0.1\n        r = np.random.rand(n) * 0.05 + 0.01\n        \n        # Strategic starting layouts\n        if r_idx == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.25\n            c[1:5] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[1:5] = 0.15\n        elif r_idx == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25*np.cos(ang), 0.5 + 0.25*np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45*np.cos(ang), 0.5 + 0.45*np.sin(ang)]\n                r[i+9] = 0.05\n        elif r_idx == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i*0.2, 0.1 + j*0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif r_idx == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i+1] = [0.5 + 0.2*np.cos(ang), 0.5 + 0.2*np.sin(ang)]; r[i+1] = 0.1\n            for i in range(12):\n                ang = 2 * np.pi * i / 12\n                c[i+7] = [0.5 + 0.38*np.cos(ang), 0.5 + 0.38*np.sin(ang)]; r[i+7] = 0.08\n            for i in range(7):\n                ang = 2 * np.pi * i / 7\n                c[i+19] = [0.5 + 0.48*np.cos(ang), 0.5 + 0.48*np.sin(ang)]; r[i+19] = 0.05\n        elif r_idx == 4:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.25\n        elif r_idx == 5:\n            c[0:4] = [[0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:4] = 0.2\n        elif r_idx == 6:\n            c[:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[:3] = 0.25\n            \n        # Tiny random perturbation to break perfect symmetry\n        c += np.random.normal(0, 1e-4, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        states.append((c, r))\n    return states\n\n\ndef run_packing():\n    \"\"\"\n    Main execution entry point. Combines continuous gradient descent (Adam) \n    with LP-driven relaxation to bounce out of local optima and discover \n    highly optimized packings.\n    \"\"\"\n    n = 26\n    states = generate_initial_states(n, num_restarts=30)\n    best_sum = 0\n    best_c = None\n    best_r = None\n    \n    steps = 10000\n    \n    for _, (c_init, r_init) in enumerate(states):\n        c = c_init.copy()\n        r = r_init.copy()\n        \n        # Adam optimizer state variables\n        mc = np.zeros_like(c)\n        vc = np.zeros_like(c)\n        mr = np.zeros_like(r)\n        vr = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        \n        # Exponentially escalating penalty weight (Simulated Annealing analog)\n        penalty_start = 1.0\n        penalty_end = 1e5\n        mult = (penalty_end / penalty_start) ** (1.0 / steps)\n        penalty_weight = penalty_start\n        \n        for step in range(steps):\n            # Smoothly decaying learning rate\n            lr = 0.005 * (0.1 ** (step / steps))\n            \n            # Periodically inject exact LP solutions with slight overlap padding \n            # to provoke layout restructuring and escape local maxima.\n            if step in [4000, 7000, 9000]:\n                c = np.clip(c, 1e-5, 1 - 1e-5)\n                r_lp = make_valid_lp(c)\n                r = r_lp + np.random.uniform(0.001, 0.005, n)\n                mr.fill(0); vr.fill(0)\n                mc.fill(0); vc.fill(0)\n                \n            gc, gr = get_gradients(c, r, penalty_weight)\n            \n            mc = beta1 * mc + (1 - beta1) * gc\n            vc = beta2 * vc + (1 - beta2) * (gc ** 2)\n            mch = mc / (1 - beta1 ** (step + 1))\n            vch = vc / (1 - beta2 ** (step + 1))\n            c -= lr * mch / (np.sqrt(vch) + eps)\n            \n            mr = beta1 * mr + (1 - beta1) * gr\n            vr = beta2 * vr + (1 - beta2) * (gr ** 2)\n            mrh = mr / (1 - beta1 ** (step + 1))\n            vrh = vr / (1 - beta2 ** (step + 1))\n            r -= lr * mrh / (np.sqrt(vrh) + eps)\n            \n            c = np.clip(c, 0.0, 1.0)\n            r = np.maximum(r, 1e-5)\n            \n            penalty_weight *= mult\n            \n        # Extrapolate perfect solution using LP for current layout\n        c = np.clip(c, 1e-5, 1 - 1e-5)\n        r_lp = make_valid_lp(c)\n        \n        # Guaranteed evaluator clearance\n        c_rescaled, r_rescaled = rigid_rescale(c, r_lp)\n        \n        current_sum = np.sum(r_rescaled)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c_rescaled.copy()\n            best_r = r_rescaled.copy()\n            \n    return best_c, best_r\n\n\nif __name__ == \"__main__\":\n    run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef get_optimal_radii(centers):\n    n = len(centers)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    bounds = []\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-11)\n    bounds_adj = [(0, max(0, b[1] - 1e-11)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n    except Exception:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n        \n    if res.success:\n        return res.x\n    return np.zeros(n)\n\ndef solve():\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 40\n    steps = 15000\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        if time.time() - start_time > 550:\n            break\n            \n        np.random.seed(42 + attempt * 17)\n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n        \n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(8):\n                ang = i * 2 * np.pi / 8\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]; r[i+1] = 0.1\n            for i in range(17):\n                ang = i * 2 * np.pi / 17\n                c[i+9] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]; r[i+9] = 0.05\n        elif attempt == 1:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 2:\n            c[0] = [0.5, 0.5]; r[0] = 0.18\n            for i in range(5):\n                ang = 2 * np.pi * i / 5\n                c[i+1] = [0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)]; r[i+1] = 0.1\n            for i in range(10):\n                ang = 2 * np.pi * i / 10\n                c[i+6] = [0.5 + 0.38 * np.cos(ang), 0.5 + 0.38 * np.sin(ang)]; r[i+6] = 0.08\n            for i in range(10):\n                ang = 2 * np.pi * i / 10 + 0.1\n                c[i+16] = [0.5 + 0.48 * np.cos(ang), 0.5 + 0.48 * np.sin(ang)]; r[i+16] = 0.05\n        elif attempt == 3:\n            c[0:4] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[0:4] = 0.15\n        elif attempt == 4:\n            c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        elif attempt == 5:\n            c[:, 0] = c[:, 0] * 0.8 + 0.1\n            c[:, 1] = c[:, 1] * 0.8 + 0.1\n        elif attempt == 6:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.2\n        elif attempt == 7:\n            for i in range(6):\n                ang = 2 * np.pi * i / 6 + 0.1\n                c[i] = [0.5 + 0.3 * np.cos(ang), 0.5 + 0.3 * np.sin(ang)]; r[i] = 0.15\n        else:\n            if attempt % 2 == 0:\n                c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n                \n        c += np.random.normal(0, 1e-4, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        mc = np.zeros_like(c)\n        vc = np.zeros_like(c)\n        mr = np.zeros_like(r)\n        vr = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        \n        penalty_start = 1.0\n        penalty_end = 10000.0\n        mult = (penalty_end / penalty_start) ** (1.0 / steps)\n        penalty_weight = penalty_start\n        \n        for step in range(steps):\n            lr = 0.005 * (0.1 ** (step / steps))\n            \n            if step in [steps // 3, 2 * steps // 3]:\n                c_safe = np.clip(c, 1e-5, 1 - 1e-5)\n                r_lp = get_optimal_radii(c_safe)\n                r = r_lp + np.random.uniform(0.001, 0.005, n)\n                mc.fill(0)\n                vc.fill(0)\n                mr.fill(0)\n                vr.fill(0)\n                \n            gr = np.full(n, -1.0)\n            gc = np.zeros_like(c)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            gr += penalty_weight * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = 2 * penalty_weight * overlap / safe_dist\n            gc -= np.sum(force[..., None] * diff, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            gr += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n            gc[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n            gc[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n            \n            mc = beta1 * mc + (1 - beta1) * gc\n            vc = beta2 * vc + (1 - beta2) * (gc ** 2)\n            mch = mc / (1 - beta1 ** (step + 1))\n            vch = vc / (1 - beta2 ** (step + 1))\n            c -= lr * mch / (np.sqrt(vch) + eps)\n            \n            mr = beta1 * mr + (1 - beta1) * gr\n            vr = beta2 * vr + (1 - beta2) * (gr ** 2)\n            mrh = mr / (1 - beta1 ** (step + 1))\n            vrh = vr / (1 - beta2 ** (step + 1))\n            r -= lr * mrh / (np.sqrt(vrh) + eps)\n            \n            c = np.clip(c, 0.0, 1.0)\n            r = np.maximum(r, 0.0001)\n            \n            penalty_weight *= mult\n\n        c = np.clip(c, 1e-6, 1 - 1e-6)\n        r_lp = get_optimal_radii(c)\n        r_lp = np.maximum(r_lp, 0.0)\n        \n        diff = c[:, None, :] - c[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_r = r_lp[:, None] + r_lp[None, :]\n        mask = sum_r > 1e-9\n        \n        if np.any(mask):\n            ratio = dist[mask] / sum_r[mask]\n            scale = min(1.0, np.min(ratio))\n        else:\n            scale = 1.0\n            \n        for i in range(len(r_lp)):\n            if r_lp[i] > 1e-9:\n                b_scale = min(c[i, 0] / r_lp[i], (1 - c[i, 0]) / r_lp[i], \n                              c[i, 1] / r_lp[i], (1 - c[i, 1]) / r_lp[i])\n                scale = min(scale, b_scale)\n                \n        r_safe = r_lp * scale * 0.9999999\n        \n        current_sum = np.sum(r_safe)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c.copy()\n            best_r = r_safe.copy()\n            \n    return best_c.tolist(), best_r.tolist()\n\ndef run():\n    return solve()\n\nif __name__ == '__main__':\n    run()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport time\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef get_optimal_radii(centers):\n    \"\"\"\n    Computes exact mathematically optimal radii for fixed centers\n    using Linear Programming to maximize the sum of radii without any overlaps.\n    \"\"\"\n    n = len(centers)\n    c_obj = -np.ones(n)\n    \n    A_ub = []\n    b_ub = []\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n            \n    bounds = []\n    for i in range(n):\n        max_r = min(centers[i, 0], 1 - centers[i, 0], centers[i, 1], 1 - centers[i, 1])\n        bounds.append((0, max(0.0, max_r)))\n        \n    b_ub_arr = np.maximum(0, np.array(b_ub) - 1e-9)\n    bounds_adj = [(0, max(0, b[1] - 1e-9)) for b in bounds]\n    \n    try:\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj, method='highs')\n    except Exception:\n        # Fallback to default if 'highs' is not available\n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub_arr, bounds=bounds_adj)\n        \n    if res.success:\n        return res.x\n    return np.zeros(n)\n\n\ndef rigid_rescale(c, r):\n    \"\"\"\n    Final safety net: rigorously ensure no intersections or out-of-bounds \n    violations exist due to float precision discrepancies.\n    \"\"\"\n    c = np.clip(c, 1e-6, 1 - 1e-6)\n    r = np.maximum(r, 0.0)\n    \n    diff = c[:, None, :] - c[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n    \n    sum_r = r[:, None] + r[None, :]\n    mask = sum_r > 1e-12\n    \n    scale = 1.0\n    if np.any(mask):\n        ratio = dist[mask] / sum_r[mask]\n        scale = min(scale, np.min(ratio))\n        \n    for i in range(len(r)):\n        if r[i] > 1e-12:\n            b_scale = min(c[i, 0] / r[i], (1 - c[i, 0]) / r[i], \n                          c[i, 1] / r[i], (1 - c[i, 1]) / r[i])\n            scale = min(scale, b_scale)\n            \n    # Apply a tight multiplicative buffer\n    return c, r * scale * 0.9999999\n\n\ndef run_packing():\n    \"\"\"\n    Constructs an optimized layout of 26 circles in a unit square.\n    Applies simulated annealing over an Adam optimizer combined \n    with a Linear Programming corrector to perfectly lock bounds.\n    \"\"\"\n    n = 26\n    best_sum = 0.0\n    best_c = None\n    best_r = None\n\n    num_restarts = 60\n    steps = 10000\n    start_time = time.time()\n\n    for attempt in range(num_restarts):\n        # Time safety escape hatch\n        if time.time() - start_time > 540:\n            break\n            \n        np.random.seed(42 + attempt * 12345)\n        \n        c = np.random.uniform(0.05, 0.95, (n, 2))\n        r = np.random.uniform(0.01, 0.05, n)\n        \n        # Strategic Seed Initializations to help the optimizer\n        if attempt == 0:\n            c[0] = [0.5, 0.5]; r[0] = 0.25\n            c[1:5] = [[0.2, 0.2], [0.8, 0.2], [0.2, 0.8], [0.8, 0.8]]; r[1:5] = 0.15\n        elif attempt == 1:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(7):\n                ang = i * 2 * np.pi / 7\n                c[i+1] = [0.5 + 0.25 * np.cos(ang), 0.5 + 0.25 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(18):\n                ang = i * 2 * np.pi / 18\n                c[i+8] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+8] = 0.05\n        elif attempt == 2:\n            idx = 0\n            for i in range(5):\n                for j in range(5):\n                    c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.08\n                    idx += 1\n            c[25] = [0.5, 0.5]; r[25] = 0.08\n        elif attempt == 3:\n            c[0] = [0.5, 0.5]; r[0] = 0.15\n            for i in range(6):\n                ang = 2 * np.pi * i / 6\n                c[i+1] = [0.5 + 0.2 * np.cos(ang), 0.5 + 0.2 * np.sin(ang)]\n                r[i+1] = 0.1\n            for i in range(12):\n                ang = 2 * np.pi * i / 12\n                c[i+7] = [0.5 + 0.38 * np.cos(ang), 0.5 + 0.38 * np.sin(ang)]\n                r[i+7] = 0.08\n            for i in range(7):\n                ang = 2 * np.pi * i / 7\n                c[i+19] = [0.5 + 0.48 * np.cos(ang), 0.5 + 0.48 * np.sin(ang)]\n                r[i+19] = 0.05\n        elif attempt == 4:\n            # Corner and edge bias weighting\n            c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n        elif attempt == 5:\n            c[0] = [0.5, 0.5]; r[0] = 0.2\n            for i in range(5):\n                ang = i * 2 * np.pi / 5\n                c[i+1] = [0.5 + 0.3 * np.cos(ang), 0.5 + 0.3 * np.sin(ang)]\n                r[i+1] = 0.15\n            for i in range(20):\n                ang = i * 2 * np.pi / 20\n                c[i+6] = [0.5 + 0.45 * np.cos(ang), 0.5 + 0.45 * np.sin(ang)]\n                r[i+6] = 0.05\n        elif attempt == 6:\n            c[0:2] = [[0.3, 0.5], [0.7, 0.5]]; r[0:2] = 0.25\n        elif attempt == 7:\n            c[0:4] = [[0.3, 0.3], [0.7, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[0:4] = 0.2\n        elif attempt == 8:\n            c[:3] = [[0.5, 0.3], [0.3, 0.7], [0.7, 0.7]]; r[:3] = 0.25\n        elif attempt == 9:\n            c[0] = [0.2, 0.2]; r[0] = 0.2\n            c[1] = [0.8, 0.8]; r[1] = 0.2\n            idx = 2\n            for i in range(5):\n                for j in range(5):\n                    if idx < 26:\n                        c[idx] = [0.1 + i * 0.2, 0.1 + j * 0.2]; r[idx] = 0.05\n                        idx += 1\n        else:\n            if attempt % 2 == 0:\n                c = np.where(c < 0.5, c ** 1.5, 1 - (1 - c) ** 1.5)\n            elif attempt % 3 == 0:\n                c[:, 0] = c[:, 0] * 0.8 + 0.1\n                c[:, 1] = c[:, 1] * 0.8 + 0.1\n        \n        # Jitter to avoid local symmetry traps\n        c += np.random.normal(0, 0.005, c.shape)\n        c = np.clip(c, 0.01, 0.99)\n        \n        mc = np.zeros_like(c)\n        vc = np.zeros_like(c)\n        mr = np.zeros_like(r)\n        vr = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        \n        penalty_start = 10.0\n        penalty_end = 50000.0\n        mult = (penalty_end / penalty_start) ** (1.0 / steps)\n        penalty_weight = penalty_start\n        \n        for step in range(steps):\n            lr = 0.01 * (0.01 ** (step / steps))\n            \n            # Periodically inject exact LP solutions with slight overlap padding\n            # to provoke layout restructuring and escape local maxima.\n            if step in [2000, 4000, 6000, 8000]:\n                c_safe = np.clip(c, 1e-5, 1 - 1e-5)\n                r_lp = get_optimal_radii(c_safe)\n                r = r_lp + np.random.uniform(0.001, 0.005, n)\n                mc.fill(0)\n                vc.fill(0)\n                mr.fill(0)\n                vr.fill(0)\n            \n            gr = np.full(n, -1.0)\n            gc = np.zeros_like(c)\n            \n            diff = c[:, None, :] - c[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n            \n            sum_r = r[:, None] + r[None, :]\n            overlap = np.maximum(0, sum_r - dist)\n            \n            gr += penalty_weight * np.sum(2 * overlap, axis=1)\n            \n            safe_dist = np.where(dist < 1e-8, 1.0, dist)\n            force = 2 * penalty_weight * overlap / safe_dist\n            gc -= np.sum(force[..., None] * diff, axis=1)\n            \n            bx_min = np.maximum(0, r - c[:, 0])\n            bx_max = np.maximum(0, c[:, 0] + r - 1)\n            by_min = np.maximum(0, r - c[:, 1])\n            by_max = np.maximum(0, c[:, 1] + r - 1)\n            \n            gr += penalty_weight * 2 * (bx_min + bx_max + by_min + by_max)\n            gc[:, 0] += penalty_weight * 2 * (-bx_min + bx_max)\n            gc[:, 1] += penalty_weight * 2 * (-by_min + by_max)\n            \n            mc = beta1 * mc + (1 - beta1) * gc\n            vc = beta2 * vc + (1 - beta2) * (gc ** 2)\n            mch = mc / (1 - beta1 ** (step + 1))\n            vch = vc / (1 - beta2 ** (step + 1))\n            c -= lr * mch / (np.sqrt(vch) + eps)\n            \n            mr = beta1 * mr + (1 - beta1) * gr\n            vr = beta2 * vr + (1 - beta2) * (gr ** 2)\n            mrh = mr / (1 - beta1 ** (step + 1))\n            vrh = vr / (1 - beta2 ** (step + 1))\n            r -= lr * mrh / (np.sqrt(vrh) + eps)\n            \n            c = np.clip(c, 0.0, 1.0)\n            r = np.maximum(r, 0.0001)\n            \n            penalty_weight *= mult\n\n        # Use Linear Programming for final perfectly constrained radii solve\n        lp_r = get_optimal_radii(c)\n        c_rescaled, r_rescaled = rigid_rescale(c, lp_r)\n        \n        current_sum = np.sum(r_rescaled)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c_rescaled.copy()\n            best_r = r_rescaled.copy()\n\n    return best_c.tolist(), best_r.tolist(), float(best_sum)\n\n\ndef run():\n    return run_packing()\n\n\ndef solve():\n    return run_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run()\n```"]}}, "artifacts_json": "{\"timeout\": true, \"timeout_duration\": 60, \"failure_stage\": \"stage1\", \"error_type\": \"timeout\"}", "artifact_dir": null, "embedding": null}