{"id": "e2deb00c-85c9-4475-80fe-2d0954058e09", "code": "import time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.perf_counter()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        v_new = v.copy()\n        x = np.clip(v_new[0::3], 0.0, 1.0)\n        y = np.clip(v_new[1::3], 0.0, 1.0)\n        r = np.clip(v_new[2::3], 0.0, 1.0)\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        for _ in range(250):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new[0::3] = x\n        v_new[1::3] = y\n        v_new[2::3] = r\n        return v_new\n\n    def physics_layout(target_r, max_steps=300):\n        pos = np.random.uniform(0.1, 0.9, (N, 2))\n        vel = np.zeros((N, 2))\n        dt = 0.05\n        \n        min_dist = target_r[:, np.newaxis] + target_r[np.newaxis, :]\n        \n        for _ in range(max_steps):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :] \n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 1.0)\n            \n            overlap = min_dist - dist\n            overlap = np.clip(overlap, 0, None)\n            np.fill_diagonal(overlap, 0.0)\n            \n            f = overlap[:, :, np.newaxis] * (diff / dist[:, :, np.newaxis])\n            force = np.sum(f, axis=1)\n            \n            force += np.clip(target_r[:, np.newaxis] - pos, 0, None) * 5\n            force -= np.clip(pos - (1.0 - target_r[:, np.newaxis]), 0, None) * 5\n            \n            force += (0.5 - pos) * 0.02\n            \n            vel = 0.8 * vel + force * dt\n            pos += vel * dt\n            pos = np.clip(pos, 0.01, 0.99)\n            \n        return pos.tolist()\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    attempt = 0\n    while True:\n        if time.perf_counter() - start_time > 55.0:\n            break\n\n        mode = attempt % 6\n        v0 = np.zeros(3 * N)\n        \n        if mode in (3, 4, 5) and best_v is None:\n            mode = attempt % 3\n\n        if mode == 3 and best_v is not None:\n            v0 = best_v.copy()\n            v0[0::3] += np.random.normal(0, 0.005, N)\n            v0[1::3] += np.random.normal(0, 0.005, N)\n            v0[0::3] = np.clip(v0[0::3], 0.01, 0.99)\n            v0[1::3] = np.clip(v0[1::3], 0.01, 0.99)\n            v0[2::3] *= np.random.uniform(0.8, 0.95, N)\n            \n        elif mode == 4 and best_v is not None:\n            v0 = best_v.copy()\n            x = v0[0::3]\n            y = v0[1::3]\n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                        if dist < 0.15:\n                            dx_val = (x[i] - x[j]) / (dist + 1e-9)\n                            dy_val = (y[i] - y[j]) / (dist + 1e-9)\n                            x[i] += dx_val * 0.003\n                            y[i] += dy_val * 0.003\n                            x[j] -= dx_val * 0.003\n                            y[j] -= dy_val * 0.003\n            v0[0::3] = np.clip(x, 0.01, 0.99)\n            v0[1::3] = np.clip(y, 0.01, 0.99)\n            v0[2::3] *= 0.85\n            \n        elif mode == 5 and best_v is not None:\n            v0 = best_v.copy()\n            idx_rand = np.random.choice(N, 3, replace=False)\n            v0[3*idx_rand] = np.random.uniform(0.1, 0.9, 3)\n            v0[3*idx_rand+1] = np.random.uniform(0.1, 0.9, 3)\n            v0[3*idx_rand+2] = 0.01\n            v0[2::3] *= 0.8\n            \n        else:\n            centers = []\n            if mode == 0:\n                tr = np.random.uniform(0.04, 0.12, N)\n                centers = physics_layout(tr)\n            elif mode == 1:\n                tr = np.ones(N) * 0.08\n                centers = physics_layout(tr)\n            elif mode == 2:\n                grid_n = int(np.ceil(np.sqrt(N)))\n                for _ in range(N):\n                    for _ in range(100):\n                        gx = np.random.randint(1, grid_n + 1)\n                        gy = np.random.randint(1, grid_n + 1)\n                        px = (gx - 0.5) / grid_n + np.random.normal(0, 0.01)\n                        py = (gy - 0.5) / grid_n + np.random.normal(0, 0.01)\n                        if len(centers) == 0 or not any(np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                            centers.append([px, py])\n                            break\n                while len(centers) < N:\n                    centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n            centers = np.array(centers)\n            centers += np.random.normal(0, 0.002, size=centers.shape)\n            centers = np.clip(centers, 0.01, 0.99)\n\n            dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n            max_dist = np.max(dist_to_center) + 1e-9\n            radii = 0.01 + 0.06 * (1.0 - dist_to_center / max_dist)\n\n            v0[0::3] = centers[:, 0]\n            v0[1::3] = centers[:, 1]\n            v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-5, 'disp': False}\n        )\n\n        if not np.isfinite(res.x).all():\n            attempt += 1\n            continue\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n            \n        attempt += 1\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    centers_out = best_v.reshape(-1, 3)[:, :2].tolist()\n    radii_out = best_v.reshape(-1, 3)[:, 2].tolist()\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()", "changes_description": null, "language": "python", "parent_id": "024fcad6-4d7b-464e-b9ba-3ffda0e44ed7", "generation": 4, "timestamp": 1771884457.8466647, "iteration_found": 96, "metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following best practices:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n* You MUST think creatively, identify multiple alternative options of the algorithm design, analyze their pros and cons, and select the most promising algorithm.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: You MUST respond in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.3333\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.3333\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n60\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        for _ in range(120):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        if scale < 0:\n                            scale = 0.0\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=300)\n\n    for attempt, seed in enumerate(seeds):\n        if time.time() - start_time > 540:\n            break\n\n        np.random.seed(int(seed))\n        \n        centers_list = []\n        mode = attempt % 4\n        \n        if mode == 0:\n            centers_list.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers_list.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            centers_list.extend(np.random.uniform(0.1, 0.9, size=(N - 8, 2)).tolist())\n            \n        elif mode == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(200):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.2:\n                            f = (0.2 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers_list = pos.tolist()\n            \n        elif mode == 2:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n + 1)\n                    gy = np.random.randint(1, grid_n + 1)\n                    px, py = (gx - 0.5) / grid_n, (gy - 0.5) / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers_list) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in centers_list):\n                        centers_list.append([px, py])\n                        break\n            while len(centers_list) < N:\n                centers_list.append(np.random.uniform(0.1, 0.9, 2).tolist())\n                \n        else:\n            centers_list.append([0.5, 0.5])\n            ring1 = 8\n            for i in range(ring1):\n                angle = 2 * np.pi * i / ring1\n                centers_list.append([0.5 + 0.2 * np.cos(angle), 0.5 + 0.2 * np.sin(angle)])\n            ring2 = N - 1 - ring1\n            for i in range(ring2):\n                angle = 2 * np.pi * i / ring2\n                centers_list.append([0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)])\n\n        centers_arr = np.array(centers_list[:N])\n        centers_arr += np.random.normal(0, 0.005, size=centers_arr.shape)\n        centers_arr = np.clip(centers_arr, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers_arr - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii_arr = 0.02 + 0.04 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers_arr[:, 0]\n        v0[1::3] = centers_arr[:, 1]\n        v0[2::3] = radii_arr\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 3 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            x_sh = v_shake[0::3]\n            y_sh = v_shake[1::3]\n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.hypot(x_sh[i] - x_sh[j], y_sh[i] - y_sh[j])\n                        if dist < 0.15:\n                            dx_ = (x_sh[i] - x_sh[j]) / (dist + 1e-9)\n                            dy_ = (y_sh[i] - y_sh[j]) / (dist + 1e-9)\n                            x_sh[i] += dx_ * 0.005\n                            y_sh[i] += dy_ * 0.005\n                            x_sh[j] -= dx_ * 0.005\n                            y_sh[j] -= dy_ * 0.005\n            \n            v_shake[0::3] = np.clip(x_sh, 0.01, 0.99)\n            v_shake[1::3] = np.clip(y_sh, 0.01, 0.99)\n            v_shake[2::3] *= 0.85 \n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2].tolist()\n    radii_out = v.reshape(-1, 3)[:, 2].tolist()\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 2 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Finds a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii without any overlapping or extending bounds.\n    \"\"\"\n    N = 26\n    start_time = time.perf_counter()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(200):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    def physics_layout(target_r):\n        pos = np.random.uniform(0.1, 0.9, (N, 2))\n        vel = np.zeros((N, 2))\n        dt = 0.05\n        for _ in range(400):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :] \n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 1e-9)\n            \n            min_dist = target_r[:, np.newaxis] + target_r[np.newaxis, :]\n            \n            overlap = min_dist - dist\n            overlap = np.clip(overlap, 0, None)\n            \n            f = overlap[:, :, np.newaxis] * (diff / dist[:, :, np.newaxis])\n            force = np.sum(f, axis=1)\n            \n            force += np.clip(target_r[:, np.newaxis] - pos, 0, None) * 3\n            force -= np.clip(pos - (1.0 - target_r[:, np.newaxis]), 0, None) * 3\n            \n            force += (0.5 - pos) * 0.01\n            \n            vel = 0.8 * vel + force * dt\n            pos += vel * dt\n            pos = np.clip(pos, 0.01, 0.99)\n        return pos.tolist()\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    for attempt in range(2000):\n        if time.perf_counter() - start_time > 540:\n            break\n\n        centers = []\n        if attempt % 6 == 0:\n            np.random.seed(attempt)\n            tr = np.random.uniform(0.04, 0.12, N)\n            centers = physics_layout(tr)\n        elif attempt % 6 == 1:\n            np.random.seed(attempt)\n            tr = np.ones(N) * 0.08\n            centers = physics_layout(tr)\n        elif attempt % 6 == 2:\n            np.random.seed(attempt)\n            tr = np.random.choice([0.04, 0.06, 0.08, 0.1, 0.12], N)\n            centers = physics_layout(tr)\n        elif attempt % 6 == 3:\n            cols = 5\n            rows = 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    if len(centers) < N:\n                        x = (c_idx + 0.5 + (r_idx % 2) * 0.5) / (cols + 0.5)\n                        y = (r_idx + 0.5) / rows\n                        centers.append([x, y])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 6 == 4:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        else:\n            centers.append([0.5, 0.5])\n            for r_ring in [0.25, 0.45]:\n                count = int(2 * np.pi * r_ring * 11)\n                for i in range(count):\n                    if len(centers) < N:\n                        angle = i * 2 * np.pi / count\n                        centers.append([0.5 + r_ring * np.cos(angle), 0.5 + r_ring * np.sin(angle)])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 4 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= np.random.uniform(0.7, 0.95, N)\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out.tolist(), radii_out.tolist(), float(np.sum(radii_out))\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 3 (Score: 0.3333)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Finds a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii without any overlapping or extending bounds.\n    \"\"\"\n    N = 26\n    start_time = time.perf_counter()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    for attempt in range(1000):\n        if time.perf_counter() - start_time > 550:\n            break\n\n        centers = []\n        if attempt % 4 == 0:\n            cols = 5\n            rows = 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    if len(centers) < N:\n                        x = (c_idx + 0.5 + (r_idx % 2) * 0.5) / (cols + 0.5)\n                        y = (r_idx + 0.5) / rows\n                        centers.append([x, y])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 4 == 1:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 4 == 2:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 5 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.9\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out.tolist(), radii_out.tolist(), float(np.sum(radii_out))\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    best_v = None\n    best_sum_r = -1.0\n    start_time = time.time()\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(100):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        if scale < 0:\n                            scale = 0.0\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n    seeds = np.random.randint(0, 100000, size=150)\n\n    for attempt, seed in enumerate(seeds):\n        if time.time() - start_time > 550:\n            break\n\n        np.random.seed(int(seed))\n\n        centers = []\n        if attempt % 3 == 0:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            centers.extend(np.random.uniform(0.1, 0.9, size=(N - 8, 2)).tolist())\n        elif attempt % 3 == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(200):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(np.linalg.norm(np.array([px, py]) - np.array(p)) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 800, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 4 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.8\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 800, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(88)\n\n    for attempt in range(120):\n        if time.time() - start_time > 550:\n            break\n\n        centers = []\n        if attempt % 3 == 0:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 3 == 1:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 4 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.8\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\n\ndef constraints_fun(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n\n    c_bounds = np.empty(4 * N)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n\n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\n\ndef constraints_jac(v):\n    N = len(v) // 3\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n\n    num_bounds = 4 * N\n    num_overlaps = N * (N - 1) // 2\n\n    jac = np.zeros((num_bounds + num_overlaps, len(v)))\n\n    for i in range(N):\n        idx = 4 * i\n        jac[idx, 3 * i] = 1.0\n        jac[idx, 3 * i + 2] = -1.0\n\n        jac[idx + 1, 3 * i] = -1.0\n        jac[idx + 1, 3 * i + 2] = -1.0\n\n        jac[idx + 2, 3 * i + 1] = 1.0\n        jac[idx + 2, 3 * i + 2] = -1.0\n\n        jac[idx + 3, 3 * i + 1] = -1.0\n        jac[idx + 3, 3 * i + 2] = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    dx = x[idx_i] - x[idx_j]\n    dy = y[idx_i] - y[idx_j]\n    sr = r[idx_i] + r[idx_j]\n\n    row_idx = num_bounds + np.arange(num_overlaps)\n\n    jac[row_idx, 3 * idx_i] = 2 * dx\n    jac[row_idx, 3 * idx_j] = -2 * dx\n    jac[row_idx, 3 * idx_i + 1] = 2 * dy\n    jac[row_idx, 3 * idx_j + 1] = -2 * dy\n    jac[row_idx, 3 * idx_i + 2] = -2 * sr\n    jac[row_idx, 3 * idx\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\nN = 26\nNUM_BOUNDS = 4 * N\nNUM_OVERLAPS = N * (N - 1) // 2\nIDX_I, IDX_J = np.triu_indices(N, k=1)\nROW_IDX = NUM_BOUNDS + np.arange(NUM_OVERLAPS)\n\nJAC_TEMPLATE = np.zeros((NUM_BOUNDS + NUM_OVERLAPS, 3 * N))\nfor i in range(N):\n    idx = 4 * i\n    JAC_TEMPLATE[idx, 3*i] = 1.0\n    JAC_TEMPLATE[idx, 3*i+2] = -1.0\n    \n    JAC_TEMPLATE[idx+1, 3*i] = -1.0\n    JAC_TEMPLATE[idx+1, 3*i+2] = -1.0\n    \n    JAC_TEMPLATE[idx+2, 3*i+1] = 1.0\n    JAC_TEMPLATE[idx+2, 3*i+2] = -1.0\n    \n    JAC_TEMPLATE[idx+3, 3*i+1] = -1.0\n    JAC_TEMPLATE[idx+3, 3*i+2] = -1.0\n\n\ndef objective(v):\n    return -np.sum(v[2::3])\n\n\ndef jac_objective(v):\n    jac = np.zeros_like(v)\n    jac[2::3] = -1.0\n    return jac\n\n\ndef constraints_fun(v):\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    c_bounds = np.empty(NUM_BOUNDS)\n    c_bounds[0::4] = x - r\n    c_bounds[1::4] = 1.0 - x - r\n    c_bounds[2::4] = y - r\n    c_bounds[3::4] = 1.0 - y - r\n    \n    dx = x[IDX_I] - x[IDX_J]\n    dy = y[IDX_I] - y[IDX_J]\n    sr = r[IDX_I] + r[IDX_J]\n    \n    c_overlap = dx**2 + dy**2 - sr**2\n    return np.concatenate((c_bounds, c_overlap))\n\n\ndef constraints_jac(v):\n    jac = JAC_TEMPLATE.copy()\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3]\n    \n    dx = x[IDX_I] - x[IDX_J]\n    dy = y[IDX_I] - y[IDX_J]\n    sr = r[IDX_I] + r[IDX_J]\n    \n    jac[ROW_IDX, 3*IDX_I] = 2 * dx\n    jac[ROW_IDX, 3*IDX_J] = -2 * dx\n    jac[ROW_IDX, 3*IDX_I+1] = 2 * dy\n    jac[ROW_IDX, 3*IDX_J+1] = -2 * dy\n    jac[ROW_IDX, 3*IDX_I+2] = -2 * sr\n    jac[ROW_IDX, 3*IDX_J+2] = -2 * sr\n    \n    return jac\n\n\ndef apply_safety_shrink(v):\n    x = v[0::3]\n    y = v[1::3]\n    r = v[2::3].copy()\n    \n    for i in range(N):\n        max_r = min(x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n        if r[i] > max_r:\n            r[i] = max_r\n            \n    for _ in range(100):\n        moved = False\n        for i in range(N):\n            for j in range(i + 1, N):\n                dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                if r[i] + r[j] > dist:\n                    if r[i] + r[j] < 1e-15:\n                        r[i] = 0.0\n                        r[j] = 0.0\n                        moved = True\n                        continue\n                    scale = (dist - 1e-12) / (r[i] + r[j])\n                    if scale < 0:\n                        scale = 0.0\n                    r[i] *= scale\n                    r[j] *= scale\n                    moved = True\n        if not moved:\n            break\n            \n    for i in range(N):\n        r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n        \n    v_new = v.copy()\n    v_new[2::3] = r\n    return v_new\n\n\ndef optimize_radii_for_centers(v):\n    centers = v.reshape(N, 3)[:, :2]\n    c = -np.ones(N)\n    A_ub = []\n    b_ub = []\n    bounds_lp = []\n    \n    for i in range(N):\n        max_r = min(centers[i, 0], 1.0 - centers[i, 0], centers[i, 1], 1.0 - centers[i, 1])\n        bounds_lp.append((0.0, max(0.0, max_r)))\n        \n    for i in range(N):\n        for j in range(i + 1, N):\n            row = np.zeros(N)\n            row[i] = 1.0\n            row[j]\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef run_packing():\n    N = 26\n    start_time = time.time()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    # Pre-allocate constraint Jacobian template\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        # x_i - r_i >= 0\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n        # 1 - x_i - r_i >= 0\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n        # y_i - r_i >= 0\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n        # 1 - y_i - r_i >= 0\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef run_packing():\n    \"\"\"\n    Finds a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii without any overlapping or extending bounds.\n    \"\"\"\n    N = 26\n    start_time = time.perf_counter()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3].copy()\n\n        for i in range(N):\n            r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n\n        for _ in range(150):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new = v.copy()\n        v_new[2::3] = r\n        return v_new\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    for attempt in range(1000):\n        if time.perf_counter() - start_time > 550:\n            break\n\n        centers = []\n        if attempt % 4 == 0:\n            cols = 5\n            rows = 6\n            for r_idx in range(rows):\n                for c_idx in range(cols):\n                    if len(centers) < N:\n                        x = (c_idx + 0.5 + (r_idx % 2) * 0.5) / (cols + 0.5)\n                        y = (r_idx + 0.5) / rows\n                        centers.append([x, y])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 4 == 1:\n            grid_n = int(np.ceil(np.sqrt(N)))\n            for _ in range(N):\n                for _ in range(100):\n                    gx = np.random.randint(1, grid_n)\n                    gy = np.random.randint(1, grid_n)\n                    px, py = gx / grid_n, gy / grid_n\n                    px += np.random.normal(0, 0.015)\n                    py += np.random.normal(0, 0.015)\n                    if len(centers) == 0 or not any(\n                            np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                        centers.append([px, py])\n                        break\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n        elif attempt % 4 == 2:\n            pos = np.random.uniform(0.1, 0.9, (N, 2))\n            vel = np.zeros((N, 2))\n            dt = 0.05\n            for _ in range(250):\n                force = np.zeros((N, 2))\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        diff = pos[i] - pos[j]\n                        dist = np.linalg.norm(diff)\n                        if dist < 0.18:\n                            f = (0.18 - dist) * (diff / (dist + 1e-9))\n                            force[i] += f\n                            force[j] -= f\n                for i in range(N):\n                    for dim in range(2):\n                        if pos[i, dim] < 0.05:\n                            force[i, dim] += (0.05 - pos[i, dim]) * 2\n                        elif pos[i, dim] > 0.95:\n                            force[i, dim] -= (pos[i, dim] - 0.95) * 2\n                vel = 0.8 * vel + force * dt\n                pos += vel * dt\n                pos = np.clip(pos, 0.02, 0.98)\n            centers = pos.tolist()\n        else:\n            centers.extend([[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]])\n            centers.extend([[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]])\n            while len(centers) < N:\n                centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n        centers = np.array(centers)\n        centers += np.random.normal(0, 0.005, size=centers.shape)\n        centers = np.clip(centers, 0.01, 0.99)\n\n        dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n        max_dist = np.max(dist_to_center) + 1e-9\n        radii = 0.01 + 0.05 * (1.0 - dist_to_center / max_dist)\n\n        v0 = np.zeros(3 * N)\n        v0[0::3] = centers[:, 0]\n        v0[1::3] = centers[:, 1]\n        v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n        )\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n\n        if attempt % 5 == 0 and best_v is not None:\n            v_shake = best_v.copy()\n            v_shake[0::3] += np.random.normal(0, 0.005, N)\n            v_shake[1::3] += np.random.normal(0, 0.005, N)\n            v_shake[0::3] = np.clip(v_shake[0::3], 0.01, 0.99)\n            v_shake[1::3] = np.clip(v_shake[1::3], 0.01, 0.99)\n            v_shake[2::3] *= 0.9\n\n            res_shake = minimize(\n                objective,\n                v_shake,\n                method='SLSQP',\n                jac=jac_objective,\n                bounds=bounds,\n                constraints=constraints,\n                options={'maxiter': 1000, 'ftol': 1e-6, 'disp': False}\n            )\n\n            v_shake_safe = apply_safety_shrink(res_shake.x)\n            sum_r_shake = np.sum(v_shake_safe[2::3])\n\n            if sum_r_shake > best_sum_r:\n                best_sum_r = sum_r_shake\n                best_v = v_shake_safe\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    v = best_v.copy()\n    centers_out = v.reshape(-1, 3)[:, :2]\n    radii_out = v.reshape(-1, 3)[:, 2]\n\n    return centers_out.tolist(), radii_out.tolist(), float(np.sum(radii_out))\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["import time\nimport numpy as np\nfrom scipy.optimize import minimize\n\ndef solve():\n    N = 26\n    start_time = time.perf_counter()\n    best_v = None\n    best_sum_r = -1.0\n\n    idx_i, idx_j = np.triu_indices(N, k=1)\n    num_bounds = 4 * N\n    num_overlaps = len(idx_i)\n\n    def objective(v):\n        return -np.sum(v[2::3])\n\n    def jac_objective(v):\n        jac = np.zeros_like(v)\n        jac[2::3] = -1.0\n        return jac\n\n    jac_template = np.zeros((num_bounds + num_overlaps, 3 * N))\n    for i in range(N):\n        idx = 4 * i\n        jac_template[idx, 3 * i] = 1.0\n        jac_template[idx, 3 * i + 2] = -1.0\n\n        jac_template[idx + 1, 3 * i] = -1.0\n        jac_template[idx + 1, 3 * i + 2] = -1.0\n\n        jac_template[idx + 2, 3 * i + 1] = 1.0\n        jac_template[idx + 2, 3 * i + 2] = -1.0\n\n        jac_template[idx + 3, 3 * i + 1] = -1.0\n        jac_template[idx + 3, 3 * i + 2] = -1.0\n\n    def constraints_fun(v):\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        c_bounds = np.empty(num_bounds)\n        c_bounds[0::4] = x - r\n        c_bounds[1::4] = 1.0 - x - r\n        c_bounds[2::4] = y - r\n        c_bounds[3::4] = 1.0 - y - r\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        c_overlap = dx**2 + dy**2 - sr**2\n        return np.concatenate((c_bounds, c_overlap))\n\n    def constraints_jac(v):\n        jac = jac_template.copy()\n        x = v[0::3]\n        y = v[1::3]\n        r = v[2::3]\n\n        dx = x[idx_i] - x[idx_j]\n        dy = y[idx_i] - y[idx_j]\n        sr = r[idx_i] + r[idx_j]\n\n        row_idx = num_bounds + np.arange(num_overlaps)\n\n        jac[row_idx, 3 * idx_i] = 2 * dx\n        jac[row_idx, 3 * idx_j] = -2 * dx\n        jac[row_idx, 3 * idx_i + 1] = 2 * dy\n        jac[row_idx, 3 * idx_j + 1] = -2 * dy\n        jac[row_idx, 3 * idx_i + 2] = -2 * sr\n        jac[row_idx, 3 * idx_j + 2] = -2 * sr\n\n        return jac\n\n    def apply_safety_shrink(v):\n        v_new = v.copy()\n        x = np.clip(v_new[0::3], 0.0, 1.0)\n        y = np.clip(v_new[1::3], 0.0, 1.0)\n        r = np.clip(v_new[2::3], 0.0, 1.0)\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        for _ in range(250):\n            moved = False\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                    if r[i] + r[j] > dist:\n                        if r[i] + r[j] < 1e-15:\n                            r[i] = 0.0\n                            r[j] = 0.0\n                            moved = True\n                            continue\n                        scale = (dist - 1e-12) / (r[i] + r[j])\n                        scale = max(0.0, min(1.0, scale))\n                        r[i] *= scale\n                        r[j] *= scale\n                        moved = True\n            if not moved:\n                break\n\n        for i in range(N):\n            r[i] = max(0.0, min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i]))\n\n        v_new[0::3] = x\n        v_new[1::3] = y\n        v_new[2::3] = r\n        return v_new\n\n    def physics_layout(target_r, max_steps=300):\n        pos = np.random.uniform(0.1, 0.9, (N, 2))\n        vel = np.zeros((N, 2))\n        dt = 0.05\n        \n        min_dist = target_r[:, np.newaxis] + target_r[np.newaxis, :]\n        \n        for _ in range(max_steps):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :] \n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 1.0)\n            \n            overlap = min_dist - dist\n            overlap = np.clip(overlap, 0, None)\n            np.fill_diagonal(overlap, 0.0)\n            \n            f = overlap[:, :, np.newaxis] * (diff / dist[:, :, np.newaxis])\n            force = np.sum(f, axis=1)\n            \n            force += np.clip(target_r[:, np.newaxis] - pos, 0, None) * 5\n            force -= np.clip(pos - (1.0 - target_r[:, np.newaxis]), 0, None) * 5\n            \n            force += (0.5 - pos) * 0.02\n            \n            vel = 0.8 * vel + force * dt\n            pos += vel * dt\n            pos = np.clip(pos, 0.01, 0.99)\n            \n        return pos.tolist()\n\n    bounds = [(0.0, 1.0), (0.0, 1.0), (0.0, 0.5)] * N\n    constraints = {'type': 'ineq', 'fun': constraints_fun, 'jac': constraints_jac}\n\n    np.random.seed(42)\n\n    attempt = 0\n    while True:\n        if time.perf_counter() - start_time > 55.0:\n            break\n\n        mode = attempt % 6\n        v0 = np.zeros(3 * N)\n        \n        if mode in (3, 4, 5) and best_v is None:\n            mode = attempt % 3\n\n        if mode == 3 and best_v is not None:\n            v0 = best_v.copy()\n            v0[0::3] += np.random.normal(0, 0.005, N)\n            v0[1::3] += np.random.normal(0, 0.005, N)\n            v0[0::3] = np.clip(v0[0::3], 0.01, 0.99)\n            v0[1::3] = np.clip(v0[1::3], 0.01, 0.99)\n            v0[2::3] *= np.random.uniform(0.8, 0.95, N)\n            \n        elif mode == 4 and best_v is not None:\n            v0 = best_v.copy()\n            x = v0[0::3]\n            y = v0[1::3]\n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                        if dist < 0.15:\n                            dx_val = (x[i] - x[j]) / (dist + 1e-9)\n                            dy_val = (y[i] - y[j]) / (dist + 1e-9)\n                            x[i] += dx_val * 0.003\n                            y[i] += dy_val * 0.003\n                            x[j] -= dx_val * 0.003\n                            y[j] -= dy_val * 0.003\n            v0[0::3] = np.clip(x, 0.01, 0.99)\n            v0[1::3] = np.clip(y, 0.01, 0.99)\n            v0[2::3] *= 0.85\n            \n        elif mode == 5 and best_v is not None:\n            v0 = best_v.copy()\n            idx_rand = np.random.choice(N, 3, replace=False)\n            v0[3*idx_rand] = np.random.uniform(0.1, 0.9, 3)\n            v0[3*idx_rand+1] = np.random.uniform(0.1, 0.9, 3)\n            v0[3*idx_rand+2] = 0.01\n            v0[2::3] *= 0.8\n            \n        else:\n            centers = []\n            if mode == 0:\n                tr = np.random.uniform(0.04, 0.12, N)\n                centers = physics_layout(tr)\n            elif mode == 1:\n                tr = np.ones(N) * 0.08\n                centers = physics_layout(tr)\n            elif mode == 2:\n                grid_n = int(np.ceil(np.sqrt(N)))\n                for _ in range(N):\n                    for _ in range(100):\n                        gx = np.random.randint(1, grid_n + 1)\n                        gy = np.random.randint(1, grid_n + 1)\n                        px = (gx - 0.5) / grid_n + np.random.normal(0, 0.01)\n                        py = (gy - 0.5) / grid_n + np.random.normal(0, 0.01)\n                        if len(centers) == 0 or not any(np.hypot(px - p[0], py - p[1]) < 0.05 for p in centers):\n                            centers.append([px, py])\n                            break\n                while len(centers) < N:\n                    centers.append(np.random.uniform(0.1, 0.9, 2).tolist())\n\n            centers = np.array(centers)\n            centers += np.random.normal(0, 0.002, size=centers.shape)\n            centers = np.clip(centers, 0.01, 0.99)\n\n            dist_to_center = np.linalg.norm(centers - 0.5, axis=1)\n            max_dist = np.max(dist_to_center) + 1e-9\n            radii = 0.01 + 0.06 * (1.0 - dist_to_center / max_dist)\n\n            v0[0::3] = centers[:, 0]\n            v0[1::3] = centers[:, 1]\n            v0[2::3] = radii\n\n        res = minimize(\n            objective,\n            v0,\n            method='SLSQP',\n            jac=jac_objective,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 500, 'ftol': 1e-5, 'disp': False}\n        )\n\n        if not np.isfinite(res.x).all():\n            attempt += 1\n            continue\n\n        v_safe = apply_safety_shrink(res.x)\n        sum_r = np.sum(v_safe[2::3])\n\n        if sum_r > best_sum_r:\n            best_sum_r = sum_r\n            best_v = v_safe\n            \n        attempt += 1\n\n    if best_v is None:\n        best_v = np.zeros(3 * N)\n        for i in range(N):\n            best_v[3 * i] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 1] = np.random.uniform(0.1, 0.9)\n            best_v[3 * i + 2] = 0.001\n\n    centers_out = best_v.reshape(-1, 3)[:, :2].tolist()\n    radii_out = best_v.reshape(-1, 3)[:, 2].tolist()\n\n    return centers_out, radii_out, float(np.sum(radii_out))\n\ncenters, radii, sum_radii = solve()"]}}, "artifacts_json": "{\"stderr\": \"Stage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\", \"traceback\": \"Traceback (most recent call last):\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 384, in evaluate_stage1\\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\\n  File \\\"/home/jupyter/Code/oe/dennis/run3_improved_si/evaluator.py\\\", line 172, in run_with_timeout\\n    raise RuntimeError(f\\\"Program execution failed: {results['error']}\\\")\\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\\n\", \"failure_stage\": \"stage1_execution\", \"suggestion\": \"Check basic syntax and imports before attempting full evaluation\"}", "artifact_dir": null, "embedding": null}