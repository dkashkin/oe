{"id": "dc1b9781-1dbf-4469-ab42-f55a97aec8e7", "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= d_ij\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    seeds = []\n    \n    # Staggered Row patterns specifically tuned for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seeds with varying scaling\n    for scale in [0.45, 0.47, 0.49]:\n        phi = (np.sqrt(5) + 1) / 2\n        indices = np.arange(0, n) + 0.5\n        rad_s = np.sqrt(indices / n)\n        theta = 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * rad_s * np.cos(theta), 0.5 + scale * rad_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.02, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # Randomized repulsion-based seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.015 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the top candidates found in screening\n    for i in range(min(18, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search Jitter (Simulated Annealing step)\n    if best_v is not None:\n        for scale in [0.0008, 0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                # Keep radii positive after jitter\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-6, 0.5)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 400, 'ftol': 1e-13}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "b3682aac-9e96-4c4b-bb16-a45c0cf95530", "generation": 4, "timestamp": 1771629392.7690113, "iteration_found": 20, "metrics": {"validity": 1.0, "sum_radii": 2.626990285905961, "target_ratio": 0.9969602603058676, "combined_score": 0.9969602603058676, "radius_variance": 0.005483524848821234, "spatial_spread": 0.19404746750695484, "eval_time": 5.1109113693237305}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6126384546714747, "target_ratio": 0.9915136450366129, "combined_score": 0.9915136450366129, "radius_variance": 0.007119901506497559, "spatial_spread": 0.19152756185149414, "eval_time": 3.211047649383545}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9915\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.0000 \u2192 0.9915\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n3.21s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.612638/2.635 = 0.9915\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.2% of target value\n```\n\n### radius_stats\n```\nMin: 0.047000, Max: 0.146185, Avg: 0.100486\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6121, target_ratio: 0.9913, combined_score: 0.9913, radius_variance: 0.0070, spatial_spread: 0.2004, eval_time: 2.3492\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6126, target_ratio: 0.9915, combined_score: 0.9915, radius_variance: 0.0071, spatial_spread: 0.1915, eval_time: 3.2110\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9928)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a very fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints\n    # d_ij >= r_i + r_j\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    # These are treated as individual variable bounds.\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(44) # Use a specific seed for reproducible search\n    \n    # 1. Extensive Seed Generation\n    seeds = []\n    \n    # Hexagonal and staggered row configurations\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7],\n        [4, 5, 4, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.1, 0.12]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seed\n    indices = np.arange(0, n) + 0.5\n    phi = (np.sqrt(5) + 1) / 2\n    rad_s = np.sqrt(indices / n)\n    theta = 2 * np.pi * indices * phi\n    sun_pts = np.column_stack([0.5 + 0.45 * rad_s * np.cos(theta), 0.5 + 0.45 * rad_s * np.sin(theta)])\n    seeds.append(sun_pts)\n\n    # Concentric rings\n    for ring_cfg in [[14, 8, 4], [13, 8, 5], [12, 9, 5]]:\n        pts = []\n        for i, count in enumerate(ring_cfg):\n            dist = (i + 1) / (len(ring_cfg) + 0.5) * 0.45\n            for j in range(count):\n                a = 2 * np.pi * j / count\n                pts.append([0.5 + dist * np.cos(a), 0.5 + dist * np.sin(a)])\n        seeds.append(np.array(pts[:n]))\n\n    # Grid-based (5x5 + 1 extra)\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.05, 0.05], [0.95, 0.95], [0.5, 0.05], [0.05, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n        \n    # Randomized versions of top configurations\n    base_count = len(seeds)\n    for i in range(base_count):\n        seeds.append(seeds[i] + np.random.normal(0, 0.02, (n, 2)))\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the best few based on LP score\n    for i in range(min(12, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-11}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Global Search Jitter: Minor perturbations on the best candidate\n    if best_v is not None:\n        for scale in [0.001, 0.0005]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 300, 'ftol': 1e-12}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11 # Reliability buffer\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6160), Performs well on target_ratio (0.9928), Performs well on combined_score (0.9928), Performs well on radius_variance (0.0066), Performs well on spatial_spread (0.1893), Performs well on eval_time (3.0460)\n\n### Program 2 (Score: 0.9915)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a fast screening method to evaluate the potential of a seed arrangement.\n    \"\"\"\n    # Objective: Maximize sum of radii, so minimize -1 * sum(radii)\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances between centers\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    # Overlap constraints: r_i + r_j <= distance(C_i, C_j)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to nearest edge\n    # Use max(0, ...) to ensure bounds are valid if center is slightly outside due to jitter\n    bounds = [(0, max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        # Use 'highs' method for efficiency\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. No overlaps: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Within square: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    \n    # Pairwise overlap constraints\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    overlaps = d2[mask] - r_sum2[mask]\n    \n    # Boundary constraints\n    b_x1 = x - r\n    b_x2 = 1.0 - x - r\n    b_y1 = y - r\n    b_y2 = 1.0 - y - r\n    \n    return np.concatenate([overlaps, b_x1, b_x2, b_y1, b_y2])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives: d/dxi ((xi-xj)^2 + ...) = 2(xi-xj)\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    \n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    # x - r >= 0\n    J[b_idx : b_idx + n, :n] = np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - x - r >= 0\n    J[b_idx : b_idx + n, :n] = -np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # y - r >= 0\n    J[b_idx : b_idx + n, n:2*n] = np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - y - r >= 0\n    J[b_idx : b_idx + n, n:2*n] = -np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Diverse Structural Seed Generation\n    seeds = []\n    \n    # Hexagonal and staggered row configurations designed for n=26\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.09, 0.11]: # Varying margins\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: # Shift alternate rows\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n            \n    # Fibonacci Spiral Seed (Sunflower)\n    phi = (1 + 5**0.5) / 2\n    idx = np.arange(n) + 0.5\n    r_fib = np.sqrt(idx / n) * 0.45\n    theta = 2 * np.pi * idx * phi\n    seeds.append(np.column_stack([0.5 + r_fib * np.cos(theta), 0.5 + r_fib * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-7\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.02 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening: Use LP to quickly find the best radii for fixed center patterns\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(s, n)\n        if radii is not None:\n            results.append((score, s, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refinement: Optimize both centers and radii for the top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the most promising seeds found in screening\n    for i in range(min(15, len(results))):\n        _, s_pts, s_rad = results[i]\n        # v = [x_0...x_n, y_0...y_n, r_0...r_n]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-11}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Jitter: Small perturbations to the best candidate to escape local plateaus\n    if best_v is not None:\n        for _ in range(2):\n            x_jitter = best_v + np.random.normal(0, 0.0008, 3 * n)\n            res = minimize(\n                objective, x_jitter, jac=jac_obj, method='SLSQP',\n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                options={'maxiter': 300, 'ftol': 1e-12}\n            )\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity across machine precisions\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Entry point for the evaluator.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6126), Performs well on target_ratio (0.9915), Performs well on combined_score (0.9915), Performs well on radius_variance (0.0071), Performs well on spatial_spread (0.1915), Performs well on eval_time (3.2110)\n\n### Program 3 (Score: 0.9913)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a fast screening method to evaluate the potential of a seed arrangement.\n    \"\"\"\n    # Objective: Maximize sum of radii, so minimize -1 * sum(radii)\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances between centers\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2))\n    \n    # Overlap constraints: r_i + r_j <= distance(C_i, C_j)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to nearest edge\n    # This is passed directly into bounds for each variable\n    bounds = [(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. No overlaps: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Within square: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    \n    # Pairwise overlap constraints\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    overlaps = d2[mask] - r_sum2[mask]\n    \n    # Boundary constraints\n    b_x1 = x - r\n    b_x2 = 1.0 - x - r\n    b_y1 = y - r\n    b_y2 = 1.0 - y - r\n    \n    return np.concatenate([overlaps, b_x1, b_x2, b_y1, b_y2])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    \n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    # x - r >= 0\n    J[b_idx:b_idx+n, :n] = np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - x - r >= 0\n    J[b_idx:b_idx+n, :n] = -np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # y - r >= 0\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - y - r >= 0\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    # We use patterns known to be efficient for large-n packing (staggered rows and grids)\n    seeds = []\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.09, 0.11]: # Varying margins\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: # Staggered rows\n                    x_vals = np.clip(x_vals + 0.02, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n            \n    # Random repulsion seeds\n    for _ in range(8):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-6\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.02 * f, 0, 1)\n        seeds.append(p)\n\n    # Grid seeds with extras\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.05, 0.05], [0.95, 0.95], [0.05, 0.95]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # 2. Filter seeds using LP\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(s, n)\n        if radii is not None:\n            results.append((score, s, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine the top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing top seeds\n    for i in range(min(10, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 400, 'ftol': 1e-10}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search: Perturb the best and re-optimize\n    if best_v is not None:\n        for scale in [0.001, 0.0005]:\n            x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n            res = minimize(\n                objective, x_jitter, jac=jac_obj, method='SLSQP',\n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                options={'maxiter': 300, 'ftol': 1e-11}\n            )\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11 # Tiny safety margin for validity\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6121), Performs well on target_ratio (0.9913), Performs well on combined_score (0.9913), Performs well on radius_variance (0.0070), Performs well on spatial_spread (0.2004), Performs well on eval_time (2.3492)\n\n### Program 4 (Score: 0.0000)\n```python\nAn excellent way to break through the plateau in variable-size circle packing is to use a heavily physics-inspired **continuation penalty method**. \n\nInstead of relying on SLSQP to do the heavy lifting from fixed LP-solved radii, we can implement an unconstrained L-BFGS-B optimization that optimizes both the circle centers and their radii *simultaneously*. We use an overlap/boundary penalty that starts small (allowing circles to grow and easily push past each other to escape local minima) and exponentially increases to enforce strict feasibility. \n\nCoupled with vectorized analytical gradients, this runs blazingly fast\u2014allowing us to evaluate hundreds of distinct structural, symmetric, and stochastic seeds in just a few seconds before finishing off the top performers with strictly-constrained SLSQP.\n\n### Rewritten Program\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Diverse Seed Generation: Generate a massive variety of starting structures \n       (Hexagonal rows, Boundaries, Rings, Grids, and Poisson/Random sets).\n    2. Continuation Penalty Method (L-BFGS-B): Optimize both centers and radii simultaneously \n       using a highly vectorized L-BFGS-B with analytical gradients. We progressively increase \n       the penalty on overlap and boundary violations (from 10 to 1,000,000), simulating \n       \"inflation\" that forcefully drives circles into an optimal configuration.\n    3. Strict Refinement: Use SLSQP (also with vectorized Jacobians) on the best candidate \n       to refine any microscopic constraint tolerances perfectly.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    start_time = time.time()\n    \n    # 1. Extensive Structural Seed Generation\n    seeds = []\n    \n    # A. Row configurations (Staggered rows)\n    configs = [[5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], [4, 4, 4, 4, 5, 5]]\n    for cfg in configs:\n        for margin in [0.065, 0.085, 0.105]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / max(1, num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.02, margin/2, 1.0 - margin/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            pts = np.array(pts[:n])\n            seeds.append(pts)\n            for _ in range(2): # Add spatial jitter\n                p = pts + np.random.randn(*pts.shape) * 0.015\n                seeds.append(np.clip(p, 0, 1))\n                \n    # B. Boundary-heavy emphasis\n    for k in [2, 3\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9928, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a very fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints\n    # d_ij >= r_i + r_j\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    # These are treated as individual variable bounds.\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(44) # Use a specific seed for reproducible search\n    \n    # 1. Extensive Seed Generation\n    seeds = []\n    \n    # Hexagonal and staggered row configurations\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7],\n        [4, 5, 4, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.1, 0.12]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seed\n    indices = np.arange(0, n) + 0.5\n    phi = (np.sqrt(5) + 1) / 2\n    rad_s = np.sqrt(indices / n)\n    theta = 2 * np.pi * indices * phi\n    sun_pts = np.column_stack([0.5 + 0.45 * rad_s * np.cos(theta), 0.5 + 0.45 * rad_s * np.sin(theta)])\n    seeds.append(sun_pts)\n\n    # Concentric rings\n    for ring_cfg in [[14, 8, 4], [13, 8, 5], [12, 9, 5]]:\n        pts = []\n        for i, count in enumerate(ring_cfg):\n            dist = (i + 1) / (len(ring_cfg) + 0.5) * 0.45\n            for j in range(count):\n                a = 2 * np.pi * j / count\n                pts.append([0.5 + dist * np.cos(a), 0.5 + dist * np.sin(a)])\n        seeds.append(np.array(pts[:n]))\n\n    # Grid-based (5x5 + 1 extra)\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.05, 0.05], [0.95, 0.95], [0.5, 0.05], [0.05, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n        \n    # Randomized versions of top configurations\n    base_count = len(seeds)\n    for i in range(base_count):\n        seeds.append(seeds[i] + np.random.normal(0, 0.02, (n, 2)))\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the best few based on LP score\n    for i in range(min(12, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-11}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Global Search Jitter: Minor perturbations on the best candidate\n    if best_v is not None:\n        for scale in [0.001, 0.0005]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 300, 'ftol': 1e-12}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11 # Reliability buffer\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nAn excellent way to break through the plateau in variable-size circle packing is to use a heavily physics-inspired **continuation penalty method**. \n\nInstead of relying on SLSQP to do the heavy lifting from fixed LP-solved radii, we can implement an unconstrained L-BFGS-B optimization that optimizes both the circle centers and their radii *simultaneously*. We use an overlap/boundary penalty that starts small (allowing circles to grow and easily push past each other to escape local minima) and exponentially increases to enforce strict feasibility. \n\nCoupled with vectorized analytical gradients, this runs blazingly fast\u2014allowing us to evaluate hundreds of distinct structural, symmetric, and stochastic seeds in just a few seconds before finishing off the top performers with strictly-constrained SLSQP.\n\n### Rewritten Program\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Diverse Seed Generation: Generate a massive variety of starting structures \n       (Hexagonal rows, Boundaries, Rings, Grids, and Poisson/Random sets).\n    2. Continuation Penalty Method (L-BFGS-B): Optimize both centers and radii simultaneously \n       using a highly vectorized L-BFGS-B with analytical gradients. We progressively increase \n       the penalty on overlap and boundary violations (from 10 to 1,000,000), simulating \n       \"inflation\" that forcefully drives circles into an optimal configuration.\n    3. Strict Refinement: Use SLSQP (also with vectorized Jacobians) on the best candidate \n       to refine any microscopic constraint tolerances perfectly.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    start_time = time.time()\n    \n    # 1. Extensive Structural Seed Generation\n    seeds = []\n    \n    # A. Row configurations (Staggered rows)\n    configs = [[5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], [4, 4, 4, 4, 5, 5]]\n    for cfg in configs:\n        for margin in [0.065, 0.085, 0.105]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / max(1, num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.02, margin/2, 1.0 - margin/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            pts = np.array(pts[:n])\n            seeds.append(pts)\n            for _ in range(2): # Add spatial jitter\n                p = pts + np.random.randn(*pts.shape) * 0.015\n                seeds.append(np.clip(p, 0, 1))\n                \n    # B. Boundary-heavy emphasis\n    for k in [2, 3\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9913, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a fast screening method to evaluate the potential of a seed arrangement.\n    \"\"\"\n    # Objective: Maximize sum of radii, so minimize -1 * sum(radii)\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances between centers\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2))\n    \n    # Overlap constraints: r_i + r_j <= distance(C_i, C_j)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to nearest edge\n    # This is passed directly into bounds for each variable\n    bounds = [(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. No overlaps: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Within square: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    \n    # Pairwise overlap constraints\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    overlaps = d2[mask] - r_sum2[mask]\n    \n    # Boundary constraints\n    b_x1 = x - r\n    b_x2 = 1.0 - x - r\n    b_y1 = y - r\n    b_y2 = 1.0 - y - r\n    \n    return np.concatenate([overlaps, b_x1, b_x2, b_y1, b_y2])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    \n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    # x - r >= 0\n    J[b_idx:b_idx+n, :n] = np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - x - r >= 0\n    J[b_idx:b_idx+n, :n] = -np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # y - r >= 0\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - y - r >= 0\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    # We use patterns known to be efficient for large-n packing (staggered rows and grids)\n    seeds = []\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.09, 0.11]: # Varying margins\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: # Staggered rows\n                    x_vals = np.clip(x_vals + 0.02, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n            \n    # Random repulsion seeds\n    for _ in range(8):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-6\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.02 * f, 0, 1)\n        seeds.append(p)\n\n    # Grid seeds with extras\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.05, 0.05], [0.95, 0.95], [0.05, 0.95]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # 2. Filter seeds using LP\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(s, n)\n        if radii is not None:\n            results.append((score, s, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine the top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing top seeds\n    for i in range(min(10, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 400, 'ftol': 1e-10}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search: Perturb the best and re-optimize\n    if best_v is not None:\n        for scale in [0.001, 0.0005]:\n            x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n            res = minimize(\n                objective, x_jitter, jac=jac_obj, method='SLSQP',\n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                options={'maxiter': 300, 'ftol': 1e-11}\n            )\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11 # Tiny safety margin for validity\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a fast screening method to evaluate the potential of a seed arrangement.\n    \"\"\"\n    # Objective: Maximize sum of radii, so minimize -1 * sum(radii)\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances between centers\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    # Overlap constraints: r_i + r_j <= distance(C_i, C_j)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to nearest edge\n    # Use max(0, ...) to ensure bounds are valid if center is slightly outside due to jitter\n    bounds = [(0, max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        # Use 'highs' method for efficiency\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. No overlaps: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Within square: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    \n    # Pairwise overlap constraints\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    overlaps = d2[mask] - r_sum2[mask]\n    \n    # Boundary constraints\n    b_x1 = x - r\n    b_x2 = 1.0 - x - r\n    b_y1 = y - r\n    b_y2 = 1.0 - y - r\n    \n    return np.concatenate([overlaps, b_x1, b_x2, b_y1, b_y2])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives: d/dxi ((xi-xj)^2 + ...) = 2(xi-xj)\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    \n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    # x - r >= 0\n    J[b_idx : b_idx + n, :n] = np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - x - r >= 0\n    J[b_idx : b_idx + n, :n] = -np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # y - r >= 0\n    J[b_idx : b_idx + n, n:2*n] = np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - y - r >= 0\n    J[b_idx : b_idx + n, n:2*n] = -np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Diverse Structural Seed Generation\n    seeds = []\n    \n    # Hexagonal and staggered row configurations designed for n=26\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.09, 0.11]: # Varying margins\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: # Shift alternate rows\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n            \n    # Fibonacci Spiral Seed (Sunflower)\n    phi = (1 + 5**0.5) / 2\n    idx = np.arange(n) + 0.5\n    r_fib = np.sqrt(idx / n) * 0.45\n    theta = 2 * np.pi * idx * phi\n    seeds.append(np.column_stack([0.5 + r_fib * np.cos(theta), 0.5 + r_fib * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-7\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.02 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening: Use LP to quickly find the best radii for fixed center patterns\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(s, n)\n        if radii is not None:\n            results.append((score, s, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refinement: Optimize both centers and radii for the top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the most promising seeds found in screening\n    for i in range(min(15, len(results))):\n        _, s_pts, s_rad = results[i]\n        # v = [x_0...x_n, y_0...y_n, r_0...r_n]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-11}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Jitter: Small perturbations to the best candidate to escape local plateaus\n    if best_v is not None:\n        for _ in range(2):\n            x_jitter = best_v + np.random.normal(0, 0.0008, 3 * n)\n            res = minimize(\n                objective, x_jitter, jac=jac_obj, method='SLSQP',\n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                options={'maxiter': 300, 'ftol': 1e-12}\n            )\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity across machine precisions\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Entry point for the evaluator.\"\"\"\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= d_ij\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    seeds = []\n    \n    # Staggered Row patterns specifically tuned for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seeds with varying scaling\n    for scale in [0.45, 0.47, 0.49]:\n        phi = (np.sqrt(5) + 1) / 2\n        indices = np.arange(0, n) + 0.5\n        rad_s = np.sqrt(indices / n)\n        theta = 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * rad_s * np.cos(theta), 0.5 + scale * rad_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.02, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # Randomized repulsion-based seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.015 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the top candidates found in screening\n    for i in range(min(18, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search Jitter (Simulated Annealing step)\n    if best_v is not None:\n        for scale in [0.0008, 0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                # Keep radii positive after jitter\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-6, 0.5)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 400, 'ftol': 1e-13}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n\n```"]}}, "artifacts_json": "{\"execution_time\": \"5.11s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.626990/2.635 = 0.9970\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.7% of target value\", \"radius_stats\": \"Min: 0.060184, Max: 0.135738, Avg: 0.101038\"}", "artifact_dir": null, "embedding": null}