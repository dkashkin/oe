{"id": "75e83df3-cfa2-4f84-9482-c0f1b512f9c7", "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Seed Generation: Create a diverse range of initial circle configurations, including\n       systematic staggered row-based grids, physics-relaxed force-field layouts, and \n       standard rectangular grids.\n    2. LP Filtering: For each seed, solve a high-speed Linear Programming (LP) problem to \n       determine the optimal radii for the fixed center points. This rapidly identifies \n       topologically promising arrangements.\n    3. Nonlinear Optimization: Refine the best seeds using Sequential Least Squares \n       Programming (SLSQP). This stage optimizes positions (x, y) and radii (r) \n       simultaneously, utilizing a fully vectorized analytical Jacobian to navigate the \n       complex constraint surface efficiently.\n    4. Safety Margins: Apply small offsets to ensure no boundary or overlap violations \n       occur due to floating-point precision issues.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n    \n    # Pre-calculate indices for vectorized distance and Jacobian calculations\n    i_tri, j_tri = np.triu_indices(n, 1)\n    num_pairs = len(i_tri)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed center positions using the Highs LP solver.\"\"\"\n        # Objective: minimize -sum(radii)\n        c = -np.ones(n)\n        \n        # Distance constraints: r_i + r_j <= distance(P_i, P_j)\n        dx = P[i_tri, 0] - P[j_tri, 0]\n        dy = P[i_tri, 1] - P[j_tri, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        A_ub = np.zeros((num_pairs, n))\n        A_ub[np.arange(num_pairs), i_tri] = 1.0\n        A_ub[np.arange(num_pairs), j_tri] = 1.0\n        \n        # Boundary constraints: r_i <= distance from P_i to each wall\n        bounds = [(0, max(0, min(p[0], 1.0 - p[0], p[1], 1.0 - p[1]))) for p in P]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=dist - 1e-11, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    # --- Seed Generation ---\n    seeds = []\n    \n    # 1. Staggered Row Grids: Systematically vary row counts and staggered offsets\n    grid_configs = [\n        [5, 5, 5, 5, 6], [6, 5, 5, 5, 5], [4, 6, 6, 6, 4], \n        [5, 5, 6, 5, 5], [5, 5, 5, 6, 5], [4, 5, 4, 5, 4, 4]\n    ]\n    for cfg in grid_configs:\n        for my in [0.07, 0.10, 0.13]:\n            y_v = np.linspace(my, 1 - my, len(cfg))\n            for stagger in [0.0, 0.5]:\n                pts = []\n                for i, row_count in enumerate(cfg):\n                    mx = 1.0 / (2 * row_count)\n                    x_v = np.linspace(mx, 1 - mx, row_count)\n                    if i % 2 == 1: \n                        x_v = np.clip(x_v + stagger / row_count, 0.005, 0.995)\n                    for x in x_v: pts.append([x, y_v[i]])\n                # Pad if needed (unlikely given grid_configs)\n                while len(pts) < n: pts.append([np.random.rand(), np.random.rand()])\n                seeds.append(np.array(pts[:n]))\n\n    # 2. Physics-relaxed seeds: Use a repulsive force field to spread circles out\n    for _ in range(12):\n        P = np.random.rand(n, 2)\n        for step in range(60):\n            diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n            distsq = np.sum(diff**2, axis=2)\n            np.fill_diagonal(distsq, 1e-6)\n            mask = distsq < 0.05\n            force = diff / (distsq[:, :, np.newaxis] + 1e-4)\n            P += np.sum(force * mask[:, :, np.newaxis], axis=1) * 0.005\n            # Boundary repulsion\n            P[:, 0] += (1/(P[:, 0]**2+1e-4) - 1/((1-P[:, 0])**2+1e-4)) * 0.001\n            P[:, 1] += (1/(P[:, 1]**2+1e-4) - 1/((1-P[:, 1])**2+1e-4)) * 0.001\n            P = np.clip(P, 0.05, 0.95)\n        seeds.append(P)\n\n    # 3. Rectangular Grids\n    for rows, cols in [(4, 7), (5, 6), (6, 5)]:\n        pts = [[(i+0.5)/cols, (j+0.5)/rows] for i in range(cols) for j in range(rows)]\n        seeds.append(np.array(pts[:n]))\n\n    # --- LP Ranking ---\n    # Fast filtering to determine top geometric candidates for refinement\n    candidates = []\n    for s in seeds:\n        if time.time() - start_time > 3.0: break\n        r_opt, total = solve_lp(s)\n        if r_opt is not None:\n            candidates.append((total, s, r_opt))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n    if not candidates: return np.random.rand(n, 2), np.zeros(n), 0\n\n    # --- Nonlinear Refinement with SLSQP ---\n    def objective(v):\n        \"\"\"Maximize the sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n\n    def constraints(v):\n        \"\"\"Calculate inequality constraints: dist(P_i, P_j) - (r_i + r_j) >= 0 and wall bounds.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        c_dist = dist - (r[i_tri] + r[j_tri])\n        c_wall = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        return np.concatenate([c_dist, c_wall])\n\n    def jacobian(v):\n        \"\"\"Fully vectorized analytical Jacobian of the constraints.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        \n        J = np.zeros((num_pairs + 4 * n, 3 * n))\n        \n        # dist(P_i, P_j) - (r_i + r_j) constraints\n        J[np.arange(num_pairs), i_tri] = dx / dist\n        J[np.arange(num_pairs), j_tri] = -dx / dist\n        J[np.arange(num_pairs), n + i_tri] = dy / dist\n        J[np.arange(num_pairs), n + j_tri] = -dy / dist\n        J[np.arange(num_pairs), 2 * n + i_tri] = -1.0\n        J[np.arange(num_pairs), 2 * n + j_tri] = -1.0\n        \n        # Boundary constraints\n        row_offset = num_pairs\n        idx = np.arange(n)\n        # x_i - r_i >= 0\n        J[row_offset + idx, idx] = 1.0\n        J[row_offset + idx, 2 * n + idx] = -1.0\n        # 1 - x_i - r_i >= 0\n        J[row_offset + n + idx, idx] = -1.0\n        J[row_offset + n + idx, 2 * n + idx] = -1.0\n        # y_i - r_i >= 0\n        J[row_offset + 2 * n + idx, n + idx] = 1.0\n        J[row_offset + 2 * n + idx, 2 * n + idx] = -1.0\n        # 1 - y_i - r_i >= 0\n        J[row_offset + 3 * n + idx, n + idx] = -1.0\n        J[row_offset + 3 * n + idx, 2 * n + idx] = -1.0\n        \n        return J\n\n    best_total, best_pts, best_r = candidates[0]\n    \n    # Iterate through top 12 candidates found by LP\n    for i in range(min(12, len(candidates))):\n        if time.time() - start_time > 8.5: break\n        \n        curr_total, curr_pts, curr_r = candidates[i]\n        v0 = np.concatenate([curr_pts[:, 0], curr_pts[:, 1], curr_r])\n        \n        res = minimize(\n            objective, v0, method='SLSQP',\n            jac=lambda v: np.concatenate([np.zeros(2 * n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jacobian},\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            options={'maxiter': 300, 'ftol': 1e-9}\n        )\n        \n        if res.success and -res.fun > best_total:\n            best_total = -res.fun\n            best_pts = np.column_stack([res.x[:n], res.x[n:2 * n]])\n            best_r = res.x[2 * n:]\n\n    # Final safety clipping and precision adjustment\n    final_centers = np.clip(best_pts, 0, 1)\n    final_radii = best_r - 1e-11\n    \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "6883be87-654f-45e2-8350-2bc8acf40208", "generation": 4, "timestamp": 1771629572.0870683, "iteration_found": 28, "metrics": {"validity": 1.0, "sum_radii": 2.6228934641407027, "target_ratio": 0.9954054892374584, "combined_score": 0.9954054892374584, "radius_variance": 0.005382739583001344, "spatial_spread": 0.1972902216113243, "eval_time": 1.179598093032837}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.611256844532523, "target_ratio": 0.9909893148131018, "combined_score": 0.9909893148131018, "radius_variance": 0.008019672283756104, "spatial_spread": 0.19027475770346877, "eval_time": 2.152249813079834}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9910\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.0000 \u2192 0.9910\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n2.15s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.611257/2.635 = 0.9910\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.1% of target value\n```\n\n### radius_stats\n```\nMin: 0.036883, Max: 0.133713, Avg: 0.100433\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6108, target_ratio: 0.9908, combined_score: 0.9908, radius_variance: 0.0079, spatial_spread: 0.2033, eval_time: 2.1642\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6113, target_ratio: 0.9910, combined_score: 0.9910, radius_variance: 0.0080, spatial_spread: 0.1903, eval_time: 2.1522\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9914)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy: \n    1. Generate diverse structural seeds based on hexagonal and rectangular grids.\n    2. Solve Linear Programming (LP) for each seed to find optimal radii for fixed centers.\n    3. Refine the best seeds using nonlinear optimization (SLSQP) with an efficient linear Jacobian.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed centers using high-performance LP.\"\"\"\n        c = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(np.linalg.norm(P[i] - P[j]) - 1e-10)\n        \n        bounds = [(0, min(p[0], 1.0-p[0], p[1], 1.0-p[1])) for p in P]\n        # Use HiGHS solver for speed and robustness\n        res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=bounds, method='highs')\n        return (res.x, -res.fun) if res.success else (None, 0)\n\n    # 1. Structural Seed Generation\n    configs = [[5,5,5,5,6], [6,5,5,5,5], [4,6,6,6,4], [5,5,6,5,5], [4,5,4,5,4,4], [6,4,6,4,6]]\n    seeds = []\n    for cfg in configs:\n        for m_y in [0.08, 0.1, 0.12]:\n            pts = []\n            y_v = np.linspace(m_y, 1 - m_y, len(cfg))\n            for r_idx, cnt in enumerate(cfg):\n                m_x = 1 / (2 * cnt)\n                x_v = np.linspace(m_x, 1 - m_x, cnt)\n                if r_idx % 2 == 1: # Stagger every other row\n                    x_v = np.clip(x_v + 0.5/cnt, m_x, 1-m_x)\n                for x in x_v: pts.append([x, y_v[r_idx]])\n            seeds.append(np.array(pts[:n]))\n    \n    # Simple grid seeds\n    for gx, gy in [(5, 5), (4, 6), (6, 4)]:\n        pts = [[(i+0.5)/gx, (j+0.5)/gy] for i in range(gx) for j in range(gy)]\n        while len(pts) < n: pts.append([0.5, 0.5])\n        seeds.append(np.array(pts[:n]))\n\n    # 2. Evaluate all seeds via LP and pick the best candidates\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refine with SLSQP\n    def objective(v): return -np.sum(v[2*n:])\n    \n    def constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        res = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                res.append(np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2) - (r[i]+r[j]))\n        for i in range(n):\n            res.extend([x[i]-r[i], 1.0-x[i]-r[i], y[i]-r[i], 1.0-y[i]-r[i]])\n        return np.array(res)\n\n    def jac_constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((n * (n - 1) // 2 + 4 * n, 3 * n))\n        row = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = x[i] - x[j], y[i] - y[j]\n                d = max(1e-9, np.sqrt(dx*dx + dy*dy))\n                J[row, i], J[row, j] = dx/d, -dx/d\n                J[row, n+i], J[row, n+j] = dy/d, -dy/d\n                J[row, 2*n+i], J[row, 2*n+j] = -1.0, -1.0\n                row += 1\n        for i in range(n):\n            for k, val in enumerate([1, -1, 1, -1]):\n                idx = (k//2)*n + i\n                J[row, idx], J[row, 2*n+i], row = val, -1, row + 1\n        return J\n\n    best_sum, best_pts, best_r = candidates[0]\n    # Refine top 3 candidates within time limits\n    for i in range(min(3, len(candidates))):\n        if time.time() - start_time > 1.7: break\n        _, s_pts, s_r = candidates[i]\n        x0 = np.concatenate([s_pts[:,0], s_pts[:,1], s_r])\n        res = minimize(objective, x0, method='SLSQP', jac=lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n, options={'maxiter': 300, 'ftol': 1e-8})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_pts, best_r = -res.fun, np.column_stack((res.x[:n], res.x[n:2*n])), res.x[2*n:]\n\n    # Ensure validity and precision\n    final_centers = np.clip(best_pts, 0, 1)\n    final_radii = best_r - 1e-9\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6124), Performs well on target_ratio (0.9914), Performs well on combined_score (0.9914), Performs well on radius_variance (0.0071), Performs well on spatial_spread (0.1958), Performs well on eval_time (0.7178)\n\n### Program 2 (Score: 0.9910)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\nimport itertools\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Systematically generate diverse row-based configurations that sum to 26.\n    2. Convert configurations into geometric seeds (staggered and non-staggered grids).\n    3. Use high-performance Linear Programming (LP) to find optimal radii for fixed centers.\n    4. Rank and filter seeds based on their LP-derived sum of radii.\n    5. Refine the top candidates using Sequential Least Squares Programming (SLSQP) with a \n       fully vectorized analytical Jacobian for maximum efficiency.\n    6. Incorporate specific corner-heavy and grid-disrupted seeds to break symmetry.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    def get_partitions(target, rows, low, high):\n        \"\"\"Finds all partitions of 'target' into 'rows' integers between 'low' and 'high'.\"\"\"\n        if rows == 1:\n            return [[target]] if low <= target <= high else []\n        res = []\n        for i in range(low, high + 1):\n            if (rows - 1) * low <= target - i <= (rows - 1) * high:\n                for p in get_partitions(target - i, rows - 1, low, high):\n                    res.append([i] + p)\n        return res\n\n    # 1. Configuration Generation\n    configs = []\n    for r_count in [4, 5, 6, 7]:\n        # Limit configurations to maintain computational efficiency\n        configs.extend(get_partitions(n, r_count, 3, 9))\n\n    # 2. Seed Creation\n    seeds = []\n    # Row-based Grid Seeds\n    for cfg in configs[::2]: # Sample subset to balance coverage and time\n        for margin in [0.07, 0.10, 0.13]:\n            for stagger in [0, 1]:\n                pts = []\n                y_v = np.linspace(margin, 1.0 - margin, len(cfg))\n                for r_idx, c_cnt in enumerate(cfg):\n                    m_x = 1.0 / (2.0 * c_cnt)\n                    x_v = np.linspace(m_x, 1.0 - m_x, c_cnt)\n                    if stagger == 1 and r_idx % 2 == 1:\n                        # Shift row to create staggered hexagonal-like packing\n                        x_v = np.clip(x_v + 0.5 / c_cnt, 0.01, 0.99)\n                    for x in x_v:\n                        pts.append([x, y_v[r_idx]])\n                seeds.append(np.array(pts[:n]))\n                if len(seeds) > 500: break\n        if len(seeds) > 500: break\n\n    # Perturbed 5x5 Grid Seeds\n    g5 = np.linspace(0.1, 0.9, 5)\n    base_5x5 = np.array(list(itertools.product(g5, g5)))\n    for extra in [[0.5, 0.5], [0, 0], [1, 1], [0.1, 0.1], [0.9, 0.9]]:\n        seeds.append(np.vstack([base_5x5, extra]))\n\n    # 3. LP Evaluator for Radius Optimization\n    i_tri, j_tri = np.triu_indices(n, 1)\n    A_lp = np.zeros((len(i_tri), n))\n    A_lp[np.arange(len(i_tri)), i_tri] = 1.0\n    A_lp[np.arange(len(i_tri)), j_tri] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Solves optimal radii for fixed center points using the Highs LP solver.\"\"\"\n        dx = P[i_tri, 0] - P[j_tri, 0]\n        dy = P[i_tri, 1] - P[j_tri, 1]\n        b_ub = np.sqrt(dx**2 + dy**2) - 1e-12\n        bounds = [(0, min(p[0], 1.0-p[0], p[1], 1.0-p[1])) for p in P]\n        res = linprog(-np.ones(n), A_ub=A_lp, b_ub=b_ub, bounds=bounds, method='highs')\n        return (res.x, -res.fun) if res.success else (None, 0)\n\n    # Filter and rank seeds\n    candidates = []\n    for s in seeds:\n        if time.time() - start_time > 3.0: break\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 4. Nonlinear Refinement (SLSQP)\n    def objective(v):\n        return -np.sum(v[2*n:])\n\n    def constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy = x[i_tri] - x[j_tri], y[i_tri] - y[j_tri]\n        dist = np.sqrt(dx**2 + dy**2)\n        c_dist = dist - (r[i_tri] + r[j_tri])\n        c_bnd = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        return np.concatenate([c_dist, c_bnd])\n\n    def jacobian(v):\n        \"\"\"Vectorized analytical Jacobian for explosive SLSQP performance.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        num_pairs = len(i_tri)\n        J = np.zeros((num_pairs + 4 * n, 3 * n))\n        \n        dx, dy = x[i_tri] - x[j_tri], y[i_tri] - y[j_tri]\n        d = np.maximum(1e-10, np.sqrt(dx**2 + dy**2))\n        \n        rows = np.arange(num_pairs)\n        J[rows, i_tri], J[rows, j_tri] = dx / d, -dx / d\n        J[rows, n + i_tri], J[rows, n + j_tri] = dy / d, -dy / d\n        J[rows, 2*n + i_tri], J[rows, 2*n + j_tri] = -1.0, -1.0\n        \n        off = num_pairs\n        r_idx = np.arange(n)\n        # x-r >= 0\n        J[off + r_idx, r_idx] = 1.0\n        J[off + r_idx, 2*n + r_idx] = -1.0\n        # 1-x-r >= 0\n        J[off + n + r_idx, r_idx] = -1.0\n        J[off + n + r_idx, 2*n + r_idx] = -1.0\n        # y-r >= 0\n        J[off + 2*n + r_idx, n + r_idx] = 1.0\n        J[off + 2*n + r_idx, 2*n + r_idx] = -1.0\n        # 1-y-r >= 0\n        J[off + 3*n + r_idx, n + r_idx] = -1.0\n        J[off + 3*n + r_idx, 2*n + r_idx] = -1.0\n        return J\n\n    best_sum, best_pts, best_r = (candidates[0] if candidates else (0, None, None))\n    \n    # Refine top candidates within time budget\n    for i in range(min(16, len(candidates))):\n        if time.time() - start_time > 8.0: break\n        _, s_p, s_r = candidates[i]\n        x0 = np.concatenate([s_p[:, 0], s_p[:, 1], s_r])\n        res = minimize(objective, x0, method='SLSQP',\n                       jac=lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jacobian},\n                       bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                       options={'maxiter': 350, 'ftol': 1e-9})\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_pts = np.column_stack((res.x[:n], res.x[n:2*n]))\n            best_r = res.x[2*n:]\n\n    final_centers = np.clip(best_pts, 0, 1)\n    # Apply a tiny safety buffer to prevent overlap violations\n    final_radii = best_r - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6113), Performs well on target_ratio (0.9910), Performs well on combined_score (0.9910), Performs well on radius_variance (0.0080), Performs well on spatial_spread (0.1903), Performs well on eval_time (2.1522)\n\n### Program 3 (Score: 0.9908)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\nimport itertools\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Systematically generate a massive, diverse library of >20,000 structural, radial, and physical seeds.\n    2. Rank them instantly using a fast vectorized Jacobi-like bounding algorithm.\n    3. Evaluate the precise LP optimal radii for the top candidates.\n    4. Refine the exact geometry using a fully vectorized Sequential Least Squares Programming (SLSQP).\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    # 1. Broad Configuration Generation\n    configs = []\n    # Explore configurations with varying rows and row sizes\n    for n_rows in [3, 4, 5, 6, 7]:\n        max_c = 10 if n_rows == 3 else (9 if n_rows == 4 else 8)\n        for cfg in itertools.product(range(3, max_c), repeat=n_rows):\n            if sum(cfg) == n:\n                configs.append(cfg)\n\n    all_seeds = []\n    seed_to_cfg = []\n    cfg_idx = 0\n\n    # Grid seeds\n    for cfg in configs:\n        for m_y in [0.06, 0.1]:\n            for stagger_type in [0, 1, 2]:\n                pts = []\n                y_v = np.linspace(m_y, 1 - m_y, len(cfg))\n                for r_idx, cnt in enumerate(cfg):\n                    m_x = 1.0 / (2 * cnt)\n                    x_v = np.linspace(m_x, 1 - m_x, cnt)\n                    if stagger_type == 1 and r_idx % 2 == 1:\n                        x_v = np.clip(x_v + 0.5/cnt, m_x, 1-m_x)\n                    elif stagger_type == 2 and r_idx % 2 == 0:\n                        x_v = np.clip(x_v + 0.5/cnt, m_x, 1-m_x)\n                    for x in x_v:\n                        pts.append([x, y_v[r_idx]])\n                \n                pts = np.array(pts)\n                all_seeds.append(pts)\n                seed_to_cfg.append(cfg_idx)\n                \n                # Add micro-perturbed versions to avoid saddle points\n                noise = np.random.normal(0, 0.01, pts.shape)\n                all_seeds.append(np.clip(pts + noise, 0.02, 0.98))\n                seed_to_cfg.append(cfg_idx)\n        cfg_idx += 1\n\n    # Concentric/Radial seeds\n    for n_center in [1, 2, 3, 4, 5]:\n        for n_mid in range(5, 14):\n            n_out = n - n_center - n_mid\n            if n_out < 0: continue\n            for r_mid in [0.2, 0.3, 0.4]:\n                for r_out in [0.4, 0.45, 0.48]:\n                    pts = []\n                    if n_center == 1:\n                        pts.append([0.5, 0.5])\n                    else:\n                        for i in range(n_center):\n                            a = 2 * np.pi * i / n_center\n                            pts.append([0.5 + 0.08 * np.cos(a), 0.5 + 0.08 * np.sin(a)])\n                    for i in range(n_mid):\n                        a = 2 * np.pi * i / n_mid\n                        pts.append([0.5 + r_mid * np.cos(a), 0.5 + r_mid * np.sin(a)])\n                    for i in range(n_out):\n                        a = 2 * np.pi * i / n_out + (np.pi/n_out)\n                        pts.append([0.5 + r_out * np.cos(a), 0.5 + r_out * np.sin(a)])\n                    all_seeds.append(np.clip(pts, 0.02, 0.98))\n                    seed_to_cfg.append(cfg_idx)\n        cfg_idx += 1\n\n    # Physics-relaxed random seeds\n    for _ in range(300):\n        P = np.random.rand(n, 2)\n        for _ in range(30):\n            dx = P[:, 0:1] - P[:, 0:1].T\n            dy = P[:, 1:2] - P[:, 1:2].T\n            dist = np.sqrt(dx**2 + dy**2)\n            np.fill_diagonal(dist, np.inf)\n            F = 0.005 / (dist**2 + 1e-4) # Pairwise repulsion\n            P[:, 0] += np.sum(F * dx, axis=1)\n            P[:, 1] += np.sum(F * dy, axis=1)\n            # Boundary repulsion\n            P[:, 0] += 0.001 / (P[:, 0] + 1e-4) - 0.001 / (1.0 - P[:, 0] + 1e-4)\n            P[:, 1] += 0.001 / (P[:, 1] + 1e-4) - 0.001 / (1.0 - P[:, 1] + 1e-4)\n            P = np.clip(P, 0.02, 0.98)\n        all_seeds.append(P)\n        seed_to_cfg.append(cfg_idx)\n        cfg_idx += 1\n\n    # 2. Fast Vectorized Heuristic Ranking\n    def rank_seeds(seeds, batch_size=2000):\n        K = len(seeds)\n        scores = np.zeros(K)\n        for i in range(0, K, batch_size):\n            P = np.array(seeds[i:i+batch_size])\n            r_bounds = np.min([P[:,:,0], 1-P[:,:,0], P[:,:,1], 1-P[:,:,1]], axis=0)\n            \n            dx = P[:, :, 0:1] - P[:, np.newaxis, :, 0]\n            dy = P[:, :, 1:2] - P[:, np.newaxis, :, 1]\n            dist = np.sqrt(dx**2 + dy**2)\n            dist[:, np.arange(n), np.arange(n)] = np.inf\n            \n            # Initial safe radius guess\n            r = np.minimum(np.min(dist, axis=2) / 2.0, r_bounds)\n            # Simulated variable radius expansion\n            for _ in range(4):\n                r_j = r[:, np.newaxis, :]\n                r_new = np.min(dist - r_j, axis=2)\n                r = np.minimum(r, r_new)\n                r = np.minimum(r, r_bounds)\n                r = np.maximum(r, 0)\n            scores[i:i+batch_size] = np.sum(r, axis=1)\n        return scores\n\n    scores = rank_seeds(all_seeds)\n\n    # Keep only the single most promising variant per distinct configuration structural class\n    best_score_per_cfg = {}\n    best_seed_per_cfg = {}\n    for i, s_score in enumerate(scores):\n        c_idx = seed_to_cfg[i]\n        if c_idx not in best_score_per_cfg or s_score > best_score_per_cfg[c_idx]:\n            best_score_per_cfg[c_idx] = s_score\n            best_seed_per_cfg[c_idx] = all_seeds[i]\n\n    diverse_seeds = list(best_seed_per_cfg.values())\n    diverse_scores = list(best_score_per_cfg.values())\n\n    top_indices = np.argsort(diverse_scores)[-50:][::-1]\n    top_seeds = [diverse_seeds[i] for i in top_indices]\n\n    # 3. Precise Optimization Tools\n    i_tri, j_tri = np.triu_indices(n, 1)\n    A_ub_lp = np.zeros((len(i_tri), n))\n    A_ub_lp[np.arange(len(i_tri)), i_tri] = 1.0\n    A_ub_lp[np.arange(len(i_tri)), j_tri] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Solves optimal radii packing perfectly given fixed center points.\"\"\"\n        c = -np.ones(n)\n        dx_val = P[i_tri, 0] - P[j_tri, 0]\n        dy_val = P[i_tri, 1] - P[j_tri, 1]\n        b_ub = np.maximum(0, np.sqrt(dx_val**2 + dy_val**2) - 1e-10)\n        \n        bounds = [(0, max(0, min(p[0], 1.0-p[0], p[1], 1.0-p[1]))) for p in P]\n        res = linprog(c, A_ub=A_ub_lp, b_ub=b_ub, bounds=bounds, method='highs')\n        return (res.x, -res.fun) if res.success else (None, 0)\n\n    # Evaluate exact LP value for the structurally best candidates\n    candidates = []\n    for s in top_seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 4. Deep SLSQP Vectorized Refinement\n    def objective(v): return -np.sum(v[2*n:])\n    \n    def constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx = x[:, None] - x\n        dy = y[:, None] - y\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        c1 = dist[i_tri, j_tri] - (r[i_tri] + r[j_tri])\n        c2 = x - r\n        c3 = 1.0 - x - r\n        c4 = y - r\n        c5 = 1.0 - y - r\n        return np.concatenate([c1, c2, c3, c4, c5])\n\n    def jac_constraints(v):\n        \"\"\"Pre-vectorized analytical Jacobian for explosive performance.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((n * (n - 1) // 2 + 4 * n, 3 * n))\n        \n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        d = np.maximum(1e-9, np.sqrt(dx**2 + dy**2))\n        \n        rows = np.arange(len(i_tri))\n        J[rows, i_tri] = dx / d\n        J[rows, j_tri] = -dx / d\n        J[rows, n + i_tri] = dy / d\n        J[rows, n + j_tri] = -dy / d\n        J[rows, 2 * n + i_tri] = -1.0\n        J[rows, 2 * n + j_tri] = -1.0\n        \n        offset = len(i_tri)\n        r_idx = np.arange(n)\n        \n        J[offset + r_idx, r_idx] = 1.0\n        J[offset + r_idx, 2*n + r_idx] = -1.0\n        \n        J[offset + n + r_idx, r_idx] = -1.0\n        J[offset + n + r_idx, 2*n + r_idx] = -1.0\n        \n        J[offset + 2*n + r_idx, n + r_idx] = 1.0\n        J[offset + 2*n + r_idx, 2*n + r_idx] = -1.0\n        \n        J[offset + 3*n + r_idx, n + r_idx] = -1.0\n        J[offset + 3*n + r_idx, 2*n + r_idx] = -1.0\n        \n        return J\n\n    best_sum, best_pts, best_r = candidates[0]\n    # Refine the top distinct candidates, exploiting heavy vectorization\n    for i in range(min(12, len(candidates))):\n        if time.time() - start_time > 1.80: break\n        _, s_pts, s_r = candidates[i]\n        x0 = np.concatenate([s_pts[:,0], s_pts[:,1], s_r])\n        res = minimize(objective, x0, method='SLSQP', \n                       jac=lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n, \n                       options={'maxiter': 500, 'ftol': 1e-8})\n                       \n        if res.success and -res.fun > best_sum:\n            best_sum, best_pts, best_r = -res.fun, np.column_stack((res.x[:n], res.x[n:2*n])), res.x[2*n:]\n\n    # Final safeguards\n    final_centers = np.clip(best_pts, 0, 1)\n    final_radii = best_r - 1e-9\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6108), Performs well on target_ratio (0.9908), Performs well on combined_score (0.9908), Performs well on radius_variance (0.0079), Performs well on spatial_spread (0.2033), Performs well on eval_time (2.1642)\n\n### Program 4 (Score: 0.0000)\n```python\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\nimport itertools\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Exhaustively generate structurally diverse configurations (grids, concentric, physics-relaxed).\n    2. Rank >100,000 layouts instantly using an extremely accurate, vectorized Jacobi-iteration heuristic.\n    3. Filter out structural duplicates and evaluate exact LP optimal radii on the best distinct topologies.\n    4. Refine exact geometries using fully vectorized, analytical Sequential Least Squares Programming (SLSQP).\n    5. Perform a deep final polish on the absolute best result.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    # 1. Structural Generation (Grid Partitions)\n    cfgs = []\n    for n_rows in [4, 5, 6, 7]:\n        for c in itertools.product(range(2, 9), repeat=n_rows):\n            if sum(c) == n:\n                # Keep only topologically distinct combinations to avoid duplicate mirrors\n                if list(c) <= list(c)[::-1]:\n                    cfgs.append(c)\n\n    all_seeds = []\n    tags = []\n\n    # Map transformations for grid setups\n    for cfg in cfgs:\n        for m_y in [0.05, 0.08, 0.11]:\n            for p_y in [0.8, 1.0, 1.2]:\n                for p_x in [0.8, 1.0, 1.2]:\n                    for stagger in [0, 1, 2]:\n                        pts = []\n                        t_y = np.linspace(0, 1, len(cfg))\n                        if p_y != 1.0:\n                            t_y = 0.5 + 0.5 * np.sign(t_y - 0.5) * np.abs(2*t_y - 1)**p_y\n                        y_v = m_y + t_y * (1 - 2*m_y)\n                        \n                        for r_idx, cnt in enumerate(cfg):\n                            m_x = 1.0 / (2 * cnt)\n                            if cnt > 1:\n                                t_x = np.linspace(0, 1, cnt)\n                                if p_x != 1.0:\n                                    t_x = 0.5 + 0.5 * np.sign(t_x - 0.5) * np.abs(2*t_x - 1)**p_x\n                                x_v = m_x + t_x * (1 - 2*m_x)\n                            else:\n                                x_v = np.array([0.5])\n                                \n                            if stagger == 1 and r_idx % 2 == 1:\n                                x_v += 0.5 / cnt\n                            elif stagger == 2 and r_idx % 2 == 0:\n                                x_v += 0.5 / cnt\n                                \n                            x_v = np.clip(x_v, m_x, 1 - m_x)\n                            for x in x_v:\n                                pts.append([x, y_v[r_idx]])\n                        \n                        P = np.array(pts[:n])\n                        \n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9914, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy: \n    1. Generate diverse structural seeds based on hexagonal and rectangular grids.\n    2. Solve Linear Programming (LP) for each seed to find optimal radii for fixed centers.\n    3. Refine the best seeds using nonlinear optimization (SLSQP) with an efficient linear Jacobian.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed centers using high-performance LP.\"\"\"\n        c = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(np.linalg.norm(P[i] - P[j]) - 1e-10)\n        \n        bounds = [(0, min(p[0], 1.0-p[0], p[1], 1.0-p[1])) for p in P]\n        # Use HiGHS solver for speed and robustness\n        res = linprog(c, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=bounds, method='highs')\n        return (res.x, -res.fun) if res.success else (None, 0)\n\n    # 1. Structural Seed Generation\n    configs = [[5,5,5,5,6], [6,5,5,5,5], [4,6,6,6,4], [5,5,6,5,5], [4,5,4,5,4,4], [6,4,6,4,6]]\n    seeds = []\n    for cfg in configs:\n        for m_y in [0.08, 0.1, 0.12]:\n            pts = []\n            y_v = np.linspace(m_y, 1 - m_y, len(cfg))\n            for r_idx, cnt in enumerate(cfg):\n                m_x = 1 / (2 * cnt)\n                x_v = np.linspace(m_x, 1 - m_x, cnt)\n                if r_idx % 2 == 1: # Stagger every other row\n                    x_v = np.clip(x_v + 0.5/cnt, m_x, 1-m_x)\n                for x in x_v: pts.append([x, y_v[r_idx]])\n            seeds.append(np.array(pts[:n]))\n    \n    # Simple grid seeds\n    for gx, gy in [(5, 5), (4, 6), (6, 4)]:\n        pts = [[(i+0.5)/gx, (j+0.5)/gy] for i in range(gx) for j in range(gy)]\n        while len(pts) < n: pts.append([0.5, 0.5])\n        seeds.append(np.array(pts[:n]))\n\n    # 2. Evaluate all seeds via LP and pick the best candidates\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refine with SLSQP\n    def objective(v): return -np.sum(v[2*n:])\n    \n    def constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        res = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                res.append(np.sqrt((x[i]-x[j])**2 + (y[i]-y[j])**2) - (r[i]+r[j]))\n        for i in range(n):\n            res.extend([x[i]-r[i], 1.0-x[i]-r[i], y[i]-r[i], 1.0-y[i]-r[i]])\n        return np.array(res)\n\n    def jac_constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((n * (n - 1) // 2 + 4 * n, 3 * n))\n        row = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy = x[i] - x[j], y[i] - y[j]\n                d = max(1e-9, np.sqrt(dx*dx + dy*dy))\n                J[row, i], J[row, j] = dx/d, -dx/d\n                J[row, n+i], J[row, n+j] = dy/d, -dy/d\n                J[row, 2*n+i], J[row, 2*n+j] = -1.0, -1.0\n                row += 1\n        for i in range(n):\n            for k, val in enumerate([1, -1, 1, -1]):\n                idx = (k//2)*n + i\n                J[row, idx], J[row, 2*n+i], row = val, -1, row + 1\n        return J\n\n    best_sum, best_pts, best_r = candidates[0]\n    # Refine top 3 candidates within time limits\n    for i in range(min(3, len(candidates))):\n        if time.time() - start_time > 1.7: break\n        _, s_pts, s_r = candidates[i]\n        x0 = np.concatenate([s_pts[:,0], s_pts[:,1], s_r])\n        res = minimize(objective, x0, method='SLSQP', jac=lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n, options={'maxiter': 300, 'ftol': 1e-8})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_pts, best_r = -res.fun, np.column_stack((res.x[:n], res.x[n:2*n])), res.x[2*n:]\n\n    # Ensure validity and precision\n    final_centers = np.clip(best_pts, 0, 1)\n    final_radii = best_r - 1e-9\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\nimport itertools\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Exhaustively generate structurally diverse configurations (grids, concentric, physics-relaxed).\n    2. Rank >100,000 layouts instantly using an extremely accurate, vectorized Jacobi-iteration heuristic.\n    3. Filter out structural duplicates and evaluate exact LP optimal radii on the best distinct topologies.\n    4. Refine exact geometries using fully vectorized, analytical Sequential Least Squares Programming (SLSQP).\n    5. Perform a deep final polish on the absolute best result.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    # 1. Structural Generation (Grid Partitions)\n    cfgs = []\n    for n_rows in [4, 5, 6, 7]:\n        for c in itertools.product(range(2, 9), repeat=n_rows):\n            if sum(c) == n:\n                # Keep only topologically distinct combinations to avoid duplicate mirrors\n                if list(c) <= list(c)[::-1]:\n                    cfgs.append(c)\n\n    all_seeds = []\n    tags = []\n\n    # Map transformations for grid setups\n    for cfg in cfgs:\n        for m_y in [0.05, 0.08, 0.11]:\n            for p_y in [0.8, 1.0, 1.2]:\n                for p_x in [0.8, 1.0, 1.2]:\n                    for stagger in [0, 1, 2]:\n                        pts = []\n                        t_y = np.linspace(0, 1, len(cfg))\n                        if p_y != 1.0:\n                            t_y = 0.5 + 0.5 * np.sign(t_y - 0.5) * np.abs(2*t_y - 1)**p_y\n                        y_v = m_y + t_y * (1 - 2*m_y)\n                        \n                        for r_idx, cnt in enumerate(cfg):\n                            m_x = 1.0 / (2 * cnt)\n                            if cnt > 1:\n                                t_x = np.linspace(0, 1, cnt)\n                                if p_x != 1.0:\n                                    t_x = 0.5 + 0.5 * np.sign(t_x - 0.5) * np.abs(2*t_x - 1)**p_x\n                                x_v = m_x + t_x * (1 - 2*m_x)\n                            else:\n                                x_v = np.array([0.5])\n                                \n                            if stagger == 1 and r_idx % 2 == 1:\n                                x_v += 0.5 / cnt\n                            elif stagger == 2 and r_idx % 2 == 0:\n                                x_v += 0.5 / cnt\n                                \n                            x_v = np.clip(x_v, m_x, 1 - m_x)\n                            for x in x_v:\n                                pts.append([x, y_v[r_idx]])\n                        \n                        P = np.array(pts[:n])\n                        \n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9908, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\nimport itertools\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Systematically generate a massive, diverse library of >20,000 structural, radial, and physical seeds.\n    2. Rank them instantly using a fast vectorized Jacobi-like bounding algorithm.\n    3. Evaluate the precise LP optimal radii for the top candidates.\n    4. Refine the exact geometry using a fully vectorized Sequential Least Squares Programming (SLSQP).\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    # 1. Broad Configuration Generation\n    configs = []\n    # Explore configurations with varying rows and row sizes\n    for n_rows in [3, 4, 5, 6, 7]:\n        max_c = 10 if n_rows == 3 else (9 if n_rows == 4 else 8)\n        for cfg in itertools.product(range(3, max_c), repeat=n_rows):\n            if sum(cfg) == n:\n                configs.append(cfg)\n\n    all_seeds = []\n    seed_to_cfg = []\n    cfg_idx = 0\n\n    # Grid seeds\n    for cfg in configs:\n        for m_y in [0.06, 0.1]:\n            for stagger_type in [0, 1, 2]:\n                pts = []\n                y_v = np.linspace(m_y, 1 - m_y, len(cfg))\n                for r_idx, cnt in enumerate(cfg):\n                    m_x = 1.0 / (2 * cnt)\n                    x_v = np.linspace(m_x, 1 - m_x, cnt)\n                    if stagger_type == 1 and r_idx % 2 == 1:\n                        x_v = np.clip(x_v + 0.5/cnt, m_x, 1-m_x)\n                    elif stagger_type == 2 and r_idx % 2 == 0:\n                        x_v = np.clip(x_v + 0.5/cnt, m_x, 1-m_x)\n                    for x in x_v:\n                        pts.append([x, y_v[r_idx]])\n                \n                pts = np.array(pts)\n                all_seeds.append(pts)\n                seed_to_cfg.append(cfg_idx)\n                \n                # Add micro-perturbed versions to avoid saddle points\n                noise = np.random.normal(0, 0.01, pts.shape)\n                all_seeds.append(np.clip(pts + noise, 0.02, 0.98))\n                seed_to_cfg.append(cfg_idx)\n        cfg_idx += 1\n\n    # Concentric/Radial seeds\n    for n_center in [1, 2, 3, 4, 5]:\n        for n_mid in range(5, 14):\n            n_out = n - n_center - n_mid\n            if n_out < 0: continue\n            for r_mid in [0.2, 0.3, 0.4]:\n                for r_out in [0.4, 0.45, 0.48]:\n                    pts = []\n                    if n_center == 1:\n                        pts.append([0.5, 0.5])\n                    else:\n                        for i in range(n_center):\n                            a = 2 * np.pi * i / n_center\n                            pts.append([0.5 + 0.08 * np.cos(a), 0.5 + 0.08 * np.sin(a)])\n                    for i in range(n_mid):\n                        a = 2 * np.pi * i / n_mid\n                        pts.append([0.5 + r_mid * np.cos(a), 0.5 + r_mid * np.sin(a)])\n                    for i in range(n_out):\n                        a = 2 * np.pi * i / n_out + (np.pi/n_out)\n                        pts.append([0.5 + r_out * np.cos(a), 0.5 + r_out * np.sin(a)])\n                    all_seeds.append(np.clip(pts, 0.02, 0.98))\n                    seed_to_cfg.append(cfg_idx)\n        cfg_idx += 1\n\n    # Physics-relaxed random seeds\n    for _ in range(300):\n        P = np.random.rand(n, 2)\n        for _ in range(30):\n            dx = P[:, 0:1] - P[:, 0:1].T\n            dy = P[:, 1:2] - P[:, 1:2].T\n            dist = np.sqrt(dx**2 + dy**2)\n            np.fill_diagonal(dist, np.inf)\n            F = 0.005 / (dist**2 + 1e-4) # Pairwise repulsion\n            P[:, 0] += np.sum(F * dx, axis=1)\n            P[:, 1] += np.sum(F * dy, axis=1)\n            # Boundary repulsion\n            P[:, 0] += 0.001 / (P[:, 0] + 1e-4) - 0.001 / (1.0 - P[:, 0] + 1e-4)\n            P[:, 1] += 0.001 / (P[:, 1] + 1e-4) - 0.001 / (1.0 - P[:, 1] + 1e-4)\n            P = np.clip(P, 0.02, 0.98)\n        all_seeds.append(P)\n        seed_to_cfg.append(cfg_idx)\n        cfg_idx += 1\n\n    # 2. Fast Vectorized Heuristic Ranking\n    def rank_seeds(seeds, batch_size=2000):\n        K = len(seeds)\n        scores = np.zeros(K)\n        for i in range(0, K, batch_size):\n            P = np.array(seeds[i:i+batch_size])\n            r_bounds = np.min([P[:,:,0], 1-P[:,:,0], P[:,:,1], 1-P[:,:,1]], axis=0)\n            \n            dx = P[:, :, 0:1] - P[:, np.newaxis, :, 0]\n            dy = P[:, :, 1:2] - P[:, np.newaxis, :, 1]\n            dist = np.sqrt(dx**2 + dy**2)\n            dist[:, np.arange(n), np.arange(n)] = np.inf\n            \n            # Initial safe radius guess\n            r = np.minimum(np.min(dist, axis=2) / 2.0, r_bounds)\n            # Simulated variable radius expansion\n            for _ in range(4):\n                r_j = r[:, np.newaxis, :]\n                r_new = np.min(dist - r_j, axis=2)\n                r = np.minimum(r, r_new)\n                r = np.minimum(r, r_bounds)\n                r = np.maximum(r, 0)\n            scores[i:i+batch_size] = np.sum(r, axis=1)\n        return scores\n\n    scores = rank_seeds(all_seeds)\n\n    # Keep only the single most promising variant per distinct configuration structural class\n    best_score_per_cfg = {}\n    best_seed_per_cfg = {}\n    for i, s_score in enumerate(scores):\n        c_idx = seed_to_cfg[i]\n        if c_idx not in best_score_per_cfg or s_score > best_score_per_cfg[c_idx]:\n            best_score_per_cfg[c_idx] = s_score\n            best_seed_per_cfg[c_idx] = all_seeds[i]\n\n    diverse_seeds = list(best_seed_per_cfg.values())\n    diverse_scores = list(best_score_per_cfg.values())\n\n    top_indices = np.argsort(diverse_scores)[-50:][::-1]\n    top_seeds = [diverse_seeds[i] for i in top_indices]\n\n    # 3. Precise Optimization Tools\n    i_tri, j_tri = np.triu_indices(n, 1)\n    A_ub_lp = np.zeros((len(i_tri), n))\n    A_ub_lp[np.arange(len(i_tri)), i_tri] = 1.0\n    A_ub_lp[np.arange(len(i_tri)), j_tri] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Solves optimal radii packing perfectly given fixed center points.\"\"\"\n        c = -np.ones(n)\n        dx_val = P[i_tri, 0] - P[j_tri, 0]\n        dy_val = P[i_tri, 1] - P[j_tri, 1]\n        b_ub = np.maximum(0, np.sqrt(dx_val**2 + dy_val**2) - 1e-10)\n        \n        bounds = [(0, max(0, min(p[0], 1.0-p[0], p[1], 1.0-p[1]))) for p in P]\n        res = linprog(c, A_ub=A_ub_lp, b_ub=b_ub, bounds=bounds, method='highs')\n        return (res.x, -res.fun) if res.success else (None, 0)\n\n    # Evaluate exact LP value for the structurally best candidates\n    candidates = []\n    for s in top_seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 4. Deep SLSQP Vectorized Refinement\n    def objective(v): return -np.sum(v[2*n:])\n    \n    def constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx = x[:, None] - x\n        dy = y[:, None] - y\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        c1 = dist[i_tri, j_tri] - (r[i_tri] + r[j_tri])\n        c2 = x - r\n        c3 = 1.0 - x - r\n        c4 = y - r\n        c5 = 1.0 - y - r\n        return np.concatenate([c1, c2, c3, c4, c5])\n\n    def jac_constraints(v):\n        \"\"\"Pre-vectorized analytical Jacobian for explosive performance.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((n * (n - 1) // 2 + 4 * n, 3 * n))\n        \n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        d = np.maximum(1e-9, np.sqrt(dx**2 + dy**2))\n        \n        rows = np.arange(len(i_tri))\n        J[rows, i_tri] = dx / d\n        J[rows, j_tri] = -dx / d\n        J[rows, n + i_tri] = dy / d\n        J[rows, n + j_tri] = -dy / d\n        J[rows, 2 * n + i_tri] = -1.0\n        J[rows, 2 * n + j_tri] = -1.0\n        \n        offset = len(i_tri)\n        r_idx = np.arange(n)\n        \n        J[offset + r_idx, r_idx] = 1.0\n        J[offset + r_idx, 2*n + r_idx] = -1.0\n        \n        J[offset + n + r_idx, r_idx] = -1.0\n        J[offset + n + r_idx, 2*n + r_idx] = -1.0\n        \n        J[offset + 2*n + r_idx, n + r_idx] = 1.0\n        J[offset + 2*n + r_idx, 2*n + r_idx] = -1.0\n        \n        J[offset + 3*n + r_idx, n + r_idx] = -1.0\n        J[offset + 3*n + r_idx, 2*n + r_idx] = -1.0\n        \n        return J\n\n    best_sum, best_pts, best_r = candidates[0]\n    # Refine the top distinct candidates, exploiting heavy vectorization\n    for i in range(min(12, len(candidates))):\n        if time.time() - start_time > 1.80: break\n        _, s_pts, s_r = candidates[i]\n        x0 = np.concatenate([s_pts[:,0], s_pts[:,1], s_r])\n        res = minimize(objective, x0, method='SLSQP', \n                       jac=lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n                       bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n, \n                       options={'maxiter': 500, 'ftol': 1e-8})\n                       \n        if res.success and -res.fun > best_sum:\n            best_sum, best_pts, best_r = -res.fun, np.column_stack((res.x[:n], res.x[n:2*n])), res.x[2*n:]\n\n    # Final safeguards\n    final_centers = np.clip(best_pts, 0, 1)\n    final_radii = best_r - 1e-9\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\nimport itertools\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Systematically generate diverse row-based configurations that sum to 26.\n    2. Convert configurations into geometric seeds (staggered and non-staggered grids).\n    3. Use high-performance Linear Programming (LP) to find optimal radii for fixed centers.\n    4. Rank and filter seeds based on their LP-derived sum of radii.\n    5. Refine the top candidates using Sequential Least Squares Programming (SLSQP) with a \n       fully vectorized analytical Jacobian for maximum efficiency.\n    6. Incorporate specific corner-heavy and grid-disrupted seeds to break symmetry.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n\n    def get_partitions(target, rows, low, high):\n        \"\"\"Finds all partitions of 'target' into 'rows' integers between 'low' and 'high'.\"\"\"\n        if rows == 1:\n            return [[target]] if low <= target <= high else []\n        res = []\n        for i in range(low, high + 1):\n            if (rows - 1) * low <= target - i <= (rows - 1) * high:\n                for p in get_partitions(target - i, rows - 1, low, high):\n                    res.append([i] + p)\n        return res\n\n    # 1. Configuration Generation\n    configs = []\n    for r_count in [4, 5, 6, 7]:\n        # Limit configurations to maintain computational efficiency\n        configs.extend(get_partitions(n, r_count, 3, 9))\n\n    # 2. Seed Creation\n    seeds = []\n    # Row-based Grid Seeds\n    for cfg in configs[::2]: # Sample subset to balance coverage and time\n        for margin in [0.07, 0.10, 0.13]:\n            for stagger in [0, 1]:\n                pts = []\n                y_v = np.linspace(margin, 1.0 - margin, len(cfg))\n                for r_idx, c_cnt in enumerate(cfg):\n                    m_x = 1.0 / (2.0 * c_cnt)\n                    x_v = np.linspace(m_x, 1.0 - m_x, c_cnt)\n                    if stagger == 1 and r_idx % 2 == 1:\n                        # Shift row to create staggered hexagonal-like packing\n                        x_v = np.clip(x_v + 0.5 / c_cnt, 0.01, 0.99)\n                    for x in x_v:\n                        pts.append([x, y_v[r_idx]])\n                seeds.append(np.array(pts[:n]))\n                if len(seeds) > 500: break\n        if len(seeds) > 500: break\n\n    # Perturbed 5x5 Grid Seeds\n    g5 = np.linspace(0.1, 0.9, 5)\n    base_5x5 = np.array(list(itertools.product(g5, g5)))\n    for extra in [[0.5, 0.5], [0, 0], [1, 1], [0.1, 0.1], [0.9, 0.9]]:\n        seeds.append(np.vstack([base_5x5, extra]))\n\n    # 3. LP Evaluator for Radius Optimization\n    i_tri, j_tri = np.triu_indices(n, 1)\n    A_lp = np.zeros((len(i_tri), n))\n    A_lp[np.arange(len(i_tri)), i_tri] = 1.0\n    A_lp[np.arange(len(i_tri)), j_tri] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Solves optimal radii for fixed center points using the Highs LP solver.\"\"\"\n        dx = P[i_tri, 0] - P[j_tri, 0]\n        dy = P[i_tri, 1] - P[j_tri, 1]\n        b_ub = np.sqrt(dx**2 + dy**2) - 1e-12\n        bounds = [(0, min(p[0], 1.0-p[0], p[1], 1.0-p[1])) for p in P]\n        res = linprog(-np.ones(n), A_ub=A_lp, b_ub=b_ub, bounds=bounds, method='highs')\n        return (res.x, -res.fun) if res.success else (None, 0)\n\n    # Filter and rank seeds\n    candidates = []\n    for s in seeds:\n        if time.time() - start_time > 3.0: break\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 4. Nonlinear Refinement (SLSQP)\n    def objective(v):\n        return -np.sum(v[2*n:])\n\n    def constraints(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy = x[i_tri] - x[j_tri], y[i_tri] - y[j_tri]\n        dist = np.sqrt(dx**2 + dy**2)\n        c_dist = dist - (r[i_tri] + r[j_tri])\n        c_bnd = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        return np.concatenate([c_dist, c_bnd])\n\n    def jacobian(v):\n        \"\"\"Vectorized analytical Jacobian for explosive SLSQP performance.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        num_pairs = len(i_tri)\n        J = np.zeros((num_pairs + 4 * n, 3 * n))\n        \n        dx, dy = x[i_tri] - x[j_tri], y[i_tri] - y[j_tri]\n        d = np.maximum(1e-10, np.sqrt(dx**2 + dy**2))\n        \n        rows = np.arange(num_pairs)\n        J[rows, i_tri], J[rows, j_tri] = dx / d, -dx / d\n        J[rows, n + i_tri], J[rows, n + j_tri] = dy / d, -dy / d\n        J[rows, 2*n + i_tri], J[rows, 2*n + j_tri] = -1.0, -1.0\n        \n        off = num_pairs\n        r_idx = np.arange(n)\n        # x-r >= 0\n        J[off + r_idx, r_idx] = 1.0\n        J[off + r_idx, 2*n + r_idx] = -1.0\n        # 1-x-r >= 0\n        J[off + n + r_idx, r_idx] = -1.0\n        J[off + n + r_idx, 2*n + r_idx] = -1.0\n        # y-r >= 0\n        J[off + 2*n + r_idx, n + r_idx] = 1.0\n        J[off + 2*n + r_idx, 2*n + r_idx] = -1.0\n        # 1-y-r >= 0\n        J[off + 3*n + r_idx, n + r_idx] = -1.0\n        J[off + 3*n + r_idx, 2*n + r_idx] = -1.0\n        return J\n\n    best_sum, best_pts, best_r = (candidates[0] if candidates else (0, None, None))\n    \n    # Refine top candidates within time budget\n    for i in range(min(16, len(candidates))):\n        if time.time() - start_time > 8.0: break\n        _, s_p, s_r = candidates[i]\n        x0 = np.concatenate([s_p[:, 0], s_p[:, 1], s_r])\n        res = minimize(objective, x0, method='SLSQP',\n                       jac=lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)]),\n                       constraints={'type': 'ineq', 'fun': constraints, 'jac': jacobian},\n                       bounds=[(0, 1)]*(2*n) + [(0, 0.5)]*n,\n                       options={'maxiter': 350, 'ftol': 1e-9})\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_pts = np.column_stack((res.x[:n], res.x[n:2*n]))\n            best_r = res.x[2*n:]\n\n    final_centers = np.clip(best_pts, 0, 1)\n    # Apply a tiny safety buffer to prevent overlap violations\n    final_radii = best_r - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Seed Generation: Create a diverse range of initial circle configurations, including\n       systematic staggered row-based grids, physics-relaxed force-field layouts, and \n       standard rectangular grids.\n    2. LP Filtering: For each seed, solve a high-speed Linear Programming (LP) problem to \n       determine the optimal radii for the fixed center points. This rapidly identifies \n       topologically promising arrangements.\n    3. Nonlinear Optimization: Refine the best seeds using Sequential Least Squares \n       Programming (SLSQP). This stage optimizes positions (x, y) and radii (r) \n       simultaneously, utilizing a fully vectorized analytical Jacobian to navigate the \n       complex constraint surface efficiently.\n    4. Safety Margins: Apply small offsets to ensure no boundary or overlap violations \n       occur due to floating-point precision issues.\n    \"\"\"\n    start_time = time.time()\n    n = 26\n    np.random.seed(42)\n    \n    # Pre-calculate indices for vectorized distance and Jacobian calculations\n    i_tri, j_tri = np.triu_indices(n, 1)\n    num_pairs = len(i_tri)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed center positions using the Highs LP solver.\"\"\"\n        # Objective: minimize -sum(radii)\n        c = -np.ones(n)\n        \n        # Distance constraints: r_i + r_j <= distance(P_i, P_j)\n        dx = P[i_tri, 0] - P[j_tri, 0]\n        dy = P[i_tri, 1] - P[j_tri, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        A_ub = np.zeros((num_pairs, n))\n        A_ub[np.arange(num_pairs), i_tri] = 1.0\n        A_ub[np.arange(num_pairs), j_tri] = 1.0\n        \n        # Boundary constraints: r_i <= distance from P_i to each wall\n        bounds = [(0, max(0, min(p[0], 1.0 - p[0], p[1], 1.0 - p[1]))) for p in P]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=dist - 1e-11, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n        return None, 0\n\n    # --- Seed Generation ---\n    seeds = []\n    \n    # 1. Staggered Row Grids: Systematically vary row counts and staggered offsets\n    grid_configs = [\n        [5, 5, 5, 5, 6], [6, 5, 5, 5, 5], [4, 6, 6, 6, 4], \n        [5, 5, 6, 5, 5], [5, 5, 5, 6, 5], [4, 5, 4, 5, 4, 4]\n    ]\n    for cfg in grid_configs:\n        for my in [0.07, 0.10, 0.13]:\n            y_v = np.linspace(my, 1 - my, len(cfg))\n            for stagger in [0.0, 0.5]:\n                pts = []\n                for i, row_count in enumerate(cfg):\n                    mx = 1.0 / (2 * row_count)\n                    x_v = np.linspace(mx, 1 - mx, row_count)\n                    if i % 2 == 1: \n                        x_v = np.clip(x_v + stagger / row_count, 0.005, 0.995)\n                    for x in x_v: pts.append([x, y_v[i]])\n                # Pad if needed (unlikely given grid_configs)\n                while len(pts) < n: pts.append([np.random.rand(), np.random.rand()])\n                seeds.append(np.array(pts[:n]))\n\n    # 2. Physics-relaxed seeds: Use a repulsive force field to spread circles out\n    for _ in range(12):\n        P = np.random.rand(n, 2)\n        for step in range(60):\n            diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n            distsq = np.sum(diff**2, axis=2)\n            np.fill_diagonal(distsq, 1e-6)\n            mask = distsq < 0.05\n            force = diff / (distsq[:, :, np.newaxis] + 1e-4)\n            P += np.sum(force * mask[:, :, np.newaxis], axis=1) * 0.005\n            # Boundary repulsion\n            P[:, 0] += (1/(P[:, 0]**2+1e-4) - 1/((1-P[:, 0])**2+1e-4)) * 0.001\n            P[:, 1] += (1/(P[:, 1]**2+1e-4) - 1/((1-P[:, 1])**2+1e-4)) * 0.001\n            P = np.clip(P, 0.05, 0.95)\n        seeds.append(P)\n\n    # 3. Rectangular Grids\n    for rows, cols in [(4, 7), (5, 6), (6, 5)]:\n        pts = [[(i+0.5)/cols, (j+0.5)/rows] for i in range(cols) for j in range(rows)]\n        seeds.append(np.array(pts[:n]))\n\n    # --- LP Ranking ---\n    # Fast filtering to determine top geometric candidates for refinement\n    candidates = []\n    for s in seeds:\n        if time.time() - start_time > 3.0: break\n        r_opt, total = solve_lp(s)\n        if r_opt is not None:\n            candidates.append((total, s, r_opt))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n    if not candidates: return np.random.rand(n, 2), np.zeros(n), 0\n\n    # --- Nonlinear Refinement with SLSQP ---\n    def objective(v):\n        \"\"\"Maximize the sum of radii.\"\"\"\n        return -np.sum(v[2*n:])\n\n    def constraints(v):\n        \"\"\"Calculate inequality constraints: dist(P_i, P_j) - (r_i + r_j) >= 0 and wall bounds.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        c_dist = dist - (r[i_tri] + r[j_tri])\n        c_wall = np.concatenate([x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n        return np.concatenate([c_dist, c_wall])\n\n    def jacobian(v):\n        \"\"\"Fully vectorized analytical Jacobian of the constraints.\"\"\"\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx = x[i_tri] - x[j_tri]\n        dy = y[i_tri] - y[j_tri]\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        \n        J = np.zeros((num_pairs + 4 * n, 3 * n))\n        \n        # dist(P_i, P_j) - (r_i + r_j) constraints\n        J[np.arange(num_pairs), i_tri] = dx / dist\n        J[np.arange(num_pairs), j_tri] = -dx / dist\n        J[np.arange(num_pairs), n + i_tri] = dy / dist\n        J[np.arange(num_pairs), n + j_tri] = -dy / dist\n        J[np.arange(num_pairs), 2 * n + i_tri] = -1.0\n        J[np.arange(num_pairs), 2 * n + j_tri] = -1.0\n        \n        # Boundary constraints\n        row_offset = num_pairs\n        idx = np.arange(n)\n        # x_i - r_i >= 0\n        J[row_offset + idx, idx] = 1.0\n        J[row_offset + idx, 2 * n + idx] = -1.0\n        # 1 - x_i - r_i >= 0\n        J[row_offset + n + idx, idx] = -1.0\n        J[row_offset + n + idx, 2 * n + idx] = -1.0\n        # y_i - r_i >= 0\n        J[row_offset + 2 * n + idx, n + idx] = 1.0\n        J[row_offset + 2 * n + idx, 2 * n + idx] = -1.0\n        # 1 - y_i - r_i >= 0\n        J[row_offset + 3 * n + idx, n + idx] = -1.0\n        J[row_offset + 3 * n + idx, 2 * n + idx] = -1.0\n        \n        return J\n\n    best_total, best_pts, best_r = candidates[0]\n    \n    # Iterate through top 12 candidates found by LP\n    for i in range(min(12, len(candidates))):\n        if time.time() - start_time > 8.5: break\n        \n        curr_total, curr_pts, curr_r = candidates[i]\n        v0 = np.concatenate([curr_pts[:, 0], curr_pts[:, 1], curr_r])\n        \n        res = minimize(\n            objective, v0, method='SLSQP',\n            jac=lambda v: np.concatenate([np.zeros(2 * n), -np.ones(n)]),\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jacobian},\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            options={'maxiter': 300, 'ftol': 1e-9}\n        )\n        \n        if res.success and -res.fun > best_total:\n            best_total = -res.fun\n            best_pts = np.column_stack([res.x[:n], res.x[n:2 * n]])\n            best_r = res.x[2 * n:]\n\n    # Final safety clipping and precision adjustment\n    final_centers = np.clip(best_pts, 0, 1)\n    final_radii = best_r - 1e-11\n    \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n\n```"]}}, "artifacts_json": "{\"execution_time\": \"1.18s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.622893/2.635 = 0.9954\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.5% of target value\", \"radius_stats\": \"Min: 0.065701, Max: 0.140530, Avg: 0.100881\"}", "artifact_dir": null, "embedding": null}