{"id": "45dff373-e925-4753-8a3d-7d4bf12911cb", "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-15)\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    bounds = [(0, max(0.0, float(min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Specialized Row Seeds (configs sum to 26)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3]]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.1]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.015, 0.001, 0.999)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci Spirals and Axial variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.46, 0.49, 0.51]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for force_p in [1.8, 2.5, 3.5]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                p = np.clip(p + 0.012 * np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1), 0.005, 0.995)\n            seeds.append(p)\n\n    # Grid 5x5 + extra point\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.01, 0.01], [0.99, 0.5], [0.5, 0.01]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # 2. Fast Screening and Refinement\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(25, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.998])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 600, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Jitter Polish (Basin Hopping)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00005]:\n            for _ in range(3):\n                x_jit = best_v + np.random.normal(0, scale, 3 * n)\n                x_jit[2*n:] = np.clip(x_jit[2*n:], 1e-12, 0.5)\n                res = minimize(obj_fn, x_jit, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 2e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the 26-circle packing optimizer.\"\"\"\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "5a35095f-2a3f-4989-82f5-9535f84bc8bd", "generation": 6, "timestamp": 1771630893.0121634, "iteration_found": 90, "metrics": {"validity": 1.0, "sum_radii": 2.618362366320052, "target_ratio": 0.9936859075218414, "combined_score": 0.9936859075218414, "radius_variance": 0.007188263570058052, "spatial_spread": 0.18953953108017998, "eval_time": 8.193686485290527}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.62685369424721, "target_ratio": 0.9969084228642164, "combined_score": 0.9969084228642164, "radius_variance": 0.0054515682053757, "spatial_spread": 0.1972660202482782, "eval_time": 4.440657377243042}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9969\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9970 \u2192 0.9969. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n4.44s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.626854/2.635 = 0.9969\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.7% of target value\n```\n\n### radius_stats\n```\nMin: 0.064506, Max: 0.143113, Avg: 0.101033\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 5.1109\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 8.5302\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6283, target_ratio: 0.9975, combined_score: 0.9975, radius_variance: 0.0049, spatial_spread: 0.1910, eval_time: 4.2222\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral, Symmetry)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3]]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.02 * (np.random.rand()-0.5), m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals and axial symmetry\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_clip = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clip, n)\n        if radii is not None: results.append((score, s_clip, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(22, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.98]) # start slightly smaller to allow movement\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Jitter and Polish\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-7, 0.45)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-14})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-14 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (4.2543)\n\n### Program 2 (Score: 0.9975)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    This provides the maximum possible sum of radii for a given center configuration.\n    \"\"\"\n    # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    \n    # Extract upper triangle indices for constraints\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = []\n    for i in range(n):\n        limit = max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))\n        bounds.append((0, limit))\n        \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary checks.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    # Returns 1D array of all ineq constraints (val >= 0)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx : b_idx+n, :n] = np.eye(n)          # x - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, :n] = -np.eye(n)         # 1 - x - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, n:2*n] = np.eye(n)       # y - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, n:2*n] = -np.eye(n)      # 1 - y - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grids, and Spirals)\n    # Target configurations for n=26\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], \n        [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3], [4, 4, 5, 5, 4, 4]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.1]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                # Stagger alternate rows\n                if r_idx % 2 == 1:\n                    shift = (1.0 - 2.0 * m) / (count - 1) / 2.0\n                    x_vals = np.clip(x_vals + shift, 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals with scaling variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for force_p in [1.5, 2.0, 3.0]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Fast LP Screening\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    # Sort and take the top candidates for full non-linear optimization\n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # 3. SLSQP Polish for top performers\n    for i in range(min(24, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.995])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 600, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Basin Hopping step)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00005]:\n            for _ in range(3):\n                # Apply small perturbations and re-optimize to escape local minima\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Extract final results with a microscopic safety buffer\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6283), Performs well on target_ratio (0.9975), Performs well on combined_score (0.9975), Performs well on radius_variance (0.0049), Performs well on spatial_spread (0.1910), Performs well on eval_time (4.2222)\n\n### Program 3 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances for overlap constraints\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= distance to the nearest edge\n    limits = np.minimum(np.minimum(P[:, 0], 1.0 - P[:, 0]), \n                        np.minimum(P[:, 1], 1.0 - P[:, 1]))\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seed Generation\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], \n        [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3], [4, 4, 5, 5, 4, 4]\n    ]\n    for cfg in configs:\n        for m in [0.075, 0.085, 0.095, 0.105]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.018, 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds (hard-sphere simulation)\n    for force_p in [2.0, 4.0]:\n        for _ in range(10):\n            p = np.random.rand(n, 2)\n            for _ in range(50):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # Grid 5x5 variations\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.02, 0.5], [0.5, 0.02]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # 2. Fast LP Screening\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Polish for top performers\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(22, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        # Start with radii slightly smaller to ensure initial feasibility\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.998])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Final Jitter Polish (Local search to escape plateaus)\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(3):\n                x_jitter = best_v + (np.random.normal(0, scale, 3 * n))\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-13, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (8.5302)\n\n### Program 4 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= d_ij\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    seeds = []\n    \n    # Staggered Row patterns specifically tuned for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seeds with varying scaling\n    for scale in [0.45, 0.47, 0.49]:\n        phi = (np.sqrt(5) + 1) / 2\n        indices = np.arange(0, n) + 0.5\n        rad_s = np.sqrt(indices / n)\n        theta = 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * rad_s * np.cos(theta), 0.5 + scale * rad_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.02, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # Randomized repulsion-based seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.015 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the top candidates found in screening\n    for i in range(min(18, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search Jitter (Simulated Annealing step)\n    if best_v is not None:\n        for scale in [0.0008, 0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                # Keep radii positive after jitter\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-6, 0.5)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 400, 'ftol': 1e-13}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (5.1109)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9969)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6], [4, 5, 4, 5, 4, 4]]\n    for cfg in configs:\n        for m in [0.08, 0.10]:\n            for shift in [0, 0.015, -0.015]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1: x_vals = np.clip(x_vals + shift, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point strategies\n    for m in [0.09, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.005, 0.995)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Refine top candidates\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Basin-Hopping Jitter and High-Precision Polish\n    if best_v is not None:\n        for scale in [0.0003, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-12 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP optimization: No overlaps and boundary-stay.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Patterns (Staggered rows and shifted grids)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.018, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Grid 5x5 + extra point strategies\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.98, 0.5]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # Sunflower spirals\n    phi = (np.sqrt(5) + 1) / 2\n    for scale in [0.44, 0.47, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and Refinement\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(np.clip(s, 0.001, 0.999), n)\n        if radii is not None: results.append((score, np.clip(s, 0.001, 0.999), radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(14, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Polish best result\n    if best_v is not None:\n        for scale in [0.0005, 0.0001]:\n            res = minimize(obj_fn, best_v + np.random.normal(0, scale, 3 * n), jac=jac_fn, method='SLSQP',\n                           bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                           constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                           options={'maxiter': 400, 'ftol': 1e-13})\n            if res.success and -res.fun > best_sum:\n                best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9913, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a fast screening method to evaluate the potential of a seed arrangement.\n    \"\"\"\n    # Objective: Maximize sum of radii, so minimize -1 * sum(radii)\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances between centers\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2))\n    \n    # Overlap constraints: r_i + r_j <= distance(C_i, C_j)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to nearest edge\n    # This is passed directly into bounds for each variable\n    bounds = [(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. No overlaps: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Within square: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    \n    # Pairwise overlap constraints\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    overlaps = d2[mask] - r_sum2[mask]\n    \n    # Boundary constraints\n    b_x1 = x - r\n    b_x2 = 1.0 - x - r\n    b_y1 = y - r\n    b_y2 = 1.0 - y - r\n    \n    return np.concatenate([overlaps, b_x1, b_x2, b_y1, b_y2])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    \n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    # x - r >= 0\n    J[b_idx:b_idx+n, :n] = np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - x - r >= 0\n    J[b_idx:b_idx+n, :n] = -np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # y - r >= 0\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - y - r >= 0\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n)\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    # We use patterns known to be efficient for large-n packing (staggered rows and grids)\n    seeds = []\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.09, 0.11]: # Varying margins\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: # Staggered rows\n                    x_vals = np.clip(x_vals + 0.02, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n            \n    # Random repulsion seeds\n    for _ in range(8):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-6\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.02 * f, 0, 1)\n        seeds.append(p)\n\n    # Grid seeds with extras\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.05, 0.05], [0.95, 0.95], [0.05, 0.95]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # 2. Filter seeds using LP\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(s, n)\n        if radii is not None:\n            results.append((score, s, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine the top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing top seeds\n    for i in range(min(10, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 400, 'ftol': 1e-10}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search: Perturb the best and re-optimize\n    if best_v is not None:\n        for scale in [0.001, 0.0005]:\n            x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n            res = minimize(\n                objective, x_jitter, jac=jac_obj, method='SLSQP',\n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                options={'maxiter': 300, 'ftol': 1e-11}\n            )\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11 # Tiny safety margin for validity\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9912, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-16)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    ii, jj = np.triu_indices(n, k=1)\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    bounds = [(0, max(0.0, float(min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    ii, jj = np.triu_indices(n, k=1)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Tuned Row configurations)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.10]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.02 * (np.random.rand()-0.5), 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # 2. Grid-based structures (5x5 + extra point in various positions)\n    for m in [0.09, 0.10, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [m, m], [1-m, 1-m], [0.5, m], [m, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # 3. Fibonacci/Sunflower Spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # 4. Repulsion Force Simulation\n    for force_p in [2.0, 3.5]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(45):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                p = np.clip(p + 0.012 * np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1), 0.005, 0.995)\n            seeds.append(p)\n\n    # 5. Screening with LP\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 6. SLSQP Refinement\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(28, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 800, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 7. Final Multi-scale Jitter Polish\n    if best_v is not None:\n        for scale in [0.0002, 0.00005]:\n            for _ in range(3):\n                x_jit = best_v + np.random.normal(0, scale, 3 * n)\n                x_jit[2*n:] = np.clip(x_jit[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jit, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-16)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the 26-circle packing optimizer.\"\"\"\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9939, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    Provides the maximum possible sum of radii for a given center configuration.\n    \"\"\"\n    # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n    c = -np.ones(n)\n    \n    # Pairwise distances for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    \n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= distance to the nearest edge\n    limits = np.minimum(np.minimum(P[:, 0], 1.0 - P[:, 0]), \n                        np.minimum(P[:, 1], 1.0 - P[:, 1]))\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid, Spiral)\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [3, 4, 6, 6, 4, 3],\n        [4, 4, 5, 5, 4, 4], [5, 5, 5, 5, 6]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.1]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for force_p in [2.0, 3.0]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Fast Screening using Linear Programming\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # 3. SLSQP Polish for top performers\n    for i in range(min(22, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.995])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Basin-Hopping Refinement (Jitter and re-optimize)\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(3):\n                x_jitter = best_v + (np.random.normal(0, scale, 3 * n))\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-10, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances for overlap constraints: r_i + r_j <= d_ij\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    limits = np.minimum(np.minimum(P[:, 0], 1.0 - P[:, 0]), \n                        np.minimum(P[:, 1], 1.0 - P[:, 1]))\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        # Highs is efficient for this scale of problem\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    # Return 1D array where each element >= 0 represents a satisfied constraint\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives: d/dx1 (x1-x2)^2 = 2(x1-x2)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives (x-r, 1-x-r, y-r, 1-y-r)\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer targeting n=26.\"\"\"\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Diverse Structural Seed Generation\n    # Patterns specifically choosing configurations that sum to 26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], \n        [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3], [4, 4, 5, 5, 4, 4],\n        [7, 7, 6, 6], [3, 5, 5, 5, 5, 3]\n    ]\n    for cfg in configs:\n        for m in [0.065, 0.08, 0.095, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, 0.005, 0.995)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.44, 0.46, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 variations plus corner/edge circle\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    s25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.01, 0.01], [0.99, 0.5], [0.5, 0.99], [0.01, 0.99]]:\n        seeds.append(np.vstack([s25, extra]))\n\n    # Multi-force Repulsion-based randomized seeds\n    for force_p in [1.5, 2.5, 4.0]:\n        for _ in range(5):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Fast Screening using LP (Finding the best starting centers)\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    # Sort by performance and take top candidates for nonlinear polish\n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # 3. SLSQP Polish for top performers\n    # Polishing more candidates to increase chance of finding the global optimum\n    for i in range(min(25, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.995])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 600, 'ftol': 1e-13})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Local search to escape plateaus)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00005]:\n            for _ in range(3):\n                x_jitter = best_v + (np.random.normal(0, scale, 3 * n))\n                x_jitter[:2*n] = np.clip(x_jitter[:2*n], 0, 1)\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Final result extraction with microscopic safety buffer\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    c, r, s = construct_packing()\n    print(f\"Sum of radii: {s}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6], [4, 5, 4, 5, 4, 4]]\n    for cfg in configs:\n        for m in [0.08, 0.10]:\n            for shift in [0, 0.015, -0.015]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1: x_vals = np.clip(x_vals + shift, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point strategies\n    for m in [0.09, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.005, 0.995)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Refine top candidates\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Basin-Hopping Jitter and High-Precision Polish\n    if best_v is not None:\n        for scale in [0.0003, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-12 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-15)\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    bounds = [(0, max(0.0, float(min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Specialized Row Seeds (configs sum to 26)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3]]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.1]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.015, 0.001, 0.999)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci Spirals and Axial variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.46, 0.49, 0.51]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for force_p in [1.8, 2.5, 3.5]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                p = np.clip(p + 0.012 * np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1), 0.005, 0.995)\n            seeds.append(p)\n\n    # Grid 5x5 + extra point\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.01, 0.01], [0.99, 0.5], [0.5, 0.01]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # 2. Fast Screening and Refinement\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(25, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.998])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 600, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Jitter Polish (Basin Hopping)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00005]:\n            for _ in range(3):\n                x_jit = best_v + np.random.normal(0, scale, 3 * n)\n                x_jit[2*n:] = np.clip(x_jit[2*n:], 1e-12, 0.5)\n                res = minimize(obj_fn, x_jit, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 2e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the 26-circle packing optimizer.\"\"\"\n    return run_packing()\n```"]}}, "artifacts_json": "{\"execution_time\": \"8.19s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.618362/2.635 = 0.9937\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.4% of target value\", \"radius_stats\": \"Min: 0.054280, Max: 0.141841, Avg: 0.100706\"}", "artifact_dir": null, "embedding": null}