{"id": "71ed0d73-b5d9-477f-89b5-fd7410ba4e6e", "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Target: 2.635.\n    Strategy:\n    1. Multi-Modal Seeding: Combines row partitions, hexagonal-like staggered \n       grids, and heterogeneous physics-based repulsion (variable 'masses').\n    2. LP Screening: Rapidly evaluates candidate topologies using Linear \n       Programming to find the absolute maximum sum of radii for fixed centers.\n    3. Analytical Nonlinear Optimization: Refines the best 18 topologies using \n       SLSQP with exact Jacobians for both coordinates and radii.\n    4. Adaptive Local Search: Applies iterative \"shake\" and re-optimization \n       on the top 4 performers to escape local geometric traps.\n    5. Precision Final Squeeze: A final high-precision LP pass maximizes sum \n       of radii for the optimized coordinates.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Constraint matrix for Linear Programming: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Finds max radii sum for fixed centers P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundaries: ri <= x, ri <= 1-x, ri <= y, ri <= 1-y\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Seed Generation\n    seeds = []\n    \n    # 1a. Systematic Row Partitions\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 5, 4, 5, 4, 4], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 4, 5, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7],\n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 5, 5, 5, 4, 3],\n        [2, 5, 6, 6, 5, 2], [1, 6, 6, 6, 6, 1], [4, 4, 4, 5, 5, 4]\n    ]\n    for p in partitions:\n        nr = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, nr)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.3, 0.6]:\n                    pts = []\n                    for r_idx, cnt in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, cnt)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # 1b. Biased Force-Directed Repulsion\n    for _ in range(25):\n        pos = rng.rand(n, 2)\n        # Weights encourage variable radii (heterogeneous packing)\n        bias = rng.exponential(0.6, n) + 0.6\n        if _ % 5 == 0: bias[:4] *= 2.0  # Corner bias\n        for _it in range(75):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            f_mag = (bias[:, None] + bias[None, :]) / (dsq**1.5)\n            force = np.sum(diff * f_mag[:, :, None], axis=1)\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.005 * force + 0.003 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Screening\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Nonlinear Refinement (SLSQP with Analytical Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_obj(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constr(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constr(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    refined_list = []\n    for i in range(min(18, len(candidates))):\n        _, s_c, s_r = candidates[i]\n        x0 = np.concatenate([s_c[:, 0], s_c[:, 1], s_r])\n        res = minimize(objective, x0, jac=jac_obj, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constr, 'jac': jac_constr},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            cur_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            cur_r, cur_s = solve_lp(cur_c)\n            if cur_r is not None: refined_list.append((cur_s, cur_c, cur_r))\n    \n    refined_list.sort(key=lambda x: x[0], reverse=True)\n    best_sum, best_centers, best_radii = refined_list[0]\n\n    # 4. Basin-Hopping Local Search\n    for i in range(min(4, len(refined_list))):\n        c_sum, c_c, c_r = refined_list[i]\n        state = np.concatenate([c_c[:, 0], c_c[:, 1], c_r])\n        for shake in [0.0006, 0.0001]:\n            for _ in range(3):\n                p_state = state + rng.normal(0, shake, 3*n)\n                res = minimize(objective, p_state, jac=jac_obj, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constr, 'jac': jac_constr},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Final Geometry Fix\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "ac6874c0-be52-44a1-a4c3-041bdb265b0c", "generation": 5, "timestamp": 1771630964.5508323, "iteration_found": 92, "metrics": {"validity": 1.0, "sum_radii": 2.6310935888183637, "target_ratio": 0.9985174910126619, "combined_score": 0.9985174910126619, "radius_variance": 0.00555189404751289, "spatial_spread": 0.19740718412429487, "eval_time": 5.537215948104858}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.631093572791535, "target_ratio": 0.9985174849303738, "combined_score": 0.9985174849303738, "radius_variance": 0.005551893302517669, "spatial_spread": 0.19740718399427795, "eval_time": 1.6225297451019287}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9985\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9985\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n1.62s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.631094/2.635 = 0.9985\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.9% of target value\n```\n\n### radius_stats\n```\nMin: 0.072859, Max: 0.131817, Avg: 0.101196\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6311, target_ratio: 0.9985, combined_score: 0.9985, radius_variance: 0.0056, spatial_spread: 0.1974, eval_time: 1.6225\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6311, target_ratio: 0.9985, combined_score: 0.9985, radius_variance: 0.0056, spatial_spread: 0.1974, eval_time: 2.3503\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6311, target_ratio: 0.9985, combined_score: 0.9985, radius_variance: 0.0056, spatial_spread: 0.1974, eval_time: 4.3248\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Heterogeneous Seed Generation: Focuses on \"defect-based\" grids and weighted \n       repulsion to discover asymmetric topologies that favor a mix of large and \n       small circles, which is optimal for the sum-of-radii objective.\n    2. Dual-Stage Global Search:\n       - Screening: Rapidly evaluates candidate topologies via Linear Programming (LP).\n       - Focused Refinement: Deeply optimizes the top 20 diverse topologies.\n    3. Analytical Nonlinear Optimization: Uses high-precision SLSQP with vectorized \n       Jacobians to converge on precise geometric coordinates.\n    4. Iterative Basin-Hopping: Perturbs the best candidates to explore the local \n       geometry more thoroughly.\n    5. Final Precision Squeeze: A final LP pass extract every possible micron of radius.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates optimal radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Diverse Seed Generation\n    seeds = []\n    \n    # 1a. Row partitions (likely high-density candidates)\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4],\n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 4, 4, 5, 5, 4]\n    ]\n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, cnt in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, cnt)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # 1b. Defect-based Grid Seeds (starting from 5x5)\n    gx, gy = np.mgrid[0.1:0.9:5j, 0.1:0.9:5j]\n    base_grid = np.column_stack([gx.ravel(), gy.ravel()])\n    for _ in range(5):\n        # Add 26th circle at various locations to \"break\" the symmetry\n        pt = rng.uniform(0.1, 0.9, (1, 2))\n        seeds.append(np.vstack([base_grid, pt]))\n\n    # 1c. Weighted Physics-based Repulsion\n    # Using varying weights forces some circles to become larger\n    for _ in range(20):\n        pos = rng.rand(n, 2)\n        # Mix of equal weights and highly varied weights\n        bias = rng.exponential(0.5, n) + 0.7 if _ % 2 == 0 else np.ones(n)\n        for _iter in range(70):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            # Repulsion force inversely proportional to distance cubed, scaled by bias\n            force = np.sum(diff * ((bias[:, None, None] + bias[None, :, None]) / dsq[:, :, None]**1.5), axis=1)\n            # Wall repulsion to keep things in the unit square\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.004 * force + 0.002 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Filtering Stage (LP)\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refinement Stage (SLSQP with Analytical Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_sum, best_centers, best_radii = 0, candidates[0][1], candidates[0][2]\n\n    # Refine the top 20 candidate topologies discovered during screening\n    for i in range(min(20, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 600, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_sum:\n                best_sum, best_centers, best_radii = curr_s, curr_c, curr_r\n\n    # 4. Basin-Hopping Polish\n    if best_centers is not None:\n        curr_state = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        for shake in [0.001, 0.0002]:\n            for _ in range(4):\n                x_perturbed = curr_state + rng.normal(0, shake, 3*n)\n                res = minimize(objective, x_perturbed, jac=jac_objective, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        curr_state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Final Geometry Finalization\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    # Robust safety buffer for float-point precision\n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (7.3835)\n\n### Program 2 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square with the goal of reaching 2.635.\n    \n    Strategy:\n    1. Multi-Origin Seeding:\n       - Structured Row Partitions: Systematically explores integer partitions of 26 into \n         staggered rows to cover dense hexagonal-like grid topologies.\n       - Biased Physics-Based Repulsion: Uses a force-directed model where circles are \n         assigned heterogeneous weights ('masses'), encouraging the discovery of layouts \n         that favor a mixture of large and small circles.\n       - Corner-Anchored Seeds: Forces circles into corners before applying repulsion, \n         optimizing for edge effects.\n    2. High-Throughput LP Screening:\n       - Uses vectorized Linear Programming (HiGHS) to instantly calculate the absolute \n         optimal radii for hundreds of center-position candidates.\n    3. High-Precision Nonlinear Optimization:\n       - Refines the top 15 candidates using SLSQP with vectorized analytical Jacobians.\n       - Simultaneously optimizes centers and radii to satisfy non-overlap and boundary constraints.\n    4. Multi-Path Basin-Hopping:\n       - Applies local perturbations and restarts for the top 3 discovered topologies \n         to escape local minima and push the radii to the limit.\n    5. Precise Final Squeeze:\n       - A high-precision LP pass and microscopic safety buffer (1e-11) ensure valid, maximal radii.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates exact optimal radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary constraints: r_i <= min(xi, 1-xi, yi, 1-yi)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Broad Seed Generation\n    seeds = []\n    \n    # 1a. Row partitions covering the integer partition space of 26\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4],\n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 4, 4, 5, 5, 4],\n        [2, 5, 6, 6, 5, 2], [1, 6, 6, 6, 6, 1]\n    ]\n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.3, 0.6]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, count)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # 1b. Heterogeneous Bias Force-Directed Repulsion\n    for _ in range(30):\n        pos = rng.rand(n, 2)\n        # Mixtures of biased weights help discover asymmetric optimal topologies\n        bias = rng.exponential(0.6, n) + 0.6 if _ % 2 == 0 else np.ones(n)\n        if _ % 5 == 0: bias[:4] *= 2.0 # Favoring corner/edge dominance\n        for _iter in range(80):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            f_mag = (bias[:, None] + bias[None, :]) / (dsq**1.5)\n            force = np.sum(diff * f_mag[:, :, None], axis=1)\n            # Boundary push\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.005 * force + 0.003 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Vectorized LP Screening\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. High-Precision Refinement (SLSQP with Vectorized Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    top_refinements = []\n    # Refine the top 15 candidate topologies\n    for i in range(min(15, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None:\n                top_refinements.append((curr_s, curr_c, curr_r))\n    \n    top_refinements.sort(key=lambda x: x[0], reverse=True)\n    best_sum, best_centers, best_radii = top_refinements[0]\n\n    # 4. Basin-Hopping Polish (Deep search on top 3 candidates)\n    for i in range(min(3, len(top_refinements))):\n        curr_sum, curr_c, curr_r = top_refinements[i]\n        curr_state = np.concatenate([curr_c[:, 0], curr_c[:, 1], curr_r])\n        for shake in [0.0005, 0.0001]:\n            for _ in range(3):\n                x_shaken = curr_state + rng.normal(0, shake, 3*n)\n                res = minimize(objective, x_shaken, jac=jac_objective, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        curr_state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Precision Geometry Finalization\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    # Microscopic safety buffer for floating point requirements\n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (4.3248)\n\n### Program 3 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Hybrid Seed Generation: Combines structural partitions (row-based) and \n       physics-based repulsion to explore diverse topologies.\n    2. Linear Programming (LP) Screening: Rapidly evaluates fixed-center \n       configurations to find the maximum possible sum of radii.\n    3. Nonlinear Optimization (SLSQP): Simultaneously refines centers and \n       radii using analytical Jacobians for high precision.\n    4. Post-Optimization Squeeze: A final LP pass ensures the Tightest \n       possible packing for the discovered center geometry.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix (ri + rj <= dij)\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed centers P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary: ri <= min(xi, 1-xi, yi, 1-yi)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-11)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-11), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Generate Seeds\n    seeds = []\n    # Row partitions likely to be dense for n=26\n    partitions = [[5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], \n                  [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7]]\n    \n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, count)\n                        if r_idx % 2 == 1:\n                            step = (xc[1]-xc[0]) if len(xc)>1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # Physics seeds with varied repulsion biases\n    for _ in range(15):\n        pos = rng.rand(n, 2)\n        bias = rng.uniform(0.8, 1.2, n)\n        for _iter in range(50):\n            diff = pos[:, None, :] - pos[None, :, :]\n            distsq = np.sum(diff**2, axis=-1) + 1e-7\n            force = np.sum(diff * (bias[:, None, None] / distsq[:, :, None]**1.5), axis=1)\n            pos = np.clip(pos + 0.005 * force, 0.05, 0.95)\n        seeds.append(pos)\n\n    # 2. Filter Topologies via LP\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None: candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. High-Precision SLSQP Refinement\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb = num_overlap\n        rn = np.arange(n)\n        # x-r, 1-x-r, y-r, 1-y-r boundaries\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_sum, best_centers, best_radii = 0, candidates[0][1], candidates[0][2]\n\n    # Refine top candidates\n    for i in range(min(12, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-11})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_sum:\n                best_sum, best_centers, best_radii = curr_s, curr_c, curr_r\n\n    # Final verification and safety buffer\n    final_radii = best_radii - 1e-10\n    final_centers = np.clip(best_centers, 0, 1)\n    for i in range(n):\n        final_centers[i] = np.clip(final_centers[i], final_radii[i], 1.0 - final_radii[i])\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (2.3503)\n\n### Program 4 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles within a unit square.\n    \n    The strategy involves:\n    1.  Generation of diverse structural seeds (staggered row patterns, hexagonal grids, \n        and physics-based repulsion models).\n    2.  Screening candidate topologies via Linear Programming (LP) for radii optimization \n        at fixed center locations.\n    3.  High-precision refinement using Nonlinear Optimization (SLSQP) with vectorized \n        analytical Jacobians for both centers and radii.\n    4.  A final LP adjustment ensures maximum possible tightness for the optimized geometry.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix (ri + rj <= dij)\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates the absolute maximum sum of radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-11)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-11), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Extensive Seed Generation\n    seeds = []\n    # Row partitions likely to yield high density for n=26\n    partitions = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], \n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [3, 4, 5, 5, 5, 4], [4, 5, 5, 5, 4, 3], [5, 5, 5, 5, 5, 1]\n    ]\n    \n    for p in partitions:\n        num_rows = len(p)\n        for margin_y in [0.08, 0.12]:\n            yc = np.linspace(margin_y, 1.0 - margin_y, num_rows)\n            for margin_x in [0.08, 0.12]:\n                for stagger in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(margin_x, 1.0 - margin_x, count)\n                        if r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stagger * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # Force-directed repulsion seeds to break symmetries\n    for _ in range(12):\n        pos = rng.rand(n, 2)\n        bias = rng.uniform(0.8, 1.2, n)\n        for _iter in range(50):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(diff**2, axis=-1) + 1e-7\n            # Repulsion force inversely proportional to distance cubed\n            force = np.sum(diff * (bias[:, None, None] / dist_sq[:, :, None]**1.5), axis=1)\n            pos = np.clip(pos + 0.005 * force, 0.05, 0.95)\n        seeds.append(pos)\n\n    # 2. Filter Candidate Topologies via LP Screening\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. High-Precision Refinement with Analytical Jacobians\n    def objective(v): \n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        # Boundaries: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        # Jacobian of (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        # Jacobian of boundary constraints\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_final_sum = 0\n    best_final_centers = candidates[0][1]\n    best_final_radii = candidates[0][2]\n\n    # Refine top candidate topologies\n    for i in range(min(10, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            # Re-apply LP for the discovered geometry to maximize sum of radii exactly\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_final_sum:\n                best_final_sum, best_final_centers, best_final_radii = curr_s, curr_c, curr_r\n\n    # 4. Final Safety Adjustments and Validation\n    final_radii = best_final_radii - 2e-10  # Floating point safety buffer\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_final_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_final_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (1.6225)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles within a unit square.\n    Strategy:\n    1.  Generate a diverse set of structural seeds based on optimal integer partitions of 26 \n        into row-based configurations, grid patterns, and force-based repulsion configurations.\n    2.  Screen all seeds using Linear Programming (LP) to find the optimal radii for fixed center \n        positions, allowing for quick evaluation of thousands of topologies.\n    3.  Select the top candidate topologies and refine them using a high-precision Non-Linear \n        Optimization (SLSQP) with analytical Jacobians for both centers and radii.\n    4.  Perform a final LP adjustment to ensure the maximum possible sum of radii for the \n        optimized center positions while maintaining strict boundary and overlap constraints.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    def solve_lp(P):\n        \"\"\"Finds the optimal sum of radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Constraint: ri + rj <= dist_ij\n        A_ub = np.zeros((len(i_idx), n))\n        A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n        A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n        b_ub = np.maximum(0, dists - 1e-10)\n        \n        # Boundary constraints: ri <= x, ri <= 1-x, ri <= y, ri <= 1-y\n        # Essentially r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-7, max(1e-7, l - 1e-10)) for l in limits]\n        \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n        return None, 0\n\n    # 1. Seed generation using varied row partitions\n    seeds = []\n    # Key partitions for 26 circles\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 5, 4, 5, 4, 4], \n        [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 4, 5, 4, 4, 5],\n        [5, 5, 5, 5, 6], [6, 6, 7, 7], [3, 4, 5, 5, 5, 4],\n        [2, 4, 4, 5, 4, 4, 3], [5, 5, 5, 5, 5, 1]\n    ]\n    \n    for p in partitions:\n        num_rows = len(p)\n        for margin_y in [0.08, 0.12]:\n            yc = np.linspace(margin_y, 1.0 - margin_y, num_rows)\n            for margin_x in [0.08, 0.12]:\n                for stagger in [0.0, 0.25, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(margin_x, 1.0 - margin_x, count)\n                        if stagger > 0 and r_idx % 2 == 1:\n                            step = xc[1] - xc[0] if len(xc) > 1 else 0.1\n                            xc += stagger * step\n                        for x in xc:\n                            pts.append([x, yc[r_idx]])\n                    pts = np.array(pts[:n])\n                    # Fit to unit square margins\n                    pts = (pts - pts.min(0)) / (pts.max(0) - pts.min(0) + 1e-9)\n                    pts = pts * (1.0 - 2.0 * margin_x) + margin_x\n                    seeds.append(np.clip(pts, 0.0, 1.0))\n    \n    # Add physics-based repulsion seeds to find non-row-based topologies\n    for _ in range(10):\n        pos = rng.rand(n, 2)\n        for _ in range(40):\n            diff = pos[:, None, :] - pos[None, :, :]\n            d = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-3\n            force = np.sum(diff / d[:, :, None]**3, axis=1)\n            pos += 0.005 * force\n            pos = np.clip(pos, 0.1, 0.9)\n        seeds.append(pos)\n\n    # 2. Filter topologies using LP for radius optimization\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refinement stage (SLSQP with Vectorized Jacobians)\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        # Overlap: distance squared minus radii-sum squared\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        # Boundary: ri <= x, x <= 1-ri, ri <= y, y <= 1-ri\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        num_overlap = len(i_idx)\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        \n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        \n        row_b = num_overlap\n        rn = np.arange(n)\n        # x-r >= 0\n        J[row_b + rn, rn], J[row_b + rn, 2*n + rn] = 1, -1\n        # 1-x-r >= 0\n        J[row_b + n + rn, rn], J[row_b + n + rn, 2*n + rn] = -1, -1\n        # y-r >= 0\n        J[row_b + 2*n + rn, n + rn], J[row_b + 2*n + rn, 2*n + rn] = 1, -1\n        # 1-y-r >= 0\n        J[row_b + 3*n + rn, n + rn], J[row_b + 3*n + rn, 2*n + rn] = -1, -1\n        return J\n\n    best_final_sum = 0\n    best_final_centers = candidates[0][1]\n    best_final_radii = candidates[0][2]\n\n    # Refine the top 10 potential candidates\n    for i in range(min(10, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        \n        res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-7, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            options={'maxiter': 400, 'ftol': 1e-10}\n        )\n        \n        if res.success:\n            current_centers = np.column_stack([res.x[:n], res.x[n:2*n]])\n            # Final squeezed radii for this geometry\n            current_radii, current_sum = solve_lp(current_centers)\n            if current_radii is not None and current_sum > best_final_sum:\n                best_final_sum = current_sum\n                best_final_centers = current_centers\n                best_final_radii = current_radii\n\n    # Apply a tiny safety buffer and final verification\n    final_radii = best_final_radii - 1e-9\n    final_centers = np.clip(best_final_centers, 0, 1)\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9981)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Diverse Seed Generation: Focuses on row-based partitions (including asymmetric variants),\n       heterogeneous force-directed models, and perturbed grid layouts.\n    2. LP Filtering: Rapidly screens 100+ topologies using Linear Programming to find the \n       theoretical max sum of radii for fixed center positions.\n    3. Vectorized Nonlinear Optimization: Refines the top 20 candidate topologies using \n       SLSQP with analytical Jacobians for centers and radii.\n    4. Adaptive Basin Hopping: Identifies the best candidate and performs iterative\n       local searches (perturbation + refinement) to escape local optima.\n    5. Final Precision Polish: A high-precision LP pass extracts every possible micron of radius.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates the absolute maximum sum of radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary constraints: r_i <= min(xi, 1-xi, yi, 1-yi)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Seed Generation\n    seeds = []\n    \n    # 1a. Broad Row Partitions (likely candidates for n=26)\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [5, 6, 5, 6, 4], [4, 6, 6, 6, 4],\n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 5, 5, 5, 4, 3],\n        [2, 4, 5, 6, 5, 4], [3, 5, 6, 5, 4, 3], [5, 6, 6, 5, 4],\n        [1, 5, 5, 5, 5, 5], [4, 4, 4, 4, 4, 4, 2]\n    ]\n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.1, 0.12]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.12]:\n                for stag in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, count)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    # Add a bit of noise to break symmetry\n                    arr = np.array(pts[:n]) + rng.normal(0, 0.005, (n, 2))\n                    seeds.append(np.clip(arr, 0.05, 0.95))\n\n    # 1b. Weighted Force-Directed Repulsion\n    # Forces some circles to become larger by assigning varied \"potential\" weights\n    for _ in range(25):\n        pos = rng.rand(n, 2)\n        weights = rng.exponential(1.0, n) + 0.5 # Biased weight distribution\n        for _iter in range(60):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            # Repulsion force inversely proportional to distance cubed, scaled by weights\n            force_mag = (weights[:, None] + weights[None, :]) / (dsq**1.5)\n            force = np.sum(diff * force_mag[:, :, None], axis=1)\n            # Wall pressure keeps points inside\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.004 * force + 0.002 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Filtering Stage (LP Screening)\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refinement Stage (SLSQP with Analytical Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_sum, best_centers, best_radii = 0, candidates[0][1], candidates[0][2]\n\n    # Refine the top 20 candidate topologies\n    for i in range(min(20, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_sum:\n                best_sum, best_centers, best_radii = curr_s, curr_c, curr_r\n\n    # 4. Basin-Hopping Local Search on the Best Discovery\n    if best_centers is not None:\n        curr_state = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        # Try several local perturbations to shake the geometry into a tighter fit\n        for shake_scale in [0.001, 0.0002]:\n            for _ in range(4):\n                x_shaken = curr_state + rng.normal(0, shake_scale, 3*n)\n                res = minimize(objective, x_shaken, jac=jac_objective, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        curr_state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Final Geometry Finalization\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    # Robust safety buffer for float-point precision requirements\n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9985, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square with the goal of reaching 2.635.\n    \n    Strategy:\n    1. Multi-Origin Seeding:\n       - Structured Row Partitions: Systematically explores integer partitions of 26 into \n         staggered rows to cover dense hexagonal-like grid topologies.\n       - Biased Physics-Based Repulsion: Uses a force-directed model where circles are \n         assigned heterogeneous weights ('masses'), encouraging the discovery of layouts \n         that favor a mixture of large and small circles.\n       - Corner-Anchored Seeds: Forces circles into corners before applying repulsion, \n         optimizing for edge effects.\n    2. High-Throughput LP Screening:\n       - Uses vectorized Linear Programming (HiGHS) to instantly calculate the absolute \n         optimal radii for hundreds of center-position candidates.\n    3. High-Precision Nonlinear Optimization:\n       - Refines the top 15 candidates using SLSQP with vectorized analytical Jacobians.\n       - Simultaneously optimizes centers and radii to satisfy non-overlap and boundary constraints.\n    4. Multi-Path Basin-Hopping:\n       - Applies local perturbations and restarts for the top 3 discovered topologies \n         to escape local minima and push the radii to the limit.\n    5. Precise Final Squeeze:\n       - A high-precision LP pass and microscopic safety buffer (1e-11) ensure valid, maximal radii.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates exact optimal radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary constraints: r_i <= min(xi, 1-xi, yi, 1-yi)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Broad Seed Generation\n    seeds = []\n    \n    # 1a. Row partitions covering the integer partition space of 26\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4],\n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 4, 4, 5, 5, 4],\n        [2, 5, 6, 6, 5, 2], [1, 6, 6, 6, 6, 1]\n    ]\n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.3, 0.6]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, count)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # 1b. Heterogeneous Bias Force-Directed Repulsion\n    for _ in range(30):\n        pos = rng.rand(n, 2)\n        # Mixtures of biased weights help discover asymmetric optimal topologies\n        bias = rng.exponential(0.6, n) + 0.6 if _ % 2 == 0 else np.ones(n)\n        if _ % 5 == 0: bias[:4] *= 2.0 # Favoring corner/edge dominance\n        for _iter in range(80):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            f_mag = (bias[:, None] + bias[None, :]) / (dsq**1.5)\n            force = np.sum(diff * f_mag[:, :, None], axis=1)\n            # Boundary push\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.005 * force + 0.003 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Vectorized LP Screening\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. High-Precision Refinement (SLSQP with Vectorized Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    top_refinements = []\n    # Refine the top 15 candidate topologies\n    for i in range(min(15, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None:\n                top_refinements.append((curr_s, curr_c, curr_r))\n    \n    top_refinements.sort(key=lambda x: x[0], reverse=True)\n    best_sum, best_centers, best_radii = top_refinements[0]\n\n    # 4. Basin-Hopping Polish (Deep search on top 3 candidates)\n    for i in range(min(3, len(top_refinements))):\n        curr_sum, curr_c, curr_r = top_refinements[i]\n        curr_state = np.concatenate([curr_c[:, 0], curr_c[:, 1], curr_r])\n        for shake in [0.0005, 0.0001]:\n            for _ in range(3):\n                x_shaken = curr_state + rng.normal(0, shake, 3*n)\n                res = minimize(objective, x_shaken, jac=jac_objective, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        curr_state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Precision Geometry Finalization\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    # Microscopic safety buffer for floating point requirements\n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9981, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Diverse Seed Generation: Focuses on row-based partitions (including asymmetric variants),\n       heterogeneous force-directed models, and perturbed grid layouts.\n    2. LP Filtering: Rapidly screens 100+ topologies using Linear Programming to find the \n       theoretical max sum of radii for fixed center positions.\n    3. Vectorized Nonlinear Optimization: Refines the top 20 candidate topologies using \n       SLSQP with analytical Jacobians for centers and radii.\n    4. Adaptive Basin Hopping: Identifies the best candidate and performs iterative\n       local searches (perturbation + refinement) to escape local optima.\n    5. Final Precision Polish: A high-precision LP pass extracts every possible micron of radius.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates the absolute maximum sum of radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary constraints: r_i <= min(xi, 1-xi, yi, 1-yi)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Seed Generation\n    seeds = []\n    \n    # 1a. Broad Row Partitions (likely candidates for n=26)\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [5, 6, 5, 6, 4], [4, 6, 6, 6, 4],\n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 5, 5, 5, 4, 3],\n        [2, 4, 5, 6, 5, 4], [3, 5, 6, 5, 4, 3], [5, 6, 6, 5, 4],\n        [1, 5, 5, 5, 5, 5], [4, 4, 4, 4, 4, 4, 2]\n    ]\n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.1, 0.12]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.12]:\n                for stag in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, count)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    # Add a bit of noise to break symmetry\n                    arr = np.array(pts[:n]) + rng.normal(0, 0.005, (n, 2))\n                    seeds.append(np.clip(arr, 0.05, 0.95))\n\n    # 1b. Weighted Force-Directed Repulsion\n    # Forces some circles to become larger by assigning varied \"potential\" weights\n    for _ in range(25):\n        pos = rng.rand(n, 2)\n        weights = rng.exponential(1.0, n) + 0.5 # Biased weight distribution\n        for _iter in range(60):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            # Repulsion force inversely proportional to distance cubed, scaled by weights\n            force_mag = (weights[:, None] + weights[None, :]) / (dsq**1.5)\n            force = np.sum(diff * force_mag[:, :, None], axis=1)\n            # Wall pressure keeps points inside\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.004 * force + 0.002 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Filtering Stage (LP Screening)\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refinement Stage (SLSQP with Analytical Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_sum, best_centers, best_radii = 0, candidates[0][1], candidates[0][2]\n\n    # Refine the top 20 candidate topologies\n    for i in range(min(20, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_sum:\n                best_sum, best_centers, best_radii = curr_s, curr_c, curr_r\n\n    # 4. Basin-Hopping Local Search on the Best Discovery\n    if best_centers is not None:\n        curr_state = np.concatenate([best_centers[:, 0], best_centers[:, 1], best_radii])\n        # Try several local perturbations to shake the geometry into a tighter fit\n        for shake_scale in [0.001, 0.0002]:\n            for _ in range(4):\n                x_shaken = curr_state + rng.normal(0, shake_scale, 3*n)\n                res = minimize(objective, x_shaken, jac=jac_objective, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        curr_state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Final Geometry Finalization\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    # Robust safety buffer for float-point precision requirements\n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9949, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Exhaustively generate rational topological row arrangements via integer partitions.\n    2. Sweep them into 1500+ structured layouts by interleaving margins and alternating shift-staggers.\n    3. Quickly filter layouts via structural `min_dist` sorting, and score them using Linear Programming.\n    4. Group matching topological reflections into diverse subsets.\n    5. Perform a fast/short non-linear SLSQP on varied subsets, and a deep/long SLSQP on the top 6.\n    6. Ensure unbreakable boundaries utilizing a dynamic geometric shrink-adjuster.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n\n    # Pre-allocate LP boundary condition array to prevent repeat allocations\n    A_ub_lp = np.zeros((num_overlap, n))\n    A_ub_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_ub_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        c = -np.ones(n)\n        dist = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        b = np.maximum(0, dist - 1e-8)\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((1e-7, max(1e-7, d_wall - 1e-8)))\n            \n        try:\n            res = linprog(c, A_ub=A_ub_lp, b_ub=b, bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # Exhaustive Topology Partition Generation\n    partitions = []\n    def partition(rem, rows_left, current):\n        if rows_left == 1:\n            if 2 <= rem <= 8:\n                if not current or abs(rem - current[-1]) <= 2:\n                    partitions.append(current + [rem])\n            return\n        for i in range(2, 9):\n            if not current or abs(i - current[-1]) <= 2:\n                partition(rem - i, rows_left - 1, current + [i])\n                \n    for r in range(4, 8):\n        partition(n, r, [])\n        \n    unique_partitions = []\n    for p in partitions:\n        if p[::-1] < p:\n            continue\n        unique_partitions.append(p)\n\n    # Add targeted known dense subsets\n    manual_configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2],\n        [1, 5, 5, 5, 5, 5], [2, 4, 4, 4, 4, 4, 4],\n        [5, 6, 4, 6, 5], [4, 5, 4, 4, 5, 4]\n    ]\n    \n    for mc in manual_configs:\n        if mc not in unique_partitions and mc[::-1] not in unique_partitions:\n            unique_partitions.append(mc)\n\n    seeds = []\n    for cfg in unique_partitions:\n        num_rows = len(cfg)\n        for margin_y in [0.06, 0.08, 0.10, 0.12]:\n            for margin_x in [0.06, 0.08, 0.10, 0.12]:\n                for stagger in [0.0, 0.02, -0.02, 0.04, -0.04]:\n                    pts = []\n                    for r_idx, count in enumerate(cfg):\n                        y = margin_y + (1.0 - 2.0 * margin_y) * r_idx / (max(1, num_rows - 1))\n                        if count == 1:\n                            x_vals = [0.5]\n                        else:\n                            x_vals = np.linspace(margin_x, 1.0 - margin_x, count)\n                        \n                        shift = stagger if r_idx % 2 == 1 else 0.0\n                        for x in x_vals:\n                            pts.append([x + shift, y])\n                    s = np.clip(np.array(pts[:n]), 0.05, 0.95)\n                    if len(s) == n:\n                        seeds.append(s)\n\n    # Queue min_dist structural sort to obtain only computationally viable arrays\n    min_dists = []\n    for s in seeds:\n        dist_sq = np.sum((s[:, None, :] - s[None, :, :])**2, axis=-1)\n        np.fill_diagonal(dist_sq, np.inf)\n        min_dists.append(np.min(dist_sq))\n        \n    seed_dist_pairs = list(zip(min_dists, seeds))\n    seed_dist_pairs.sort(key=lambda x: x[0], reverse=True)\n    valid_seeds = [s for d, s in seed_dist_pairs[:1500]]\n\n    # Generate additional physics repulsion-based architectures\n    def get_repulsion_seed(bias_type='uniform', steps=80):\n        pos = rng.rand(n, 2)\n        if bias_type == 'biased':\n            target_r = rng.uniform(0.05, 0.15, n)\n        else:\n            target_r = np.full(n, 0.1)\n            \n        for _ in range(steps):\n            dists = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist = np.sqrt(dist_sq + 1e-9)\n            \n            force_mag = (target_r[:, None] + target_r[None, :]) / (dist + 1e-2)**2\n            mask = dist < (target_r[:, None] + target_r[None, :] + 0.05)\n            force = dists * (force_mag[:, :, None] / dist[:, :, None]) * mask[..., None]\n            pos += 0.002 * np.sum(force, axis=1)\n            \n            pos[:, 0] += 0.002 * (1/np.maximum(pos[:, 0], 0.02) - 1/np.maximum(1-pos[:, 0], 0.02))\n            pos[:, 1] += 0.002 * (1/np.maximum(pos[:, 1], 0.02) - 1/np.maximum(1-pos[:, 1], 0.02))\n            \n            pos = np.clip(pos, 0.02, 0.98)\n        return pos\n\n    for _ in range(30):\n        valid_seeds.append(get_repulsion_seed(bias_type='uniform'))\n        valid_seeds.append(get_repulsion_seed(bias_type='biased'))\n\n    # Linear Programming evaluation\n    candidates = []\n    for s in valid_seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n            \n    if not candidates:\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n        \n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    def get_topology_signature(pts):\n        dists = np.sqrt(np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1))\n        triu_dists = dists[np.triu_indices(n, k=1)]\n        return np.sort(triu_dists)\n\n    # Topological Clustering removes mirror/symmetrical iterations from draining SLSQP allocations\n    unique_candidates = []\n    seen_signatures = []\n    for total, s, radii in candidates:\n        sig = get_topology_signature(s)\n        is_unique = True\n        for seen_sig in seen_signatures:\n            if np.mean(np.abs(sig - seen_sig)) < 0.005:\n                is_unique = False\n                break\n                \n        if is_unique:\n            seen_signatures.append(sig)\n            unique_candidates.append((total, s, radii))\n            if len(unique_candidates) >= 50:\n                break\n\n    if len(unique_candidates) < 10:\n        unique_candidates = candidates[:50]\n\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        row_idx = np.arange(num_overlap)\n        J[row_idx, i_idx] = 2 * dx\n        J[row_idx, j_idx] = -2 * dx\n        J[row_idx, n + i_idx] = 2 * dy\n        J[row_idx, n + j_idx] = -2 * dy\n        J[row_idx, 2 * n + i_idx] = -2 * dr\n        J[row_idx, 2 * n + j_idx] = -2 * dr\n        \n        row = num_overlap\n        r_idx = np.arange(n)\n        J[row + r_idx, r_idx] = 1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, r_idx] = -1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, n + r_idx] = 1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, n + r_idx] = -1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        \n        return J\n\n    def is_valid(x_opt, tol=1e-3):\n        c = constraints_func(x_opt)\n        return np.all(c >= -tol)\n\n    def optimize_slsqp(centers, radii, maxiter=100, ftol=1e-6):\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        if maxiter > 100:  # Introduce slight jitter breaks saddle-symmetry blocks\n            x0[:2*n] += rng.normal(0, 1e-5, 2*n)\n            \n        res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-6, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            options={'maxiter': maxiter, 'ftol': ftol}\n        )\n        \n        if is_valid(res.x):\n            return res.fun, res.x\n        return 0, None\n\n    # Step 1: Run Short Hierarchical refinement phase\n    short_results = []\n    for total, s_pos, s_rad in unique_candidates:\n        val, x_opt = optimize_slsqp(s_pos, s_rad, maxiter=80, ftol=1e-5)\n        if x_opt is not None:\n            short_results.append((val, x_opt))\n            \n    short_results.sort(key=lambda x: x[0])\n\n    # Step 2: Extract top-tier structures into Long Hierarchical phase\n    best_val = 0\n    best_x = None\n    \n    for val, x_opt in short_results[:6]:\n        c = np.column_stack((x_opt[:n], x_opt[n:2*n]))\n        r = x_opt[2*n:]\n        final_val, final_x = optimize_slsqp(c, r, maxiter=800, ftol=1e-9)\n        if final_x is not None and final_val < best_val:\n            best_val = final_val\n            best_x = final_x\n\n    if best_x is None:\n        if short_results:\n            best_x = short_results[0][1]\n        else:\n            s, radii = unique_candidates[0][1], unique_candidates[0][2]\n            best_x = np.concatenate([s[:, 0], s[:, 1], radii])\n\n    best_centers = np.column_stack((best_x[:n], best_x[n:2*n]))\n    best_radii = best_x[2*n:]\n\n    # Bulletproof dynamic geometric constraint resolver ensures 100% boundary safety\n    final_radii = np.copy(best_radii)\n    final_centers = np.copy(best_centers)\n    \n    for i in range(n):\n        final_centers[i, 0] = np.clip(final_centers[i, 0], final_radii[i], 1.0 - final_radii[i])\n        final_centers[i, 1] = np.clip(final_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((final_centers[i] - final_centers[j])**2))\n            if final_radii[i] + final_radii[j] > dist:\n                excess = final_radii[i] + final_radii[j] - dist + 1e-10\n                sum_r = final_radii[i] + final_radii[j]\n                if sum_r > 0:\n                    final_radii[i] -= excess * (final_radii[i] / sum_r)\n                    final_radii[j] -= excess * (final_radii[j] / sum_r)\n                else:\n                    final_radii[i] = 0\n                    final_radii[j] = 0\n\n    final_sum = float(np.sum(final_radii))\n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.9985, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Hybrid Seed Generation: Combines structural partitions (row-based) and \n       physics-based repulsion to explore diverse topologies.\n    2. Linear Programming (LP) Screening: Rapidly evaluates fixed-center \n       configurations to find the maximum possible sum of radii.\n    3. Nonlinear Optimization (SLSQP): Simultaneously refines centers and \n       radii using analytical Jacobians for high precision.\n    4. Post-Optimization Squeeze: A final LP pass ensures the Tightest \n       possible packing for the discovered center geometry.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix (ri + rj <= dij)\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed centers P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary: ri <= min(xi, 1-xi, yi, 1-yi)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-11)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-11), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Generate Seeds\n    seeds = []\n    # Row partitions likely to be dense for n=26\n    partitions = [[5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], \n                  [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7]]\n    \n    for p in partitions:\n        num_rows = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, num_rows)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, count)\n                        if r_idx % 2 == 1:\n                            step = (xc[1]-xc[0]) if len(xc)>1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # Physics seeds with varied repulsion biases\n    for _ in range(15):\n        pos = rng.rand(n, 2)\n        bias = rng.uniform(0.8, 1.2, n)\n        for _iter in range(50):\n            diff = pos[:, None, :] - pos[None, :, :]\n            distsq = np.sum(diff**2, axis=-1) + 1e-7\n            force = np.sum(diff * (bias[:, None, None] / distsq[:, :, None]**1.5), axis=1)\n            pos = np.clip(pos + 0.005 * force, 0.05, 0.95)\n        seeds.append(pos)\n\n    # 2. Filter Topologies via LP\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None: candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. High-Precision SLSQP Refinement\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb = num_overlap\n        rn = np.arange(n)\n        # x-r, 1-x-r, y-r, 1-y-r boundaries\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_sum, best_centers, best_radii = 0, candidates[0][1], candidates[0][2]\n\n    # Refine top candidates\n    for i in range(min(12, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-11})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_sum:\n                best_sum, best_centers, best_radii = curr_s, curr_c, curr_r\n\n    # Final verification and safety buffer\n    final_radii = best_radii - 1e-10\n    final_centers = np.clip(best_centers, 0, 1)\n    for i in range(n):\n        final_centers[i] = np.clip(final_centers[i], final_radii[i], 1.0 - final_radii[i])\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles within a unit square.\n    \n    The strategy involves:\n    1.  Generation of diverse structural seeds (staggered row patterns, hexagonal grids, \n        and physics-based repulsion models).\n    2.  Screening candidate topologies via Linear Programming (LP) for radii optimization \n        at fixed center locations.\n    3.  High-precision refinement using Nonlinear Optimization (SLSQP) with vectorized \n        analytical Jacobians for both centers and radii.\n    4.  A final LP adjustment ensures maximum possible tightness for the optimized geometry.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Pre-calculate LP constraint matrix (ri + rj <= dij)\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Calculates the absolute maximum sum of radii for fixed center positions P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-11)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-11), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Extensive Seed Generation\n    seeds = []\n    # Row partitions likely to yield high density for n=26\n    partitions = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], \n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7], \n        [3, 4, 5, 5, 5, 4], [4, 5, 5, 5, 4, 3], [5, 5, 5, 5, 5, 1]\n    ]\n    \n    for p in partitions:\n        num_rows = len(p)\n        for margin_y in [0.08, 0.12]:\n            yc = np.linspace(margin_y, 1.0 - margin_y, num_rows)\n            for margin_x in [0.08, 0.12]:\n                for stagger in [0.0, 0.5]:\n                    pts = []\n                    for r_idx, count in enumerate(p):\n                        xc = np.linspace(margin_x, 1.0 - margin_x, count)\n                        if r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stagger * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # Force-directed repulsion seeds to break symmetries\n    for _ in range(12):\n        pos = rng.rand(n, 2)\n        bias = rng.uniform(0.8, 1.2, n)\n        for _iter in range(50):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(diff**2, axis=-1) + 1e-7\n            # Repulsion force inversely proportional to distance cubed\n            force = np.sum(diff * (bias[:, None, None] / dist_sq[:, :, None]**1.5), axis=1)\n            pos = np.clip(pos + 0.005 * force, 0.05, 0.95)\n        seeds.append(pos)\n\n    # 2. Filter Candidate Topologies via LP Screening\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. High-Precision Refinement with Analytical Jacobians\n    def objective(v): \n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        # Boundaries: x-r >= 0, 1-x-r >= 0, y-r >= 0, 1-y-r >= 0\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        # Jacobian of (xi-xj)^2 + (yi-yj)^2 - (ri+rj)^2\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        # Jacobian of boundary constraints\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    best_final_sum = 0\n    best_final_centers = candidates[0][1]\n    best_final_radii = candidates[0][2]\n\n    # Refine top candidate topologies\n    for i in range(min(10, len(candidates))):\n        _, s_centers, s_radii = candidates[i]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], s_radii])\n        res = minimize(objective, x0, jac=jac_objective, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            curr_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            # Re-apply LP for the discovered geometry to maximize sum of radii exactly\n            curr_r, curr_s = solve_lp(curr_c)\n            if curr_r is not None and curr_s > best_final_sum:\n                best_final_sum, best_final_centers, best_final_radii = curr_s, curr_c, curr_r\n\n    # 4. Final Safety Adjustments and Validation\n    final_radii = best_final_radii - 2e-10  # Floating point safety buffer\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_final_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_final_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    \n    Target: 2.635.\n    Strategy:\n    1. Multi-Modal Seeding: Combines row partitions, hexagonal-like staggered \n       grids, and heterogeneous physics-based repulsion (variable 'masses').\n    2. LP Screening: Rapidly evaluates candidate topologies using Linear \n       Programming to find the absolute maximum sum of radii for fixed centers.\n    3. Analytical Nonlinear Optimization: Refines the best 18 topologies using \n       SLSQP with exact Jacobians for both coordinates and radii.\n    4. Adaptive Local Search: Applies iterative \"shake\" and re-optimization \n       on the top 4 performers to escape local geometric traps.\n    5. Precision Final Squeeze: A final high-precision LP pass maximizes sum \n       of radii for the optimized coordinates.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    num_overlap = len(i_idx)\n\n    # Constraint matrix for Linear Programming: ri + rj <= dij\n    A_lp = np.zeros((num_overlap, n))\n    A_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        \"\"\"Finds max radii sum for fixed centers P.\"\"\"\n        c = -np.ones(n)\n        dists = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Boundaries: ri <= x, ri <= 1-x, ri <= y, ri <= 1-y\n        limits = np.min(np.concatenate([P, 1.0 - P], axis=1), axis=1)\n        bounds = [(1e-8, max(1e-8, l - 1e-12)) for l in limits]\n        try:\n            res = linprog(c, A_ub=A_lp, b_ub=np.maximum(0, dists - 1e-12), \n                          bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Seed Generation\n    seeds = []\n    \n    # 1a. Systematic Row Partitions\n    partitions = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 5, 4, 5, 4, 4], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 4, 5, 5, 4, 4], [5, 5, 5, 5, 6], [6, 6, 7, 7],\n        [5, 5, 5, 5, 5, 1], [3, 4, 5, 5, 5, 4], [4, 5, 5, 5, 4, 3],\n        [2, 5, 6, 6, 5, 2], [1, 6, 6, 6, 6, 1], [4, 4, 4, 5, 5, 4]\n    ]\n    for p in partitions:\n        nr = len(p)\n        for my in [0.08, 0.11]:\n            yc = np.linspace(my, 1.0 - my, nr)\n            for mx in [0.08, 0.11]:\n                for stag in [0.0, 0.3, 0.6]:\n                    pts = []\n                    for r_idx, cnt in enumerate(p):\n                        xc = np.linspace(mx, 1.0 - mx, cnt)\n                        if stag > 0 and r_idx % 2 == 1:\n                            step = (xc[1] - xc[0]) if len(xc) > 1 else 0.1\n                            xc = np.clip(xc + stag * step, 0, 1)\n                        for x in xc: pts.append([x, yc[r_idx]])\n                    seeds.append(np.array(pts[:n]))\n\n    # 1b. Biased Force-Directed Repulsion\n    for _ in range(25):\n        pos = rng.rand(n, 2)\n        # Weights encourage variable radii (heterogeneous packing)\n        bias = rng.exponential(0.6, n) + 0.6\n        if _ % 5 == 0: bias[:4] *= 2.0  # Corner bias\n        for _it in range(75):\n            diff = pos[:, None, :] - pos[None, :, :]\n            dsq = np.sum(diff**2, axis=-1) + 1e-7\n            f_mag = (bias[:, None] + bias[None, :]) / (dsq**1.5)\n            force = np.sum(diff * f_mag[:, :, None], axis=1)\n            wall = 0.01 * (1.0/(pos**2 + 1e-4) - 1.0/((1-pos)**2 + 1e-4))\n            pos = np.clip(pos + 0.005 * force + 0.003 * wall, 0.02, 0.98)\n        seeds.append(pos)\n\n    # 2. Screening\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Nonlinear Refinement (SLSQP with Analytical Jacobians)\n    def objective(v): return -np.sum(v[2*n:])\n    def jac_obj(v):\n        j = np.zeros(3*n); j[2*n:] = -1.0\n        return j\n        \n    def constr(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        overlap = dx**2 + dy**2 - rs**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constr(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, rs = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        row_o = np.arange(num_overlap)\n        J[row_o, i_idx], J[row_o, j_idx] = 2 * dx, -2 * dx\n        J[row_o, n + i_idx], J[row_o, n + j_idx] = 2 * dy, -2 * dy\n        J[row_o, 2*n + i_idx], J[row_o, 2*n + j_idx] = -2 * rs, -2 * rs\n        rb, rn = num_overlap, np.arange(n)\n        for k, (off, val) in enumerate([(0,1), (0,-1), (n,1), (n,-1)]):\n            J[rb + k*n + rn, off + rn], J[rb + k*n + rn, 2*n + rn] = val, -1\n        return J\n\n    refined_list = []\n    for i in range(min(18, len(candidates))):\n        _, s_c, s_r = candidates[i]\n        x0 = np.concatenate([s_c[:, 0], s_c[:, 1], s_r])\n        res = minimize(objective, x0, jac=jac_obj, method='SLSQP',\n                       bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                       constraints={'type': 'ineq', 'fun': constr, 'jac': jac_constr},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success:\n            cur_c = np.column_stack([res.x[:n], res.x[n:2*n]])\n            cur_r, cur_s = solve_lp(cur_c)\n            if cur_r is not None: refined_list.append((cur_s, cur_c, cur_r))\n    \n    refined_list.sort(key=lambda x: x[0], reverse=True)\n    best_sum, best_centers, best_radii = refined_list[0]\n\n    # 4. Basin-Hopping Local Search\n    for i in range(min(4, len(refined_list))):\n        c_sum, c_c, c_r = refined_list[i]\n        state = np.concatenate([c_c[:, 0], c_c[:, 1], c_r])\n        for shake in [0.0006, 0.0001]:\n            for _ in range(3):\n                p_state = state + rng.normal(0, shake, 3*n)\n                res = minimize(objective, p_state, jac=jac_obj, method='SLSQP',\n                               bounds=[(0, 1)] * (2*n) + [(1e-7, 0.45)] * n,\n                               constraints={'type': 'ineq', 'fun': constr, 'jac': jac_constr},\n                               options={'maxiter': 500, 'ftol': 1e-12})\n                if res.success:\n                    tc = np.column_stack([res.x[:n], res.x[n:2*n]])\n                    tr, ts = solve_lp(tc)\n                    if tr is not None and ts > best_sum:\n                        best_sum, best_centers, best_radii = ts, tc, tr\n                        state = np.concatenate([tc[:,0], tc[:,1], tr])\n\n    # 5. Final Geometry Fix\n    final_radii_raw, _ = solve_lp(best_centers)\n    if final_radii_raw is None: final_radii_raw = best_radii\n    \n    final_radii = final_radii_raw - 1e-11\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i] = [\n            np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i]),\n            np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        ]\n        \n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n\n```"]}}, "artifacts_json": "{\"execution_time\": \"5.54s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.631094/2.635 = 0.9985\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.9% of target value\", \"radius_stats\": \"Min: 0.072841, Max: 0.131818, Avg: 0.101196\"}", "artifact_dir": null, "embedding": null}