{"id": "7158de9f-6e65-422f-a10b-5c1fbc9708f3", "code": "import numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Exhaustively generate rational topological row arrangements via integer partitions.\n    2. Sweep them into 1500+ structured layouts by interleaving margins and alternating shift-staggers.\n    3. Quickly filter layouts via structural `min_dist` sorting, and score them using Linear Programming.\n    4. Group matching topological reflections into diverse subsets.\n    5. Perform a fast/short non-linear SLSQP on varied subsets, and a deep/long SLSQP on the top 6.\n    6. Ensure unbreakable boundaries utilizing a dynamic geometric shrink-adjuster.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n\n    # Pre-allocate LP boundary condition array to prevent repeat allocations\n    A_ub_lp = np.zeros((num_overlap, n))\n    A_ub_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_ub_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        c = -np.ones(n)\n        dist = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        b = np.maximum(0, dist - 1e-8)\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((1e-7, max(1e-7, d_wall - 1e-8)))\n            \n        try:\n            res = linprog(c, A_ub=A_ub_lp, b_ub=b, bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # Exhaustive Topology Partition Generation\n    partitions = []\n    def partition(rem, rows_left, current):\n        if rows_left == 1:\n            if 2 <= rem <= 8:\n                if not current or abs(rem - current[-1]) <= 2:\n                    partitions.append(current + [rem])\n            return\n        for i in range(2, 9):\n            if not current or abs(i - current[-1]) <= 2:\n                partition(rem - i, rows_left - 1, current + [i])\n                \n    for r in range(4, 8):\n        partition(n, r, [])\n        \n    unique_partitions = []\n    for p in partitions:\n        if p[::-1] < p:\n            continue\n        unique_partitions.append(p)\n\n    # Add targeted known dense subsets\n    manual_configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2],\n        [1, 5, 5, 5, 5, 5], [2, 4, 4, 4, 4, 4, 4],\n        [5, 6, 4, 6, 5], [4, 5, 4, 4, 5, 4]\n    ]\n    \n    for mc in manual_configs:\n        if mc not in unique_partitions and mc[::-1] not in unique_partitions:\n            unique_partitions.append(mc)\n\n    seeds = []\n    for cfg in unique_partitions:\n        num_rows = len(cfg)\n        for margin_y in [0.06, 0.08, 0.10, 0.12]:\n            for margin_x in [0.06, 0.08, 0.10, 0.12]:\n                for stagger in [0.0, 0.02, -0.02, 0.04, -0.04]:\n                    pts = []\n                    for r_idx, count in enumerate(cfg):\n                        y = margin_y + (1.0 - 2.0 * margin_y) * r_idx / (max(1, num_rows - 1))\n                        if count == 1:\n                            x_vals = [0.5]\n                        else:\n                            x_vals = np.linspace(margin_x, 1.0 - margin_x, count)\n                        \n                        shift = stagger if r_idx % 2 == 1 else 0.0\n                        for x in x_vals:\n                            pts.append([x + shift, y])\n                    s = np.clip(np.array(pts[:n]), 0.05, 0.95)\n                    if len(s) == n:\n                        seeds.append(s)\n\n    # Queue min_dist structural sort to obtain only computationally viable arrays\n    min_dists = []\n    for s in seeds:\n        dist_sq = np.sum((s[:, None, :] - s[None, :, :])**2, axis=-1)\n        np.fill_diagonal(dist_sq, np.inf)\n        min_dists.append(np.min(dist_sq))\n        \n    seed_dist_pairs = list(zip(min_dists, seeds))\n    seed_dist_pairs.sort(key=lambda x: x[0], reverse=True)\n    valid_seeds = [s for d, s in seed_dist_pairs[:1500]]\n\n    # Generate additional physics repulsion-based architectures\n    def get_repulsion_seed(bias_type='uniform', steps=80):\n        pos = rng.rand(n, 2)\n        if bias_type == 'biased':\n            target_r = rng.uniform(0.05, 0.15, n)\n        else:\n            target_r = np.full(n, 0.1)\n            \n        for _ in range(steps):\n            dists = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist = np.sqrt(dist_sq + 1e-9)\n            \n            force_mag = (target_r[:, None] + target_r[None, :]) / (dist + 1e-2)**2\n            mask = dist < (target_r[:, None] + target_r[None, :] + 0.05)\n            force = dists * (force_mag[:, :, None] / dist[:, :, None]) * mask[..., None]\n            pos += 0.002 * np.sum(force, axis=1)\n            \n            pos[:, 0] += 0.002 * (1/np.maximum(pos[:, 0], 0.02) - 1/np.maximum(1-pos[:, 0], 0.02))\n            pos[:, 1] += 0.002 * (1/np.maximum(pos[:, 1], 0.02) - 1/np.maximum(1-pos[:, 1], 0.02))\n            \n            pos = np.clip(pos, 0.02, 0.98)\n        return pos\n\n    for _ in range(30):\n        valid_seeds.append(get_repulsion_seed(bias_type='uniform'))\n        valid_seeds.append(get_repulsion_seed(bias_type='biased'))\n\n    # Linear Programming evaluation\n    candidates = []\n    for s in valid_seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n            \n    if not candidates:\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n        \n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    def get_topology_signature(pts):\n        dists = np.sqrt(np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1))\n        triu_dists = dists[np.triu_indices(n, k=1)]\n        return np.sort(triu_dists)\n\n    # Topological Clustering removes mirror/symmetrical iterations from draining SLSQP allocations\n    unique_candidates = []\n    seen_signatures = []\n    for total, s, radii in candidates:\n        sig = get_topology_signature(s)\n        is_unique = True\n        for seen_sig in seen_signatures:\n            if np.mean(np.abs(sig - seen_sig)) < 0.005:\n                is_unique = False\n                break\n                \n        if is_unique:\n            seen_signatures.append(sig)\n            unique_candidates.append((total, s, radii))\n            if len(unique_candidates) >= 50:\n                break\n\n    if len(unique_candidates) < 10:\n        unique_candidates = candidates[:50]\n\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        row_idx = np.arange(num_overlap)\n        J[row_idx, i_idx] = 2 * dx\n        J[row_idx, j_idx] = -2 * dx\n        J[row_idx, n + i_idx] = 2 * dy\n        J[row_idx, n + j_idx] = -2 * dy\n        J[row_idx, 2 * n + i_idx] = -2 * dr\n        J[row_idx, 2 * n + j_idx] = -2 * dr\n        \n        row = num_overlap\n        r_idx = np.arange(n)\n        J[row + r_idx, r_idx] = 1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, r_idx] = -1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, n + r_idx] = 1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, n + r_idx] = -1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        \n        return J\n\n    def is_valid(x_opt, tol=1e-3):\n        c = constraints_func(x_opt)\n        return np.all(c >= -tol)\n\n    def optimize_slsqp(centers, radii, maxiter=100, ftol=1e-6):\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        if maxiter > 100:  # Introduce slight jitter breaks saddle-symmetry blocks\n            x0[:2*n] += rng.normal(0, 1e-5, 2*n)\n            \n        res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-6, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            options={'maxiter': maxiter, 'ftol': ftol}\n        )\n        \n        if is_valid(res.x):\n            return res.fun, res.x\n        return 0, None\n\n    # Step 1: Run Short Hierarchical refinement phase\n    short_results = []\n    for total, s_pos, s_rad in unique_candidates:\n        val, x_opt = optimize_slsqp(s_pos, s_rad, maxiter=80, ftol=1e-5)\n        if x_opt is not None:\n            short_results.append((val, x_opt))\n            \n    short_results.sort(key=lambda x: x[0])\n\n    # Step 2: Extract top-tier structures into Long Hierarchical phase\n    best_val = 0\n    best_x = None\n    \n    for val, x_opt in short_results[:6]:\n        c = np.column_stack((x_opt[:n], x_opt[n:2*n]))\n        r = x_opt[2*n:]\n        final_val, final_x = optimize_slsqp(c, r, maxiter=800, ftol=1e-9)\n        if final_x is not None and final_val < best_val:\n            best_val = final_val\n            best_x = final_x\n\n    if best_x is None:\n        if short_results:\n            best_x = short_results[0][1]\n        else:\n            s, radii = unique_candidates[0][1], unique_candidates[0][2]\n            best_x = np.concatenate([s[:, 0], s[:, 1], radii])\n\n    best_centers = np.column_stack((best_x[:n], best_x[n:2*n]))\n    best_radii = best_x[2*n:]\n\n    # Bulletproof dynamic geometric constraint resolver ensures 100% boundary safety\n    final_radii = np.copy(best_radii)\n    final_centers = np.copy(best_centers)\n    \n    for i in range(n):\n        final_centers[i, 0] = np.clip(final_centers[i, 0], final_radii[i], 1.0 - final_radii[i])\n        final_centers[i, 1] = np.clip(final_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((final_centers[i] - final_centers[j])**2))\n            if final_radii[i] + final_radii[j] > dist:\n                excess = final_radii[i] + final_radii[j] - dist + 1e-10\n                sum_r = final_radii[i] + final_radii[j]\n                if sum_r > 0:\n                    final_radii[i] -= excess * (final_radii[i] / sum_r)\n                    final_radii[j] -= excess * (final_radii[j] / sum_r)\n                else:\n                    final_radii[i] = 0\n                    final_radii[j] = 0\n\n    final_sum = float(np.sum(final_radii))\n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "60ddf6cc-2126-4c50-b3bd-b741374c72c4", "generation": 3, "timestamp": 1771629414.0356534, "iteration_found": 14, "metrics": {"validity": 1.0, "sum_radii": 2.621461467736171, "target_ratio": 0.9948620370915261, "combined_score": 0.9948620370915261, "radius_variance": 0.006234023244297276, "spatial_spread": 0.18390067439558994, "eval_time": 15.71621322631836}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6208297952143944, "target_ratio": 0.9946223131743434, "combined_score": 0.9946223131743434, "radius_variance": 0.005620709132697197, "spatial_spread": 0.1841473155662647, "eval_time": 1.9818177223205566}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9946\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.0000 \u2192 0.9946\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n1.98s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.620830/2.635 = 0.9946\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.5% of target value\n```\n\n### radius_stats\n```\nMin: 0.063929, Max: 0.145252, Avg: 0.100801\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6208, target_ratio: 0.9946, combined_score: 0.9946, radius_variance: 0.0056, spatial_spread: 0.1841, eval_time: 1.9818\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6237, target_ratio: 0.9957, combined_score: 0.9957, radius_variance: 0.0056, spatial_spread: 0.1859, eval_time: 1.1783\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9957)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles within a unit square.\n    The strategy uses diverse structural seeds, a linear programming (LP) stage \n    to filter topologies, and a high-precision SLSQP refinement stage \n    with analytical Jacobians for efficiency.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed center positions using Linear Programming.\"\"\"\n        c = -np.ones(n)\n        A, b = [], []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A.append(row)\n                dist = np.sqrt(np.sum((P[i] - P[j])**2))\n                b.append(max(0, dist))\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0, d_wall)))\n            \n        res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n        return None, 0\n\n    # 1. Generate diverse structural seeds (hexagonal-like, grid-based)\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2]\n    ]\n    \n    seeds = []\n    # Grid seed (5x5 + 1)\n    g = np.mgrid[0.1:0.9:5j, 0.1:0.9:5j].reshape(2,-1).T\n    seeds.append(np.vstack([g, [[0.5, 0.5]]]))\n    \n    # Row-based configurations with various margins and staggers\n    for cfg in configs:\n        num_rows = len(cfg)\n        for margin in [0.07, 0.09, 0.11]:\n            pts = []\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                # Apply staggered shift to odd rows\n                shift = 0.015 if r_idx % 2 == 1 else 0.0\n                for x in x_vals:\n                    pts.append([x + shift, y])\n            seeds.append(np.array(pts[:n]))\n    \n    # 2. Filter seeds using LP to find the best candidate topologies\n    candidates = []\n    for s in seeds:\n        # Add tiny perturbation to break symmetries and avoid exact overlaps\n        s = np.clip(s + rng.normal(0, 0.005, s.shape), 0, 1)\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    \n    if not candidates: # Fallback in case of failure\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refinement using Nonlinear Optimization (SLSQP)\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints(v):\n        x, y, r = v[0:n], v[n:2*n], v[2*n:3*n]\n        res = np.zeros(n * (n - 1) // 2 + 4 * n)\n        row = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                res[row] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                row += 1\n            res[row:row+4] = [x[i] - r[i], 1.0 - x[i] - r[i], y[i] - r[i], 1.0 - y[i] - r[i]]\n            row += 4\n        return res\n\n    def jac_constraints(v):\n        x, y, r = v[0:n], v[n:2*n], v[2*n:3*n]\n        J = np.zeros((n * (n - 1) // 2 + 4 * n, 3 * n))\n        row = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy, dr_sum = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n                J[row, i], J[row, j] = 2 * dx, -2 * dx\n                J[row, n + i], J[row, n + j] = 2 * dy, -2 * dy\n                J[row, 2 * n + i], J[row, 2 * n + j] = -2 * dr_sum, -2 * dr_sum\n                row += 1\n            for k, val in enumerate([1, -1, 1, -1]):\n                J[row, (k//2)*n + i] = val\n                J[row, 2 * n + i] = -1\n                row += 1\n        return J\n\n    best_total_sum, best_centers, best_radii = candidates[0]\n    # Refine the top 3 candidate seeds found by LP\n    for idx in range(min(3, len(candidates))):\n        _, s_centers, s_radii = candidates[idx]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], np.maximum(s_radii, 1e-4)])\n        \n        opt_res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-7, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        if opt_res.success and -opt_res.fun > best_total_sum:\n            best_total_sum = -opt_res.fun\n            best_centers = np.column_stack((opt_res.x[:n], opt_res.x[n:2*n]))\n            best_radii = opt_res.x[2*n:]\n\n    # Final validity adjustment: apply a safety buffer\n    final_radii = best_radii - 1e-9\n    final_centers = np.clip(best_centers, 0, 1)\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6237), Performs well on target_ratio (0.9957), Performs well on combined_score (0.9957), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1859), Performs well on eval_time (1.1783)\n\n### Program 2 (Score: 0.9946)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1.  Multi-topology seed generation using structured grids, row-based patterns, and repulsion-based configurations.\n    2.  Filtering topologies via Linear Programming (LP) to find the best radii for fixed centers.\n    3.  High-precision refinement using SLSQP with vectorized analytical Jacobians for efficient global/local search.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed center positions using Linear Programming.\"\"\"\n        c = -np.ones(n)\n        A = np.zeros((num_overlap, n))\n        A[np.arange(num_overlap), i_idx] = 1.0\n        A[np.arange(num_overlap), j_idx] = 1.0\n        dist = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Add safety buffer to prevent exact boundary issues\n        b = np.maximum(0, dist - 1e-8)\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((1e-7, max(1e-7, d_wall - 1e-8)))\n            \n        try:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Generate diverse structural seeds\n    seeds = []\n    \n    # Row-based configurations (often optimal for square packings)\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2]\n    ]\n    \n    for cfg in configs:\n        num_rows = len(cfg)\n        for margin in [0.08, 0.10, 0.12]:\n            pts = []\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                # Staggered shift for rows\n                shift = 0.02 if r_idx % 2 == 1 else 0.0\n                for x in x_vals:\n                    pts.append([x + shift, y])\n            seeds.append(np.clip(np.array(pts[:n]), 0.05, 0.95))\n\n    # Repulsion-based seeds for non-obvious topologies\n    def get_repulsion_seed(bias_type='uniform'):\n        pos = rng.rand(n, 2)\n        target_r = rng.uniform(0.7, 1.3, n) if bias_type == 'biased' else np.ones(n)\n        for _ in range(60):\n            dists = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist = np.sqrt(dist_sq + 1e-9)\n            force_mag = (target_r[:, None] + target_r[None, :]) / (dist_sq + 1e-3)\n            force = dists * (force_mag[:, :, None] / dist[:, :, None])\n            pos += 0.003 * np.sum(force, axis=1)\n            # Wall repulsion\n            pos[:, 0] += 0.005 * (1/(pos[:, 0]**2 + 1e-4) - 1/((1-pos[:, 0])**2 + 1e-4))\n            pos[:, 1] += 0.005 * (1/(pos[:, 1]**2 + 1e-4) - 1/((1-pos[:, 1])**2 + 1e-4))\n            pos = np.clip(pos, 0.02, 0.98)\n        return pos\n\n    for _ in range(40):\n        seeds.append(get_repulsion_seed(bias_type='biased' if _ % 2 == 0 else 'uniform'))\n\n    # 2. Filter seeds using LP\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    \n    if not candidates:\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refinement using Nonlinear Optimization (SLSQP)\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, dr = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        \n        # Overlaps\n        row_idx = np.arange(num_overlap)\n        J[row_idx, i_idx] = 2 * dx\n        J[row_idx, j_idx] = -2 * dx\n        J[row_idx, n + i_idx] = 2 * dy\n        J[row_idx, n + j_idx] = -2 * dy\n        J[row_idx, 2 * n + i_idx] = -2 * dr\n        J[row_idx, 2 * n + j_idx] = -2 * dr\n        \n        # Boundary\n        row = num_overlap\n        J[row : row+n, :n] = np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        row += n\n        J[row : row+n, :n] = -np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        row += n\n        J[row : row+n, n:2*n] = np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        row += n\n        J[row : row+n, n:2*n] = -np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        return J\n\n    best_total_sum, best_centers, best_radii = candidates[0]\n    \n    # Refine top candidate topologies\n    for i in range(min(12, len(candidates))):\n        _, s_pos, s_rad = candidates[i]\n        x0 = np.concatenate([s_pos[:, 0], s_pos[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-7, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            options={'maxiter': 600 if i < 4 else 300, 'ftol': 1e-10}\n        )\n        \n        if res.success and -res.fun > best_total_sum:\n            best_total_sum = -res.fun\n            best_centers = np.column_stack((res.x[:n], res.x[n:2*n]))\n            best_radii = res.x[2*n:]\n\n    # Final safety buffer and clipping\n    final_radii = np.maximum(1e-7, best_radii - 1e-8)\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i, 0] = np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i])\n        final_centers[i, 1] = np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n    \n    final_sum = float(np.sum(final_radii))\n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6208), Performs well on target_ratio (0.9946), Performs well on combined_score (0.9946), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1841), Performs well on eval_time (1.9818)\n\n### Program 3 (Score: 0.0000)\n```python\n)))\n                            pts.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n                        for j in range(i):\n                            theta = 2 * np.pi * j / i + phase2\n                            r = 0.25 / max(abs(np.cos(theta)), abs(np.sin(theta)))\n                            pts.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n                        if inn == 1:\n                            pts.append([0.5, 0.5])\n                        elif inn > 1:\n                            for j in range(inn):\n                                theta = 2 * np.pi * j / inn\n                                r = 0.08\n                                pts.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n                        pts = np.array(pts)\n                        pts += rng.normal(0, 0.005, pts.shape)\n                        pts = np.clip(pts, 0.01, 0.99)\n                        seeds.append(pts)\n\n    # Physics-based repulsion with structural size biases\n    def simulate_repulsion(sizes_array, iterations=60):\n        out_seeds = []\n        for _ in range(200):\n            pts = rng.rand(n, 2)\n            sizes = np.array(sizes_array) if not callable(sizes_array) else sizes_array()\n            for _ in range(iterations):\n                diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n                dist = np.linalg.norm(diff, axis=-1)\n                np.fill_diagonal(dist, np.inf)\n                \n                force_mag = (sizes[:, np.newaxis] + sizes[np.newaxis, :]) / (dist**3 + 1e-9)\n                force = diff * force_mag[..., np.newaxis]\n                F = np.sum(force, axis=1)\n                \n                F[:, 0] += sizes / (pts[:, 0]**2 + 1e-9) - sizes / ((1 - pts[:, 0])**2 + 1e-9)\n                F[:, 1] += sizes / (pts[:, 1]**2 + 1e-9) - sizes / ((1 - pts[:, 1])**2 + 1e-9)\n                \n                F = np.clip(F, -50.0, 50.0)\n                pts += F * 0.002\n                pts = np.clip(pts, 0.02, 0.98)\n            out_seeds.append(pts)\n        return out_seeds\n\n    # Uniform repulsion\n    seeds.extend(simulate_repulsion(lambda: np.ones(n)))\n    \n    # Corner-biased repulsion\n    def corner_biased():\n        s = rng.uniform(0.5, 1.2, n)\n        s[0:4] = 2.5\n        return s\n    seeds.extend(simulate_repulsion(corner_biased))\n\n    # Corner + Edge-biased repulsion\n    def corner_edge_biased():\n        s = rng.uniform(0.5, 1.0, n)\n        s[0:4] = 2.5\n        s[4\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9957, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles within a unit square.\n    The strategy uses diverse structural seeds, a linear programming (LP) stage \n    to filter topologies, and a high-precision SLSQP refinement stage \n    with analytical Jacobians for efficiency.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed center positions using Linear Programming.\"\"\"\n        c = -np.ones(n)\n        A, b = [], []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i], row[j] = 1.0, 1.0\n                A.append(row)\n                dist = np.sqrt(np.sum((P[i] - P[j])**2))\n                b.append(max(0, dist))\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0, d_wall)))\n            \n        res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n        return None, 0\n\n    # 1. Generate diverse structural seeds (hexagonal-like, grid-based)\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2]\n    ]\n    \n    seeds = []\n    # Grid seed (5x5 + 1)\n    g = np.mgrid[0.1:0.9:5j, 0.1:0.9:5j].reshape(2,-1).T\n    seeds.append(np.vstack([g, [[0.5, 0.5]]]))\n    \n    # Row-based configurations with various margins and staggers\n    for cfg in configs:\n        num_rows = len(cfg)\n        for margin in [0.07, 0.09, 0.11]:\n            pts = []\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                # Apply staggered shift to odd rows\n                shift = 0.015 if r_idx % 2 == 1 else 0.0\n                for x in x_vals:\n                    pts.append([x + shift, y])\n            seeds.append(np.array(pts[:n]))\n    \n    # 2. Filter seeds using LP to find the best candidate topologies\n    candidates = []\n    for s in seeds:\n        # Add tiny perturbation to break symmetries and avoid exact overlaps\n        s = np.clip(s + rng.normal(0, 0.005, s.shape), 0, 1)\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    \n    if not candidates: # Fallback in case of failure\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refinement using Nonlinear Optimization (SLSQP)\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints(v):\n        x, y, r = v[0:n], v[n:2*n], v[2*n:3*n]\n        res = np.zeros(n * (n - 1) // 2 + 4 * n)\n        row = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                res[row] = (x[i] - x[j])**2 + (y[i] - y[j])**2 - (r[i] + r[j])**2\n                row += 1\n            res[row:row+4] = [x[i] - r[i], 1.0 - x[i] - r[i], y[i] - r[i], 1.0 - y[i] - r[i]]\n            row += 4\n        return res\n\n    def jac_constraints(v):\n        x, y, r = v[0:n], v[n:2*n], v[2*n:3*n]\n        J = np.zeros((n * (n - 1) // 2 + 4 * n, 3 * n))\n        row = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx, dy, dr_sum = x[i] - x[j], y[i] - y[j], r[i] + r[j]\n                J[row, i], J[row, j] = 2 * dx, -2 * dx\n                J[row, n + i], J[row, n + j] = 2 * dy, -2 * dy\n                J[row, 2 * n + i], J[row, 2 * n + j] = -2 * dr_sum, -2 * dr_sum\n                row += 1\n            for k, val in enumerate([1, -1, 1, -1]):\n                J[row, (k//2)*n + i] = val\n                J[row, 2 * n + i] = -1\n                row += 1\n        return J\n\n    best_total_sum, best_centers, best_radii = candidates[0]\n    # Refine the top 3 candidate seeds found by LP\n    for idx in range(min(3, len(candidates))):\n        _, s_centers, s_radii = candidates[idx]\n        x0 = np.concatenate([s_centers[:, 0], s_centers[:, 1], np.maximum(s_radii, 1e-4)])\n        \n        opt_res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-7, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints, 'jac': jac_constraints},\n            options={'maxiter': 500, 'ftol': 1e-9}\n        )\n        \n        if opt_res.success and -opt_res.fun > best_total_sum:\n            best_total_sum = -opt_res.fun\n            best_centers = np.column_stack((opt_res.x[:n], opt_res.x[n:2*n]))\n            best_radii = opt_res.x[2*n:]\n\n    # Final validity adjustment: apply a safety buffer\n    final_radii = best_radii - 1e-9\n    final_centers = np.clip(best_centers, 0, 1)\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n)))\n                            pts.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n                        for j in range(i):\n                            theta = 2 * np.pi * j / i + phase2\n                            r = 0.25 / max(abs(np.cos(theta)), abs(np.sin(theta)))\n                            pts.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n                        if inn == 1:\n                            pts.append([0.5, 0.5])\n                        elif inn > 1:\n                            for j in range(inn):\n                                theta = 2 * np.pi * j / inn\n                                r = 0.08\n                                pts.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n                        pts = np.array(pts)\n                        pts += rng.normal(0, 0.005, pts.shape)\n                        pts = np.clip(pts, 0.01, 0.99)\n                        seeds.append(pts)\n\n    # Physics-based repulsion with structural size biases\n    def simulate_repulsion(sizes_array, iterations=60):\n        out_seeds = []\n        for _ in range(200):\n            pts = rng.rand(n, 2)\n            sizes = np.array(sizes_array) if not callable(sizes_array) else sizes_array()\n            for _ in range(iterations):\n                diff = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n                dist = np.linalg.norm(diff, axis=-1)\n                np.fill_diagonal(dist, np.inf)\n                \n                force_mag = (sizes[:, np.newaxis] + sizes[np.newaxis, :]) / (dist**3 + 1e-9)\n                force = diff * force_mag[..., np.newaxis]\n                F = np.sum(force, axis=1)\n                \n                F[:, 0] += sizes / (pts[:, 0]**2 + 1e-9) - sizes / ((1 - pts[:, 0])**2 + 1e-9)\n                F[:, 1] += sizes / (pts[:, 1]**2 + 1e-9) - sizes / ((1 - pts[:, 1])**2 + 1e-9)\n                \n                F = np.clip(F, -50.0, 50.0)\n                pts += F * 0.002\n                pts = np.clip(pts, 0.02, 0.98)\n            out_seeds.append(pts)\n        return out_seeds\n\n    # Uniform repulsion\n    seeds.extend(simulate_repulsion(lambda: np.ones(n)))\n    \n    # Corner-biased repulsion\n    def corner_biased():\n        s = rng.uniform(0.5, 1.2, n)\n        s[0:4] = 2.5\n        return s\n    seeds.extend(simulate_repulsion(corner_biased))\n\n    # Corner + Edge-biased repulsion\n    def corner_edge_biased():\n        s = rng.uniform(0.5, 1.0, n)\n        s[0:4] = 2.5\n        s[4\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1.  Multi-topology seed generation using structured grids, row-based patterns, and repulsion-based configurations.\n    2.  Filtering topologies via Linear Programming (LP) to find the best radii for fixed centers.\n    3.  High-precision refinement using SLSQP with vectorized analytical Jacobians for efficient global/local search.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n\n    def solve_lp(P):\n        \"\"\"Finds optimal radii for fixed center positions using Linear Programming.\"\"\"\n        c = -np.ones(n)\n        A = np.zeros((num_overlap, n))\n        A[np.arange(num_overlap), i_idx] = 1.0\n        A[np.arange(num_overlap), j_idx] = 1.0\n        dist = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        # Add safety buffer to prevent exact boundary issues\n        b = np.maximum(0, dist - 1e-8)\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((1e-7, max(1e-7, d_wall - 1e-8)))\n            \n        try:\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # 1. Generate diverse structural seeds\n    seeds = []\n    \n    # Row-based configurations (often optimal for square packings)\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2]\n    ]\n    \n    for cfg in configs:\n        num_rows = len(cfg)\n        for margin in [0.08, 0.10, 0.12]:\n            pts = []\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                # Staggered shift for rows\n                shift = 0.02 if r_idx % 2 == 1 else 0.0\n                for x in x_vals:\n                    pts.append([x + shift, y])\n            seeds.append(np.clip(np.array(pts[:n]), 0.05, 0.95))\n\n    # Repulsion-based seeds for non-obvious topologies\n    def get_repulsion_seed(bias_type='uniform'):\n        pos = rng.rand(n, 2)\n        target_r = rng.uniform(0.7, 1.3, n) if bias_type == 'biased' else np.ones(n)\n        for _ in range(60):\n            dists = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist = np.sqrt(dist_sq + 1e-9)\n            force_mag = (target_r[:, None] + target_r[None, :]) / (dist_sq + 1e-3)\n            force = dists * (force_mag[:, :, None] / dist[:, :, None])\n            pos += 0.003 * np.sum(force, axis=1)\n            # Wall repulsion\n            pos[:, 0] += 0.005 * (1/(pos[:, 0]**2 + 1e-4) - 1/((1-pos[:, 0])**2 + 1e-4))\n            pos[:, 1] += 0.005 * (1/(pos[:, 1]**2 + 1e-4) - 1/((1-pos[:, 1])**2 + 1e-4))\n            pos = np.clip(pos, 0.02, 0.98)\n        return pos\n\n    for _ in range(40):\n        seeds.append(get_repulsion_seed(bias_type='biased' if _ % 2 == 0 else 'uniform'))\n\n    # 2. Filter seeds using LP\n    candidates = []\n    for s in seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n    \n    if not candidates:\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n    \n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    # 3. Refinement using Nonlinear Optimization (SLSQP)\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx, dy, dr = x[i_idx] - x[j_idx], y[i_idx] - y[j_idx], r[i_idx] + r[j_idx]\n        \n        # Overlaps\n        row_idx = np.arange(num_overlap)\n        J[row_idx, i_idx] = 2 * dx\n        J[row_idx, j_idx] = -2 * dx\n        J[row_idx, n + i_idx] = 2 * dy\n        J[row_idx, n + j_idx] = -2 * dy\n        J[row_idx, 2 * n + i_idx] = -2 * dr\n        J[row_idx, 2 * n + j_idx] = -2 * dr\n        \n        # Boundary\n        row = num_overlap\n        J[row : row+n, :n] = np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        row += n\n        J[row : row+n, :n] = -np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        row += n\n        J[row : row+n, n:2*n] = np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        row += n\n        J[row : row+n, n:2*n] = -np.eye(n)\n        J[row : row+n, 2*n:] = -np.eye(n)\n        return J\n\n    best_total_sum, best_centers, best_radii = candidates[0]\n    \n    # Refine top candidate topologies\n    for i in range(min(12, len(candidates))):\n        _, s_pos, s_rad = candidates[i]\n        x0 = np.concatenate([s_pos[:, 0], s_pos[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-7, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            options={'maxiter': 600 if i < 4 else 300, 'ftol': 1e-10}\n        )\n        \n        if res.success and -res.fun > best_total_sum:\n            best_total_sum = -res.fun\n            best_centers = np.column_stack((res.x[:n], res.x[n:2*n]))\n            best_radii = res.x[2*n:]\n\n    # Final safety buffer and clipping\n    final_radii = np.maximum(1e-7, best_radii - 1e-8)\n    final_centers = np.zeros((n, 2))\n    for i in range(n):\n        final_centers[i, 0] = np.clip(best_centers[i, 0], final_radii[i], 1.0 - final_radii[i])\n        final_centers[i, 1] = np.clip(best_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n    \n    final_sum = float(np.sum(final_radii))\n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["An elegant and significantly enhanced solution that completely rewrites the optimization strategy. The core focus here is casting an incredibly dense and structured net over possible configurations, while maintaining strict constraints to bypass local minima more successfully.\n\n### Key Improvements\n1. **Exhaustive Topology Generation**: Instead of a few manual seed configurations, we explicitly calculate all valid row-based integer partitions that can equal 26 points.\n2. **Matrix Sweeps & Shift Staggers**: The program sweeps through a rich matrix of horizontal/vertical spacing bounds and row-staggers. This generates tens of thousands of theoretically optimal dense initial structures.\n3. **`min_dist` Priority Queue**: We efficiently narrow down tens of thousands of configurations into the absolute best 1,500 by measuring their minimum structural distances.\n4. **Signature-Based Clustering**: Before sending LP-approved topologies to the heavy nonlinear SLSQP optimizer, an extremely fast invariant topology signature (triangular distance sorting) calculates layout similarities to strictly prevent evaluating mirror or redundant setups.\n5. **Hierarchical Refinement**: Topologically unique seeds get a fast 80-iteration SLSQP filter. Only the 6 top-performing architectures enter the deep 800-iteration hyper-refinement.\n6. **Bulletproof Dynamic Validation Adjuster**: Bypasses arbitrary tiny epsilons that limit boundary packing by instead shrinking overlaps mathematically precisely via proportional distribution. The final returned array is guaranteed to be physically possible by definition. \n\n### Python 3 Source Code\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Optimizes the sum of radii for 26 circles in a unit square.\n    Strategy:\n    1. Exhaustively generate rational topological row arrangements via integer partitions.\n    2. Sweep them into 1500+ structured layouts by interleaving margins and alternating shift-staggers.\n    3. Quickly filter layouts via structural `min_dist` sorting, and score them using Linear Programming.\n    4. Group matching topological reflections into diverse subsets.\n    5. Perform a fast/short non-linear SLSQP on varied subsets, and a deep/long SLSQP on the top 6.\n    6. Ensure unbreakable boundaries utilizing a dynamic geometric shrink-adjuster.\n    \"\"\"\n    n = 26\n    rng = np.random.RandomState(42)\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    num_overlap = len(i_idx)\n\n    # Pre-allocate LP boundary condition array to prevent repeat allocations\n    A_ub_lp = np.zeros((num_overlap, n))\n    A_ub_lp[np.arange(num_overlap), i_idx] = 1.0\n    A_ub_lp[np.arange(num_overlap), j_idx] = 1.0\n\n    def solve_lp(P):\n        c = -np.ones(n)\n        dist = np.sqrt(np.sum((P[i_idx] - P[j_idx])**2, axis=1))\n        b = np.maximum(0, dist - 1e-8)\n        \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((1e-7, max(1e-7, d_wall - 1e-8)))\n            \n        try:\n            res = linprog(c, A_ub=A_ub_lp, b_ub=b, bounds=bounds, method='highs')\n            if res.success and res.x is not None:\n                return res.x, -res.fun\n        except:\n            pass\n        return None, 0\n\n    # Exhaustive Topology Partition Generation\n    partitions = []\n    def partition(rem, rows_left, current):\n        if rows_left == 1:\n            if 2 <= rem <= 8:\n                if not current or abs(rem - current[-1]) <= 2:\n                    partitions.append(current + [rem])\n            return\n        for i in range(2, 9):\n            if not current or abs(i - current[-1]) <= 2:\n                partition(rem - i, rows_left - 1, current + [i])\n                \n    for r in range(4, 8):\n        partition(n, r, [])\n        \n    unique_partitions = []\n    for p in partitions:\n        if p[::-1] < p:\n            continue\n        unique_partitions.append(p)\n\n    # Add targeted known dense subsets\n    manual_configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4],\n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [6, 6, 7, 7], [4, 4, 5, 4, 4, 5], [4, 4, 4, 4, 5, 5],\n        [5, 5, 5, 5, 5, 1], [4, 4, 4, 4, 4, 4, 2],\n        [1, 5, 5, 5, 5, 5], [2, 4, 4, 4, 4, 4, 4],\n        [5, 6, 4, 6, 5], [4, 5, 4, 4, 5, 4]\n    ]\n    \n    for mc in manual_configs:\n        if mc not in unique_partitions and mc[::-1] not in unique_partitions:\n            unique_partitions.append(mc)\n\n    seeds = []\n    for cfg in unique_partitions:\n        num_rows = len(cfg)\n        for margin_y in [0.06, 0.08, 0.10, 0.12]:\n            for margin_x in [0.06, 0.08, 0.10, 0.12]:\n                for stagger in [0.0, 0.02, -0.02, 0.04, -0.04]:\n                    pts = []\n                    for r_idx, count in enumerate(cfg):\n                        y = margin_y + (1.0 - 2.0 * margin_y) * r_idx / (max(1, num_rows - 1))\n                        if count == 1:\n                            x_vals = [0.5]\n                        else:\n                            x_vals = np.linspace(margin_x, 1.0 - margin_x, count)\n                        \n                        shift = stagger if r_idx % 2 == 1 else 0.0\n                        for x in x_vals:\n                            pts.append([x + shift, y])\n                    s = np.clip(np.array(pts[:n]), 0.05, 0.95)\n                    if len(s) == n:\n                        seeds.append(s)\n\n    # Queue min_dist structural sort to obtain only computationally viable arrays\n    min_dists = []\n    for s in seeds:\n        dist_sq = np.sum((s[:, None, :] - s[None, :, :])**2, axis=-1)\n        np.fill_diagonal(dist_sq, np.inf)\n        min_dists.append(np.min(dist_sq))\n        \n    seed_dist_pairs = list(zip(min_dists, seeds))\n    seed_dist_pairs.sort(key=lambda x: x[0], reverse=True)\n    valid_seeds = [s for d, s in seed_dist_pairs[:1500]]\n\n    # Generate additional physics repulsion-based architectures\n    def get_repulsion_seed(bias_type='uniform', steps=80):\n        pos = rng.rand(n, 2)\n        if bias_type == 'biased':\n            target_r = rng.uniform(0.05, 0.15, n)\n        else:\n            target_r = np.full(n, 0.1)\n            \n        for _ in range(steps):\n            dists = pos[:, None, :] - pos[None, :, :]\n            dist_sq = np.sum(dists**2, axis=-1)\n            dist = np.sqrt(dist_sq + 1e-9)\n            \n            force_mag = (target_r[:, None] + target_r[None, :]) / (dist + 1e-2)**2\n            mask = dist < (target_r[:, None] + target_r[None, :] + 0.05)\n            force = dists * (force_mag[:, :, None] / dist[:, :, None]) * mask[..., None]\n            pos += 0.002 * np.sum(force, axis=1)\n            \n            pos[:, 0] += 0.002 * (1/np.maximum(pos[:, 0], 0.02) - 1/np.maximum(1-pos[:, 0], 0.02))\n            pos[:, 1] += 0.002 * (1/np.maximum(pos[:, 1], 0.02) - 1/np.maximum(1-pos[:, 1], 0.02))\n            \n            pos = np.clip(pos, 0.02, 0.98)\n        return pos\n\n    for _ in range(30):\n        valid_seeds.append(get_repulsion_seed(bias_type='uniform'))\n        valid_seeds.append(get_repulsion_seed(bias_type='biased'))\n\n    # Linear Programming evaluation\n    candidates = []\n    for s in valid_seeds:\n        radii, total = solve_lp(s)\n        if radii is not None:\n            candidates.append((total, s, radii))\n            \n    if not candidates:\n        candidates.append((0.26, rng.rand(n, 2), np.full(n, 0.01)))\n        \n    candidates.sort(key=lambda x: x[0], reverse=True)\n\n    def get_topology_signature(pts):\n        dists = np.sqrt(np.sum((pts[:, None, :] - pts[None, :, :])**2, axis=-1))\n        triu_dists = dists[np.triu_indices(n, k=1)]\n        return np.sort(triu_dists)\n\n    # Topological Clustering removes mirror/symmetrical iterations from draining SLSQP allocations\n    unique_candidates = []\n    seen_signatures = []\n    for total, s, radii in candidates:\n        sig = get_topology_signature(s)\n        is_unique = True\n        for seen_sig in seen_signatures:\n            if np.mean(np.abs(sig - seen_sig)) < 0.005:\n                is_unique = False\n                break\n                \n        if is_unique:\n            seen_signatures.append(sig)\n            unique_candidates.append((total, s, radii))\n            if len(unique_candidates) >= 50:\n                break\n\n    if len(unique_candidates) < 10:\n        unique_candidates = candidates[:50]\n\n    def objective(v):\n        return -np.sum(v[2*n:])\n        \n    def jac_objective(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n        \n    def constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        overlap = (x[i_idx] - x[j_idx])**2 + (y[i_idx] - y[j_idx])**2 - (r[i_idx] + r[j_idx])**2\n        return np.concatenate([overlap, x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\n    def jac_constraints_func(v):\n        x, y, r = v[:n], v[n:2*n], v[2*n:]\n        J = np.zeros((num_overlap + 4*n, 3*n))\n        dx = x[i_idx] - x[j_idx]\n        dy = y[i_idx] - y[j_idx]\n        dr = r[i_idx] + r[j_idx]\n        \n        row_idx = np.arange(num_overlap)\n        J[row_idx, i_idx] = 2 * dx\n        J[row_idx, j_idx] = -2 * dx\n        J[row_idx, n + i_idx] = 2 * dy\n        J[row_idx, n + j_idx] = -2 * dy\n        J[row_idx, 2 * n + i_idx] = -2 * dr\n        J[row_idx, 2 * n + j_idx] = -2 * dr\n        \n        row = num_overlap\n        r_idx = np.arange(n)\n        J[row + r_idx, r_idx] = 1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, r_idx] = -1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, n + r_idx] = 1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        row += n\n        \n        J[row + r_idx, n + r_idx] = -1.0\n        J[row + r_idx, 2*n + r_idx] = -1.0\n        \n        return J\n\n    def is_valid(x_opt, tol=1e-3):\n        c = constraints_func(x_opt)\n        return np.all(c >= -tol)\n\n    def optimize_slsqp(centers, radii, maxiter=100, ftol=1e-6):\n        x0 = np.concatenate([centers[:, 0], centers[:, 1], radii])\n        if maxiter > 100:  # Introduce slight jitter breaks saddle-symmetry blocks\n            x0[:2*n] += rng.normal(0, 1e-5, 2*n)\n            \n        res = minimize(\n            objective, x0, jac=jac_objective, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(1e-6, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': constraints_func, 'jac': jac_constraints_func},\n            options={'maxiter': maxiter, 'ftol': ftol}\n        )\n        \n        if is_valid(res.x):\n            return res.fun, res.x\n        return 0, None\n\n    # Step 1: Run Short Hierarchical refinement phase\n    short_results = []\n    for total, s_pos, s_rad in unique_candidates:\n        val, x_opt = optimize_slsqp(s_pos, s_rad, maxiter=80, ftol=1e-5)\n        if x_opt is not None:\n            short_results.append((val, x_opt))\n            \n    short_results.sort(key=lambda x: x[0])\n\n    # Step 2: Extract top-tier structures into Long Hierarchical phase\n    best_val = 0\n    best_x = None\n    \n    for val, x_opt in short_results[:6]:\n        c = np.column_stack((x_opt[:n], x_opt[n:2*n]))\n        r = x_opt[2*n:]\n        final_val, final_x = optimize_slsqp(c, r, maxiter=800, ftol=1e-9)\n        if final_x is not None and final_val < best_val:\n            best_val = final_val\n            best_x = final_x\n\n    if best_x is None:\n        if short_results:\n            best_x = short_results[0][1]\n        else:\n            s, radii = unique_candidates[0][1], unique_candidates[0][2]\n            best_x = np.concatenate([s[:, 0], s[:, 1], radii])\n\n    best_centers = np.column_stack((best_x[:n], best_x[n:2*n]))\n    best_radii = best_x[2*n:]\n\n    # Bulletproof dynamic geometric constraint resolver ensures 100% boundary safety\n    final_radii = np.copy(best_radii)\n    final_centers = np.copy(best_centers)\n    \n    for i in range(n):\n        final_centers[i, 0] = np.clip(final_centers[i, 0], final_radii[i], 1.0 - final_radii[i])\n        final_centers[i, 1] = np.clip(final_centers[i, 1], final_radii[i], 1.0 - final_radii[i])\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((final_centers[i] - final_centers[j])**2))\n            if final_radii[i] + final_radii[j] > dist:\n                excess = final_radii[i] + final_radii[j] - dist + 1e-10\n                sum_r = final_radii[i] + final_radii[j]\n                if sum_r > 0:\n                    final_radii[i] -= excess * (final_radii[i] / sum_r)\n                    final_radii[j] -= excess * (final_radii[j] / sum_r)\n                else:\n                    final_radii[i] = 0\n                    final_radii[j] = 0\n\n    final_sum = float(np.sum(final_radii))\n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    return run_packing()\n```"]}}, "artifacts_json": "{\"execution_time\": \"15.72s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.621461/2.635 = 0.9949\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.5% of target value\", \"radius_stats\": \"Min: 0.059894, Max: 0.137092, Avg: 0.100825\"}", "artifact_dir": null, "embedding": null}