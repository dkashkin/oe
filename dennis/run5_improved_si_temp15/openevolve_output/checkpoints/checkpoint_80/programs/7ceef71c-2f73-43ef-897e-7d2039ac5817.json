{"id": "7ceef71c-2f73-43ef-897e-7d2039ac5817", "code": "import numpy as np\n\ndef generate_initial_states(batch_size, n):\n    np.random.seed(1337)\n    X = np.random.uniform(0.1, 0.9, (batch_size, n, 2))\n    R = np.random.uniform(0.01, 0.06, (batch_size, n))\n    \n    for b in range(batch_size):\n        strategy = b % 8\n        if strategy == 0:\n            pass\n        elif strategy == 1:\n            X[b] = np.random.normal(0.5, 0.25, (n, 2))\n        elif strategy == 2:\n            grid_dim = int(np.ceil(np.sqrt(n)))\n            idx = 0\n            for i in range(grid_dim):\n                for j in range(grid_dim):\n                    if idx < n:\n                        X[b, idx] = [0.1 + 0.8*i/(grid_dim-1), 0.1 + 0.8*j/(grid_dim-1)]\n                        idx += 1\n            X[b] += np.random.uniform(-0.02, 0.02, (n, 2))\n        elif strategy == 3:\n            idx = 0\n            for i in range(6):\n                for j in range(6):\n                    if idx < n:\n                        x = 0.1 + 0.15*j + (i%2)*0.075\n                        y = 0.1 + 0.15*i\n                        X[b, idx] = [x, y]\n                        idx += 1\n            X[b] += np.random.uniform(-0.02, 0.02, (n, 2))\n        elif strategy == 4:\n            X[b, 0] = [0.5, 0.5]\n            R[b, 0] = 0.1\n            idx = 1\n            n_inner = min(8, n - 1)\n            for i in range(n_inner):\n                ang = 2*np.pi*i/n_inner + np.random.uniform(0, 0.5)\n                X[b, idx] = [0.5 + 0.22*np.cos(ang), 0.5 + 0.22*np.sin(ang)]\n                R[b, idx] = 0.08\n                idx += 1\n            n_outer = n - 1 - n_inner\n            for i in range(n_outer):\n                ang = 2*np.pi*i/n_outer + np.random.uniform(0, 0.5)\n                X[b, idx] = [0.5 + 0.42*np.cos(ang), 0.5 + 0.42*np.sin(ang)]\n                idx += 1\n        elif strategy == 5:\n            X[b, 0] = [0.5, 0.5]\n            idx = 1\n            for rng, r in [(5, 0.15), (9, 0.3), (n - 1 - 5 - 9, 0.45)]:\n                for i in range(rng):\n                    if idx < n:\n                        ang = 2*np.pi*i/rng + np.random.uniform(0, 1.0)\n                        X[b, idx] = [0.5 + r*np.cos(ang), 0.5 + r*np.sin(ang)]\n                        idx += 1\n        elif strategy == 6:\n            idx = 0\n            centers = [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]]\n            for c in centers:\n                if idx < n:\n                    X[b, idx] = c\n                    idx += 1\n                for _ in range((n-4)//4):\n                    if idx < n:\n                        X[b, idx] = [c[0] + np.random.uniform(-0.1, 0.1), c[1] + np.random.uniform(-0.1, 0.1)]\n                        idx += 1\n        elif strategy == 7:\n            idx = 0\n            while idx < n:\n                if np.random.rand() < 0.7:\n                    if np.random.rand() < 0.5:\n                        X[b, idx] = [np.random.choice([0.05, 0.95]), np.random.uniform(0.1, 0.9)]\n                    else:\n                        X[b, idx] = [np.random.uniform(0.1, 0.9), np.random.choice([0.05, 0.95])]\n                else:\n                    X[b, idx] = np.random.uniform(0.2, 0.8, 2)\n                idx += 1\n\n    X = np.clip(X, 0.01, 0.99)\n    return X, R\n\n\ndef optimize_batch(X, R, n, iters=3500):\n    m_p, v_p = np.zeros_like(X), np.zeros_like(X)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005 \n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        lr = base_learning_rate * (1.0 - 0.9 * progress)\n        penalty = 10.0 * (1000.0 ** progress)\n        \n        x = X[:, :, 0:1]\n        y = X[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n).reshape(1, n, n) * 100.0\n        \n        sum_r = R[:, :, None] + R[:, None, :]\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2)\n        grad_r_pair = np.sum(force_pair, axis=2)\n        \n        ox0 = np.maximum(0.0, R - X[:, :, 0])\n        ox1 = np.maximum(0.0, R + X[:, :, 0] - 1.0)\n        oy0 = np.maximum(0.0, R - X[:, :, 1])\n        oy1 = np.maximum(0.0, R + X[:, :, 1] - 1.0)\n        \n        fx0 = 2.0 * penalty * ox0\n        fx1 = 2.0 * penalty * ox1\n        fy0 = 2.0 * penalty * oy0\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_p = np.stack([grad_x, grad_y], axis=-1)\n        \n        grad_r = grad_r_pair + fx0 + fx1 + fy0 + fy1 - 1.5\n        \n        if progress < 0.6:\n            noise_scale = 0.02 * (0.6 - progress) * penalty\n            grad_p += np.random.normal(0, noise_scale, grad_p.shape)\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        X -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        R -= lr * step_r\n        \n        X = np.clip(X, 0.0, 1.0)\n        R = np.clip(R, 0.001, 1.0)\n        \n    return X, R\n\n\ndef make_valid_simple(X, R):\n    X = np.clip(X, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    for _ in range(150):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-10:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-10:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef refine_single_layout(X, R, max_passes=120):\n    n = len(R)\n    X = X.copy()\n    R = R.copy()\n    \n    for pass_idx in range(max_passes):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.03 * (0.94 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                diff_circ = m_circ - min_m\n                w_circ = np.exp(-150.0 * np.maximum(0, diff_circ))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                diff_bnd = m_bnd - min_m\n                w_bnd = np.exp(-150.0 * np.maximum(0, diff_bnd))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n                    \n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    return X, R\n\n\ndef enforce_strict_validity(X, R):\n    X = np.clip(X, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    for _ in range(400):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-11:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-11:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef construct_packing():\n    batch_size = 80\n    n = 26\n    iters = 3500\n    \n    X_init, R_init = generate_initial_states(batch_size, n)\n    X_opt, R_opt = optimize_batch(X_init, R_init, n, iters=iters)\n    \n    results = []\n    for b in range(batch_size):\n        x_val, r_val = make_valid_simple(X_opt[b], R_opt[b])\n        results.append((np.sum(r_val), x_val, r_val))\n        \n    results.sort(key=lambda item: item[0], reverse=True)\n    \n    top_k = min(12, batch_size)\n    best_score = -1.0\n    best_X = None\n    best_R = None\n    \n    for i in range(top_k):\n        score_b, x_val, r_val = results[i]\n        \n        x_refined, r_refined = refine_single_layout(x_val, r_val, max_passes=120)\n        x_final, r_final = enforce_strict_validity(x_refined, r_refined)\n        \n        final_score = np.sum(r_final)\n        if final_score > best_score:\n            best_score = final_score\n            best_X = x_final.copy()\n            best_R = r_final.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")", "changes_description": null, "language": "python", "parent_id": "0e28271b-a651-44ec-af22-84a373ea457a", "generation": 3, "timestamp": 1771902918.7183917, "iteration_found": 22, "metrics": {"validity": 1.0, "sum_radii": 2.6328888336839475, "target_ratio": 0.9991987983620295, "combined_score": 0.9991987983620295, "radius_variance": 0.0045176118960811844, "spatial_spread": 0.18850371016353815, "eval_time": 10.022164106369019}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6331524161544184, "target_ratio": 0.999298829660121, "combined_score": 0.999298829660121, "radius_variance": 0.004920736423024544, "spatial_spread": 0.18567601166702546, "eval_time": 10.272722244262695}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9993\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.9937 \u2192 0.9993\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n10.27s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.633152/2.635 = 0.9993\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.9% of target value\n```\n\n### radius_stats\n```\nMin: 0.061913, Max: 0.135446, Avg: 0.101275\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6185, target_ratio: 0.9937, combined_score: 0.9937, radius_variance: 0.0051, spatial_spread: 0.1931, eval_time: 8.3362\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6276, target_ratio: 0.9972, combined_score: 0.9972, radius_variance: 0.0053, spatial_spread: 0.2036, eval_time: 1.8165\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6332, target_ratio: 0.9993, combined_score: 0.9993, radius_variance: 0.0049, spatial_spread: 0.1857, eval_time: 10.2727\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9993)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by resolving overlaps, bounding dynamically,\n    and pushing coordinates precisely towards mathematical kissing constraints to inflate bounds.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Resolving intersecting structural bounds loop safely geometrically\n    for _ in range(4000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if overlap[i, j] > 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    # Iterative aggressive local block-coordinate space nudging & optimization\n    # Expands inner spaces by sliding circles mathematically along multiple constraint interfaces\n    for pass_idx in range(80):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.02 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            # Active microscopic coordinate drift gradient against closest topological barriers\n            for _ in range(15):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                # Temperature based vector formulation directing into deepest space pools safely\n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                w_circ = np.exp(-200.0 * np.maximum(0, m_circ - min_m))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                w_bnd = np.exp(-200.0 * np.maximum(0, m_bnd - min_m))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n\n            # Confirm and capture safe bounds limits improvements continuously\n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 10:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=7000, restarts=12, lr_start=0.015):\n    \"\"\"Execute dynamic penalty-scaled Adam physics with targeted varied structured seeds.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Heterogeneous structured parameter placements balancing varied densities intelligently\n        if restart < 3:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n            \n        elif restart < 6:\n            X = np.zeros((n, 2))\n            if n > 0: X[0] = [0.5, 0.5]\n            n_inner = min((n - 1) // 3, 8) if n > 1 else 0\n            n_outer = max(0, n - 1 - n_inner)\n            \n            for i in range(n_inner):\n                angle = 2 * np.pi * i / max(1, n_inner) + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(n_outer):\n                angle = 2 * np.pi * i / max(1, n_outer) + np.random.randn() * 0.1\n                X[i + 1 + n_inner] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                \n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            if n > 0: R[0] = 0.1\n            \n        elif restart < 9:\n            X = np.random.rand(n, 2) * 0.8 + 0.1\n            R = np.random.rand(n) * 0.04 + 0.01\n            max_c = min(n, 4)\n            bases = [[0.2, 0.2], [0.2, 0.8], [0.8, 0.2], [0.8, 0.8]]\n            for i in range(max_c):\n                X[i] = bases[i]\n                R[i] = 0.15\n            if n > 4:\n                X[4] = [0.5, 0.5]\n                R[4] = 0.15\n                \n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.5\n            edge_y_mask = np.random.rand(n) > 0.5\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.02, 0.05, 0.95)\n            R = np.ones(n) * 0.03\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        # Annealing engine parameters safely integrating complex gradient intersections\n        for step in range(iterations):\n            progress = step / iterations\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            safe_dist = np.maximum(dist, 1e-10)\n            \n            dir_x = dx / safe_dist\n            dir_y = dy / safe_dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            # Injection bounds preventing symmetrically stalled forces mathematically resolving space locks\n            if progress < 0.6:\n                noise_scale = 0.002 * (0.6 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        # Post evaluate strict limits to bounds ensuring safe returns globally scaling perfectly \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"Construct highly optimized mathematically tight layouts evaluated inside strictly rigorous boundaries.\"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6332), Performs well on target_ratio (0.9993), Performs well on combined_score (0.9993), Performs well on radius_variance (0.0049), Performs well on spatial_spread (0.1857), Performs well on eval_time (10.2727)\n\n### Program 2 (Score: 0.9972)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures,\n    while breaking symmetry through micro-randomizations.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        \n        # Central circles (varying cluster arrangements to maximize topology search space)\n        num_center = b % 4 + 1\n        for i in range(num_center):\n            if idx < n_circles:\n                angle = 2.0 * np.pi * i / num_center\n                radius = 0.05 if num_center > 1 else 0.0\n                positions[b, idx] = [\n                    0.5 + radius * np.cos(angle), \n                    0.5 + radius * np.sin(angle)\n                ]\n                radii[b, idx] = 0.15 - 0.02 * num_center\n                idx += 1\n                \n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        places = corners + edges\n        np.random.shuffle(places)\n        \n        # Deploy at edges/corners iteratively\n        for pos in places:\n            if idx < n_circles:\n                p_x = pos[0] + np.random.uniform(-0.02, 0.02)\n                p_y = pos[1] + np.random.uniform(-0.02, 0.02)\n                positions[b, idx] = [p_x, p_y]\n                radii[b, idx] = 0.08\n                idx += 1\n                \n        # Fill interstitials \n        while idx < n_circles:\n            positions[b, idx] = np.random.uniform(0.1, 0.9, 2)\n            radii[b, idx] = np.random.uniform(0.02, 0.06)\n            idx += 1\n            \n    positions = np.clip(positions, 0.0, 1.0)\n    return positions, radii\n\n\ndef make_valid(positions, radii):\n    \"\"\"\n    Rigorously cleans the batch solution down to exactly 100% precision valid states\n    where there are mathematically strictly zero structural overlaps.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Boundary limiting pass\n    for i in range(n_circles):\n        x, y = positions[i]\n        max_r = min(x, y, 1.0 - x, 1.0 - y)\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    # Successive intersection reduction mapping\n    for _ in range(100):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                \n                # Check bounding against tiny floating scale offset\n                if r_out[i] + r_out[j] > d + 1e-9:\n                    if d < 1e-7:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        # Safety compression margin mitigates Zeno-locking bounds loops\n                        scale *= 0.99999 \n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n        \n        # Perfect stable-packing breaks early\n        if not has_overlap:\n            break\n            \n    return r_out\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized mathematical geometric simulation packing \n    applying physics-modeled continuous gradient Adam momentum mechanics.\n    Provides natural pressure growth to systematically seek maximized cumulative bounds.\n    \"\"\"\n    batch_size = 32\n    n_circles = 26\n    iters = 3000\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    # Configure Adam state allocations\n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005\n    \n    # Perform Continuous Constraint and Target Growth Vector Mapping (Numpy SIMD Processed)\n    for step in range(1, iters + 1):\n        # Gradual simulated annealing constraints \n        lr = base_learning_rate * (1.0 - 0.9 * step / iters)\n        penalty = 10.0 * (1000.0 ** (step / iters))\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        # Formulate non-diverging bounds matrix for pair overlaps \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        # Accumulate matrix gradients mathematically symmetrical interactions\n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        # Construct constraint mechanics against geometry bounds limitation\n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        grad_radii -= 2.0  # Imparts uniform target radius sum maximizing bounds pressure \n        \n        # Compute discrete Adam velocity steps \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        radii -= lr * step_r\n        \n        # Keep components locally rigid to mathematical possibility structures\n        positions = np.clip(positions, 0.0, 1.0)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    # Discover supreme outcome enforcing totally correct unoverlapped borders\n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        \n        cleaned_radii = make_valid(curr_positions, curr_radii)\n        eval_score = np.sum(cleaned_radii)\n        \n        if eval_score > best_score:\n            best_score = eval_score\n            best_positions = curr_positions\n            best_radii = cleaned_radii\n            \n    return best_positions, best_radii, best_score\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Functionally preserved for pipeline continuity if strictly examined standalone.\n    Yields overlapping safety-bounds dynamically mirroring strict shrinkage model mapping.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6276), Performs well on target_ratio (0.9972), Performs well on combined_score (0.9972), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.2036), Performs well on eval_time (1.8165)\n\n### Program 3 (Score: 0.9937)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by safely constraining inside logical boundaries.\"\"\"\n    # Enforce basic constraints\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Clean overlapping space optimally with symmetric radius reduction loops\n    for _ in range(2000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if R[i] + R[j] > dist[i, j] + 1e-12:\n                    scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                    R[i] *= scale\n                    R[j] *= scale\n                    violation = True\n        if not violation:\n            break\n            \n    # Sub-pass aggressive localized radius expansion into micro-residual space\n    for _ in range(25):\n        order = np.random.permutation(n)\n        for i in order:\n            max_r = min(X[i, 0], 1.0 - X[i, 0], X[i, 1], 1.0 - X[i, 1])\n            for j in range(n):\n                if i != j:\n                    d = np.linalg.norm(X[i] - X[j])\n                    max_r = min(max_r, d - R[j])\n            if max_r > R[i]:\n                R[i] = max_r\n                \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=8000, restarts=10, lr_start=0.015):\n    \"\"\"Execute projected constraint minimization using varied seeds iteratively.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    # Using heterogeneous restarts to discover maximum optimal boundaries without hardcoding topology.\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Divergent architectural seeding biases (corners, uniform array mapping, core density clustering)\n        if restart < 2:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n        elif restart < 6:\n            X = np.zeros((n, 2))\n            X[0] = [0.5, 0.5]\n            for i in range(8):\n                angle = 2 * np.pi * i / 8 + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(17):\n                angle = 2 * np.pi * i / 17 + np.random.randn() * 0.1\n                X[i+9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            R[0] = 0.1\n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.6\n            edge_y_mask = np.random.rand(n) > 0.6\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.01, 0.05, 0.95)\n            R = np.ones(n) * 0.04\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        for step in range(iterations):\n            progress = step / iterations\n            \n            # Simulated annealing physics parameter schedule\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            # Intersective topological differentials mapped cleanly\n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            \n            dir_x = dx / dist\n            dir_y = dy / dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            # Maximize gradient (-1 scales with iteration expansion bounds via descent engine mechanics)\n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            \n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            if progress < 0.5:\n                noise_scale = 0.001 * (0.5 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        # Evaluation metric extraction per model pass framework limitation scope boundaries \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs the highly optimized mathematically accurate mapping\n    Returns coordinates and specific size metrics safely evaluated inside parameters bounds.\n    \"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6185), Performs well on target_ratio (0.9937), Performs well on combined_score (0.9937), Performs well on radius_variance (0.0051), Performs well on spatial_spread (0.1931), Performs well on eval_time (8.3362)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9972, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures,\n    while breaking symmetry through micro-randomizations.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        \n        # Central circles (varying cluster arrangements to maximize topology search space)\n        num_center = b % 4 + 1\n        for i in range(num_center):\n            if idx < n_circles:\n                angle = 2.0 * np.pi * i / num_center\n                radius = 0.05 if num_center > 1 else 0.0\n                positions[b, idx] = [\n                    0.5 + radius * np.cos(angle), \n                    0.5 + radius * np.sin(angle)\n                ]\n                radii[b, idx] = 0.15 - 0.02 * num_center\n                idx += 1\n                \n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        places = corners + edges\n        np.random.shuffle(places)\n        \n        # Deploy at edges/corners iteratively\n        for pos in places:\n            if idx < n_circles:\n                p_x = pos[0] + np.random.uniform(-0.02, 0.02)\n                p_y = pos[1] + np.random.uniform(-0.02, 0.02)\n                positions[b, idx] = [p_x, p_y]\n                radii[b, idx] = 0.08\n                idx += 1\n                \n        # Fill interstitials \n        while idx < n_circles:\n            positions[b, idx] = np.random.uniform(0.1, 0.9, 2)\n            radii[b, idx] = np.random.uniform(0.02, 0.06)\n            idx += 1\n            \n    positions = np.clip(positions, 0.0, 1.0)\n    return positions, radii\n\n\ndef make_valid(positions, radii):\n    \"\"\"\n    Rigorously cleans the batch solution down to exactly 100% precision valid states\n    where there are mathematically strictly zero structural overlaps.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Boundary limiting pass\n    for i in range(n_circles):\n        x, y = positions[i]\n        max_r = min(x, y, 1.0 - x, 1.0 - y)\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    # Successive intersection reduction mapping\n    for _ in range(100):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                \n                # Check bounding against tiny floating scale offset\n                if r_out[i] + r_out[j] > d + 1e-9:\n                    if d < 1e-7:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        # Safety compression margin mitigates Zeno-locking bounds loops\n                        scale *= 0.99999 \n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n        \n        # Perfect stable-packing breaks early\n        if not has_overlap:\n            break\n            \n    return r_out\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized mathematical geometric simulation packing \n    applying physics-modeled continuous gradient Adam momentum mechanics.\n    Provides natural pressure growth to systematically seek maximized cumulative bounds.\n    \"\"\"\n    batch_size = 32\n    n_circles = 26\n    iters = 3000\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    # Configure Adam state allocations\n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005\n    \n    # Perform Continuous Constraint and Target Growth Vector Mapping (Numpy SIMD Processed)\n    for step in range(1, iters + 1):\n        # Gradual simulated annealing constraints \n        lr = base_learning_rate * (1.0 - 0.9 * step / iters)\n        penalty = 10.0 * (1000.0 ** (step / iters))\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        # Formulate non-diverging bounds matrix for pair overlaps \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        # Accumulate matrix gradients mathematically symmetrical interactions\n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        # Construct constraint mechanics against geometry bounds limitation\n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        grad_radii -= 2.0  # Imparts uniform target radius sum maximizing bounds pressure \n        \n        # Compute discrete Adam velocity steps \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        radii -= lr * step_r\n        \n        # Keep components locally rigid to mathematical possibility structures\n        positions = np.clip(positions, 0.0, 1.0)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    # Discover supreme outcome enforcing totally correct unoverlapped borders\n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        \n        cleaned_radii = make_valid(curr_positions, curr_radii)\n        eval_score = np.sum(cleaned_radii)\n        \n        if eval_score > best_score:\n            best_score = eval_score\n            best_positions = curr_positions\n            best_radii = cleaned_radii\n            \n    return best_positions, best_radii, best_score\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Functionally preserved for pipeline continuity if strictly examined standalone.\n    Yields overlapping safety-bounds dynamically mirroring strict shrinkage model mapping.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9937, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by safely constraining inside logical boundaries.\"\"\"\n    # Enforce basic constraints\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Clean overlapping space optimally with symmetric radius reduction loops\n    for _ in range(2000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if R[i] + R[j] > dist[i, j] + 1e-12:\n                    scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                    R[i] *= scale\n                    R[j] *= scale\n                    violation = True\n        if not violation:\n            break\n            \n    # Sub-pass aggressive localized radius expansion into micro-residual space\n    for _ in range(25):\n        order = np.random.permutation(n)\n        for i in order:\n            max_r = min(X[i, 0], 1.0 - X[i, 0], X[i, 1], 1.0 - X[i, 1])\n            for j in range(n):\n                if i != j:\n                    d = np.linalg.norm(X[i] - X[j])\n                    max_r = min(max_r, d - R[j])\n            if max_r > R[i]:\n                R[i] = max_r\n                \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=8000, restarts=10, lr_start=0.015):\n    \"\"\"Execute projected constraint minimization using varied seeds iteratively.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    # Using heterogeneous restarts to discover maximum optimal boundaries without hardcoding topology.\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Divergent architectural seeding biases (corners, uniform array mapping, core density clustering)\n        if restart < 2:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n        elif restart < 6:\n            X = np.zeros((n, 2))\n            X[0] = [0.5, 0.5]\n            for i in range(8):\n                angle = 2 * np.pi * i / 8 + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(17):\n                angle = 2 * np.pi * i / 17 + np.random.randn() * 0.1\n                X[i+9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            R[0] = 0.1\n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.6\n            edge_y_mask = np.random.rand(n) > 0.6\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.01, 0.05, 0.95)\n            R = np.ones(n) * 0.04\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        for step in range(iterations):\n            progress = step / iterations\n            \n            # Simulated annealing physics parameter schedule\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            # Intersective topological differentials mapped cleanly\n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            \n            dir_x = dx / dist\n            dir_y = dy / dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            # Maximize gradient (-1 scales with iteration expansion bounds via descent engine mechanics)\n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            \n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            if progress < 0.5:\n                noise_scale = 0.001 * (0.5 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        # Evaluation metric extraction per model pass framework limitation scope boundaries \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs the highly optimized mathematically accurate mapping\n    Returns coordinates and specific size metrics safely evaluated inside parameters bounds.\n    \"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by resolving overlaps, bounding dynamically,\n    and pushing coordinates precisely towards mathematical kissing constraints to inflate bounds.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Resolving intersecting structural bounds loop safely geometrically\n    for _ in range(4000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if overlap[i, j] > 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    # Iterative aggressive local block-coordinate space nudging & optimization\n    # Expands inner spaces by sliding circles mathematically along multiple constraint interfaces\n    for pass_idx in range(80):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.02 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            # Active microscopic coordinate drift gradient against closest topological barriers\n            for _ in range(15):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                # Temperature based vector formulation directing into deepest space pools safely\n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                w_circ = np.exp(-200.0 * np.maximum(0, m_circ - min_m))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                w_bnd = np.exp(-200.0 * np.maximum(0, m_bnd - min_m))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n\n            # Confirm and capture safe bounds limits improvements continuously\n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 10:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=7000, restarts=12, lr_start=0.015):\n    \"\"\"Execute dynamic penalty-scaled Adam physics with targeted varied structured seeds.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Heterogeneous structured parameter placements balancing varied densities intelligently\n        if restart < 3:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n            \n        elif restart < 6:\n            X = np.zeros((n, 2))\n            if n > 0: X[0] = [0.5, 0.5]\n            n_inner = min((n - 1) // 3, 8) if n > 1 else 0\n            n_outer = max(0, n - 1 - n_inner)\n            \n            for i in range(n_inner):\n                angle = 2 * np.pi * i / max(1, n_inner) + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(n_outer):\n                angle = 2 * np.pi * i / max(1, n_outer) + np.random.randn() * 0.1\n                X[i + 1 + n_inner] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                \n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            if n > 0: R[0] = 0.1\n            \n        elif restart < 9:\n            X = np.random.rand(n, 2) * 0.8 + 0.1\n            R = np.random.rand(n) * 0.04 + 0.01\n            max_c = min(n, 4)\n            bases = [[0.2, 0.2], [0.2, 0.8], [0.8, 0.2], [0.8, 0.8]]\n            for i in range(max_c):\n                X[i] = bases[i]\n                R[i] = 0.15\n            if n > 4:\n                X[4] = [0.5, 0.5]\n                R[4] = 0.15\n                \n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.5\n            edge_y_mask = np.random.rand(n) > 0.5\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.02, 0.05, 0.95)\n            R = np.ones(n) * 0.03\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        # Annealing engine parameters safely integrating complex gradient intersections\n        for step in range(iterations):\n            progress = step / iterations\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            safe_dist = np.maximum(dist, 1e-10)\n            \n            dir_x = dx / safe_dist\n            dir_y = dy / safe_dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            # Injection bounds preventing symmetrically stalled forces mathematically resolving space locks\n            if progress < 0.6:\n                noise_scale = 0.002 * (0.6 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        # Post evaluate strict limits to bounds ensuring safe returns globally scaling perfectly \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"Construct highly optimized mathematically tight layouts evaluated inside strictly rigorous boundaries.\"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["import numpy as np\n\ndef generate_initial_states(batch_size, n):\n    np.random.seed(1337)\n    X = np.random.uniform(0.1, 0.9, (batch_size, n, 2))\n    R = np.random.uniform(0.01, 0.06, (batch_size, n))\n    \n    for b in range(batch_size):\n        strategy = b % 8\n        if strategy == 0:\n            pass\n        elif strategy == 1:\n            X[b] = np.random.normal(0.5, 0.25, (n, 2))\n        elif strategy == 2:\n            grid_dim = int(np.ceil(np.sqrt(n)))\n            idx = 0\n            for i in range(grid_dim):\n                for j in range(grid_dim):\n                    if idx < n:\n                        X[b, idx] = [0.1 + 0.8*i/(grid_dim-1), 0.1 + 0.8*j/(grid_dim-1)]\n                        idx += 1\n            X[b] += np.random.uniform(-0.02, 0.02, (n, 2))\n        elif strategy == 3:\n            idx = 0\n            for i in range(6):\n                for j in range(6):\n                    if idx < n:\n                        x = 0.1 + 0.15*j + (i%2)*0.075\n                        y = 0.1 + 0.15*i\n                        X[b, idx] = [x, y]\n                        idx += 1\n            X[b] += np.random.uniform(-0.02, 0.02, (n, 2))\n        elif strategy == 4:\n            X[b, 0] = [0.5, 0.5]\n            R[b, 0] = 0.1\n            idx = 1\n            n_inner = min(8, n - 1)\n            for i in range(n_inner):\n                ang = 2*np.pi*i/n_inner + np.random.uniform(0, 0.5)\n                X[b, idx] = [0.5 + 0.22*np.cos(ang), 0.5 + 0.22*np.sin(ang)]\n                R[b, idx] = 0.08\n                idx += 1\n            n_outer = n - 1 - n_inner\n            for i in range(n_outer):\n                ang = 2*np.pi*i/n_outer + np.random.uniform(0, 0.5)\n                X[b, idx] = [0.5 + 0.42*np.cos(ang), 0.5 + 0.42*np.sin(ang)]\n                idx += 1\n        elif strategy == 5:\n            X[b, 0] = [0.5, 0.5]\n            idx = 1\n            for rng, r in [(5, 0.15), (9, 0.3), (n - 1 - 5 - 9, 0.45)]:\n                for i in range(rng):\n                    if idx < n:\n                        ang = 2*np.pi*i/rng + np.random.uniform(0, 1.0)\n                        X[b, idx] = [0.5 + r*np.cos(ang), 0.5 + r*np.sin(ang)]\n                        idx += 1\n        elif strategy == 6:\n            idx = 0\n            centers = [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]]\n            for c in centers:\n                if idx < n:\n                    X[b, idx] = c\n                    idx += 1\n                for _ in range((n-4)//4):\n                    if idx < n:\n                        X[b, idx] = [c[0] + np.random.uniform(-0.1, 0.1), c[1] + np.random.uniform(-0.1, 0.1)]\n                        idx += 1\n        elif strategy == 7:\n            idx = 0\n            while idx < n:\n                if np.random.rand() < 0.7:\n                    if np.random.rand() < 0.5:\n                        X[b, idx] = [np.random.choice([0.05, 0.95]), np.random.uniform(0.1, 0.9)]\n                    else:\n                        X[b, idx] = [np.random.uniform(0.1, 0.9), np.random.choice([0.05, 0.95])]\n                else:\n                    X[b, idx] = np.random.uniform(0.2, 0.8, 2)\n                idx += 1\n\n    X = np.clip(X, 0.01, 0.99)\n    return X, R\n\n\ndef optimize_batch(X, R, n, iters=3500):\n    m_p, v_p = np.zeros_like(X), np.zeros_like(X)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005 \n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        lr = base_learning_rate * (1.0 - 0.9 * progress)\n        penalty = 10.0 * (1000.0 ** progress)\n        \n        x = X[:, :, 0:1]\n        y = X[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n).reshape(1, n, n) * 100.0\n        \n        sum_r = R[:, :, None] + R[:, None, :]\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2)\n        grad_r_pair = np.sum(force_pair, axis=2)\n        \n        ox0 = np.maximum(0.0, R - X[:, :, 0])\n        ox1 = np.maximum(0.0, R + X[:, :, 0] - 1.0)\n        oy0 = np.maximum(0.0, R - X[:, :, 1])\n        oy1 = np.maximum(0.0, R + X[:, :, 1] - 1.0)\n        \n        fx0 = 2.0 * penalty * ox0\n        fx1 = 2.0 * penalty * ox1\n        fy0 = 2.0 * penalty * oy0\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_p = np.stack([grad_x, grad_y], axis=-1)\n        \n        grad_r = grad_r_pair + fx0 + fx1 + fy0 + fy1 - 1.5\n        \n        if progress < 0.6:\n            noise_scale = 0.02 * (0.6 - progress) * penalty\n            grad_p += np.random.normal(0, noise_scale, grad_p.shape)\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        X -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        R -= lr * step_r\n        \n        X = np.clip(X, 0.0, 1.0)\n        R = np.clip(R, 0.001, 1.0)\n        \n    return X, R\n\n\ndef make_valid_simple(X, R):\n    X = np.clip(X, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    for _ in range(150):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-10:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-10:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef refine_single_layout(X, R, max_passes=120):\n    n = len(R)\n    X = X.copy()\n    R = R.copy()\n    \n    for pass_idx in range(max_passes):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.03 * (0.94 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                diff_circ = m_circ - min_m\n                w_circ = np.exp(-150.0 * np.maximum(0, diff_circ))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                diff_bnd = m_bnd - min_m\n                w_bnd = np.exp(-150.0 * np.maximum(0, diff_bnd))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n                    \n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    return X, R\n\n\ndef enforce_strict_validity(X, R):\n    X = np.clip(X, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    for _ in range(400):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-11:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-11:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef construct_packing():\n    batch_size = 80\n    n = 26\n    iters = 3500\n    \n    X_init, R_init = generate_initial_states(batch_size, n)\n    X_opt, R_opt = optimize_batch(X_init, R_init, n, iters=iters)\n    \n    results = []\n    for b in range(batch_size):\n        x_val, r_val = make_valid_simple(X_opt[b], R_opt[b])\n        results.append((np.sum(r_val), x_val, r_val))\n        \n    results.sort(key=lambda item: item[0], reverse=True)\n    \n    top_k = min(12, batch_size)\n    best_score = -1.0\n    best_X = None\n    best_R = None\n    \n    for i in range(top_k):\n        score_b, x_val, r_val = results[i]\n        \n        x_refined, r_refined = refine_single_layout(x_val, r_val, max_passes=120)\n        x_final, r_final = enforce_strict_validity(x_refined, r_refined)\n        \n        final_score = np.sum(r_final)\n        if final_score > best_score:\n            best_score = final_score\n            best_X = x_final.copy()\n            best_R = r_final.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")"]}}, "artifacts_json": "{\"execution_time\": \"10.02s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.632889/2.635 = 0.9992\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.9% of target value\", \"radius_stats\": \"Min: 0.069366, Max: 0.136422, Avg: 0.101265\"}", "artifact_dir": null, "embedding": null}