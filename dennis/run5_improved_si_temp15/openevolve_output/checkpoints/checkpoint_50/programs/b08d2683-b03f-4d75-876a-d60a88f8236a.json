{"id": "b08d2683-b03f-4d75-876a-d60a88f8236a", "code": "# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures.\n    Constructs symmetry mappings explicitly before breaking perfectly parallel\n    alignment structurally through fine geometric permutations across states.\n    \"\"\"\n    np.random.seed(2025)\n    X = np.zeros((batch_size, n_circles, 2))\n    R = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        strat = b % 10\n        idx = 0\n        \n        if strat == 0:\n            # Layout mapped implicitly for structural centers at (1, 8, 17) boundaries\n            X[b, idx] = [0.5, 0.5]; R[b, idx] = 0.12; idx += 1\n            for i in range(8):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 8 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.20 * np.cos(a), 0.5 + 0.20 * np.sin(a)]\n                    idx += 1\n            for i in range(17):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 17 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 1:\n            # Alternate layout mapping structures via 1-7-18\n            X[b, idx] = [0.5, 0.5]; R[b, idx] = 0.12; idx += 1\n            for i in range(7):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 7 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.22 * np.cos(a), 0.5 + 0.22 * np.sin(a)]\n                    idx += 1\n            for i in range(18):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 18 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.43 * np.cos(a), 0.5 + 0.43 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 2:\n            # Bifurcated twin structures dynamically optimizing mid-states logically \n            X[b, idx] = [0.4, 0.5]; R[b, idx] = 0.10; idx += 1\n            X[b, idx] = [0.6, 0.5]; R[b, idx] = 0.10; idx += 1\n            for i in range(8):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 8 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n                    idx += 1\n            for i in range(16):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 16 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.44 * np.cos(a), 0.5 + 0.44 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 3:\n            # Mathematical grid bounding nodes properly matching borders\n            for c in [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]:\n                if idx < n_circles:\n                    X[b, idx] = c; idx += 1\n            for i in range(22):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 22\n                    X[b, idx] = [0.5 + 0.35 * np.cos(a), 0.5 + 0.35 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 4:\n            pts = []\n            for i in range(6):\n                for j in range(6):\n                    pts.append([0.1 + 0.16 * j + (i % 2) * 0.08, 0.1 + 0.16 * i])\n            np.random.shuffle(pts)\n            for i in range(n_circles):\n                if idx < n_circles:\n                    X[b, idx] = pts[i]; idx += 1\n                    \n        elif strat == 5:\n            # Spatially random distributed maps uniformly populated properly\n            for i in range(n_circles):\n                if idx < n_circles:\n                    X[b, idx] = [np.random.uniform(0.05, 0.95), np.random.uniform(0.05, 0.95)]\n                    idx += 1\n                    \n        elif strat == 6:\n            # Interspersed complex topology layering naturally effectively \n            X[b, idx] = [0.5, 0.5]; idx += 1\n            for layers in [5, 9, 11]:\n                r = layers / 24.0\n                for i in range(layers):\n                    if idx < n_circles:\n                        a = 2 * np.pi * i / layers + np.random.uniform(0, 0.5)\n                        X[b, idx] = [0.5 + r * np.cos(a), 0.5 + r * np.sin(a)]\n                        idx += 1\n                        \n        elif strat == 7:\n            for c in [[0.35, 0.35], [0.35, 0.65], [0.65, 0.35], [0.65, 0.65]]:\n                if idx < n_circles:\n                    X[b, idx] = c; idx += 1\n            for i in range(8):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 8\n                    X[b, idx] = [0.5 + 0.28 * np.cos(a), 0.5 + 0.28 * np.sin(a)]\n                    idx += 1\n            for i in range(14):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 14\n                    X[b, idx] = [0.5 + 0.44 * np.cos(a), 0.5 + 0.44 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 8:\n            pts = np.random.normal(0.5, 0.2, (n_circles, 2))\n            pts = np.clip(pts, 0.05, 0.95)\n            for i in range(n_circles):\n                if idx < n_circles:\n                    X[b, idx] = pts[i]\n                    idx += 1\n                    \n        elif strat == 9:\n            # Border edge biasing cleanly forcing outer limits directly\n            for i in range(n_circles):\n                if idx < n_circles:\n                    x = np.random.uniform(0.05, 0.95)\n                    y = np.random.uniform(0.05, 0.95)\n                    if np.random.rand() < 0.6:\n                        if np.random.rand() < 0.5:\n                            x = np.random.choice([0.05, 0.95]) + np.random.uniform(-0.02, 0.02)\n                        else:\n                            y = np.random.choice([0.05, 0.95]) + np.random.uniform(-0.02, 0.02)\n                    X[b, idx] = [x, y]; idx += 1\n                    \n        while idx < n_circles:\n            X[b, idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            idx += 1\n            \n        X[b] += np.random.uniform(-0.01, 0.01, (n_circles, 2))\n        R[b] = np.random.uniform(0.02, 0.08, n_circles)\n\n    X = np.clip(X, 0.01, 0.99)\n    return X, R\n\n\ndef optimize_batch(X, R, n, iters=4500):\n    \"\"\"\n    Simulates dynamic tensor gradient flows using Adam scaling globally.\n    Systematically discovers optimally packed spatial representations mapped cleanly.\n    \"\"\"\n    m_p, v_p = np.zeros_like(X), np.zeros_like(X)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.008\n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        lr = base_learning_rate * (1.0 - 0.9 * progress)\n        penalty = 15.0 * (1000.0 ** progress)\n        \n        x = X[:, :, 0:1]\n        y = X[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n).reshape(1, n, n) * 100.0\n        \n        sum_r = R[:, :, None] + R[:, None, :]\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2)\n        grad_r_pair = np.sum(force_pair, axis=2)\n        \n        ox0 = np.maximum(0.0, R - X[:, :, 0])\n        ox1 = np.maximum(0.0, R + X[:, :, 0] - 1.0)\n        oy0 = np.maximum(0.0, R - X[:, :, 1])\n        oy1 = np.maximum(0.0, R + X[:, :, 1] - 1.0)\n        \n        fx0 = 2.0 * penalty * ox0\n        fx1 = 2.0 * penalty * ox1\n        fy0 = 2.0 * penalty * oy0\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_p = np.stack([grad_x, grad_y], axis=-1)\n        \n        # Maximize gradient against constant forces intelligently capturing density bounds smoothly.\n        grad_r = grad_r_pair + fx0 + fx1 + fy0 + fy1 - 1.5\n        \n        if progress < 0.6:\n            noise_scale = 0.02 * (0.6 - progress) * penalty\n            grad_p += np.random.normal(0, noise_scale, grad_p.shape)\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        X -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        R -= lr * step_r\n        \n        X = np.clip(X, 0.0, 1.0)\n        R = np.clip(R, 0.001, 1.0)\n        \n    return X, R\n\n\ndef make_valid_simple(X, R):\n    \"\"\"Safely pre-evaluate validly corrected mathematical bounds constraints easily perfectly natively.\"\"\"\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.001)\n    n = len(R)\n    \n    for _ in range(80):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = (R.reshape(-1, 1) + R) - dist\n        if np.max(overlap) > 1e-10:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-10:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return R\n\n\ndef make_valid_and_refine(X, R):\n    \"\"\"\n    Actively explores and physically shifts mathematical geometric mapping effectively.\n    Aggressive targeted gap filling securely bounds the layout maximizing score perfectly reliably smoothly structurally exactly cleanly gracefully flawlessly perfectly effectively cleanly mathematically safely seamlessly tightly effectively correctly optimally accurately robustly properly.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    \n    for _ in range(500):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = (R.reshape(-1, 1) + R) - dist\n        if np.max(overlap) > 1e-11:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-11:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.99999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    for pass_idx in range(120):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.025 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r + 1e-12:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                diff_circ = m_circ - min_m\n                w_circ = np.exp(-200.0 * np.maximum(0, diff_circ))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                diff_bnd = m_bnd - min_m\n                w_bnd = np.exp(-200.0 * np.maximum(0, diff_bnd))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n                    \n            if best_r > R[i] + 1e-10:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    \n    for _ in range(500):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = (R.reshape(-1, 1) + R) - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.999999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef construct_packing():\n    \"\"\"Build structurally maximized configurations globally scaling tightly evaluated properly.\"\"\"\n    batch_size = 90\n    n = 26\n    iters = 4500\n    \n    X_init, R_init = generate_initial_states(batch_size, n)\n    X_opt, R_opt = optimize_batch(X_init, R_init, n, iters=iters)\n    \n    results = []\n    for b in range(batch_size):\n        r_val = make_valid_simple(X_opt[b].copy(), R_opt[b].copy())\n        results.append((np.sum(r_val), b))\n        \n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    top_k = min(16, batch_size)\n    best_score = -1.0\n    best_X = None\n    best_R = None\n    \n    for i in range(top_k):\n        b = results[i][1]\n        x_final, r_final = make_valid_and_refine(X_opt[b].copy(), R_opt[b].copy())\n        score = np.sum(r_final)\n        \n        if score > best_score:\n            best_score = score\n            best_X = x_final.copy()\n            best_R = r_final.copy()\n            \n    return best_X, best_R, best_score\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "530470d3-1152-4178-99e6-7de7ce8881ba", "generation": 4, "timestamp": 1771903368.6994326, "iteration_found": 32, "metrics": {"validity": 1.0, "sum_radii": 2.6221214679746754, "target_ratio": 0.9951125115653418, "combined_score": 0.9951125115653418, "radius_variance": 0.00496054610678248, "spatial_spread": 0.18558684099496084, "eval_time": 11.496063709259033}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6246353610251956, "target_ratio": 0.9960665506736985, "combined_score": 0.9960665506736985, "radius_variance": 0.005440342992579624, "spatial_spread": 0.18643339376773407, "eval_time": 13.197705507278442}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9961\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9983 \u2192 0.9961. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n13.20s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.624635/2.635 = 0.9961\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.6% of target value\n```\n\n### radius_stats\n```\nMin: 0.063444, Max: 0.133649, Avg: 0.100948\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6304, target_ratio: 0.9983, combined_score: 0.9983, radius_variance: 0.0045, spatial_spread: 0.1879, eval_time: 4.3127\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6329, target_ratio: 0.9992, combined_score: 0.9992, radius_variance: 0.0045, spatial_spread: 0.1885, eval_time: 10.0222\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6332, target_ratio: 0.9993, combined_score: 0.9993, radius_variance: 0.0049, spatial_spread: 0.1857, eval_time: 10.2727\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9993)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by resolving overlaps, bounding dynamically,\n    and pushing coordinates precisely towards mathematical kissing constraints to inflate bounds.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Resolving intersecting structural bounds loop safely geometrically\n    for _ in range(4000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if overlap[i, j] > 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    # Iterative aggressive local block-coordinate space nudging & optimization\n    # Expands inner spaces by sliding circles mathematically along multiple constraint interfaces\n    for pass_idx in range(80):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.02 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            # Active microscopic coordinate drift gradient against closest topological barriers\n            for _ in range(15):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                # Temperature based vector formulation directing into deepest space pools safely\n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                w_circ = np.exp(-200.0 * np.maximum(0, m_circ - min_m))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                w_bnd = np.exp(-200.0 * np.maximum(0, m_bnd - min_m))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n\n            # Confirm and capture safe bounds limits improvements continuously\n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 10:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=7000, restarts=12, lr_start=0.015):\n    \"\"\"Execute dynamic penalty-scaled Adam physics with targeted varied structured seeds.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Heterogeneous structured parameter placements balancing varied densities intelligently\n        if restart < 3:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n            \n        elif restart < 6:\n            X = np.zeros((n, 2))\n            if n > 0: X[0] = [0.5, 0.5]\n            n_inner = min((n - 1) // 3, 8) if n > 1 else 0\n            n_outer = max(0, n - 1 - n_inner)\n            \n            for i in range(n_inner):\n                angle = 2 * np.pi * i / max(1, n_inner) + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(n_outer):\n                angle = 2 * np.pi * i / max(1, n_outer) + np.random.randn() * 0.1\n                X[i + 1 + n_inner] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                \n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            if n > 0: R[0] = 0.1\n            \n        elif restart < 9:\n            X = np.random.rand(n, 2) * 0.8 + 0.1\n            R = np.random.rand(n) * 0.04 + 0.01\n            max_c = min(n, 4)\n            bases = [[0.2, 0.2], [0.2, 0.8], [0.8, 0.2], [0.8, 0.8]]\n            for i in range(max_c):\n                X[i] = bases[i]\n                R[i] = 0.15\n            if n > 4:\n                X[4] = [0.5, 0.5]\n                R[4] = 0.15\n                \n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.5\n            edge_y_mask = np.random.rand(n) > 0.5\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.02, 0.05, 0.95)\n            R = np.ones(n) * 0.03\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        # Annealing engine parameters safely integrating complex gradient intersections\n        for step in range(iterations):\n            progress = step / iterations\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            safe_dist = np.maximum(dist, 1e-10)\n            \n            dir_x = dx / safe_dist\n            dir_y = dy / safe_dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            # Injection bounds preventing symmetrically stalled forces mathematically resolving space locks\n            if progress < 0.6:\n                noise_scale = 0.002 * (0.6 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        # Post evaluate strict limits to bounds ensuring safe returns globally scaling perfectly \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"Construct highly optimized mathematically tight layouts evaluated inside strictly rigorous boundaries.\"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6332), Performs well on target_ratio (0.9993), Performs well on combined_score (0.9993), Performs well on radius_variance (0.0049), Performs well on spatial_spread (0.1857), Performs well on eval_time (10.2727)\n\n### Program 2 (Score: 0.9992)\n```python\nimport numpy as np\n\ndef generate_initial_states(batch_size, n):\n    np.random.seed(1337)\n    X = np.random.uniform(0.1, 0.9, (batch_size, n, 2))\n    R = np.random.uniform(0.01, 0.06, (batch_size, n))\n    \n    for b in range(batch_size):\n        strategy = b % 8\n        if strategy == 0:\n            pass\n        elif strategy == 1:\n            X[b] = np.random.normal(0.5, 0.25, (n, 2))\n        elif strategy == 2:\n            grid_dim = int(np.ceil(np.sqrt(n)))\n            idx = 0\n            for i in range(grid_dim):\n                for j in range(grid_dim):\n                    if idx < n:\n                        X[b, idx] = [0.1 + 0.8*i/(grid_dim-1), 0.1 + 0.8*j/(grid_dim-1)]\n                        idx += 1\n            X[b] += np.random.uniform(-0.02, 0.02, (n, 2))\n        elif strategy == 3:\n            idx = 0\n            for i in range(6):\n                for j in range(6):\n                    if idx < n:\n                        x = 0.1 + 0.15*j + (i%2)*0.075\n                        y = 0.1 + 0.15*i\n                        X[b, idx] = [x, y]\n                        idx += 1\n            X[b] += np.random.uniform(-0.02, 0.02, (n, 2))\n        elif strategy == 4:\n            X[b, 0] = [0.5, 0.5]\n            R[b, 0] = 0.1\n            idx = 1\n            n_inner = min(8, n - 1)\n            for i in range(n_inner):\n                ang = 2*np.pi*i/n_inner + np.random.uniform(0, 0.5)\n                X[b, idx] = [0.5 + 0.22*np.cos(ang), 0.5 + 0.22*np.sin(ang)]\n                R[b, idx] = 0.08\n                idx += 1\n            n_outer = n - 1 - n_inner\n            for i in range(n_outer):\n                ang = 2*np.pi*i/n_outer + np.random.uniform(0, 0.5)\n                X[b, idx] = [0.5 + 0.42*np.cos(ang), 0.5 + 0.42*np.sin(ang)]\n                idx += 1\n        elif strategy == 5:\n            X[b, 0] = [0.5, 0.5]\n            idx = 1\n            for rng, r in [(5, 0.15), (9, 0.3), (n - 1 - 5 - 9, 0.45)]:\n                for i in range(rng):\n                    if idx < n:\n                        ang = 2*np.pi*i/rng + np.random.uniform(0, 1.0)\n                        X[b, idx] = [0.5 + r*np.cos(ang), 0.5 + r*np.sin(ang)]\n                        idx += 1\n        elif strategy == 6:\n            idx = 0\n            centers = [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75]]\n            for c in centers:\n                if idx < n:\n                    X[b, idx] = c\n                    idx += 1\n                for _ in range((n-4)//4):\n                    if idx < n:\n                        X[b, idx] = [c[0] + np.random.uniform(-0.1, 0.1), c[1] + np.random.uniform(-0.1, 0.1)]\n                        idx += 1\n        elif strategy == 7:\n            idx = 0\n            while idx < n:\n                if np.random.rand() < 0.7:\n                    if np.random.rand() < 0.5:\n                        X[b, idx] = [np.random.choice([0.05, 0.95]), np.random.uniform(0.1, 0.9)]\n                    else:\n                        X[b, idx] = [np.random.uniform(0.1, 0.9), np.random.choice([0.05, 0.95])]\n                else:\n                    X[b, idx] = np.random.uniform(0.2, 0.8, 2)\n                idx += 1\n\n    X = np.clip(X, 0.01, 0.99)\n    return X, R\n\n\ndef optimize_batch(X, R, n, iters=3500):\n    m_p, v_p = np.zeros_like(X), np.zeros_like(X)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005 \n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        lr = base_learning_rate * (1.0 - 0.9 * progress)\n        penalty = 10.0 * (1000.0 ** progress)\n        \n        x = X[:, :, 0:1]\n        y = X[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n).reshape(1, n, n) * 100.0\n        \n        sum_r = R[:, :, None] + R[:, None, :]\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2)\n        grad_r_pair = np.sum(force_pair, axis=2)\n        \n        ox0 = np.maximum(0.0, R - X[:, :, 0])\n        ox1 = np.maximum(0.0, R + X[:, :, 0] - 1.0)\n        oy0 = np.maximum(0.0, R - X[:, :, 1])\n        oy1 = np.maximum(0.0, R + X[:, :, 1] - 1.0)\n        \n        fx0 = 2.0 * penalty * ox0\n        fx1 = 2.0 * penalty * ox1\n        fy0 = 2.0 * penalty * oy0\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_p = np.stack([grad_x, grad_y], axis=-1)\n        \n        grad_r = grad_r_pair + fx0 + fx1 + fy0 + fy1 - 1.5\n        \n        if progress < 0.6:\n            noise_scale = 0.02 * (0.6 - progress) * penalty\n            grad_p += np.random.normal(0, noise_scale, grad_p.shape)\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        X -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        R -= lr * step_r\n        \n        X = np.clip(X, 0.0, 1.0)\n        R = np.clip(R, 0.001, 1.0)\n        \n    return X, R\n\n\ndef make_valid_simple(X, R):\n    X = np.clip(X, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    for _ in range(150):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-10:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-10:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef refine_single_layout(X, R, max_passes=120):\n    n = len(R)\n    X = X.copy()\n    R = R.copy()\n    \n    for pass_idx in range(max_passes):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.03 * (0.94 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                diff_circ = m_circ - min_m\n                w_circ = np.exp(-150.0 * np.maximum(0, diff_circ))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                diff_bnd = m_bnd - min_m\n                w_bnd = np.exp(-150.0 * np.maximum(0, diff_bnd))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n                    \n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    return X, R\n\n\ndef enforce_strict_validity(X, R):\n    X = np.clip(X, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    for _ in range(400):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-11:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-11:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef construct_packing():\n    batch_size = 80\n    n = 26\n    iters = 3500\n    \n    X_init, R_init = generate_initial_states(batch_size, n)\n    X_opt, R_opt = optimize_batch(X_init, R_init, n, iters=iters)\n    \n    results = []\n    for b in range(batch_size):\n        x_val, r_val = make_valid_simple(X_opt[b], R_opt[b])\n        results.append((np.sum(r_val), x_val, r_val))\n        \n    results.sort(key=lambda item: item[0], reverse=True)\n    \n    top_k = min(12, batch_size)\n    best_score = -1.0\n    best_X = None\n    best_R = None\n    \n    for i in range(top_k):\n        score_b, x_val, r_val = results[i]\n        \n        x_refined, r_refined = refine_single_layout(x_val, r_val, max_passes=120)\n        x_final, r_final = enforce_strict_validity(x_refined, r_refined)\n        \n        final_score = np.sum(r_final)\n        if final_score > best_score:\n            best_score = final_score\n            best_X = x_final.copy()\n            best_R = r_final.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6329), Performs well on target_ratio (0.9992), Performs well on combined_score (0.9992), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1885), Performs well on eval_time (10.0222)\n\n### Program 3 (Score: 0.9983)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures.\n    Uses structural polymorphism to ensure wide landscape spanning natively.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        strategy = b % 8\n        \n        # Central topological formations for implicit space crystallization mapping\n        if strategy == 0:\n            positions[b, idx] = [0.5, 0.5]; radii[b, idx] = 0.20; idx += 1\n        elif strategy == 1:\n            positions[b, idx] = [0.35, 0.5]; radii[b, idx] = 0.15; idx += 1\n            positions[b, idx] = [0.65, 0.5]; radii[b, idx] = 0.15; idx += 1\n        elif strategy == 2:\n            for i in range(3):\n                angle = 2.0 * np.pi * i / 3.0\n                positions[b, idx] = [0.5 + 0.15 * np.cos(angle), 0.5 + 0.15 * np.sin(angle)]\n                radii[b, idx] = 0.12; idx += 1\n        elif strategy == 3:\n            for i in range(4):\n                angle = 2.0 * np.pi * i / 4.0\n                positions[b, idx] = [0.5 + 0.18 * np.cos(angle), 0.5 + 0.18 * np.sin(angle)]\n                radii[b, idx] = 0.12; idx += 1\n        elif strategy == 4:\n            positions[b, idx] = [0.5, 0.5]; radii[b, idx] = 0.12; idx += 1\n            for i in range(4):\n                angle = 2.0 * np.pi * i / 4.0 + np.pi/4.0\n                positions[b, idx] = [0.5 + 0.22 * np.cos(angle), 0.5 + 0.22 * np.sin(angle)]\n                radii[b, idx] = 0.10; idx += 1\n        elif strategy == 5:\n            for i in range(6):\n                angle = 2.0 * np.pi * i / 6.0\n                positions[b, idx] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                radii[b, idx] = 0.10; idx += 1\n        elif strategy == 6:\n            for i in range(8):\n                angle = 2.0 * np.pi * i / 8.0\n                positions[b, idx] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                radii[b, idx] = 0.08; idx += 1\n                \n        # Fill structural edges and grid corners systematically\n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        interstitials = [[0.25, 0.25], [0.25, 0.75], [0.75, 0.25], [0.75, 0.75],\n                         [0.25, 0.5], [0.75, 0.5], [0.5, 0.25], [0.5, 0.75]]\n        \n        places = corners + edges + interstitials\n        np.random.shuffle(places)\n        \n        for pos in places:\n            if idx < n_circles:\n                positions[b, idx] = pos\n                radii[b, idx] = 0.06 if pos in corners else 0.08\n                idx += 1\n                \n        # Provide arbitrary density map filling to any remaining void allocations\n        while idx < n_circles:\n            positions[b, idx] = np.random.uniform(0.1, 0.9, 2)\n            radii[b, idx] = np.random.uniform(0.01, 0.05)\n            idx += 1\n            \n        # Guarantee non-degenerate configurations against perfectly mirroring limits\n        positions[b] += np.random.uniform(-0.015, 0.015, (n_circles, 2))\n            \n    positions = np.clip(positions, 0.01, 0.99)\n    return positions, radii\n\n\ndef make_valid(positions, radii):\n    \"\"\"\n    Cleans structural mappings to exactly 100% strictly-enforced valid bounds \n    and aggressively recovers locally lost residuals via constrained uniform expansions.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Restrict initially to square mathematical enclosure \n    for i in range(n_circles):\n        max_r = min(positions[i, 0], positions[i, 1], 1.0 - positions[i, 0], 1.0 - positions[i, 1])\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    # Proportional geometric convergence loop scaling pairs optimally and cleanly avoiding loops\n    for _ in range(250):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                \n                # Check bounding via float tolerance thresholds \n                if r_out[i] + r_out[j] > d + 1e-11:\n                    if d < 1e-9:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        scale *= 0.9999999\n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n                    \n        if not has_overlap:\n            break\n            \n    # Successive sub-pass maximizing gap capture mathematically filling loose tolerance offsets\n    for _ in range(60):\n        expanded = False\n        order = np.random.permutation(n_circles)\n        for i in order:\n            max_r = min(positions[i, 0], 1.0 - positions[i, 0], positions[i, 1], 1.0 - positions[i, 1])\n            for j in range(n_circles):\n                if i != j:\n                    d = np.linalg.norm(positions[i] - positions[j])\n                    max_r = min(max_r, d - r_out[j] - 1e-10)\n            \n            if max_r > r_out[i] + 1e-9:\n                r_out[i] = max_r\n                expanded = True\n                \n        if not expanded:\n            break\n            \n    return r_out\n\n\ndef construct_packing():\n    \"\"\"\n    Creates and orchestrates highly accurate structural bounding geometries leveraging \n    batched computational Adam gradient descent across thousands of potential physical simulations.\n    \"\"\"\n    batch_size = 64\n    n_circles = 26\n    iters = 4500\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    # Establish dynamic tensor moment mappings parameters internally\n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005\n    \n    # Simulate fluid annealing mechanics globally against mathematically derived structural forces\n    for step in range(1, iters + 1):\n        # Gradual learning decay with strict bounds growth \n        lr = base_learning_rate * (0.01 ** (step / iters))\n        penalty = 5.0 * (10000.0 ** (step / iters))\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        # Calculate matrix pairwise differentials mapping symmetrically without 0-collisions offset\n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        # Aggregate internal constraints mathematically per spatial matrix vector block\n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        # Applies constant pull to directly increase score function target evaluation structurally \n        grad_radii -= 2.0  \n        \n        # Inject annealing thermal forces mimicking stochastic shifts effectively resolving gridlocks\n        if step < iters * 0.4:\n            noise_scale = 0.5 * (1.0 - step / (iters * 0.4))\n            grad_positions += np.random.randn(*grad_positions.shape) * noise_scale\n\n        # Run adaptive tensor descent correctly mapping safely down descent pathways limits \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        v_p_hat = v_p / (1.0 - beta2**step)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p_hat) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        v_r_hat = v_r / (1.0 - beta2**step)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r_hat) + epsilon)\n        radii -= lr * step_r\n        \n        # Bind coordinate nodes functionally tightly ensuring matrix doesn't deviate during heat runs\n        positions = np.clip(positions, 0.0, 1.0)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    # Locate objectively highest evaluated bounds mathematically resolving to 100% accurate boundaries\n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        \n        cleaned_radii = make_valid(curr_positions, curr_radii)\n        eval_score = np.sum(cleaned_radii)\n        \n        if eval_score > best_score:\n            best_score = eval_score\n            best_positions = curr_positions\n            best_radii = cleaned_radii\n            \n    return best_positions, best_radii, best_score\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Independent secondary check matching functionality mapped directly matching previous scopes parameters limits mathematically. \n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6304), Performs well on target_ratio (0.9983), Performs well on combined_score (0.9983), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1879), Performs well on eval_time (4.3127)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9961)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures.\n    Injects micro randomizations natively mapped enforcing varied geometries across multiple layers natively.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        strat = b % 8\n        \n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        if strat == 0:\n            positions[b, idx] = [0.5, 0.5]; radii[b, idx] = 0.15; idx += 1\n            for i in range(7):\n                a = 2 * np.pi * i / 7\n                positions[b, idx] = [0.5 + 0.18 * np.cos(a), 0.5 + 0.18 * np.sin(a)]\n                radii[b, idx] = 0.10; idx += 1\n            for i in range(12):\n                a = 2 * np.pi * i / 12 + 0.1\n                positions[b, idx] = [0.5 + 0.35 * np.cos(a), 0.5 + 0.35 * np.sin(a)]\n                radii[b, idx] = 0.09; idx += 1\n            for i in range(n_circles - idx):\n                positions[b, idx] = corners[i % 4]\n                radii[b, idx] = 0.06; idx += 1\n        elif strat == 1:\n            for i in range(4):\n                a = 2 * np.pi * i / 4 + np.pi/4\n                positions[b, idx] = [0.5 + 0.15 * np.cos(a), 0.5 + 0.15 * np.sin(a)]\n                radii[b, idx] = 0.12; idx += 1\n            for i in range(10):\n                a = 2 * np.pi * i / 10\n                positions[b, idx] = [0.5 + 0.32 * np.cos(a), 0.5 + 0.32 * np.sin(a)]\n                radii[b, idx] = 0.09; idx += 1\n            for i in range(12):\n                a = 2 * np.pi * i / 12\n                positions[b, idx] = [0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)]\n                radii[b, idx] = 0.07; idx += 1\n        elif strat == 2:\n            positions[b, idx] = [0.35, 0.5]; radii[b, idx] = 0.13; idx += 1\n            positions[b, idx] = [0.65, 0.5]; radii[b, idx] = 0.13; idx += 1\n            for i in range(8):\n                a = 2 * np.pi * i / 8\n                positions[b, idx] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n                radii[b, idx] = 0.10; idx += 1\n            for i in range(16):\n                a = 2 * np.pi * i / 16\n                positions[b, idx] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n                radii[b, idx] = 0.08; idx += 1\n        elif strat == 3:\n            for i in range(3):\n                a = 2 * np.pi * i / 3\n                positions[b, idx] = [0.5 + 0.15 * np.cos(a), 0.5 + 0.15 * np.sin(a)]\n                radii[b, idx] = 0.12; idx += 1\n            for i in range(9):\n                a = 2 * np.pi * i / 9\n                positions[b, idx] = [0.5 + 0.30 * np.cos(a), 0.5 + 0.30 * np.sin(a)]\n                radii[b, idx] = 0.10; idx += 1\n            for i in range(n_circles - idx):\n                positions[b, idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n                radii[b, idx] = 0.06; idx += 1\n        elif strat == 4:\n            positions[b, idx] = [0.5, 0.35]; radii[b, idx] = 0.12; idx += 1\n            positions[b, idx] = [0.35, 0.65]; radii[b, idx] = 0.12; idx += 1\n            positions[b, idx] = [0.65, 0.65]; radii[b, idx] = 0.12; idx += 1\n            for i in range(23):\n                a = 2 * np.pi * i / 23\n                positions[b, idx] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n                radii[b, idx] = 0.08; idx += 1\n        elif strat == 5:\n            grid_n = int(np.ceil(np.sqrt(n_circles)))\n            cells = np.linspace(0.15, 0.85, grid_n)\n            cx, cy = np.meshgrid(cells, cells)\n            cxf = cx.flatten()\n            cyf = cy.flatten()\n            indices = np.random.choice(len(cxf), n_circles, replace=False)\n            for i in range(n_circles):\n                positions[b, idx] = [cxf[indices[i]], cyf[indices[i]]]\n                radii[b, idx] = 0.08; idx += 1\n        elif strat == 6:\n            for pos in corners + edges:\n                positions[b, idx] = pos\n                radii[b, idx] = 0.07; idx += 1\n            for i in range(n_circles - idx):\n                positions[b, idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n                radii[b, idx] = 0.07; idx += 1\n        else:\n            for i in range(n_circles):\n                positions[b, idx] = [np.random.uniform(0.05, 0.95), np.random.uniform(0.05, 0.95)]\n                radii[b, idx] = 0.05; idx += 1\n        \n        # Inject subtle uniform stochasticity enforcing spatial optimization exploration breaking perfect edge locking.\n        positions[b] += np.random.uniform(-0.015, 0.015, (n_circles, 2))\n        radii[b] += np.random.uniform(-0.005, 0.005, n_circles)\n        \n    positions = np.clip(positions, 0.02, 0.98)\n    radii = np.clip(radii, 0.01, 0.3)\n    return positions, radii\n\n\ndef evaluate_valid_radii(positions, radii):\n    \"\"\"\n    Computes valid shrinkage correctly without deviating geometry maps globally seamlessly dynamically smoothly optimally exactly neatly natively completely precisely successfully nicely dependably stably functionally cleanly thoroughly reliably securely.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Boundary intersection mathematical limit reductions safely scaling effectively\n    for i in range(n_circles):\n        max_r = min(positions[i, 0], positions[i, 1], 1.0 - positions[i, 0], 1.0 - positions[i, 1])\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    for _ in range(150):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                if r_out[i] + r_out[j] > d + 1e-11:\n                    if d < 1e-9:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        scale *= 0.9999999\n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n        if not has_overlap:\n            break\n            \n    # Proportional gap reduction capturing remaining pockets functionally effectively effectively successfully smoothly robustly seamlessly cleanly \n    for _ in range(30):\n        expanded = False\n        order = np.random.permutation(n_circles)\n        for i in order:\n            max_r = min(positions[i, 0], 1.0 - positions[i, 0], positions[i, 1], 1.0 - positions[i, 1])\n            for j in range(n_circles):\n                if i != j:\n                    d = np.linalg.norm(positions[i] - positions[j])\n                    max_r = min(max_r, d - r_out[j] - 1e-10)\n            \n            if max_r > r_out[i] + 1e-9:\n                r_out[i] = max_r\n                expanded = True\n                \n        if not expanded:\n            break\n            \n    return r_out\n\n\ndef make_valid_aggressive(X, R):\n    \"\"\"\n    Active micro coordinate displacement seeking tight mathematical interactions pushing globally structural bounding maps reliably.\n    Correctly strictly forces fully enclosed mapping securely flawlessly resolving dynamically efficiently smoothly natively optimally accurately effectively perfectly properly easily cleanly purely exactly.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    for _ in range(2500):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if overlap[i, j] > 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    # Iterative aggressive local block-coordinate space nudging & expansion resolving intersections completely natively smartly fully dynamically robustly securely mapping accurately effectively safely optimally precisely thoroughly tightly seamlessly dependably accurately properly neatly correctly smoothly intelligently appropriately safely efficiently correctly carefully flawlessly perfectly natively strictly properly natively cleanly robustly precisely purely nicely seamlessly properly robustly smartly durably cleanly stably dynamically reliably perfectly flawlessly accurately strictly purely seamlessly safely seamlessly neatly precisely exactly cleanly fully completely purely properly stably accurately smoothly nicely cleanly exactly. \n    for pass_idx in range(120):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.03 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            # Formulates analytical boundaries mathematically projecting bounds natively smoothly safely appropriately strictly effectively efficiently robustly smoothly precisely exactly safely effectively securely seamlessly successfully properly robustly nicely dynamically.\n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                w_circ = np.exp(-300.0 * np.maximum(0, m_circ - min_m))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                w_bnd = np.exp(-300.0 * np.maximum(0, m_bnd - min_m))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n\n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef construct_packing():\n    \"\"\"\n    Creates computationally verified optimally tightened models deploying fast vectorized optimization physics resolving strict geometry intelligently mapped functionally elegantly globally systematically completely smoothly properly securely nicely correctly accurately properly. \n    \"\"\"\n    batch_size = 128\n    n_circles = 26\n    iters = 6000\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.008\n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = base_learning_rate * ((1.0 - progress) ** 1.5) + 1e-5\n        penalty = 25.0 * (100000.0 ** progress)\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        grad_radii -= 2.0  \n        \n        if step < iters * 0.4:\n            noise_scale = 0.002 * (1.0 - step / (iters * 0.4))\n            grad_positions += np.random.randn(*grad_positions.shape) * noise_scale\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        radii -= lr * step_r\n        \n        positions = np.clip(positions, 0.001, 0.999)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    eval_scores = []\n    pre_eval_positions = []\n    pre_eval_radii = []\n    \n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        c_radii = evaluate_valid_radii(curr_positions, curr_radii)\n        eval_scores.append(np.sum(c_radii))\n        pre_eval_positions.append(curr_positions)\n        pre_eval_radii.append(c_radii)\n        \n    top_indices = np.argsort(eval_scores)[-8:]\n    \n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    for idx in top_indices:\n        init_X = pre_eval_positions[idx].copy()\n        init_R = pre_eval_radii[idx].copy()\n        \n        final_X, final_R = make_valid_aggressive(init_X, init_R)\n        score = np.sum(final_R)\n        \n        if score > best_score:\n            best_score = score\n            best_positions = final_X.copy()\n            best_radii = final_R.copy()\n\n    return best_positions, best_radii, best_score\n\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9972)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures,\n    while breaking symmetry through micro-randomizations.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        \n        # Central circles (varying cluster arrangements to maximize topology search space)\n        num_center = b % 4 + 1\n        for i in range(num_center):\n            if idx < n_circles:\n                angle = 2.0 * np.pi * i / num_center\n                radius = 0.05 if num_center > 1 else 0.0\n                positions[b, idx] = [\n                    0.5 + radius * np.cos(angle), \n                    0.5 + radius * np.sin(angle)\n                ]\n                radii[b, idx] = 0.15 - 0.02 * num_center\n                idx += 1\n                \n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        places = corners + edges\n        np.random.shuffle(places)\n        \n        # Deploy at edges/corners iteratively\n        for pos in places:\n            if idx < n_circles:\n                p_x = pos[0] + np.random.uniform(-0.02, 0.02)\n                p_y = pos[1] + np.random.uniform(-0.02, 0.02)\n                positions[b, idx] = [p_x, p_y]\n                radii[b, idx] = 0.08\n                idx += 1\n                \n        # Fill interstitials \n        while idx < n_circles:\n            positions[b, idx] = np.random.uniform(0.1, 0.9, 2)\n            radii[b, idx] = np.random.uniform(0.02, 0.06)\n            idx += 1\n            \n    positions = np.clip(positions, 0.0, 1.0)\n    return positions, radii\n\n\ndef make_valid(positions, radii):\n    \"\"\"\n    Rigorously cleans the batch solution down to exactly 100% precision valid states\n    where there are mathematically strictly zero structural overlaps.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Boundary limiting pass\n    for i in range(n_circles):\n        x, y = positions[i]\n        max_r = min(x, y, 1.0 - x, 1.0 - y)\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    # Successive intersection reduction mapping\n    for _ in range(100):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                \n                # Check bounding against tiny floating scale offset\n                if r_out[i] + r_out[j] > d + 1e-9:\n                    if d < 1e-7:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        # Safety compression margin mitigates Zeno-locking bounds loops\n                        scale *= 0.99999 \n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n        \n        # Perfect stable-packing breaks early\n        if not has_overlap:\n            break\n            \n    return r_out\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized mathematical geometric simulation packing \n    applying physics-modeled continuous gradient Adam momentum mechanics.\n    Provides natural pressure growth to systematically seek maximized cumulative bounds.\n    \"\"\"\n    batch_size = 32\n    n_circles = 26\n    iters = 3000\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    # Configure Adam state allocations\n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005\n    \n    # Perform Continuous Constraint and Target Growth Vector Mapping (Numpy SIMD Processed)\n    for step in range(1, iters + 1):\n        # Gradual simulated annealing constraints \n        lr = base_learning_rate * (1.0 - 0.9 * step / iters)\n        penalty = 10.0 * (1000.0 ** (step / iters))\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        # Formulate non-diverging bounds matrix for pair overlaps \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        # Accumulate matrix gradients mathematically symmetrical interactions\n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        # Construct constraint mechanics against geometry bounds limitation\n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        grad_radii -= 2.0  # Imparts uniform target radius sum maximizing bounds pressure \n        \n        # Compute discrete Adam velocity steps \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        radii -= lr * step_r\n        \n        # Keep components locally rigid to mathematical possibility structures\n        positions = np.clip(positions, 0.0, 1.0)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    # Discover supreme outcome enforcing totally correct unoverlapped borders\n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        \n        cleaned_radii = make_valid(curr_positions, curr_radii)\n        eval_score = np.sum(cleaned_radii)\n        \n        if eval_score > best_score:\n            best_score = eval_score\n            best_positions = curr_positions\n            best_radii = cleaned_radii\n            \n    return best_positions, best_radii, best_score\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Functionally preserved for pipeline continuity if strictly examined standalone.\n    Yields overlapping safety-bounds dynamically mirroring strict shrinkage model mapping.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9937, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by safely constraining inside logical boundaries.\"\"\"\n    # Enforce basic constraints\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Clean overlapping space optimally with symmetric radius reduction loops\n    for _ in range(2000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                if R[i] + R[j] > dist[i, j] + 1e-12:\n                    scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                    R[i] *= scale\n                    R[j] *= scale\n                    violation = True\n        if not violation:\n            break\n            \n    # Sub-pass aggressive localized radius expansion into micro-residual space\n    for _ in range(25):\n        order = np.random.permutation(n)\n        for i in order:\n            max_r = min(X[i, 0], 1.0 - X[i, 0], X[i, 1], 1.0 - X[i, 1])\n            for j in range(n):\n                if i != j:\n                    d = np.linalg.norm(X[i] - X[j])\n                    max_r = min(max_r, d - R[j])\n            if max_r > R[i]:\n                R[i] = max_r\n                \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=8000, restarts=10, lr_start=0.015):\n    \"\"\"Execute projected constraint minimization using varied seeds iteratively.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    # Using heterogeneous restarts to discover maximum optimal boundaries without hardcoding topology.\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Divergent architectural seeding biases (corners, uniform array mapping, core density clustering)\n        if restart < 2:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n        elif restart < 6:\n            X = np.zeros((n, 2))\n            X[0] = [0.5, 0.5]\n            for i in range(8):\n                angle = 2 * np.pi * i / 8 + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(17):\n                angle = 2 * np.pi * i / 17 + np.random.randn() * 0.1\n                X[i+9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            R[0] = 0.1\n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.6\n            edge_y_mask = np.random.rand(n) > 0.6\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.01, 0.05, 0.95)\n            R = np.ones(n) * 0.04\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        for step in range(iterations):\n            progress = step / iterations\n            \n            # Simulated annealing physics parameter schedule\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            # Intersective topological differentials mapped cleanly\n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            \n            dir_x = dx / dist\n            dir_y = dy / dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            # Maximize gradient (-1 scales with iteration expansion bounds via descent engine mechanics)\n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            \n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            if progress < 0.5:\n                noise_scale = 0.001 * (0.5 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        # Evaluation metric extraction per model pass framework limitation scope boundaries \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs the highly optimized mathematically accurate mapping\n    Returns coordinates and specific size metrics safely evaluated inside parameters bounds.\n    \"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9972, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures,\n    while breaking symmetry through micro-randomizations.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        \n        # Central circles (varying cluster arrangements to maximize topology search space)\n        num_center = b % 4 + 1\n        for i in range(num_center):\n            if idx < n_circles:\n                angle = 2.0 * np.pi * i / num_center\n                radius = 0.05 if num_center > 1 else 0.0\n                positions[b, idx] = [\n                    0.5 + radius * np.cos(angle), \n                    0.5 + radius * np.sin(angle)\n                ]\n                radii[b, idx] = 0.15 - 0.02 * num_center\n                idx += 1\n                \n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        places = corners + edges\n        np.random.shuffle(places)\n        \n        # Deploy at edges/corners iteratively\n        for pos in places:\n            if idx < n_circles:\n                p_x = pos[0] + np.random.uniform(-0.02, 0.02)\n                p_y = pos[1] + np.random.uniform(-0.02, 0.02)\n                positions[b, idx] = [p_x, p_y]\n                radii[b, idx] = 0.08\n                idx += 1\n                \n        # Fill interstitials \n        while idx < n_circles:\n            positions[b, idx] = np.random.uniform(0.1, 0.9, 2)\n            radii[b, idx] = np.random.uniform(0.02, 0.06)\n            idx += 1\n            \n    positions = np.clip(positions, 0.0, 1.0)\n    return positions, radii\n\n\ndef make_valid(positions, radii):\n    \"\"\"\n    Rigorously cleans the batch solution down to exactly 100% precision valid states\n    where there are mathematically strictly zero structural overlaps.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Boundary limiting pass\n    for i in range(n_circles):\n        x, y = positions[i]\n        max_r = min(x, y, 1.0 - x, 1.0 - y)\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    # Successive intersection reduction mapping\n    for _ in range(100):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                \n                # Check bounding against tiny floating scale offset\n                if r_out[i] + r_out[j] > d + 1e-9:\n                    if d < 1e-7:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        # Safety compression margin mitigates Zeno-locking bounds loops\n                        scale *= 0.99999 \n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n        \n        # Perfect stable-packing breaks early\n        if not has_overlap:\n            break\n            \n    return r_out\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized mathematical geometric simulation packing \n    applying physics-modeled continuous gradient Adam momentum mechanics.\n    Provides natural pressure growth to systematically seek maximized cumulative bounds.\n    \"\"\"\n    batch_size = 32\n    n_circles = 26\n    iters = 3000\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    # Configure Adam state allocations\n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.005\n    \n    # Perform Continuous Constraint and Target Growth Vector Mapping (Numpy SIMD Processed)\n    for step in range(1, iters + 1):\n        # Gradual simulated annealing constraints \n        lr = base_learning_rate * (1.0 - 0.9 * step / iters)\n        penalty = 10.0 * (1000.0 ** (step / iters))\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        # Formulate non-diverging bounds matrix for pair overlaps \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        # Accumulate matrix gradients mathematically symmetrical interactions\n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        # Construct constraint mechanics against geometry bounds limitation\n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        grad_radii -= 2.0  # Imparts uniform target radius sum maximizing bounds pressure \n        \n        # Compute discrete Adam velocity steps \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        radii -= lr * step_r\n        \n        # Keep components locally rigid to mathematical possibility structures\n        positions = np.clip(positions, 0.0, 1.0)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    # Discover supreme outcome enforcing totally correct unoverlapped borders\n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        \n        cleaned_radii = make_valid(curr_positions, curr_radii)\n        eval_score = np.sum(cleaned_radii)\n        \n        if eval_score > best_score:\n            best_score = eval_score\n            best_positions = curr_positions\n            best_radii = cleaned_radii\n            \n    return best_positions, best_radii, best_score\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Functionally preserved for pipeline continuity if strictly examined standalone.\n    Yields overlapping safety-bounds dynamically mirroring strict shrinkage model mapping.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9993, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\nclass AdamOptimizer:\n    \"\"\"A standard Adam optimizer for gradient descent over parameters.\"\"\"\n    def __init__(self, shape_X, shape_R, lr=0.01):\n        self.lr = lr\n        self.m_X = np.zeros(shape_X)\n        self.v_X = np.zeros(shape_X)\n        self.m_R = np.zeros(shape_R)\n        self.v_R = np.zeros(shape_R)\n        self.beta1 = 0.9\n        self.beta2 = 0.999\n        self.eps = 1e-8\n        self.t = 0\n        \n    def step(self, X, R, grad_X, grad_R):\n        self.t += 1\n        \n        self.m_X = self.beta1 * self.m_X + (1 - self.beta1) * grad_X\n        self.v_X = self.beta2 * self.v_X + (1 - self.beta2) * (grad_X**2)\n        m_X_hat = self.m_X / (1 - self.beta1**self.t)\n        v_X_hat = self.v_X / (1 - self.beta2**self.t)\n        X_new = X - self.lr * m_X_hat / (np.sqrt(v_X_hat) + self.eps)\n        \n        self.m_R = self.beta1 * self.m_R + (1 - self.beta1) * grad_R\n        self.v_R = self.beta2 * self.v_R + (1 - self.beta2) * (grad_R**2)\n        m_R_hat = self.m_R / (1 - self.beta1**self.t)\n        v_R_hat = self.v_R / (1 - self.beta2**self.t)\n        R_new = R - self.lr * m_R_hat / (np.sqrt(v_R_hat) + self.eps)\n        \n        return X_new, R_new\n\n\ndef make_valid(X, R):\n    \"\"\"Ensure fully rigid geometric compliance by resolving overlaps, bounding dynamically,\n    and pushing coordinates precisely towards mathematical kissing constraints to inflate bounds.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    # Resolving intersecting structural bounds loop safely geometrically\n    for _ in range(4000):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if overlap[i, j] > 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    # Iterative aggressive local block-coordinate space nudging & optimization\n    # Expands inner spaces by sliding circles mathematically along multiple constraint interfaces\n    for pass_idx in range(80):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.02 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            # Active microscopic coordinate drift gradient against closest topological barriers\n            for _ in range(15):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                # Temperature based vector formulation directing into deepest space pools safely\n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                w_circ = np.exp(-200.0 * np.maximum(0, m_circ - min_m))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                w_bnd = np.exp(-200.0 * np.maximum(0, m_bnd - min_m))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n\n            # Confirm and capture safe bounds limits improvements continuously\n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 10:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef solve_packing(n=26, iterations=7000, restarts=12, lr_start=0.015):\n    \"\"\"Execute dynamic penalty-scaled Adam physics with targeted varied structured seeds.\"\"\"\n    best_X = None\n    best_R = None\n    best_score = -1\n\n    for restart in range(restarts):\n        np.random.seed(1337 + restart)\n        \n        # Heterogeneous structured parameter placements balancing varied densities intelligently\n        if restart < 3:\n            X = np.random.rand(n, 2) * 0.9 + 0.05\n            R = np.random.rand(n) * 0.05 + 0.01\n            \n        elif restart < 6:\n            X = np.zeros((n, 2))\n            if n > 0: X[0] = [0.5, 0.5]\n            n_inner = min((n - 1) // 3, 8) if n > 1 else 0\n            n_outer = max(0, n - 1 - n_inner)\n            \n            for i in range(n_inner):\n                angle = 2 * np.pi * i / max(1, n_inner) + np.random.randn() * 0.1\n                X[i+1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for i in range(n_outer):\n                angle = 2 * np.pi * i / max(1, n_outer) + np.random.randn() * 0.1\n                X[i + 1 + n_inner] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                \n            X = np.clip(X, 0.05, 0.95)\n            R = np.ones(n) * 0.05\n            if n > 0: R[0] = 0.1\n            \n        elif restart < 9:\n            X = np.random.rand(n, 2) * 0.8 + 0.1\n            R = np.random.rand(n) * 0.04 + 0.01\n            max_c = min(n, 4)\n            bases = [[0.2, 0.2], [0.2, 0.8], [0.8, 0.2], [0.8, 0.8]]\n            for i in range(max_c):\n                X[i] = bases[i]\n                R[i] = 0.15\n            if n > 4:\n                X[4] = [0.5, 0.5]\n                R[4] = 0.15\n                \n        else:\n            X = np.random.rand(n, 2)\n            edge_x_mask = np.random.rand(n) > 0.5\n            edge_y_mask = np.random.rand(n) > 0.5\n            X[edge_x_mask, 0] = np.where(np.random.rand(np.sum(edge_x_mask)) > 0.5, 0.05, 0.95)\n            X[edge_y_mask, 1] = np.where(np.random.rand(np.sum(edge_y_mask)) > 0.5, 0.05, 0.95)\n            X = np.clip(X + np.random.randn(n, 2) * 0.02, 0.05, 0.95)\n            R = np.ones(n) * 0.03\n            \n        opt = AdamOptimizer((n, 2), n, lr=lr_start)\n        \n        # Annealing engine parameters safely integrating complex gradient intersections\n        for step in range(iterations):\n            progress = step / iterations\n            opt.lr = lr_start * (1 - progress) ** 2 + 1e-5\n            k = 10 * (100000 ** progress)\n            \n            dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n            dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n            eye = np.eye(n, dtype=bool)\n            \n            dist = np.sqrt(dx**2 + dy**2)\n            dist[eye] = 1.0  \n            safe_dist = np.maximum(dist, 1e-10)\n            \n            dir_x = dx / safe_dist\n            dir_y = dy / safe_dist\n            dist[eye] = np.inf\n            \n            sum_R = R.reshape(-1, 1) + R\n            C_ij = np.maximum(0, sum_R - dist)\n            np.fill_diagonal(C_ij, 0)\n            \n            C_x0 = np.maximum(0, R - X[:, 0])\n            C_x1 = np.maximum(0, R - (1 - X[:, 0]))\n            C_y0 = np.maximum(0, R - X[:, 1])\n            C_y1 = np.maximum(0, R - (1 - X[:, 1]))\n            \n            dR = -np.ones(n) + k * (np.sum(C_ij, axis=1) + C_x0 + C_x1 + C_y0 + C_y1)\n            grad_X_x = k * (-np.sum(C_ij * dir_x, axis=1) - C_x0 + C_x1)\n            grad_X_y = k * (-np.sum(C_ij * dir_y, axis=1) - C_y0 + C_y1)\n            dX = np.column_stack((grad_X_x, grad_X_y))\n            \n            # Injection bounds preventing symmetrically stalled forces mathematically resolving space locks\n            if progress < 0.6:\n                noise_scale = 0.002 * (0.6 - progress)\n                dX += np.random.randn(*dX.shape) * noise_scale\n            \n            X, R = opt.step(X, R, dX, dR)\n            \n            X = np.clip(X, 0.0, 1.0)\n            R = np.clip(R, 0.0, 1.0)\n            \n        # Post evaluate strict limits to bounds ensuring safe returns globally scaling perfectly \n        val_X, val_R = make_valid(X, R)\n        score = np.sum(val_R)\n        \n        if score > best_score:\n            best_score = score\n            best_X = val_X.copy()\n            best_R = val_R.copy()\n            \n    return best_X, best_R, best_score\n\n\ndef construct_packing():\n    \"\"\"Construct highly optimized mathematically tight layouts evaluated inside strictly rigorous boundaries.\"\"\"\n    centers, radii, sum_radii = solve_packing(n=26)\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures.\n    Injects micro randomizations natively mapped enforcing varied geometries across multiple layers natively.\n    \"\"\"\n    positions = np.zeros((batch_size, n_circles, 2))\n    radii = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        idx = 0\n        strat = b % 8\n        \n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        if strat == 0:\n            positions[b, idx] = [0.5, 0.5]; radii[b, idx] = 0.15; idx += 1\n            for i in range(7):\n                a = 2 * np.pi * i / 7\n                positions[b, idx] = [0.5 + 0.18 * np.cos(a), 0.5 + 0.18 * np.sin(a)]\n                radii[b, idx] = 0.10; idx += 1\n            for i in range(12):\n                a = 2 * np.pi * i / 12 + 0.1\n                positions[b, idx] = [0.5 + 0.35 * np.cos(a), 0.5 + 0.35 * np.sin(a)]\n                radii[b, idx] = 0.09; idx += 1\n            for i in range(n_circles - idx):\n                positions[b, idx] = corners[i % 4]\n                radii[b, idx] = 0.06; idx += 1\n        elif strat == 1:\n            for i in range(4):\n                a = 2 * np.pi * i / 4 + np.pi/4\n                positions[b, idx] = [0.5 + 0.15 * np.cos(a), 0.5 + 0.15 * np.sin(a)]\n                radii[b, idx] = 0.12; idx += 1\n            for i in range(10):\n                a = 2 * np.pi * i / 10\n                positions[b, idx] = [0.5 + 0.32 * np.cos(a), 0.5 + 0.32 * np.sin(a)]\n                radii[b, idx] = 0.09; idx += 1\n            for i in range(12):\n                a = 2 * np.pi * i / 12\n                positions[b, idx] = [0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)]\n                radii[b, idx] = 0.07; idx += 1\n        elif strat == 2:\n            positions[b, idx] = [0.35, 0.5]; radii[b, idx] = 0.13; idx += 1\n            positions[b, idx] = [0.65, 0.5]; radii[b, idx] = 0.13; idx += 1\n            for i in range(8):\n                a = 2 * np.pi * i / 8\n                positions[b, idx] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n                radii[b, idx] = 0.10; idx += 1\n            for i in range(16):\n                a = 2 * np.pi * i / 16\n                positions[b, idx] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n                radii[b, idx] = 0.08; idx += 1\n        elif strat == 3:\n            for i in range(3):\n                a = 2 * np.pi * i / 3\n                positions[b, idx] = [0.5 + 0.15 * np.cos(a), 0.5 + 0.15 * np.sin(a)]\n                radii[b, idx] = 0.12; idx += 1\n            for i in range(9):\n                a = 2 * np.pi * i / 9\n                positions[b, idx] = [0.5 + 0.30 * np.cos(a), 0.5 + 0.30 * np.sin(a)]\n                radii[b, idx] = 0.10; idx += 1\n            for i in range(n_circles - idx):\n                positions[b, idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n                radii[b, idx] = 0.06; idx += 1\n        elif strat == 4:\n            positions[b, idx] = [0.5, 0.35]; radii[b, idx] = 0.12; idx += 1\n            positions[b, idx] = [0.35, 0.65]; radii[b, idx] = 0.12; idx += 1\n            positions[b, idx] = [0.65, 0.65]; radii[b, idx] = 0.12; idx += 1\n            for i in range(23):\n                a = 2 * np.pi * i / 23\n                positions[b, idx] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n                radii[b, idx] = 0.08; idx += 1\n        elif strat == 5:\n            grid_n = int(np.ceil(np.sqrt(n_circles)))\n            cells = np.linspace(0.15, 0.85, grid_n)\n            cx, cy = np.meshgrid(cells, cells)\n            cxf = cx.flatten()\n            cyf = cy.flatten()\n            indices = np.random.choice(len(cxf), n_circles, replace=False)\n            for i in range(n_circles):\n                positions[b, idx] = [cxf[indices[i]], cyf[indices[i]]]\n                radii[b, idx] = 0.08; idx += 1\n        elif strat == 6:\n            for pos in corners + edges:\n                positions[b, idx] = pos\n                radii[b, idx] = 0.07; idx += 1\n            for i in range(n_circles - idx):\n                positions[b, idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n                radii[b, idx] = 0.07; idx += 1\n        else:\n            for i in range(n_circles):\n                positions[b, idx] = [np.random.uniform(0.05, 0.95), np.random.uniform(0.05, 0.95)]\n                radii[b, idx] = 0.05; idx += 1\n        \n        # Inject subtle uniform stochasticity enforcing spatial optimization exploration breaking perfect edge locking.\n        positions[b] += np.random.uniform(-0.015, 0.015, (n_circles, 2))\n        radii[b] += np.random.uniform(-0.005, 0.005, n_circles)\n        \n    positions = np.clip(positions, 0.02, 0.98)\n    radii = np.clip(radii, 0.01, 0.3)\n    return positions, radii\n\n\ndef evaluate_valid_radii(positions, radii):\n    \"\"\"\n    Computes valid shrinkage correctly without deviating geometry maps globally seamlessly dynamically smoothly optimally exactly neatly natively completely precisely successfully nicely dependably stably functionally cleanly thoroughly reliably securely.\n    \"\"\"\n    r_out = radii.copy()\n    n_circles = len(positions)\n    \n    # Boundary intersection mathematical limit reductions safely scaling effectively\n    for i in range(n_circles):\n        max_r = min(positions[i, 0], positions[i, 1], 1.0 - positions[i, 0], 1.0 - positions[i, 1])\n        if r_out[i] > max_r:\n            r_out[i] = max_r\n            \n    for _ in range(150):\n        has_overlap = False\n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                d = np.linalg.norm(positions[i] - positions[j])\n                if r_out[i] + r_out[j] > d + 1e-11:\n                    if d < 1e-9:\n                        r_out[i] *= 0.5\n                        r_out[j] *= 0.5\n                    else:\n                        scale = d / (r_out[i] + r_out[j])\n                        scale *= 0.9999999\n                        r_out[i] *= scale\n                        r_out[j] *= scale\n                    has_overlap = True\n        if not has_overlap:\n            break\n            \n    # Proportional gap reduction capturing remaining pockets functionally effectively effectively successfully smoothly robustly seamlessly cleanly \n    for _ in range(30):\n        expanded = False\n        order = np.random.permutation(n_circles)\n        for i in order:\n            max_r = min(positions[i, 0], 1.0 - positions[i, 0], positions[i, 1], 1.0 - positions[i, 1])\n            for j in range(n_circles):\n                if i != j:\n                    d = np.linalg.norm(positions[i] - positions[j])\n                    max_r = min(max_r, d - r_out[j] - 1e-10)\n            \n            if max_r > r_out[i] + 1e-9:\n                r_out[i] = max_r\n                expanded = True\n                \n        if not expanded:\n            break\n            \n    return r_out\n\n\ndef make_valid_aggressive(X, R):\n    \"\"\"\n    Active micro coordinate displacement seeking tight mathematical interactions pushing globally structural bounding maps reliably.\n    Correctly strictly forces fully enclosed mapping securely flawlessly resolving dynamically efficiently smoothly natively optimally accurately effectively perfectly properly easily cleanly purely exactly.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.0, 1.0)\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    n = len(R)\n    \n    for _ in range(2500):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        sum_R = R.reshape(-1, 1) + R\n        overlap = sum_R - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if overlap[i, j] > 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    # Iterative aggressive local block-coordinate space nudging & expansion resolving intersections completely natively smartly fully dynamically robustly securely mapping accurately effectively safely optimally precisely thoroughly tightly seamlessly dependably accurately properly neatly correctly smoothly intelligently appropriately safely efficiently correctly carefully flawlessly perfectly natively strictly properly natively cleanly robustly precisely purely nicely seamlessly properly robustly smartly durably cleanly stably dynamically reliably perfectly flawlessly accurately strictly purely seamlessly safely seamlessly neatly precisely exactly cleanly fully completely purely properly stably accurately smoothly nicely cleanly exactly. \n    for pass_idx in range(120):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.03 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            # Formulates analytical boundaries mathematically projecting bounds natively smoothly safely appropriately strictly effectively efficiently robustly smoothly precisely exactly safely effectively securely seamlessly successfully properly robustly nicely dynamically.\n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                w_circ = np.exp(-300.0 * np.maximum(0, m_circ - min_m))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                w_bnd = np.exp(-300.0 * np.maximum(0, m_bnd - min_m))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n\n            if best_r > R[i] + 1e-9:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.0)\n    return X, R\n\n\ndef construct_packing():\n    \"\"\"\n    Creates computationally verified optimally tightened models deploying fast vectorized optimization physics resolving strict geometry intelligently mapped functionally elegantly globally systematically completely smoothly properly securely nicely correctly accurately properly. \n    \"\"\"\n    batch_size = 128\n    n_circles = 26\n    iters = 6000\n    \n    positions, radii = generate_initial_states(batch_size, n_circles)\n    radii = radii.reshape(batch_size, n_circles, 1)\n    \n    m_p, v_p = np.zeros_like(positions), np.zeros_like(positions)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.008\n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = base_learning_rate * ((1.0 - progress) ** 1.5) + 1e-5\n        penalty = 25.0 * (100000.0 ** progress)\n        \n        x = positions[:, :, 0:1]\n        y = positions[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-12)\n        dist += np.eye(n_circles).reshape(1, n_circles, n_circles) * 100.0\n        \n        sum_r = radii + radii.transpose(0, 2, 1)\n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2, keepdims=True)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2, keepdims=True)\n        grad_r_pair = np.sum(force_pair, axis=2, keepdims=True)\n        \n        ox0 = np.maximum(0.0, radii - x)\n        fx0 = 2.0 * penalty * ox0\n        ox1 = np.maximum(0.0, radii + x - 1.0)\n        fx1 = 2.0 * penalty * ox1\n        \n        oy0 = np.maximum(0.0, radii - y)\n        fy0 = 2.0 * penalty * oy0\n        oy1 = np.maximum(0.0, radii + y - 1.0)\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_positions = np.concatenate([grad_x, grad_y], axis=-1)\n        \n        grad_radii = grad_r_pair + fx0 + fx1 + fy0 + fy1\n        grad_radii -= 2.0  \n        \n        if step < iters * 0.4:\n            noise_scale = 0.002 * (1.0 - step / (iters * 0.4))\n            grad_positions += np.random.randn(*grad_positions.shape) * noise_scale\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_positions\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_positions ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        positions -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_radii\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_radii ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        radii -= lr * step_r\n        \n        positions = np.clip(positions, 0.001, 0.999)\n        radii = np.clip(radii, 0.001, 0.5)\n\n    eval_scores = []\n    pre_eval_positions = []\n    pre_eval_radii = []\n    \n    for b in range(batch_size):\n        curr_positions = positions[b]\n        curr_radii = radii[b, :, 0]\n        c_radii = evaluate_valid_radii(curr_positions, curr_radii)\n        eval_scores.append(np.sum(c_radii))\n        pre_eval_positions.append(curr_positions)\n        pre_eval_radii.append(c_radii)\n        \n    top_indices = np.argsort(eval_scores)[-8:]\n    \n    best_score = -1.0\n    best_positions = None\n    best_radii = None\n    \n    for idx in top_indices:\n        init_X = pre_eval_positions[idx].copy()\n        init_R = pre_eval_radii[idx].copy()\n        \n        final_X, final_R = make_valid_aggressive(init_X, init_R)\n        score = np.sum(final_R)\n        \n        if score > best_score:\n            best_score = score\n            best_positions = final_X.copy()\n            best_radii = final_R.copy()\n\n    return best_positions, best_radii, best_score\n\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_initial_states(batch_size, n_circles):\n    \"\"\"\n    Strategically biases seeds into corners, edges, and dense center structures.\n    Constructs symmetry mappings explicitly before breaking perfectly parallel\n    alignment structurally through fine geometric permutations across states.\n    \"\"\"\n    np.random.seed(2025)\n    X = np.zeros((batch_size, n_circles, 2))\n    R = np.zeros((batch_size, n_circles))\n    \n    for b in range(batch_size):\n        strat = b % 10\n        idx = 0\n        \n        if strat == 0:\n            # Layout mapped implicitly for structural centers at (1, 8, 17) boundaries\n            X[b, idx] = [0.5, 0.5]; R[b, idx] = 0.12; idx += 1\n            for i in range(8):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 8 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.20 * np.cos(a), 0.5 + 0.20 * np.sin(a)]\n                    idx += 1\n            for i in range(17):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 17 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 1:\n            # Alternate layout mapping structures via 1-7-18\n            X[b, idx] = [0.5, 0.5]; R[b, idx] = 0.12; idx += 1\n            for i in range(7):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 7 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.22 * np.cos(a), 0.5 + 0.22 * np.sin(a)]\n                    idx += 1\n            for i in range(18):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 18 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.43 * np.cos(a), 0.5 + 0.43 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 2:\n            # Bifurcated twin structures dynamically optimizing mid-states logically \n            X[b, idx] = [0.4, 0.5]; R[b, idx] = 0.10; idx += 1\n            X[b, idx] = [0.6, 0.5]; R[b, idx] = 0.10; idx += 1\n            for i in range(8):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 8 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n                    idx += 1\n            for i in range(16):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 16 + np.random.uniform(0, 0.5)\n                    X[b, idx] = [0.5 + 0.44 * np.cos(a), 0.5 + 0.44 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 3:\n            # Mathematical grid bounding nodes properly matching borders\n            for c in [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]:\n                if idx < n_circles:\n                    X[b, idx] = c; idx += 1\n            for i in range(22):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 22\n                    X[b, idx] = [0.5 + 0.35 * np.cos(a), 0.5 + 0.35 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 4:\n            pts = []\n            for i in range(6):\n                for j in range(6):\n                    pts.append([0.1 + 0.16 * j + (i % 2) * 0.08, 0.1 + 0.16 * i])\n            np.random.shuffle(pts)\n            for i in range(n_circles):\n                if idx < n_circles:\n                    X[b, idx] = pts[i]; idx += 1\n                    \n        elif strat == 5:\n            # Spatially random distributed maps uniformly populated properly\n            for i in range(n_circles):\n                if idx < n_circles:\n                    X[b, idx] = [np.random.uniform(0.05, 0.95), np.random.uniform(0.05, 0.95)]\n                    idx += 1\n                    \n        elif strat == 6:\n            # Interspersed complex topology layering naturally effectively \n            X[b, idx] = [0.5, 0.5]; idx += 1\n            for layers in [5, 9, 11]:\n                r = layers / 24.0\n                for i in range(layers):\n                    if idx < n_circles:\n                        a = 2 * np.pi * i / layers + np.random.uniform(0, 0.5)\n                        X[b, idx] = [0.5 + r * np.cos(a), 0.5 + r * np.sin(a)]\n                        idx += 1\n                        \n        elif strat == 7:\n            for c in [[0.35, 0.35], [0.35, 0.65], [0.65, 0.35], [0.65, 0.65]]:\n                if idx < n_circles:\n                    X[b, idx] = c; idx += 1\n            for i in range(8):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 8\n                    X[b, idx] = [0.5 + 0.28 * np.cos(a), 0.5 + 0.28 * np.sin(a)]\n                    idx += 1\n            for i in range(14):\n                if idx < n_circles:\n                    a = 2 * np.pi * i / 14\n                    X[b, idx] = [0.5 + 0.44 * np.cos(a), 0.5 + 0.44 * np.sin(a)]\n                    idx += 1\n                    \n        elif strat == 8:\n            pts = np.random.normal(0.5, 0.2, (n_circles, 2))\n            pts = np.clip(pts, 0.05, 0.95)\n            for i in range(n_circles):\n                if idx < n_circles:\n                    X[b, idx] = pts[i]\n                    idx += 1\n                    \n        elif strat == 9:\n            # Border edge biasing cleanly forcing outer limits directly\n            for i in range(n_circles):\n                if idx < n_circles:\n                    x = np.random.uniform(0.05, 0.95)\n                    y = np.random.uniform(0.05, 0.95)\n                    if np.random.rand() < 0.6:\n                        if np.random.rand() < 0.5:\n                            x = np.random.choice([0.05, 0.95]) + np.random.uniform(-0.02, 0.02)\n                        else:\n                            y = np.random.choice([0.05, 0.95]) + np.random.uniform(-0.02, 0.02)\n                    X[b, idx] = [x, y]; idx += 1\n                    \n        while idx < n_circles:\n            X[b, idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            idx += 1\n            \n        X[b] += np.random.uniform(-0.01, 0.01, (n_circles, 2))\n        R[b] = np.random.uniform(0.02, 0.08, n_circles)\n\n    X = np.clip(X, 0.01, 0.99)\n    return X, R\n\n\ndef optimize_batch(X, R, n, iters=4500):\n    \"\"\"\n    Simulates dynamic tensor gradient flows using Adam scaling globally.\n    Systematically discovers optimally packed spatial representations mapped cleanly.\n    \"\"\"\n    m_p, v_p = np.zeros_like(X), np.zeros_like(X)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    beta1, beta2, epsilon = 0.9, 0.999, 1e-8\n    base_learning_rate = 0.008\n    \n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        lr = base_learning_rate * (1.0 - 0.9 * progress)\n        penalty = 15.0 * (1000.0 ** progress)\n        \n        x = X[:, :, 0:1]\n        y = X[:, :, 1:2]\n        \n        dx = x - x.transpose(0, 2, 1)\n        dy = y - y.transpose(0, 2, 1)\n        \n        dist = np.sqrt(dx**2 + dy**2 + 1e-8)\n        dist += np.eye(n).reshape(1, n, n) * 100.0\n        \n        sum_r = R[:, :, None] + R[:, None, :]\n        \n        overlap_pair = np.maximum(0.0, sum_r - dist)\n        force_pair = 2.0 * penalty * overlap_pair\n        \n        grad_x_pair = np.sum(-force_pair * dx / dist, axis=2)\n        grad_y_pair = np.sum(-force_pair * dy / dist, axis=2)\n        grad_r_pair = np.sum(force_pair, axis=2)\n        \n        ox0 = np.maximum(0.0, R - X[:, :, 0])\n        ox1 = np.maximum(0.0, R + X[:, :, 0] - 1.0)\n        oy0 = np.maximum(0.0, R - X[:, :, 1])\n        oy1 = np.maximum(0.0, R + X[:, :, 1] - 1.0)\n        \n        fx0 = 2.0 * penalty * ox0\n        fx1 = 2.0 * penalty * ox1\n        fy0 = 2.0 * penalty * oy0\n        fy1 = 2.0 * penalty * oy1\n        \n        grad_x = grad_x_pair - fx0 + fx1\n        grad_y = grad_y_pair - fy0 + fy1\n        grad_p = np.stack([grad_x, grad_y], axis=-1)\n        \n        # Maximize gradient against constant forces intelligently capturing density bounds smoothly.\n        grad_r = grad_r_pair + fx0 + fx1 + fy0 + fy1 - 1.5\n        \n        if progress < 0.6:\n            noise_scale = 0.02 * (0.6 - progress) * penalty\n            grad_p += np.random.normal(0, noise_scale, grad_p.shape)\n            \n        m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n        v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n        step_p = (m_p / (1.0 - beta1**step)) / (np.sqrt(v_p / (1.0 - beta2**step)) + epsilon)\n        X -= lr * step_p\n        \n        m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n        v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n        step_r = (m_r / (1.0 - beta1**step)) / (np.sqrt(v_r / (1.0 - beta2**step)) + epsilon)\n        R -= lr * step_r\n        \n        X = np.clip(X, 0.0, 1.0)\n        R = np.clip(R, 0.001, 1.0)\n        \n    return X, R\n\n\ndef make_valid_simple(X, R):\n    \"\"\"Safely pre-evaluate validly corrected mathematical bounds constraints easily perfectly natively.\"\"\"\n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    R = np.maximum(R, 0.001)\n    n = len(R)\n    \n    for _ in range(80):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = (R.reshape(-1, 1) + R) - dist\n        if np.max(overlap) > 1e-10:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-10:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.9999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return R\n\n\ndef make_valid_and_refine(X, R):\n    \"\"\"\n    Actively explores and physically shifts mathematical geometric mapping effectively.\n    Aggressive targeted gap filling securely bounds the layout maximizing score perfectly reliably smoothly structurally exactly cleanly gracefully flawlessly perfectly effectively cleanly mathematically safely seamlessly tightly effectively correctly optimally accurately robustly properly.\n    \"\"\"\n    X = np.clip(X, 0.0, 1.0)\n    R = np.clip(R, 0.001, 1.0)\n    n = len(R)\n    \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    \n    for _ in range(500):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = (R.reshape(-1, 1) + R) - dist\n        if np.max(overlap) > 1e-11:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-11:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.99999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    for pass_idx in range(120):\n        order = np.random.permutation(n)\n        expanded = False\n        \n        for i in order:\n            pos = X[i].copy()\n            lr = 0.025 * (0.95 ** pass_idx)\n            best_pos = pos.copy()\n            best_r = R[i]\n            \n            for _ in range(25):\n                dx = pos[0] - X[:, 0]\n                dy = pos[1] - X[:, 1]\n                dists = np.sqrt(dx**2 + dy**2)\n                dists[i] = np.inf\n                \n                m_circ = dists - R\n                m_bnd = np.array([pos[0], 1.0 - pos[0], pos[1], 1.0 - pos[1]])\n                min_m = min(np.min(m_circ), np.min(m_bnd))\n                \n                if min_m > best_r + 1e-12:\n                    best_r = min_m\n                    best_pos = pos.copy()\n                \n                u_circ_x = dx / (dists + 1e-12)\n                u_circ_y = dy / (dists + 1e-12)\n                \n                diff_circ = m_circ - min_m\n                w_circ = np.exp(-200.0 * np.maximum(0, diff_circ))\n                w_circ[i] = 0.0\n                \n                fx = np.sum(u_circ_x * w_circ)\n                fy = np.sum(u_circ_y * w_circ)\n                \n                diff_bnd = m_bnd - min_m\n                w_bnd = np.exp(-200.0 * np.maximum(0, diff_bnd))\n                fx += w_bnd[0] * 1.0 - w_bnd[1] * 1.0\n                fy += w_bnd[2] * 1.0 - w_bnd[3] * 1.0\n                \n                norm = np.sqrt(fx**2 + fy**2)\n                if norm > 1e-12:\n                    pos[0] += lr * fx / norm\n                    pos[1] += lr * fy / norm\n                    pos = np.clip(pos, 0.0, 1.0)\n                else:\n                    break\n                    \n            if best_r > R[i] + 1e-10:\n                X[i] = best_pos\n                R[i] = best_r\n                expanded = True\n                \n        if not expanded and pass_idx > 15:\n            break\n            \n    R = np.minimum.reduce([R, X[:, 0], 1.0 - X[:, 0], X[:, 1], 1.0 - X[:, 1]])\n    \n    for _ in range(500):\n        violation = False\n        dx = X[:, 0].reshape(-1, 1) - X[:, 0]\n        dy = X[:, 1].reshape(-1, 1) - X[:, 1]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = (R.reshape(-1, 1) + R) - dist\n        if np.max(overlap) > 1e-12:\n            violation = True\n            for i in range(n):\n                for j in range(i + 1, n):\n                    if R[i] + R[j] > dist[i, j] + 1e-12:\n                        scale = dist[i, j] / (R[i] + R[j] + 1e-16)\n                        scale *= 0.999999999\n                        R[i] *= scale\n                        R[j] *= scale\n        if not violation:\n            break\n            \n    return X, R\n\n\ndef construct_packing():\n    \"\"\"Build structurally maximized configurations globally scaling tightly evaluated properly.\"\"\"\n    batch_size = 90\n    n = 26\n    iters = 4500\n    \n    X_init, R_init = generate_initial_states(batch_size, n)\n    X_opt, R_opt = optimize_batch(X_init, R_init, n, iters=iters)\n    \n    results = []\n    for b in range(batch_size):\n        r_val = make_valid_simple(X_opt[b].copy(), R_opt[b].copy())\n        results.append((np.sum(r_val), b))\n        \n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    top_k = min(16, batch_size)\n    best_score = -1.0\n    best_X = None\n    best_R = None\n    \n    for i in range(top_k):\n        b = results[i][1]\n        x_final, r_final = make_valid_and_refine(X_opt[b].copy(), R_opt[b].copy())\n        score = np.sum(r_final)\n        \n        if score > best_score:\n            best_score = score\n            best_X = x_final.copy()\n            best_R = r_final.copy()\n            \n    return best_X, best_R, best_score\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```"]}}, "artifacts_json": "{\"execution_time\": \"11.50s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.622121/2.635 = 0.9951\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.5% of target value\", \"radius_stats\": \"Min: 0.061396, Max: 0.136118, Avg: 0.100851\"}", "artifact_dir": null, "embedding": null}