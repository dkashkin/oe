{"id": "8dc43dc6-758e-414b-b51b-fd64bf241fad", "code": "```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64  # Optimal batch size for topological diversity\n    iters = 12500\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # 26 distinct dense grid topological distributions (sums = 26)\n    configs = [\n        [6, 5, 5, 5, 5], [5, 6, 5, 5, 5], [5, 5, 6, 5, 5],\n        [5, 5, 5, 6, 5], [5, 5, 5, 5, 6], [6, 5, 4, 5, 6],\n        [5, 6, 4, 6, 5], [6, 4, 6, 4, 6], [5, 4, 6, 5, 6],\n        [4, 5, 4, 5, 4, 4], [5, 4, 5, 4, 4, 4], [4, 5, 4, 4, 5, 4],\n        [5, 4, 4, 5, 4, 4], [5, 5, 4, 4, 4, 4], [4, 4, 5, 5, 4, 4],\n        [3, 5, 5, 5, 5, 3], [4, 4, 4, 4, 5, 5], [4, 4, 4, 5, 5, 4],\n        [4, 3, 4, 4, 4, 3, 4], [3, 4, 4, 4, 4, 4, 3], [4, 4, 3, 4, 3, 4, 4],\n        [4, 4, 4, 2, 4, 4, 4], [7, 6, 6, 7], [6, 7, 7, 6],\n        [6, 7, 6, 7], [7, 6, 7, 6]\n    ]\n\n    # Initialize seeds with robust geometrical and dense grid priors\n    for b in range(B):\n        if b < len(configs) * 2:\n            conf = configs[b % len(configs)]\n            transpose = (b >= len(configs))\n            idx = 0\n            num_rows = len(conf)\n            for row, count in enumerate(conf):\n                for col in range(count):\n                    # Spacing ensures initial bounding box stays comfortably inside the", "changes_description": null, "language": "python", "parent_id": "0fb0bd7f-1e30-46ca-9b03-dae713b116a9", "generation": 5, "timestamp": 1771878089.2227576, "iteration_found": 96, "metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6125275700850605, "target_ratio": 0.9914715635996435, "combined_score": 0.9914715635996435, "radius_variance": 0.005436854253505329, "spatial_spread": 0.1951052642322164, "eval_time": 37.07047200202942}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9915\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9915\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n37.07s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.612528/2.635 = 0.9915\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.1% of target value\n```\n\n### radius_stats\n```\nMin: 0.064020, Max: 0.142290, Avg: 0.100482\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6125, target_ratio: 0.9915, combined_score: 0.9915, radius_variance: 0.0054, spatial_spread: 0.1951, eval_time: 37.0705\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6144, target_ratio: 0.9922, combined_score: 0.9922, radius_variance: 0.0045, spatial_spread: 0.1921, eval_time: 38.8016\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6170, target_ratio: 0.9932, combined_score: 0.9932, radius_variance: 0.0056, spatial_spread: 0.1927, eval_time: 36.1163\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9932)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 56\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]\n            r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]\n            r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]\n            r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]\n            r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6170), Performs well on target_ratio (0.9932), Performs well on combined_score (0.9932), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1927), Performs well on eval_time (36.1163)\n\n### Program 2 (Score: 0.9922)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 60\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 6\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        else:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    for b in range(B):\n        cb = c[b]\n        dist_matrix = np.linalg.norm(cb[:, None, :] - cb[None, :, :], axis=-1)\n        \n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_matrix[i, j])\n                \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        c_obj = -np.ones(n)\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6144), Performs well on target_ratio (0.9922), Performs well on combined_score (0.9922), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1921), Performs well on eval_time (38.8016)\n\n### Program 3 (Score: 0.9915)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64  # Optimal batch size for parallel topology exploration within timeout limits\n    iters = 11000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # Initialize seeds with structurally diverse geometrical priors\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor large circles in the corners, leaving a hollow middle for scattering\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution + central disruption\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: \n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # Alternative tight concentric shells\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            # 5 large circles: 4 corners + 1 center\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.15\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.15\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            # Anchor circles along the edges\n            c[b, 0] = [0.15, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.5]; r[b, 1] = 0.15\n            c[b, 2] = [0.5, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.5, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        else:\n            # Spiral distribution (Golden angle)\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        # Add random noise to break perfect symmetries and escape saddle points\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    # Keep initial guesses strictly inside feasible boundaries\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state tracking\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Physics-inspired iterative penalty method for joint optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        # Exponential learning rate decay and escalating penalty enforcement\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Vectorized pairwise distance computation\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps penalty and gradients\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0  # Erase self-overlaps\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Wall boundary penalties and gradients\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Combine objectives: max sum(r) subject to min(violations)\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like random exploration in early stages\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam update mechanics for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam update mechanics for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft physical bounding box\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Pre-compute static LP constraint matrix to severely reduce overhead\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    # Post-process with exact linear programming for pristine mathematical validity\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        max_r_arr = np.minimum.reduce([cb[:, 0], 1.0 - cb[:, 0], cb[:, 1], 1.0 - cb[:, 1]])\n        max_r_arr = np.maximum(0.0, max_r_arr)\n        bounds = [(0.0, float(max_r_arr[i])) for i in range(n)]\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            # Include a strict safety epsilon to obliterate floating point error risk\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            # Guarantee bounds definitively\n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            # Strict safety scaling to definitively handle any micro-overlaps\n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    # Fallback to defaults in case of catastrophic solver failure\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6125), Performs well on target_ratio (0.9915), Performs well on combined_score (0.9915), Performs well on radius_variance (0.0054), Performs well on spatial_spread (0.1951), Performs well on eval_time (37.0705)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9912)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 50\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # Initialize seeds with structurally diverse geometrical priors\n    for b in range(B):\n        mode = b % 7\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor large circles in the corners, leaving a hollow middle for scattering\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution + central disruption\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: \n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # Alternative tight concentric shells\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            # 5 large circles: 4 corners + 1 center\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.15\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.15\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        else:\n            # Random scattering\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n\n        # Add random noise to break perfect symmetries and escape saddle points\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    # Keep initial guesses strictly inside feasible boundaries\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state tracking\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Physics-inspired iterative penalty method for joint optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        # Exponential learning rate decay and escalating penalty enforcement\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Vectorized pairwise distance computation\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps penalty and gradients\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0  # Erase self-overlaps\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Wall boundary penalties and gradients\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Combine objectives: max sum(r) subject to min(violations)\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like random exploration in early stages\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam update mechanics for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam update mechanics for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft physical bounding box\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Pre-compute static LP constraint matrix to severely reduce overhead\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    # Post-process with exact linear programming for pristine mathematical validity\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            # Include a strict safety epsilon to obliterate floating point error risk\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            # Guarantee bounds definitively\n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    # Fallback to defaults in case of catastrophic solver failure\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9911)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64\n    iters = 13000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]\n            r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]\n            r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]\n            r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]\n            r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(3):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9911, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64\n    iters = 13000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]\n            r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]\n            r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]\n            r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]\n            r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(3):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9932, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 56\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]\n            r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]\n            r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]\n            r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]\n            r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64\n    iters = 14000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    \n    # Pre-calculated dense grid distributions (rows) for extreme space utilization \n    configs = [\n        [6, 5, 5, 5, 5], [5, 6, 5, 5, 5], [5, 5, 6, 5, 5],\n        [6, 5, 4, 5, 6], [5, 6, 4, 6, 5], [6, 4, 6, 4, 6],\n        [5, 5, 5, 5, 6], [5, 5, 5, 6, 5], [5, 4, 6, 5, 6],\n        [4, 5, 4, 5, 4, 4], [5, 4, 5, 4, 4, 4], [4, 5, 4, 4, 5, 4],\n        [5, 4, 4, 5, 4, 4], [5, 5, 4, 4, 4, 4], [4, 4, 5, 5, 4, 4],\n        [3, 5, 5, 5, 5, 3], [4, 4, 4, 4, 5, 5], [4, 4, 4, 5, 5, 4],\n        [4, 3, 4, 4, 4, 3, 4], [3, 4, 4, 4, 4, 4, 3], [4, 4, 3, 4, 3, 4, 4],\n        [4, 4, 4, 2, 4, 4, 4]\n    ]\n\n    for b in range(B):\n        if b < len(configs) * 2:\n            conf = configs[b % len(configs)]\n            transpose = (b >= len(configs))\n            idx = 0\n            y_spacing = 1.0 / len(conf)\n            for row, count in enumerate(conf):\n                x_spacing = 1.0 / count\n                for col in range(count):\n                    x = (col + 0.5) / count\n                    y = (row + 0.5) / len(conf)\n                    # Add a slight structural stagger to encourage hexagonal packing\n                    if row % 2 == 1:\n                        x += (0.5 / count) * 0\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64  # Optimal batch size for parallel topology exploration within timeout limits\n    iters = 11000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # Initialize seeds with structurally diverse geometrical priors\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor large circles in the corners, leaving a hollow middle for scattering\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution + central disruption\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: \n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # Alternative tight concentric shells\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            # 5 large circles: 4 corners + 1 center\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.15\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.15\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            # Anchor circles along the edges\n            c[b, 0] = [0.15, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.5]; r[b, 1] = 0.15\n            c[b, 2] = [0.5, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.5, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        else:\n            # Spiral distribution (Golden angle)\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        # Add random noise to break perfect symmetries and escape saddle points\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    # Keep initial guesses strictly inside feasible boundaries\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state tracking\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Physics-inspired iterative penalty method for joint optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        # Exponential learning rate decay and escalating penalty enforcement\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Vectorized pairwise distance computation\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps penalty and gradients\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0  # Erase self-overlaps\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Wall boundary penalties and gradients\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Combine objectives: max sum(r) subject to min(violations)\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like random exploration in early stages\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam update mechanics for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam update mechanics for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft physical bounding box\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Pre-compute static LP constraint matrix to severely reduce overhead\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    # Post-process with exact linear programming for pristine mathematical validity\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        max_r_arr = np.minimum.reduce([cb[:, 0], 1.0 - cb[:, 0], cb[:, 1], 1.0 - cb[:, 1]])\n        max_r_arr = np.maximum(0.0, max_r_arr)\n        bounds = [(0.0, float(max_r_arr[i])) for i in range(n)]\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            # Include a strict safety epsilon to obliterate floating point error risk\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            # Guarantee bounds definitively\n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            # Strict safety scaling to definitively handle any micro-overlaps\n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    # Fallback to defaults in case of catastrophic solver failure\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 64  # Optimal batch size for topological diversity\n    iters = 12500\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # 26 distinct dense grid topological distributions (sums = 26)\n    configs = [\n        [6, 5, 5, 5, 5], [5, 6, 5, 5, 5], [5, 5, 6, 5, 5],\n        [5, 5, 5, 6, 5], [5, 5, 5, 5, 6], [6, 5, 4, 5, 6],\n        [5, 6, 4, 6, 5], [6, 4, 6, 4, 6], [5, 4, 6, 5, 6],\n        [4, 5, 4, 5, 4, 4], [5, 4, 5, 4, 4, 4], [4, 5, 4, 4, 5, 4],\n        [5, 4, 4, 5, 4, 4], [5, 5, 4, 4, 4, 4], [4, 4, 5, 5, 4, 4],\n        [3, 5, 5, 5, 5, 3], [4, 4, 4, 4, 5, 5], [4, 4, 4, 5, 5, 4],\n        [4, 3, 4, 4, 4, 3, 4], [3, 4, 4, 4, 4, 4, 3], [4, 4, 3, 4, 3, 4, 4],\n        [4, 4, 4, 2, 4, 4, 4], [7, 6, 6, 7], [6, 7, 7, 6],\n        [6, 7, 6, 7], [7, 6, 7, 6]\n    ]\n\n    # Initialize seeds with robust geometrical and dense grid priors\n    for b in range(B):\n        if b < len(configs) * 2:\n            conf = configs[b % len(configs)]\n            transpose = (b >= len(configs))\n            idx = 0\n            num_rows = len(conf)\n            for row, count in enumerate(conf):\n                for col in range(count):\n                    # Spacing ensures initial bounding box stays comfortably inside the"]}}, "artifacts_json": "{\"stderr\": \"Stage 1 evaluation failed: Program execution failed: invalid syntax (tmporqpfsvp.py, line 1)\", \"traceback\": \"Traceback (most recent call last):\\n  File \\\"/home/jupyter/Code/oe/dennis/run2_improved_si/evaluator.py\\\", line 384, in evaluate_stage1\\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\\n  File \\\"/home/jupyter/Code/oe/dennis/run2_improved_si/evaluator.py\\\", line 172, in run_with_timeout\\n    raise RuntimeError(f\\\"Program execution failed: {results['error']}\\\")\\nRuntimeError: Program execution failed: invalid syntax (tmporqpfsvp.py, line 1)\\n\", \"failure_stage\": \"stage1_execution\", \"suggestion\": \"Check basic syntax and imports before attempting full evaluation\"}", "artifact_dir": null, "embedding": null}