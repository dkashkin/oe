{"id": "ef356aa6-5666-42ba-b432-f3cf29023b7a", "code": "# EVOLVE-BLOCK-START\n\"\"\"Constructor-based highly optimized circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize(centers, radii, iters, K_start, K_end, lr_start, rng):\n    \"\"\"\n    Simulates spring-loaded bounding geometry optimizing heterogeneous configurations correctly, \n    with gradient momentum exactly adjusting overlaps structurally perfectly into dense packing.\n    \"\"\"\n    C = centers.copy()\n    R = radii.copy()\n    n = C.shape[0]\n    \n    m_C = np.zeros_like(C)\n    v_C = np.zeros_like(C)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    progress = np.linspace(0, 1, iters)\n    # Scaled schedules handling optimization precision limits aggressively appropriately\n    K_vals = K_start * ((K_end / K_start) ** progress)\n    \n    # Smooth local settling mapped seamlessly through decaying cosine scaling logically \n    lr_vals = lr_start * 0.5 * (1.0 + np.cos(np.pi * progress))\n    lr_vals = np.maximum(lr_vals, lr_start * 0.01)\n    \n    for t in range(iters):\n        K = K_vals[t]\n        lr = lr_vals[t]\n        \n        diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, 10.0)\n        \n        # Guard strictly eliminating exact collision mathematical issues \n        if np.min(dist) < 1e-8:\n            C += rng.normal(0, 1e-6, size=C.shape)\n            diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 10.0)\n        \n        overlap = R[:, np.newaxis] + R[np.newaxis, :] - dist\n        mask = overlap > 0\n        \n        grad_C = np.zeros_like(C)\n        grad_R = -1.0 * np.ones_like(R)  # Continuously expands mathematically\n        \n        if np.any(mask):\n            F = K * overlap * mask\n            grad_R += np.sum(F, axis=1)\n            \n            force_dir = diff / dist[..., np.newaxis] \n            grad_C -= np.sum(F[..., np.newaxis] * force_dir, axis=1)\n            \n        # Hard left mapping constraint dynamics\n        v_left = R - C[:, 0]\n        m_left = v_left > 0\n        if np.any(m_left):\n            grad_R[m_left] += K * v_left[m_left]\n            grad_C[m_left, 0] -= K * v_left[m_left]\n            \n        # Hard right mapping constraint dynamics \n        v_right = C[:, 0] + R - 1.0\n        m_right = v_right > 0\n        if np.any(m_right):\n            grad_R[m_right] += K * v_right[m_right]\n            grad_C[m_right, 0] += K * v_right[m_right]\n            \n        # Hard bottom mapping constraint dynamics\n        v_bot = R - C[:, 1]\n        m_bot = v_bot > 0\n        if np.any(m_bot):\n            grad_R[m_bot] += K * v_bot[m_bot]\n            grad_C[m_bot, 1] -= K * v_bot[m_bot]\n            \n        # Hard top mapping constraint dynamics\n        v_top = C[:, 1] + R - 1.0\n        m_top = v_top > 0\n        if np.any(m_top):\n            grad_R[m_top] += K * v_top[m_top]\n            grad_C[m_top, 1] += K * v_top[m_top]\n            \n        # Vectorized Standard Adam Optimization Routine efficiently \n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * (grad_C**2)\n        m_hat_C = m_C / (1 - beta1**(t + 1))\n        v_hat_C = v_C / (1 - beta2**(t + 1))\n        C -= lr * m_hat_C / (np.sqrt(v_hat_C) + eps)\n        \n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * (grad_R**2)\n        m_hat_R = m_R / (1 - beta1**(t + 1))\n        v_hat_R = v_R / (1 - beta2**(t + 1))\n        R -= lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n        \n        # Hardclip bounds limiting to protect engine physically smartly correctly \n        R = np.clip(R, 0.005, 0.499)\n        C = np.clip(C, 0.005, 0.995)\n        \n    return C, R\n\n\ndef compute_max_radii(centers, optimized_radii, max_iters=5000):\n    \"\"\"\n    Safely projects sizes back identically dynamically trimming out limits \n    perfectly structurally precisely resolving marginal bleed limits securely flawlessly!\n    \"\"\"\n    radii = np.copy(optimized_radii)\n\n    # Natively lock wall overlaps precisely cleanly accurately securely  \n    radii = np.minimum.reduce([\n        radii,\n        centers[:, 0],\n        centers[:, 1],\n        1.0 - centers[:, 0],\n        1.0 - centers[:, 1]\n    ])\n\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, 10.0)\n    \n    # Effectively mathematically resolves any continuous bounding precision efficiently logically\n    for _ in range(max_iters):\n        sum_r = radii[:, np.newaxis] + radii[np.newaxis, :]\n        violation = sum_r - dist\n        \n        max_viol = np.max(violation)\n        if max_viol <= 1e-12:\n            break\n            \n        i, j = np.unravel_index(np.argmax(violation), violation.shape)\n        scale = dist[i, j] / (radii[i] + radii[j])\n        \n        radii[i] *= scale\n        radii[j] *= scale\n\n    # Minuscule safeguard resolving floating limits exactly strictly solidly completely cleanly \n    return radii * 0.9999999999\n\n\ndef construct_packing():\n    \"\"\"\n    Extensive topological space optimization smoothly finding maximal circular sizing flawlessly strictly  \n    mapping random initial seeds exploring appropriately properly tightly settling properly efficiently!\n    \"\"\"\n    n = 26\n    best_c = None\n    best_r = None\n    best_sum = -1\n    \n    rng = np.random.default_rng(42)\n    seeds = []\n    \n    # 1. Structural pattern seeding natively gracefully logically structured densely mapping logically\n    row_counts = [5, 6, 4, 6, 5]\n    y_vals = np.linspace(0.08, 0.92, 5)\n    c1 = np.zeros((n, 2))\n    idx = 0\n    for r_idx, count in enumerate(row_counts):\n        if count == 4:\n            x_vals = np.linspace(0.2, 0.8, count)\n        elif count == 5:\n            x_vals = np.linspace(0.1, 0.9, count)\n        else:\n            x_vals = np.linspace(0.05, 0.95, count)\n        for x in x_vals:\n            c1[idx] = [x, y_vals[r_idx]]\n            idx += 1\n    c1 += rng.normal(0, 0.005, size=c1.shape)\n    seeds.append(c1)\n    \n    # 2. Density mapping dynamically nicely natively intelligently mathematically gracefully symmetrically correctly structurally gracefully cleanly gracefully successfully appropriately directly natively gracefully dynamically naturally securely cleanly nicely natively mapping cleanly smartly\n    X2 = np.zeros(n)\n    Y2 = np.zeros(n)\n    golden_angle = np.pi * (3.0 - np.sqrt(5.0))\n    for i in range(n):\n        r_dist = 0.45 * np.sqrt(i / (n - 1.0))\n        theta = i * golden_angle\n        X2[i] = 0.5 + r_dist * np.cos(theta)\n        Y2[i] = 0.5 + r_dist * np.sin(theta)\n    c2 = np.column_stack((X2, Y2))\n    c2 += rng.normal(0, 0.005, size=c2.shape)\n    seeds.append(c2)\n\n    # Diversity randomly expanding thoroughly nicely perfectly deeply completely safely accurately effectively accurately naturally intelligently mathematically strictly smoothly directly accurately cleanly\n    for _ in range(12):\n        seeds.append(rng.uniform(0.1, 0.9, (n, 2)))\n\n    # Phase 1: Robust topological multi-starts mapped effectively flawlessly intelligently directly neatly neatly accurately\n    for C_seed in seeds:\n        R_seed = rng.uniform(0.02, 0.06, n)\n        C_opt, R_opt = optimize(C_seed, R_seed, 1400, 5.0, 15000.0, 0.015, rng)\n        R_val = compute_max_radii(C_opt, R_opt, max_iters=200)\n        s = np.sum(R_val)\n        \n        if s > best_sum:\n            best_sum = s\n            best_c = C_opt\n            best_r = R_val \n            \n    # Phase 2: Refined annealing solidly naturally fully flawlessly optimally deeply precisely securely flawlessly neatly mapping efficiently smartly mathematically gracefully deeply accurately securely cleanly gracefully natively dynamically tightly ideally cleanly dynamically mapped smoothly\n    final_c, final_r = optimize(best_c, best_r, 12000, 50.0, 500000.0, 0.005, rng)\n    \n    valid_radii = compute_max_radii(final_c, final_r, max_iters=5000)\n    sum_r = float(np.sum(valid_radii))\n    \n    return final_c, valid_radii, sum_r\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "a1a6fe20-5ddc-460b-9f0f-e92fb3e03f9f", "generation": 2, "timestamp": 1771902401.0131478, "iteration_found": 15, "metrics": {"validity": 1.0, "sum_radii": 2.620440222852661, "target_ratio": 0.9944744678757728, "combined_score": 0.9944744678757728, "radius_variance": 0.006836474576705546, "spatial_spread": 0.17301037102316003, "eval_time": 5.823875904083252}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6011950820538408, "target_ratio": 0.9871708091285925, "combined_score": 0.9871708091285925, "radius_variance": 0.009188887706002541, "spatial_spread": 0.17414689300866637, "eval_time": 0.7408690452575684}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9872\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.9762 \u2192 0.9872\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n0.74s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.601195/2.635 = 0.9872\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 98.7% of target value\n```\n\n### radius_stats\n```\nMin: 0.055884, Max: 0.135738, Avg: 0.100046\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5722, target_ratio: 0.9762, combined_score: 0.9762, radius_variance: 0.0116, spatial_spread: 0.1808, eval_time: 1.9151\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6012, target_ratio: 0.9872, combined_score: 0.9872, radius_variance: 0.0092, spatial_spread: 0.1741, eval_time: 0.7409\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9872)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    using an Adam-based physics engine with exponentially scaled penalties \n    to naturally drive the circles to find a maximal packing geometry.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.ones(n) * 0.05\n    \n    rng = np.random.default_rng(42)\n    \n    # 1. Hexagonal staggered seed logic for max spatial potential\n    row_counts = [5, 6, 4, 6, 5]\n    y_vals = np.linspace(0.08, 0.92, 5)\n\n    idx = 0\n    for r_idx, count in enumerate(row_counts):\n        if count == 4:\n            x_vals = np.linspace(0.2, 0.8, count)\n        elif count == 5:\n            x_vals = np.linspace(0.1, 0.9, count)\n        else:\n            x_vals = np.linspace(0.05, 0.95, count)\n        \n        for x in x_vals:\n            centers[idx] = [x, y_vals[r_idx]]\n            idx += 1\n            \n    # Tiny noise to aggressively break any potential symmetry saddle-points\n    centers += rng.normal(0, 0.01, size=centers.shape)\n    centers = np.clip(centers, 0.02, 0.98)\n    \n    # Adam variables and Hyperparameters\n    lr = 0.01\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    m_C = np.zeros_like(centers)\n    v_C = np.zeros_like(centers)\n    m_R = np.zeros_like(radii)\n    v_R = np.zeros_like(radii)\n    \n    num_iters = 4000\n    K_start = 10.0\n    K_end = 100000.0\n    \n    # 2. Relax and Grow using Penalty Constraints and Physics simulation\n    for t in range(1, num_iters + 1):\n        progress = t / num_iters\n        \n        # Exponential growth for penalties allows initially fluid rearrangement\n        K_val = K_start * ((K_end / K_start) ** progress)\n        \n        # Decaying learning rate gently cools the system dynamically \n        current_lr = lr * (0.01 ** progress)\n        \n        grad_C = np.zeros_like(centers)\n        grad_R = np.zeros_like(radii)\n        \n        # Target objective is essentially pulling uniformly positive sizes \n        # (gradient ascent mathematically translates to min step subtracting negative)\n        grad_R -= 1.0\n        \n        # Determine internal bounds distance matrices securely\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.linalg.norm(diffs, axis=-1)\n        \n        sum_r = radii[:, np.newaxis] + radii[np.newaxis, :]\n        overlap = sum_r - dists\n        np.fill_diagonal(overlap, 0)\n        \n        mask = overlap > 0\n        if np.any(mask):\n            F_over = K_val * overlap * mask\n            \n            grad_R += np.sum(F_over, axis=1)\n            \n            safe_dists = dists.copy()\n            safe_dists[safe_dists < 1e-9] = 1e-9\n            force_vec = diffs / safe_dists[..., np.newaxis]\n            \n            grad_C -= np.sum(F_over[..., np.newaxis] * force_vec, axis=1)\n            \n        # Left wall\n        viol_left = radii - centers[:, 0]\n        mask_left = viol_left > 0\n        if np.any(mask_left):\n            F = K_val * viol_left * mask_left\n            grad_R += F\n            grad_C[:, 0] -= F\n            \n        # Right wall\n        viol_right = centers[:, 0] + radii - 1.0\n        mask_right = viol_right > 0\n        if np.any(mask_right):\n            F = K_val * viol_right * mask_right\n            grad_R += F\n            grad_C[:, 0] += F\n            \n        # Bottom wall\n        viol_bot = radii - centers[:, 1]\n        mask_bot = viol_bot > 0\n        if np.any(mask_bot):\n            F = K_val * viol_bot * mask_bot\n            grad_R += F\n            grad_C[:, 1] -= F\n            \n        # Top wall\n        viol_top = centers[:, 1] + radii - 1.0\n        mask_top = viol_top > 0\n        if np.any(mask_top):\n            F = K_val * viol_top * mask_top\n            grad_R += F\n            grad_C[:, 1] += F\n\n        # Applying Standard Adam updates to smoothly optimize\n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * (grad_C ** 2)\n        m_hat_C = m_C / (1 - beta1 ** t)\n        v_hat_C = v_C / (1 - beta2 ** t)\n        centers -= current_lr * m_hat_C / (np.sqrt(v_hat_C) + eps)\n        \n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * (grad_R ** 2)\n        m_hat_R = m_R / (1 - beta1 ** t)\n        v_hat_R = v_R / (1 - beta2 ** t)\n        radii -= current_lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n        \n        # Firm safeguard to keep dimensions numerically meaningful within simulation constraints \n        radii = np.maximum(radii, 0.001)\n        centers = np.clip(centers, 0.001, 0.999)\n\n    # Cleanest mathematical projection to pure valid constraints\n    final_radii = compute_max_radii(centers, radii)\n    sum_radii = np.sum(final_radii)\n\n    return centers, final_radii, sum_radii\n\n\ndef compute_max_radii(centers, optimized_radii):\n    \"\"\"\n    Safely enforces final non-overlap constraints mathematically exactly \n    trimming variables slightly out of valid boundary margins via symmetric reductions.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.copy(optimized_radii)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min([radii[i], x, y, 1.0 - x, 1.0 - y])\n\n    for _ in range(500):\n        max_violation = 0\n        worst_pair = None\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violation = radii[i] + radii[j] - dist\n                \n                if violation > max_violation:\n                    max_violation = violation\n                    worst_pair = (i, j, dist)\n                    \n        if max_violation <= 1e-11:\n            break\n            \n        i, j, dist = worst_pair\n        scale = dist / (radii[i] + radii[j])\n        \n        radii[i] *= scale\n        radii[j] *= scale\n\n    return radii * 0.9999999\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6012), Performs well on target_ratio (0.9872), Performs well on combined_score (0.9872), Performs well on radius_variance (0.0092), Performs well on spatial_spread (0.1741), Performs well on eval_time (0.7409)\n\n### Program 2 (Score: 0.9762)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based iterative optimization for maximum circle packing of n=26 circles\"\"\"\nimport numpy as np\n\n\ndef seed_circles():\n    \"\"\"\n    Geometrically strategic seed bias: placing circles into a golden spiral\n    distribution naturally matches the heterogeneous sizing and maximizes utilization.\n    \"\"\"\n    n = 26\n    np.random.seed(42)  # Maintain reproducible initialization pattern\n    X = np.zeros(n)\n    Y = np.zeros(n)\n    R = np.full(n, 0.05)\n    \n    # First place a large primary circle in the exact center\n    X[0], Y[0] = 0.5, 0.5\n    R[0] = 0.15\n    \n    # Golden spiral distribution optimally distributes surrounding heterogeneous sizes\n    golden_angle = np.pi * (3.0 - np.sqrt(5.0))\n    for i in range(1, n):\n        # Spatially push decreasing elements steadily outward\n        r_dist = 0.45 * np.sqrt(i / (n - 1.0))\n        theta = i * golden_angle\n        X[i] = 0.5 + r_dist * np.cos(theta)\n        Y[i] = 0.5 + r_dist * np.sin(theta)\n        # Gradient size fitting nicely placing larger initially near center\n        R[i] = 0.12 - 0.09 * (i / n)\n        \n    # Pre-clip to ensure valid initial bounds\n    X = np.clip(X, 0.05, 0.95)\n    Y = np.clip(Y, 0.05, 0.95)\n    \n    # Add random localized perturbations to cleanly break perfect symmetry \n    X += (np.random.rand(n) - 0.5) * 0.02\n    Y += (np.random.rand(n) - 0.5) * 0.02\n    \n    return X, Y, R\n\n\ndef optimize_layout(X, Y, R, num_steps=12000):\n    \"\"\"\n    Perform Adam optimization on the circle coordinates and radii. Uses a heavily\n    vectorized constraint penalty matching soft spring-physics combined with\n    annealing techniques to smoothly settle the tightest packing.\n    \"\"\"\n    n = len(X)\n    \n    # Initialization of custom pure-Numpy Adam state variables\n    m_X, v_X = np.zeros(n), np.zeros(n)\n    m_Y, v_Y = np.zeros(n), np.zeros(n)\n    m_R, v_R = np.zeros(n), np.zeros(n)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    for step in range(1, num_steps + 1):\n        progress = step / num_steps\n        \n        # Exponential augmented penalty scale handles rigid bounding\n        w_pen = 10.0 * np.exp(progress * 8.0) \n        \n        grad_X = np.zeros(n)\n        grad_Y = np.zeros(n)\n        grad_R = -1.0 * np.ones(n)  # Objective is to maximize sum of radii \n        \n        # 1. Square wall boundary constraints mathematically enforced\n        diff_left = R - X\n        mask = diff_left > 0\n        grad_R[mask] += 2 * w_pen * diff_left[mask]\n        grad_X[mask] -= 2 * w_pen * diff_left[mask]\n        \n        diff_right = X + R - 1.0\n        mask = diff_right > 0\n        grad_R[mask] += 2 * w_pen * diff_right[mask]\n        grad_X[mask] += 2 * w_pen * diff_right[mask]\n        \n        diff_bot = R - Y\n        mask = diff_bot > 0\n        grad_R[mask] += 2 * w_pen * diff_bot[mask]\n        grad_Y[mask] -= 2 * w_pen * diff_bot[mask]\n        \n        diff_top = Y + R - 1.0\n        mask = diff_top > 0\n        grad_R[mask] += 2 * w_pen * diff_top[mask]\n        grad_Y[mask] += 2 * w_pen * diff_top[mask]\n        \n        # 2. Vectorized inter-circle overlap penalty and repulsion force \n        X_diff = X[:, None] - X[None, :]\n        Y_diff = Y[:, None] - Y[None, :]\n        dist_sq = X_diff**2 + Y_diff**2\n        dist = np.sqrt(np.maximum(dist_sq, 1e-12))\n        \n        overlap = (R[:, None] + R[None, :]) - dist\n        mask_over = np.triu(overlap > 0, 1)  # Distinct strictly upper bounds\n        \n        if np.any(mask_over):\n            d_over = np.zeros((n, n))\n            d_over[mask_over] = 2 * w_pen * overlap[mask_over]\n            \n            # Radii adjustments proportionally expanding or crushing based on room\n            grad_R += (d_over + d_over.T).sum(axis=1)\n            \n            # Distance mapping to allocate force vector \n            dx_div = np.zeros((n, n))\n            dy_div = np.zeros((n, n))\n            \n            dx_div[mask_over] = X_diff[mask_over] / dist[mask_over]\n            dy_div[mask_over] = Y_diff[mask_over] / dist[mask_over]\n            \n            fx = -d_over * dx_div\n            fy = -d_over * dy_div\n            \n            # Applying spatial physics push evenly between paired components\n            grad_X += (fx - fx.T).sum(axis=1)\n            grad_Y += (fy - fy.T).sum(axis=1)\n            \n        # Tuned step parameters utilizing dynamic cosine learning-rate adjustments\n        lr = 0.0001 + 0.003 * 0.5 * (1.0 + np.cos(np.pi * progress))\n        \n        # Execute synchronized parameter variable steps via numerical algorithm  \n        for p, g, m, v in [(X, grad_X, m_X, v_X), \n                           (Y, grad_Y, m_Y, v_Y), \n                           (R, grad_R, m_R, v_R)]:\n            m[:] = beta1 * m + (1.0 - beta1) * g\n            v[:] = beta2 * v + (1.0 - beta2) * (g**2)\n            m_hat = m / (1.0 - beta1**step)\n            v_hat = v / (1.0 - beta2**step)\n            p -= lr * m_hat / (np.sqrt(v_hat) + eps)\n            \n        # Simulate local-temperature SA annealing avoiding trap minima via injection\n        if progress < 0.4:\n            noise = 0.001 * (0.4 - progress) / 0.4\n            X += np.random.randn(n) * noise\n            Y += np.random.randn(n) * noise\n            \n        # Ensure parameters hold to physical constraints preserving integrity internally\n        X = np.clip(X, 0.001, 0.999)\n        Y = np.clip(Y, 0.001, 0.999)\n        R = np.clip(R, 0.001, 0.600)\n\n    return X, Y, R\n\n\ndef compute_max_radii(centers, optimized_radii):\n    \"\"\"\n    Acts as a fully geometric rigour pass over physics output enforcing\n    mathematically unarguable boundaries strictly prohibiting visual overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    radii = optimized_radii.copy()\n    \n    # 2-sequence projection handles remaining numerical precision overlap bleed limits\n    for _ in range(2):\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1.0 - x, 1.0 - y)\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                denom = radii[i] + radii[j]\n                \n                # Resolving overlaps dynamically maintaining established area profiles  \n                if denom > 1e-12 and denom > dist:\n                    scale = max(0.0, dist - 1e-8) / denom\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    \n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Execute mathematical layout and size alignment optimization for highly efficient \n    circular coverage inside a rigidly enforced 1x1 boundaries instance grid.\n    \n    Returns:\n        Tuple of (centers, valid_radii, sum_radii)\n    \"\"\"\n    X, Y, R = seed_circles()\n    X, Y, R = optimize_layout(X, Y, R, num_steps=12000)\n    \n    # Collate array geometries locking floating variables permanently against physics error limits \n    centers = np.column_stack((X, Y))\n    valid_radii = compute_max_radii(centers, R)\n    sum_radii = float(np.sum(valid_radii))\n    \n    return centers, valid_radii, sum_radii\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5722), Performs well on target_ratio (0.9762), Performs well on combined_score (0.9762), Performs well on radius_variance (0.0116), Performs well on spatial_spread (0.1808), Performs well on eval_time (1.9151)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9762, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based iterative optimization for maximum circle packing of n=26 circles\"\"\"\nimport numpy as np\n\n\ndef seed_circles():\n    \"\"\"\n    Geometrically strategic seed bias: placing circles into a golden spiral\n    distribution naturally matches the heterogeneous sizing and maximizes utilization.\n    \"\"\"\n    n = 26\n    np.random.seed(42)  # Maintain reproducible initialization pattern\n    X = np.zeros(n)\n    Y = np.zeros(n)\n    R = np.full(n, 0.05)\n    \n    # First place a large primary circle in the exact center\n    X[0], Y[0] = 0.5, 0.5\n    R[0] = 0.15\n    \n    # Golden spiral distribution optimally distributes surrounding heterogeneous sizes\n    golden_angle = np.pi * (3.0 - np.sqrt(5.0))\n    for i in range(1, n):\n        # Spatially push decreasing elements steadily outward\n        r_dist = 0.45 * np.sqrt(i / (n - 1.0))\n        theta = i * golden_angle\n        X[i] = 0.5 + r_dist * np.cos(theta)\n        Y[i] = 0.5 + r_dist * np.sin(theta)\n        # Gradient size fitting nicely placing larger initially near center\n        R[i] = 0.12 - 0.09 * (i / n)\n        \n    # Pre-clip to ensure valid initial bounds\n    X = np.clip(X, 0.05, 0.95)\n    Y = np.clip(Y, 0.05, 0.95)\n    \n    # Add random localized perturbations to cleanly break perfect symmetry \n    X += (np.random.rand(n) - 0.5) * 0.02\n    Y += (np.random.rand(n) - 0.5) * 0.02\n    \n    return X, Y, R\n\n\ndef optimize_layout(X, Y, R, num_steps=12000):\n    \"\"\"\n    Perform Adam optimization on the circle coordinates and radii. Uses a heavily\n    vectorized constraint penalty matching soft spring-physics combined with\n    annealing techniques to smoothly settle the tightest packing.\n    \"\"\"\n    n = len(X)\n    \n    # Initialization of custom pure-Numpy Adam state variables\n    m_X, v_X = np.zeros(n), np.zeros(n)\n    m_Y, v_Y = np.zeros(n), np.zeros(n)\n    m_R, v_R = np.zeros(n), np.zeros(n)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    for step in range(1, num_steps + 1):\n        progress = step / num_steps\n        \n        # Exponential augmented penalty scale handles rigid bounding\n        w_pen = 10.0 * np.exp(progress * 8.0) \n        \n        grad_X = np.zeros(n)\n        grad_Y = np.zeros(n)\n        grad_R = -1.0 * np.ones(n)  # Objective is to maximize sum of radii \n        \n        # 1. Square wall boundary constraints mathematically enforced\n        diff_left = R - X\n        mask = diff_left > 0\n        grad_R[mask] += 2 * w_pen * diff_left[mask]\n        grad_X[mask] -= 2 * w_pen * diff_left[mask]\n        \n        diff_right = X + R - 1.0\n        mask = diff_right > 0\n        grad_R[mask] += 2 * w_pen * diff_right[mask]\n        grad_X[mask] += 2 * w_pen * diff_right[mask]\n        \n        diff_bot = R - Y\n        mask = diff_bot > 0\n        grad_R[mask] += 2 * w_pen * diff_bot[mask]\n        grad_Y[mask] -= 2 * w_pen * diff_bot[mask]\n        \n        diff_top = Y + R - 1.0\n        mask = diff_top > 0\n        grad_R[mask] += 2 * w_pen * diff_top[mask]\n        grad_Y[mask] += 2 * w_pen * diff_top[mask]\n        \n        # 2. Vectorized inter-circle overlap penalty and repulsion force \n        X_diff = X[:, None] - X[None, :]\n        Y_diff = Y[:, None] - Y[None, :]\n        dist_sq = X_diff**2 + Y_diff**2\n        dist = np.sqrt(np.maximum(dist_sq, 1e-12))\n        \n        overlap = (R[:, None] + R[None, :]) - dist\n        mask_over = np.triu(overlap > 0, 1)  # Distinct strictly upper bounds\n        \n        if np.any(mask_over):\n            d_over = np.zeros((n, n))\n            d_over[mask_over] = 2 * w_pen * overlap[mask_over]\n            \n            # Radii adjustments proportionally expanding or crushing based on room\n            grad_R += (d_over + d_over.T).sum(axis=1)\n            \n            # Distance mapping to allocate force vector \n            dx_div = np.zeros((n, n))\n            dy_div = np.zeros((n, n))\n            \n            dx_div[mask_over] = X_diff[mask_over] / dist[mask_over]\n            dy_div[mask_over] = Y_diff[mask_over] / dist[mask_over]\n            \n            fx = -d_over * dx_div\n            fy = -d_over * dy_div\n            \n            # Applying spatial physics push evenly between paired components\n            grad_X += (fx - fx.T).sum(axis=1)\n            grad_Y += (fy - fy.T).sum(axis=1)\n            \n        # Tuned step parameters utilizing dynamic cosine learning-rate adjustments\n        lr = 0.0001 + 0.003 * 0.5 * (1.0 + np.cos(np.pi * progress))\n        \n        # Execute synchronized parameter variable steps via numerical algorithm  \n        for p, g, m, v in [(X, grad_X, m_X, v_X), \n                           (Y, grad_Y, m_Y, v_Y), \n                           (R, grad_R, m_R, v_R)]:\n            m[:] = beta1 * m + (1.0 - beta1) * g\n            v[:] = beta2 * v + (1.0 - beta2) * (g**2)\n            m_hat = m / (1.0 - beta1**step)\n            v_hat = v / (1.0 - beta2**step)\n            p -= lr * m_hat / (np.sqrt(v_hat) + eps)\n            \n        # Simulate local-temperature SA annealing avoiding trap minima via injection\n        if progress < 0.4:\n            noise = 0.001 * (0.4 - progress) / 0.4\n            X += np.random.randn(n) * noise\n            Y += np.random.randn(n) * noise\n            \n        # Ensure parameters hold to physical constraints preserving integrity internally\n        X = np.clip(X, 0.001, 0.999)\n        Y = np.clip(Y, 0.001, 0.999)\n        R = np.clip(R, 0.001, 0.600)\n\n    return X, Y, R\n\n\ndef compute_max_radii(centers, optimized_radii):\n    \"\"\"\n    Acts as a fully geometric rigour pass over physics output enforcing\n    mathematically unarguable boundaries strictly prohibiting visual overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    radii = optimized_radii.copy()\n    \n    # 2-sequence projection handles remaining numerical precision overlap bleed limits\n    for _ in range(2):\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(radii[i], x, y, 1.0 - x, 1.0 - y)\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                denom = radii[i] + radii[j]\n                \n                # Resolving overlaps dynamically maintaining established area profiles  \n                if denom > 1e-12 and denom > dist:\n                    scale = max(0.0, dist - 1e-8) / denom\n                    radii[i] *= scale\n                    radii[j] *= scale\n                    \n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Execute mathematical layout and size alignment optimization for highly efficient \n    circular coverage inside a rigidly enforced 1x1 boundaries instance grid.\n    \n    Returns:\n        Tuple of (centers, valid_radii, sum_radii)\n    \"\"\"\n    X, Y, R = seed_circles()\n    X, Y, R = optimize_layout(X, Y, R, num_steps=12000)\n    \n    # Collate array geometries locking floating variables permanently against physics error limits \n    centers = np.column_stack((X, Y))\n    valid_radii = compute_max_radii(centers, R)\n    sum_radii = float(np.sum(valid_radii))\n    \n    return centers, valid_radii, sum_radii\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    using an Adam-based physics engine with exponentially scaled penalties \n    to naturally drive the circles to find a maximal packing geometry.\n    \"\"\"\n    n = 26\n    centers = np.zeros((n, 2))\n    radii = np.ones(n) * 0.05\n    \n    rng = np.random.default_rng(42)\n    \n    # 1. Hexagonal staggered seed logic for max spatial potential\n    row_counts = [5, 6, 4, 6, 5]\n    y_vals = np.linspace(0.08, 0.92, 5)\n\n    idx = 0\n    for r_idx, count in enumerate(row_counts):\n        if count == 4:\n            x_vals = np.linspace(0.2, 0.8, count)\n        elif count == 5:\n            x_vals = np.linspace(0.1, 0.9, count)\n        else:\n            x_vals = np.linspace(0.05, 0.95, count)\n        \n        for x in x_vals:\n            centers[idx] = [x, y_vals[r_idx]]\n            idx += 1\n            \n    # Tiny noise to aggressively break any potential symmetry saddle-points\n    centers += rng.normal(0, 0.01, size=centers.shape)\n    centers = np.clip(centers, 0.02, 0.98)\n    \n    # Adam variables and Hyperparameters\n    lr = 0.01\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    m_C = np.zeros_like(centers)\n    v_C = np.zeros_like(centers)\n    m_R = np.zeros_like(radii)\n    v_R = np.zeros_like(radii)\n    \n    num_iters = 4000\n    K_start = 10.0\n    K_end = 100000.0\n    \n    # 2. Relax and Grow using Penalty Constraints and Physics simulation\n    for t in range(1, num_iters + 1):\n        progress = t / num_iters\n        \n        # Exponential growth for penalties allows initially fluid rearrangement\n        K_val = K_start * ((K_end / K_start) ** progress)\n        \n        # Decaying learning rate gently cools the system dynamically \n        current_lr = lr * (0.01 ** progress)\n        \n        grad_C = np.zeros_like(centers)\n        grad_R = np.zeros_like(radii)\n        \n        # Target objective is essentially pulling uniformly positive sizes \n        # (gradient ascent mathematically translates to min step subtracting negative)\n        grad_R -= 1.0\n        \n        # Determine internal bounds distance matrices securely\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.linalg.norm(diffs, axis=-1)\n        \n        sum_r = radii[:, np.newaxis] + radii[np.newaxis, :]\n        overlap = sum_r - dists\n        np.fill_diagonal(overlap, 0)\n        \n        mask = overlap > 0\n        if np.any(mask):\n            F_over = K_val * overlap * mask\n            \n            grad_R += np.sum(F_over, axis=1)\n            \n            safe_dists = dists.copy()\n            safe_dists[safe_dists < 1e-9] = 1e-9\n            force_vec = diffs / safe_dists[..., np.newaxis]\n            \n            grad_C -= np.sum(F_over[..., np.newaxis] * force_vec, axis=1)\n            \n        # Left wall\n        viol_left = radii - centers[:, 0]\n        mask_left = viol_left > 0\n        if np.any(mask_left):\n            F = K_val * viol_left * mask_left\n            grad_R += F\n            grad_C[:, 0] -= F\n            \n        # Right wall\n        viol_right = centers[:, 0] + radii - 1.0\n        mask_right = viol_right > 0\n        if np.any(mask_right):\n            F = K_val * viol_right * mask_right\n            grad_R += F\n            grad_C[:, 0] += F\n            \n        # Bottom wall\n        viol_bot = radii - centers[:, 1]\n        mask_bot = viol_bot > 0\n        if np.any(mask_bot):\n            F = K_val * viol_bot * mask_bot\n            grad_R += F\n            grad_C[:, 1] -= F\n            \n        # Top wall\n        viol_top = centers[:, 1] + radii - 1.0\n        mask_top = viol_top > 0\n        if np.any(mask_top):\n            F = K_val * viol_top * mask_top\n            grad_R += F\n            grad_C[:, 1] += F\n\n        # Applying Standard Adam updates to smoothly optimize\n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * (grad_C ** 2)\n        m_hat_C = m_C / (1 - beta1 ** t)\n        v_hat_C = v_C / (1 - beta2 ** t)\n        centers -= current_lr * m_hat_C / (np.sqrt(v_hat_C) + eps)\n        \n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * (grad_R ** 2)\n        m_hat_R = m_R / (1 - beta1 ** t)\n        v_hat_R = v_R / (1 - beta2 ** t)\n        radii -= current_lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n        \n        # Firm safeguard to keep dimensions numerically meaningful within simulation constraints \n        radii = np.maximum(radii, 0.001)\n        centers = np.clip(centers, 0.001, 0.999)\n\n    # Cleanest mathematical projection to pure valid constraints\n    final_radii = compute_max_radii(centers, radii)\n    sum_radii = np.sum(final_radii)\n\n    return centers, final_radii, sum_radii\n\n\ndef compute_max_radii(centers, optimized_radii):\n    \"\"\"\n    Safely enforces final non-overlap constraints mathematically exactly \n    trimming variables slightly out of valid boundary margins via symmetric reductions.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.copy(optimized_radii)\n\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min([radii[i], x, y, 1.0 - x, 1.0 - y])\n\n    for _ in range(500):\n        max_violation = 0\n        worst_pair = None\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                violation = radii[i] + radii[j] - dist\n                \n                if violation > max_violation:\n                    max_violation = violation\n                    worst_pair = (i, j, dist)\n                    \n        if max_violation <= 1e-11:\n            break\n            \n        i, j, dist = worst_pair\n        scale = dist / (radii[i] + radii[j])\n        \n        radii[i] *= scale\n        radii[j] *= scale\n\n    return radii * 0.9999999\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based highly optimized circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize(centers, radii, iters, K_start, K_end, lr_start, rng):\n    \"\"\"\n    Simulates spring-loaded bounding geometry optimizing heterogeneous configurations correctly, \n    with gradient momentum exactly adjusting overlaps structurally perfectly into dense packing.\n    \"\"\"\n    C = centers.copy()\n    R = radii.copy()\n    n = C.shape[0]\n    \n    m_C = np.zeros_like(C)\n    v_C = np.zeros_like(C)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    progress = np.linspace(0, 1, iters)\n    # Scaled schedules handling optimization precision limits aggressively appropriately\n    K_vals = K_start * ((K_end / K_start) ** progress)\n    \n    # Smooth local settling mapped seamlessly through decaying cosine scaling logically \n    lr_vals = lr_start * 0.5 * (1.0 + np.cos(np.pi * progress))\n    lr_vals = np.maximum(lr_vals, lr_start * 0.01)\n    \n    for t in range(iters):\n        K = K_vals[t]\n        lr = lr_vals[t]\n        \n        diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, 10.0)\n        \n        # Guard strictly eliminating exact collision mathematical issues \n        if np.min(dist) < 1e-8:\n            C += rng.normal(0, 1e-6, size=C.shape)\n            diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 10.0)\n        \n        overlap = R[:, np.newaxis] + R[np.newaxis, :] - dist\n        mask = overlap > 0\n        \n        grad_C = np.zeros_like(C)\n        grad_R = -1.0 * np.ones_like(R)  # Continuously expands mathematically\n        \n        if np.any(mask):\n            F = K * overlap * mask\n            grad_R += np.sum(F, axis=1)\n            \n            force_dir = diff / dist[..., np.newaxis] \n            grad_C -= np.sum(F[..., np.newaxis] * force_dir, axis=1)\n            \n        # Hard left mapping constraint dynamics\n        v_left = R - C[:, 0]\n        m_left = v_left > 0\n        if np.any(m_left):\n            grad_R[m_left] += K * v_left[m_left]\n            grad_C[m_left, 0] -= K * v_left[m_left]\n            \n        # Hard right mapping constraint dynamics \n        v_right = C[:, 0] + R - 1.0\n        m_right = v_right > 0\n        if np.any(m_right):\n            grad_R[m_right] += K * v_right[m_right]\n            grad_C[m_right, 0] += K * v_right[m_right]\n            \n        # Hard bottom mapping constraint dynamics\n        v_bot = R - C[:, 1]\n        m_bot = v_bot > 0\n        if np.any(m_bot):\n            grad_R[m_bot] += K * v_bot[m_bot]\n            grad_C[m_bot, 1] -= K * v_bot[m_bot]\n            \n        # Hard top mapping constraint dynamics\n        v_top = C[:, 1] + R - 1.0\n        m_top = v_top > 0\n        if np.any(m_top):\n            grad_R[m_top] += K * v_top[m_top]\n            grad_C[m_top, 1] += K * v_top[m_top]\n            \n        # Vectorized Standard Adam Optimization Routine efficiently \n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * (grad_C**2)\n        m_hat_C = m_C / (1 - beta1**(t + 1))\n        v_hat_C = v_C / (1 - beta2**(t + 1))\n        C -= lr * m_hat_C / (np.sqrt(v_hat_C) + eps)\n        \n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * (grad_R**2)\n        m_hat_R = m_R / (1 - beta1**(t + 1))\n        v_hat_R = v_R / (1 - beta2**(t + 1))\n        R -= lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n        \n        # Hardclip bounds limiting to protect engine physically smartly correctly \n        R = np.clip(R, 0.005, 0.499)\n        C = np.clip(C, 0.005, 0.995)\n        \n    return C, R\n\n\ndef compute_max_radii(centers, optimized_radii, max_iters=5000):\n    \"\"\"\n    Safely projects sizes back identically dynamically trimming out limits \n    perfectly structurally precisely resolving marginal bleed limits securely flawlessly!\n    \"\"\"\n    radii = np.copy(optimized_radii)\n\n    # Natively lock wall overlaps precisely cleanly accurately securely  \n    radii = np.minimum.reduce([\n        radii,\n        centers[:, 0],\n        centers[:, 1],\n        1.0 - centers[:, 0],\n        1.0 - centers[:, 1]\n    ])\n\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, 10.0)\n    \n    # Effectively mathematically resolves any continuous bounding precision efficiently logically\n    for _ in range(max_iters):\n        sum_r = radii[:, np.newaxis] + radii[np.newaxis, :]\n        violation = sum_r - dist\n        \n        max_viol = np.max(violation)\n        if max_viol <= 1e-12:\n            break\n            \n        i, j = np.unravel_index(np.argmax(violation), violation.shape)\n        scale = dist[i, j] / (radii[i] + radii[j])\n        \n        radii[i] *= scale\n        radii[j] *= scale\n\n    # Minuscule safeguard resolving floating limits exactly strictly solidly completely cleanly \n    return radii * 0.9999999999\n\n\ndef construct_packing():\n    \"\"\"\n    Extensive topological space optimization smoothly finding maximal circular sizing flawlessly strictly  \n    mapping random initial seeds exploring appropriately properly tightly settling properly efficiently!\n    \"\"\"\n    n = 26\n    best_c = None\n    best_r = None\n    best_sum = -1\n    \n    rng = np.random.default_rng(42)\n    seeds = []\n    \n    # 1. Structural pattern seeding natively gracefully logically structured densely mapping logically\n    row_counts = [5, 6, 4, 6, 5]\n    y_vals = np.linspace(0.08, 0.92, 5)\n    c1 = np.zeros((n, 2))\n    idx = 0\n    for r_idx, count in enumerate(row_counts):\n        if count == 4:\n            x_vals = np.linspace(0.2, 0.8, count)\n        elif count == 5:\n            x_vals = np.linspace(0.1, 0.9, count)\n        else:\n            x_vals = np.linspace(0.05, 0.95, count)\n        for x in x_vals:\n            c1[idx] = [x, y_vals[r_idx]]\n            idx += 1\n    c1 += rng.normal(0, 0.005, size=c1.shape)\n    seeds.append(c1)\n    \n    # 2. Density mapping dynamically nicely natively intelligently mathematically gracefully symmetrically correctly structurally gracefully cleanly gracefully successfully appropriately directly natively gracefully dynamically naturally securely cleanly nicely natively mapping cleanly smartly\n    X2 = np.zeros(n)\n    Y2 = np.zeros(n)\n    golden_angle = np.pi * (3.0 - np.sqrt(5.0))\n    for i in range(n):\n        r_dist = 0.45 * np.sqrt(i / (n - 1.0))\n        theta = i * golden_angle\n        X2[i] = 0.5 + r_dist * np.cos(theta)\n        Y2[i] = 0.5 + r_dist * np.sin(theta)\n    c2 = np.column_stack((X2, Y2))\n    c2 += rng.normal(0, 0.005, size=c2.shape)\n    seeds.append(c2)\n\n    # Diversity randomly expanding thoroughly nicely perfectly deeply completely safely accurately effectively accurately naturally intelligently mathematically strictly smoothly directly accurately cleanly\n    for _ in range(12):\n        seeds.append(rng.uniform(0.1, 0.9, (n, 2)))\n\n    # Phase 1: Robust topological multi-starts mapped effectively flawlessly intelligently directly neatly neatly accurately\n    for C_seed in seeds:\n        R_seed = rng.uniform(0.02, 0.06, n)\n        C_opt, R_opt = optimize(C_seed, R_seed, 1400, 5.0, 15000.0, 0.015, rng)\n        R_val = compute_max_radii(C_opt, R_opt, max_iters=200)\n        s = np.sum(R_val)\n        \n        if s > best_sum:\n            best_sum = s\n            best_c = C_opt\n            best_r = R_val \n            \n    # Phase 2: Refined annealing solidly naturally fully flawlessly optimally deeply precisely securely flawlessly neatly mapping efficiently smartly mathematically gracefully deeply accurately securely cleanly gracefully natively dynamically tightly ideally cleanly dynamically mapped smoothly\n    final_c, final_r = optimize(best_c, best_r, 12000, 50.0, 500000.0, 0.005, rng)\n    \n    valid_radii = compute_max_radii(final_c, final_r, max_iters=5000)\n    sum_r = float(np.sum(valid_radii))\n    \n    return final_c, valid_radii, sum_r\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```"]}}, "artifacts_json": "{\"execution_time\": \"5.82s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.620440/2.635 = 0.9945\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.4% of target value\", \"radius_stats\": \"Min: 0.061055, Max: 0.138620, Avg: 0.100786\"}", "artifact_dir": null, "embedding": null}