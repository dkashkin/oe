{"id": "e1b8924e-b53a-43e5-bc88-15e2745e66d9", "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    This provides an extremely fast way to screen thousands of center arrangements.\n    \"\"\"\n    # Objective: Maximize the sum of radii (minimize -sum(r))\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2))\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    limits = np.min(np.hstack([P, 1.0 - P]), axis=1)\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives: d/dx1 [(x1-x2)^2 + ... - (r1+r2)^2] = 2(x1-x2)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(1337)\n    seeds = []\n    \n    # 1. Structural Seed Generation: Diversified Row & Grid Patterns for n=26\n    configs = [\n        [5, 6, 5, 6, 4], [6, 7, 7, 6], [5, 5, 6, 5, 5], \n        [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3], [5, 5, 5, 5, 5, 1]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.095, 0.11]:\n            for stagger in [0.0, 0.015, 0.03]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1:\n                        x_vals = np.clip(x_vals + stagger, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                if len(pts) >= n: seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.51, 0.54]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    for grid_m in [0.09, 0.1, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(grid_m, 1-grid_m, 5), np.linspace(grid_m, 1-grid_m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.02, 0.5], [0.5, 0.98]]:\n            seeds.append(np.vstack([grid25, extra]))\n\n    # Symmetric seeds (Point and Mirror)\n    for _ in range(8):\n        h = n // 2\n        p1 = np.random.rand(h, 2)\n        # Mirror x-axis\n        p2 = p1.copy()\n        p2[:, 0] = 1.0 - p2[:, 0]\n        seeds.append(np.vstack([p1, p2]))\n        # Central point symmetry\n        p3 = 1.0 - p1\n        seeds.append(np.vstack([p1, p3]))\n\n    # Repulsion-based seeds\n    for power in [2.0, 4.0]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**((power+1)/2))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Screening Top Candidates via LP\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            results.append((score, s_cl, radii))\n    \n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Non-linear Refinement\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_obj = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Optimize top candidates from screening\n    for i in range(min(24, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.998])\n        res = minimize(obj_fn, x0, jac=jac_obj, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-13})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Deep local search to breakthrough plateaus)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00002]:\n            for _ in range(2):\n                x_jitter = best_v.copy()\n                x_jitter[:2*n] += np.random.normal(0, scale, 2*n)\n                x_jitter[2*n:] *= 0.999 # Shrink slightly to maintain feasibility\n                res = minimize(obj_fn, x_jitter, jac=jac_obj, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Final construction with a tiny safety buffer for machine precision validity\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the 26-circle packing optimizer.\"\"\"\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "bbd91099-53bf-4108-92e6-436da71cf225", "generation": 5, "timestamp": 1771631117.0303037, "iteration_found": 98, "metrics": {"validity": 1.0, "sum_radii": 2.6292543118585674, "target_ratio": 0.9978194731911072, "combined_score": 0.9978194731911072, "radius_variance": 0.005189456890723567, "spatial_spread": 0.19540793320188302, "eval_time": 5.333369731903076}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.631093589098101, "target_ratio": 0.9985174911188239, "combined_score": 0.9985174911188239, "radius_variance": 0.0055518940475694145, "spatial_spread": 0.19740718412430547, "eval_time": 4.254320383071899}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9985\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.9970 \u2192 0.9985\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n4.25s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.631094/2.635 = 0.9985\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.9% of target value\n```\n\n### radius_stats\n```\nMin: 0.072841, Max: 0.131818, Avg: 0.101196\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 5.1109\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 8.5302\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6311, target_ratio: 0.9985, combined_score: 0.9985, radius_variance: 0.0056, spatial_spread: 0.1974, eval_time: 4.2543\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    This provides a fast way to screen thousands of center arrangements.\n    \"\"\"\n    # Objective: Maximize the sum of radii (minimize -sum(r))\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    limits = np.minimum(np.minimum(P[:, 0], 1.0 - P[:, 0]), \n                        np.minimum(P[:, 1], 1.0 - P[:, 1]))\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Efficient vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(1337)\n    seeds = []\n    \n    # 1. Broad Seed Generation Strategy\n    # Staggered patterns tuned for n=26\n    configs = [\n        [5, 6, 5, 6, 4], [6, 7, 7, 6], [5, 5, 6, 5, 5], \n        [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3], [5, 5, 5, 5, 5, 1]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.10, 0.115]:\n            for stagger in [0.0, 0.015, 0.03]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1:\n                        x_vals = np.clip(x_vals + stagger, 0.01, 0.99)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.51, 0.54]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    for grid_m in [0.09, 0.1, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(grid_m, 1-grid_m, 5), np.linspace(grid_m, 1-grid_m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.02, 0.5], [0.5, 0.98]]:\n            seeds.append(np.vstack([grid25, extra]))\n\n    # Power-law repulsion seeds\n    for power in [1.5, 2.0, 3.0]:\n        for _ in range(10):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**((power+1)/2))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Screening Top Candidates via LP\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            results.append((score, s_cl, radii))\n    \n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Non-linear Refinement\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_obj = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Optimize top candidates from screening\n    for i in range(min(25, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.997])\n        res = minimize(obj_fn, x0, jac=jac_obj, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Local search to break through plateaus)\n    if best_v is not None:\n        for scale in [0.0004, 0.0001, 0.00005]:\n            for _ in range(3):\n                # Apply small perturbations to centers and radii and re-polish\n                x_jitter = best_v.copy()\n                x_jitter[:2*n] += np.random.normal(0, scale, 2*n)\n                x_jitter[2*n:] *= 0.998 # Shrink slightly to maintain feasibility\n                res = minimize(obj_fn, x_jitter, jac=jac_obj, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Final construction with a tiny safety buffer for validity\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (6.3702)\n\n### Program 2 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral, Symmetry)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3]]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.02 * (np.random.rand()-0.5), m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals and axial symmetry\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_clip = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clip, n)\n        if radii is not None: results.append((score, s_clip, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(22, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.98]) # start slightly smaller to allow movement\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Jitter and Polish\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-7, 0.45)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-14})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-14 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (4.2543)\n\n### Program 3 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances for overlap constraints\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= distance to the nearest edge\n    limits = np.minimum(np.minimum(P[:, 0], 1.0 - P[:, 0]), \n                        np.minimum(P[:, 1], 1.0 - P[:, 1]))\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seed Generation\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], \n        [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3], [4, 4, 5, 5, 4, 4]\n    ]\n    for cfg in configs:\n        for m in [0.075, 0.085, 0.095, 0.105]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.018, 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds (hard-sphere simulation)\n    for force_p in [2.0, 4.0]:\n        for _ in range(10):\n            p = np.random.rand(n, 2)\n            for _ in range(50):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # Grid 5x5 variations\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.02, 0.5], [0.5, 0.02]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # 2. Fast LP Screening\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Polish for top performers\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(22, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        # Start with radii slightly smaller to ensure initial feasibility\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.998])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Final Jitter Polish (Local search to escape plateaus)\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(3):\n                x_jitter = best_v + (np.random.normal(0, scale, 3 * n))\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-13, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (8.5302)\n\n### Program 4 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= d_ij\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    seeds = []\n    \n    # Staggered Row patterns specifically tuned for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seeds with varying scaling\n    for scale in [0.45, 0.47, 0.49]:\n        phi = (np.sqrt(5) + 1) / 2\n        indices = np.arange(0, n) + 0.5\n        rad_s = np.sqrt(indices / n)\n        theta = 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * rad_s * np.cos(theta), 0.5 + scale * rad_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.02, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # Randomized repulsion-based seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.015 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the top candidates found in screening\n    for i in range(min(18, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search Jitter (Simulated Annealing step)\n    if best_v is not None:\n        for scale in [0.0008, 0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                # Keep radii positive after jitter\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-6, 0.5)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 400, 'ftol': 1e-13}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (5.1109)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP optimization: No overlaps and boundary-stay.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Patterns (Staggered rows and shifted grids)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.018, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Grid 5x5 + extra point strategies\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.98, 0.5]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # Sunflower spirals\n    phi = (np.sqrt(5) + 1) / 2\n    for scale in [0.44, 0.47, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and Refinement\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(np.clip(s, 0.001, 0.999), n)\n        if radii is not None: results.append((score, np.clip(s, 0.001, 0.999), radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(14, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Polish best result\n    if best_v is not None:\n        for scale in [0.0005, 0.0001]:\n            res = minimize(obj_fn, best_v + np.random.normal(0, scale, 3 * n), jac=jac_fn, method='SLSQP',\n                           bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                           constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                           options={'maxiter': 400, 'ftol': 1e-13})\n            if res.success and -res.fun > best_sum:\n                best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9969)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6], [4, 5, 4, 5, 4, 4]]\n    for cfg in configs:\n        for m in [0.08, 0.10]:\n            for shift in [0, 0.015, -0.015]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1: x_vals = np.clip(x_vals + shift, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point strategies\n    for m in [0.09, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.005, 0.995)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Refine top candidates\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Basin-Hopping Jitter and High-Precision Polish\n    if best_v is not None:\n        for scale in [0.0003, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-12 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9970, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP optimization: No overlaps and boundary-stay.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Patterns (Staggered rows and shifted grids)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.018, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Grid 5x5 + extra point strategies\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.98, 0.5]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # Sunflower spirals\n    phi = (np.sqrt(5) + 1) / 2\n    for scale in [0.44, 0.47, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and Refinement\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(np.clip(s, 0.001, 0.999), n)\n        if radii is not None: results.append((score, np.clip(s, 0.001, 0.999), radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(14, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Polish best result\n    if best_v is not None:\n        for scale in [0.0005, 0.0001]:\n            res = minimize(obj_fn, best_v + np.random.normal(0, scale, 3 * n), jac=jac_fn, method='SLSQP',\n                           bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                           constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                           options={'maxiter': 400, 'ftol': 1e-13})\n            if res.success and -res.fun > best_sum:\n                best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9912, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-16)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    ii, jj = np.triu_indices(n, k=1)\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    bounds = [(0, max(0.0, float(min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1])))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    ii, jj = np.triu_indices(n, k=1)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Tuned Row configurations)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.10]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.02 * (np.random.rand()-0.5), 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # 2. Grid-based structures (5x5 + extra point in various positions)\n    for m in [0.09, 0.10, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [m, m], [1-m, 1-m], [0.5, m], [m, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # 3. Fibonacci/Sunflower Spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # 4. Repulsion Force Simulation\n    for force_p in [2.0, 3.5]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(45):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                p = np.clip(p + 0.012 * np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1), 0.005, 0.995)\n            seeds.append(p)\n\n    # 5. Screening with LP\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 6. SLSQP Refinement\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(28, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 800, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 7. Final Multi-scale Jitter Polish\n    if best_v is not None:\n        for scale in [0.0002, 0.00005]:\n            for _ in range(3):\n                x_jit = best_v + np.random.normal(0, scale, 3 * n)\n                x_jit[2*n:] = np.clip(x_jit[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jit, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-16)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the 26-circle packing optimizer.\"\"\"\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9969, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6], [4, 5, 4, 5, 4, 4]]\n    for cfg in configs:\n        for m in [0.08, 0.10]:\n            for shift in [0, 0.015, -0.015]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1: x_vals = np.clip(x_vals + shift, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point strategies\n    for m in [0.09, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.005, 0.995)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Refine top candidates\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Basin-Hopping Jitter and High-Precision Polish\n    if best_v is not None:\n        for scale in [0.0003, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-12 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.9915, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    This provides a fast screening method to evaluate the potential of a seed arrangement.\n    \"\"\"\n    # Objective: Maximize sum of radii, so minimize -1 * sum(radii)\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances between centers\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    # Overlap constraints: r_i + r_j <= distance(C_i, C_j)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to nearest edge\n    # Use max(0, ...) to ensure bounds are valid if center is slightly outside due to jitter\n    bounds = [(0, max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        # Use 'highs' method for efficiency\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. No overlaps: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Within square: x_i - r_i >= 0, 1 - x_i - r_i >= 0, etc.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    \n    # Pairwise overlap constraints\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    overlaps = d2[mask] - r_sum2[mask]\n    \n    # Boundary constraints\n    b_x1 = x - r\n    b_x2 = 1.0 - x - r\n    b_y1 = y - r\n    b_y2 = 1.0 - y - r\n    \n    return np.concatenate([overlaps, b_x1, b_x2, b_y1, b_y2])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives: d/dxi ((xi-xj)^2 + ...) = 2(xi-xj)\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    \n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    # x - r >= 0\n    J[b_idx : b_idx + n, :n] = np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - x - r >= 0\n    J[b_idx : b_idx + n, :n] = -np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # y - r >= 0\n    J[b_idx : b_idx + n, n:2*n] = np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    b_idx += n\n    # 1 - y - r >= 0\n    J[b_idx : b_idx + n, n:2*n] = -np.eye(n)\n    J[b_idx : b_idx + n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Diverse Structural Seed Generation\n    seeds = []\n    \n    # Hexagonal and staggered row configurations designed for n=26\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.09, 0.11]: # Varying margins\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: # Shift alternate rows\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n            \n    # Fibonacci Spiral Seed (Sunflower)\n    phi = (1 + 5**0.5) / 2\n    idx = np.arange(n) + 0.5\n    r_fib = np.sqrt(idx / n) * 0.45\n    theta = 2 * np.pi * idx * phi\n    seeds.append(np.column_stack([0.5 + r_fib * np.cos(theta), 0.5 + r_fib * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-7\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.02 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening: Use LP to quickly find the best radii for fixed center patterns\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(s, n)\n        if radii is not None:\n            results.append((score, s, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refinement: Optimize both centers and radii for the top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the most promising seeds found in screening\n    for i in range(min(15, len(results))):\n        _, s_pts, s_rad = results[i]\n        # v = [x_0...x_n, y_0...y_n, r_0...r_n]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-11}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Jitter: Small perturbations to the best candidate to escape local plateaus\n    if best_v is not None:\n        for _ in range(2):\n            x_jitter = best_v + np.random.normal(0, 0.0008, 3 * n)\n            res = minimize(\n                objective, x_jitter, jac=jac_obj, method='SLSQP',\n                bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                options={'maxiter': 300, 'ftol': 1e-12}\n            )\n            if res.success and -res.fun > best_sum:\n                best_sum = -res.fun\n                best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity across machine precisions\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Entry point for the evaluator.\"\"\"\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral, Symmetry)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3]]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.02 * (np.random.rand()-0.5), m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals and axial symmetry\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_clip = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clip, n)\n        if radii is not None: results.append((score, s_clip, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(22, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.98]) # start slightly smaller to allow movement\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Jitter and Polish\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-7, 0.45)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-14})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-14 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    This provides an extremely fast way to screen thousands of center arrangements.\n    \"\"\"\n    # Objective: Maximize the sum of radii (minimize -sum(r))\n    c = -np.ones(n)\n    \n    # Calculate pairwise distances for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2))\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    limits = np.min(np.hstack([P, 1.0 - P]), axis=1)\n    bounds = [(0, max(0.0, lim)) for lim in limits]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives: d/dx1 [(x1-x2)^2 + ... - (r1+r2)^2] = 2(x1-x2)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives (vectorized blocks)\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(1337)\n    seeds = []\n    \n    # 1. Structural Seed Generation: Diversified Row & Grid Patterns for n=26\n    configs = [\n        [5, 6, 5, 6, 4], [6, 7, 7, 6], [5, 5, 6, 5, 5], \n        [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3], [5, 5, 5, 5, 5, 1]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.095, 0.11]:\n            for stagger in [0.0, 0.015, 0.03]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1:\n                        x_vals = np.clip(x_vals + stagger, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                if len(pts) >= n: seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.51, 0.54]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    for grid_m in [0.09, 0.1, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(grid_m, 1-grid_m, 5), np.linspace(grid_m, 1-grid_m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.02, 0.5], [0.5, 0.98]]:\n            seeds.append(np.vstack([grid25, extra]))\n\n    # Symmetric seeds (Point and Mirror)\n    for _ in range(8):\n        h = n // 2\n        p1 = np.random.rand(h, 2)\n        # Mirror x-axis\n        p2 = p1.copy()\n        p2[:, 0] = 1.0 - p2[:, 0]\n        seeds.append(np.vstack([p1, p2]))\n        # Central point symmetry\n        p3 = 1.0 - p1\n        seeds.append(np.vstack([p1, p3]))\n\n    # Repulsion-based seeds\n    for power in [2.0, 4.0]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**((power+1)/2))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Screening Top Candidates via LP\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            results.append((score, s_cl, radii))\n    \n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Non-linear Refinement\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_obj = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Optimize top candidates from screening\n    for i in range(min(24, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.998])\n        res = minimize(obj_fn, x0, jac=jac_obj, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-13})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Deep local search to breakthrough plateaus)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00002]:\n            for _ in range(2):\n                x_jitter = best_v.copy()\n                x_jitter[:2*n] += np.random.normal(0, scale, 2*n)\n                x_jitter[2*n:] *= 0.999 # Shrink slightly to maintain feasibility\n                res = minimize(obj_fn, x_jitter, jac=jac_obj, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 600, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Final construction with a tiny safety buffer for machine precision validity\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the 26-circle packing optimizer.\"\"\"\n    return run_packing()\n\n```"]}}, "artifacts_json": "{\"execution_time\": \"5.33s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.629254/2.635 = 0.9978\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.8% of target value\", \"radius_stats\": \"Min: 0.065712, Max: 0.126740, Avg: 0.101125\"}", "artifact_dir": null, "embedding": null}