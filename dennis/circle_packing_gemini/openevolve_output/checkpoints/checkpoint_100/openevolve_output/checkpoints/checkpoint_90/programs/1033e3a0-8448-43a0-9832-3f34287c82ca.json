{"id": "1033e3a0-8448-43a0-9832-3f34287c82ca", "code": "import numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    This provides the maximum possible sum of radii for a given center configuration.\n    \"\"\"\n    # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    \n    # Extract upper triangle indices for constraints\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = []\n    for i in range(n):\n        limit = max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))\n        bounds.append((0, limit))\n        \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary checks.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    # Returns 1D array of all ineq constraints (val >= 0)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx : b_idx+n, :n] = np.eye(n)          # x - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, :n] = -np.eye(n)         # 1 - x - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, n:2*n] = np.eye(n)       # y - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, n:2*n] = -np.eye(n)      # 1 - y - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grids, and Spirals)\n    # Target configurations for n=26\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], \n        [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3], [4, 4, 5, 5, 4, 4]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.1]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                # Stagger alternate rows\n                if r_idx % 2 == 1:\n                    shift = (1.0 - 2.0 * m) / (count - 1) / 2.0\n                    x_vals = np.clip(x_vals + shift, 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals with scaling variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for force_p in [1.5, 2.0, 3.0]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Fast LP Screening\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    # Sort and take the top candidates for full non-linear optimization\n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # 3. SLSQP Polish for top performers\n    for i in range(min(24, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.995])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 600, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Basin Hopping step)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00005]:\n            for _ in range(3):\n                # Apply small perturbations and re-optimize to escape local minima\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Extract final results with a microscopic safety buffer\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()", "changes_description": null, "language": "python", "parent_id": "ba9f59fc-0f06-4e87-a058-01b3a04f8de5", "generation": 6, "timestamp": 1771630214.204802, "iteration_found": 59, "metrics": {"validity": 1.0, "sum_radii": 2.62831532981783, "target_ratio": 0.9974631232705239, "combined_score": 0.9974631232705239, "radius_variance": 0.004914133895766568, "spatial_spread": 0.19101236503465352, "eval_time": 4.222204208374023}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6261647760640403, "target_ratio": 0.9966469738383456, "combined_score": 0.9966469738383456, "radius_variance": 0.00528875262201075, "spatial_spread": 0.19558118152938833, "eval_time": 6.2878570556640625}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. We're trying to reach the AlphaEvolve target of 2.635 for the sum of radii when packing 26 circles in a unit square. The current implementation has plateaued at 2.377, so we need significant improvements.\n\nKey insights to explore:\n1. The optimal arrangement likely involves variable-sized circles\n2. A pure hexagonal arrangement may not be optimal due to edge effects\n3. The densest known circle packings often use a hybrid approach\n4. The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n5. Consider strategic placement of circles at square corners and edges\n6. Adjusting the pattern to place larger circles at the center and smaller at the edges\n7. The math literature suggests special arrangements for specific values of n\n\nFocus on breaking through the plateau by trying fundamentally different approaches - don't just tweak parameters.\n", "user": "# Current Program Information\n- Fitness: 0.9966\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9970 \u2192 0.9966. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n6.29s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.626165/2.635 = 0.9966\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.7% of target value\n```\n\n### radius_stats\n```\nMin: 0.069677, Max: 0.131285, Avg: 0.101006\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 4\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 3.7713\n- Outcome: Mixed results\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 2.9266\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6270, target_ratio: 0.9970, combined_score: 0.9970, radius_variance: 0.0055, spatial_spread: 0.1940, eval_time: 5.1109\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9985)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral, Symmetry)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3]]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.02 * (np.random.rand()-0.5), m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals and axial symmetry\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_clip = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clip, n)\n        if radii is not None: results.append((score, s_clip, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(22, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.98]) # start slightly smaller to allow movement\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Jitter and Polish\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-7, 0.45)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-14})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-14 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6311), Performs well on target_ratio (0.9985), Performs well on combined_score (0.9985), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1974), Performs well on eval_time (4.2543)\n\n### Program 2 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= d_ij\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-12)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"\n    Vectorized constraints for SLSQP optimization:\n    1. Overlap: d_ij^2 - (r_i + r_j)^2 >= 0\n    2. Boundary: x_i - r_i >= 0, 1 - x_i - r_i >= 0, y_i - r_i >= 0, 1 - y_i - r_i >= 0\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        d2[mask] - r_sum2[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"\n    Highly efficient vectorized Jacobian for the constraint set.\n    \"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    # Overlap derivatives\n    dx = x[ii] - x[jj]\n    dy = y[ii] - y[jj]\n    rs = r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii] = 2 * dx\n    J[idx, jj] = -2 * dx\n    J[idx, n + ii] = 2 * dy\n    J[idx, n + jj] = -2 * dy\n    J[idx, 2 * n + ii] = -2 * rs\n    J[idx, 2 * n + jj] = -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx:b_idx+n, :n] = np.eye(n) # x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, :n] = -np.eye(n) # 1-x-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = np.eye(n) # y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    b_idx += n\n    J[b_idx:b_idx+n, n:2*n] = -np.eye(n) # 1-y-r\n    J[b_idx:b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Structural Seed Generation\n    seeds = []\n    \n    # Staggered Row patterns specifically tuned for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6],\n        [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3]\n    ]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (num_rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral seeds with varying scaling\n    for scale in [0.45, 0.47, 0.49]:\n        phi = (np.sqrt(5) + 1) / 2\n        indices = np.arange(0, n) + 0.5\n        rad_s = np.sqrt(indices / n)\n        theta = 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * rad_s * np.cos(theta), 0.5 + scale * rad_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point in various regions\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for extra in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.02, 0.5]]:\n        seeds.append(np.vstack([grid25, extra]))\n\n    # Randomized repulsion-based seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, np.newaxis, :] - p[np.newaxis, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            f = np.sum(diff / d2[:, :, np.newaxis], axis=1)\n            p = np.clip(p + 0.015 * f, 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Filter seeds using LP (Center evaluation)\n    results = []\n    for s in seeds:\n        s_clipped = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clipped, n)\n        if radii is not None:\n            results.append((score, s_clipped, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refine top candidates using SLSQP\n    best_v = None\n    best_sum = 0\n    \n    def objective(v):\n        return -np.sum(v[2*n:])\n    \n    def jac_obj(v):\n        j = np.zeros(3*n)\n        j[2*n:] = -1.0\n        return j\n\n    # Polishing the top candidates found in screening\n    for i in range(min(18, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        \n        res = minimize(\n            objective, x0, jac=jac_obj, method='SLSQP',\n            bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n            constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n            options={'maxiter': 500, 'ftol': 1e-12}\n        )\n        \n        if res.success and -res.fun > best_sum:\n            best_sum = -res.fun\n            best_v = res.x\n\n    # 4. Final Local Search Jitter (Simulated Annealing step)\n    if best_v is not None:\n        for scale in [0.0008, 0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                # Keep radii positive after jitter\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-6, 0.5)\n                res = minimize(\n                    objective, x_jitter, jac=jac_obj, method='SLSQP',\n                    bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                    constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                    options={'maxiter': 400, 'ftol': 1e-13}\n                )\n                if res.success and -res.fun > best_sum:\n                    best_sum = -res.fun\n                    best_v = res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    # Apply a tiny safety buffer to ensure validity\n    final_radii = best_v[2*n:] - 1e-12\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (5.1109)\n\n### Program 3 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP optimization: No overlaps and boundary-stay.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Patterns (Staggered rows and shifted grids)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.018, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Grid 5x5 + extra point strategies\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.98, 0.5]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # Sunflower spirals\n    phi = (np.sqrt(5) + 1) / 2\n    for scale in [0.44, 0.47, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and Refinement\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(np.clip(s, 0.001, 0.999), n)\n        if radii is not None: results.append((score, np.clip(s, 0.001, 0.999), radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(14, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Polish best result\n    if best_v is not None:\n        for scale in [0.0005, 0.0001]:\n            res = minimize(obj_fn, best_v + np.random.normal(0, scale, 3 * n), jac=jac_fn, method='SLSQP',\n                           bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                           constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                           options={'maxiter': 400, 'ftol': 1e-13})\n            if res.success and -res.fun > best_sum:\n                best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (2.9266)\n\n### Program 4 (Score: 0.9970)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    # Objective: Maximize sum of radii\n    c = -np.ones(n)\n    \n    # Pairwise distances for overlap constraints: r_i + r_j <= d_ij\n    dists = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dists[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i == 0: J[slc, :n] = np.eye(n) # x-r\n        elif i == 1: J[slc, :n] = -np.eye(n) # 1-x-r\n        elif i == 2: J[slc, n:2*n] = np.eye(n) # y-r\n        else: J[slc, n:2*n] = -np.eye(n) # 1-y-r\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Patterns (Staggered rows and grid configurations)\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7],\n        [5, 5, 5, 5, 6], [4, 4, 5, 5, 4, 4], [3, 4, 6, 6, 4, 3],\n        [4, 4, 4, 4, 5, 5]\n    ]\n    for cfg in configs:\n        for m in [0.075, 0.085, 0.095, 0.105]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.018, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci / Sunflower spiral\n    phi = (np.sqrt(5) + 1) / 2\n    for scale in [0.44, 0.46, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point variations\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.98, 0.5]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening: LP evaluation\n    results = []\n    for s in seeds:\n        s_clip = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clip, n)\n        if radii is not None: results.append((score, s_clip, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. Refinement: SLSQP Optimization\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Basin Hopping / Jitter: Final Polishing\n    if best_v is not None:\n        for scale in [0.0006, 0.0002]:\n            for _ in range(2):\n                x_jitter = best_v + np.random.normal(0, scale, 3 * n)\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-6, 0.5)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-13})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11 # Safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6270), Performs well on target_ratio (0.9970), Performs well on combined_score (0.9970), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1940), Performs well on eval_time (3.7713)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9966)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates the optimal radii for a fixed set of centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    # Pairwise distances for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to the nearest edge\n    bounds = [(1e-12, max(1e-12, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary checks.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    # Returns 1D array of all ineq constraints (val >= 0)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    # d/dx (dx^2) = 2*dx\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n) # x or 1-x\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)  # y or 1-y\n        J[slc, 2*n:] = -np.eye(n) # always -r\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Broad Seed Generation: Row-based patterns for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], \n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3],\n        [4, 4, 5, 5, 4, 4], [2, 4, 6, 6, 5, 3], [4, 4, 4, 5, 5, 4], [3, 4, 5, 6, 5, 3]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.09, 0.1, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                # Stagger alternate rows with a bit of noise\n                if r_idx % 2 == 1:\n                    shift = (1.0 - 2.0 * m) / (count - 1) / 2.0\n                    x_vals = np.clip(x_vals + shift * (1.0 + 0.1 * np.random.randn()), 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Symmetry-based seeds (4-fold + axis fillers)\n    for m in [0.08, 0.1]:\n        p6 = np.random.rand(6, 2) * 0.4 + 0.05\n        s1 = p6\n        s2 = np.column_stack([1-p6[:,0], p6[:,1]])\n        s3 = np.column_stack([p6[:,0], 1-p6[:,1]])\n        s4 = np.column_stack([1-p6[:,0], 1-p6[:,1]])\n        seeds.append(np.vstack([s1, s2, s3, s4, [[0.5, 0.3], [0.5, 0.7]]]))\n\n    # Repulsion-based seeds\n    for force_exp in [1, 2]:\n        for _ in range(8):\n            p = np.random.rand(n, 2)\n            for _ in range(45):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-8\n                if force_exp == 1:\n                    p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n                else:\n                    p = np.clip(p + 0.008 * np.sum(diff / (d2**1.5)[:, :, None], axis=1), 0.01, 0.99)\n            seeds.append(p)\n\n    # 2. Fast LP Screening\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Polish for top candidates\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(26, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Final Multi-scale Jitter on the absolute best to escape local plateaus\n    if best_v is not None:\n        for scale in [0.0004, 0.0001, 0.00005]:\n            for _ in range(3):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-12) # Precision buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9969)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6], [4, 5, 4, 5, 4, 4]]\n    for cfg in configs:\n        for m in [0.08, 0.10]:\n            for shift in [0, 0.015, -0.015]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1: x_vals = np.clip(x_vals + shift, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point strategies\n    for m in [0.09, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.005, 0.995)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Refine top candidates\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Basin-Hopping Jitter and High-Precision Polish\n    if best_v is not None:\n        for scale in [0.0003, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-12 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nAn excellent way to break through the plateau in variable-size circle packing is to use a heavily physics-inspired **continuation penalty method**. \n\nInstead of relying on SLSQP to do the heavy lifting from fixed LP-solved radii, we can implement an unconstrained L-BFGS-B optimization that optimizes both the circle centers and their radii *simultaneously*. We use an overlap/boundary penalty that starts small (allowing circles to grow and easily push past each other to escape local minima) and exponentially increases to enforce strict feasibility. \n\nCoupled with vectorized analytical gradients, this runs blazingly fast\u2014allowing us to evaluate hundreds of distinct structural, symmetric, and stochastic seeds in just a few seconds before finishing off the top performers with strictly-constrained SLSQP.\n\n### Rewritten Program\n\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport time\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for 26 circles in a unit square.\n    \n    Strategy:\n    1. Diverse Seed Generation: Generate a massive variety of starting structures \n       (Hexagonal rows, Boundaries, Rings, Grids, and Poisson/Random sets).\n    2. Continuation Penalty Method (L-BFGS-B): Optimize both centers and radii simultaneously \n       using a highly vectorized L-BFGS-B with analytical gradients. We progressively increase \n       the penalty on overlap and boundary violations (from 10 to 1,000,000), simulating \n       \"inflation\" that forcefully drives circles into an optimal configuration.\n    3. Strict Refinement: Use SLSQP (also with vectorized Jacobians) on the best candidate \n       to refine any microscopic constraint tolerances perfectly.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    start_time = time.time()\n    \n    # 1. Extensive Structural Seed Generation\n    seeds = []\n    \n    # A. Row configurations (Staggered rows)\n    configs = [[5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], [4, 4, 4, 4, 5, 5]]\n    for cfg in configs:\n        for margin in [0.065, 0.085, 0.105]:\n            pts = []\n            num_rows = len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = margin + (1.0 - 2.0 * margin) * r_idx / max(1, num_rows - 1)\n                x_vals = np.linspace(margin, 1.0 - margin, count)\n                if r_idx % 2 == 1:\n                    x_vals = np.clip(x_vals + 0.02, margin/2, 1.0 - margin/2)\n                for x in x_vals:\n                    pts.append([x, y])\n            pts = np.array(pts[:n])\n            seeds.append(pts)\n            for _ in range(2): # Add spatial jitter\n                p = pts + np.random.randn(*pts.shape) * 0.015\n                seeds.append(np.clip(p, 0, 1))\n                \n    # B. Boundary-heavy emphasis\n    for k in [2, 3\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9969, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP: Overlap (d^2 - (r1+r2)^2 >= 0) and boundary check.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grid-based, Spiral)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6], [4, 5, 4, 5, 4, 4]]\n    for cfg in configs:\n        for m in [0.08, 0.10]:\n            for shift in [0, 0.015, -0.015]:\n                pts, rows = [], len(cfg)\n                for r_idx, count in enumerate(cfg):\n                    y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                    x_vals = np.linspace(m, 1.0 - m, count)\n                    if r_idx % 2 == 1: x_vals = np.clip(x_vals + shift, m/2, 1.0 - m/2)\n                    for x in x_vals: pts.append([x, y])\n                seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.45, 0.48, 0.50]:\n        idx_range = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(idx_range / n), 2 * np.pi * idx_range * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Grid 5x5 + extra point strategies\n    for m in [0.09, 0.11]:\n        gx, gy = np.meshgrid(np.linspace(m, 1-m, 5), np.linspace(m, 1-m, 5))\n        grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n        for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.5]]:\n            seeds.append(np.vstack([grid25, ex]))\n\n    # Repulsion-based seeds\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(45):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-9\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.005, 0.995)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None: results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # Refine top candidates\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Basin-Hopping Jitter and High-Precision Polish\n    if best_v is not None:\n        for scale in [0.0003, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-12 # Minimal safety buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, None, :] - P[None, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i], A_ub[idx, j], idx = 1.0, 1.0, idx + 1\n            \n    b_ub = dist_matrix[np.triu_indices(n, k=1)]\n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success: return res.x, -res.fun\n    except: pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps and square boundary.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, None] - x[None, :]\n    dy = y[:, None] - y[None, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, None] + r[None, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n, np.random.seed(42) = 26, 42\n    seeds = []\n    \n    # 1. Structural Seeds (Varied row configurations)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 5, 4, 5, 4, 4], [3, 4, 6, 6, 4, 3], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.015, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Sunflower spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.44, 0.47, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Randomized repulsion\n    for _ in range(12):\n        p = np.random.rand(n, 2)\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and SLSQP Polish\n    results = []\n    for s in seeds:\n        s_clip = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_clip, n)\n        if radii is not None: results.append((score, s_clip, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(20, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Final Multi-scale Refinement\n    if best_v is not None:\n        for scale in [0.0004, 0.0001]:\n            for _ in range(2):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 400, 'ftol': 1e-14})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    return np.column_stack((best_v[:n], best_v[n:2*n])), best_v[2*n:] - 1e-14, float(best_sum)\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 4 (Score: 0.9970, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for fixed centers using Linear Programming.\n    Provides a fast way to screen a large number of center arrangements.\n    \"\"\"\n    c = -np.ones(n)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    bounds = [(0, max(0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success and res.x is not None:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints for SLSQP optimization: No overlaps and boundary-stay.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    \n    return np.concatenate([\n        (d2 - r_sum2)[mask],\n        x - r, 1.0 - x - r,\n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for the constraint set.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n)\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)\n        J[slc, 2*n:] = -np.eye(n)\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Patterns (Staggered rows and shifted grids)\n    configs = [[6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6]]\n    for cfg in configs:\n        for m in [0.08, 0.09, 0.10, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                if r_idx % 2 == 1: x_vals = np.clip(x_vals + 0.018, m/2, 1.0 - m/2)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Grid 5x5 + extra point strategies\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    grid25 = np.column_stack([gx.ravel(), gy.ravel()])\n    for ex in [[0.5, 0.5], [0.02, 0.02], [0.98, 0.98], [0.5, 0.02], [0.98, 0.5]]:\n        seeds.append(np.vstack([grid25, ex]))\n\n    # Sunflower spirals\n    phi = (np.sqrt(5) + 1) / 2\n    for scale in [0.44, 0.47, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion seeds\n    for _ in range(15):\n        p = np.random.rand(n, 2)\n        for _ in range(35):\n            diff = p[:, None, :] - p[None, :, :]\n            d2 = np.sum(diff**2, axis=-1) + 1e-8\n            p = np.clip(p + 0.015 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n        seeds.append(p)\n\n    # 2. Screening and Refinement\n    results = []\n    for s in seeds:\n        radii, score = solve_lp(np.clip(s, 0.001, 0.999), n)\n        if radii is not None: results.append((score, np.clip(s, 0.001, 0.999), radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(14, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 3. Polish best result\n    if best_v is not None:\n        for scale in [0.0005, 0.0001]:\n            res = minimize(obj_fn, best_v + np.random.normal(0, scale, 3 * n), jac=jac_fn, method='SLSQP',\n                           bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                           constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                           options={'maxiter': 400, 'ftol': 1e-13})\n            if res.success and -res.fun > best_sum:\n                best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = best_v[2*n:] - 1e-11\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    return run_packing()\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"Calculates the optimal radii for a fixed set of centers using Linear Programming.\"\"\"\n    c = -np.ones(n)\n    # Pairwise distances for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    dist_matrix = np.sqrt(np.sum((P[:, np.newaxis, :] - P[np.newaxis, :, :])**2, axis=2) + 1e-15)\n    \n    num_overlap = n * (n - 1) // 2\n    A_ub = np.zeros((num_overlap, n))\n    b_ub = np.zeros(num_overlap)\n    idx = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[idx, i] = 1.0\n            A_ub[idx, j] = 1.0\n            b_ub[idx] = dist_matrix[i, j]\n            idx += 1\n            \n    # Boundary constraints: r_i <= distance to the nearest edge\n    bounds = [(1e-12, max(1e-12, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))) for i in range(n)]\n    \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary checks.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    # Returns 1D array of all ineq constraints (val >= 0)\n    return np.concatenate([(d2 - r_sum2)[mask], x - r, 1.0 - x - r, y - r, 1.0 - y - r])\n\ndef get_jacobian(v, n):\n    \"\"\"Highly efficient vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    num_overlap = n * (n - 1) // 2\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    ii, jj = np.where(mask)\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    # d/dx (dx^2) = 2*dx\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    for i in range(4):\n        slc = slice(b_idx, b_idx + n)\n        if i < 2: J[slc, :n] = np.eye(n) if i == 0 else -np.eye(n) # x or 1-x\n        else: J[slc, n:2*n] = np.eye(n) if i == 2 else -np.eye(n)  # y or 1-y\n        J[slc, 2*n:] = -np.eye(n) # always -r\n        b_idx += n\n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Broad Seed Generation: Row-based patterns for n=26\n    configs = [\n        [6, 7, 7, 6], [5, 5, 6, 5, 5], [4, 6, 6, 6, 4], [5, 6, 5, 6, 4], \n        [4, 5, 4, 5, 4, 4], [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3],\n        [4, 4, 5, 5, 4, 4], [2, 4, 6, 6, 5, 3], [4, 4, 4, 5, 5, 4], [3, 4, 5, 6, 5, 3]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.08, 0.09, 0.1, 0.11]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                # Stagger alternate rows with a bit of noise\n                if r_idx % 2 == 1:\n                    shift = (1.0 - 2.0 * m) / (count - 1) / 2.0\n                    x_vals = np.clip(x_vals + shift * (1.0 + 0.1 * np.random.randn()), 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Symmetry-based seeds (4-fold + axis fillers)\n    for m in [0.08, 0.1]:\n        p6 = np.random.rand(6, 2) * 0.4 + 0.05\n        s1 = p6\n        s2 = np.column_stack([1-p6[:,0], p6[:,1]])\n        s3 = np.column_stack([p6[:,0], 1-p6[:,1]])\n        s4 = np.column_stack([1-p6[:,0], 1-p6[:,1]])\n        seeds.append(np.vstack([s1, s2, s3, s4, [[0.5, 0.3], [0.5, 0.7]]]))\n\n    # Repulsion-based seeds\n    for force_exp in [1, 2]:\n        for _ in range(8):\n            p = np.random.rand(n, 2)\n            for _ in range(45):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-8\n                if force_exp == 1:\n                    p = np.clip(p + 0.012 * np.sum(diff / d2[:, :, None], axis=1), 0.01, 0.99)\n                else:\n                    p = np.clip(p + 0.008 * np.sum(diff / (d2**1.5)[:, :, None], axis=1), 0.01, 0.99)\n            seeds.append(p)\n\n    # 2. Fast LP Screening\n    results = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            results.append((score, s_cl, radii))\n    results.sort(key=lambda x: x[0], reverse=True)\n    \n    # 3. SLSQP Polish for top candidates\n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    for i in range(min(26, len(results))):\n        _, s_pts, s_rad = results[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.99])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 500, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Final Multi-scale Jitter on the absolute best to escape local plateaus\n    if best_v is not None:\n        for scale in [0.0004, 0.0001, 0.00005]:\n            for _ in range(3):\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-8, 0.48)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-12) # Precision buffer\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\ndef solve_lp(P, n):\n    \"\"\"\n    Calculates the optimal radii for a fixed set of centers using Linear Programming.\n    This provides the maximum possible sum of radii for a given center configuration.\n    \"\"\"\n    # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n    c = -np.ones(n)\n    \n    # Pairwise distance matrix for overlap constraints: r_i + r_j <= distance(P_i, P_j)\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=2) + 1e-18)\n    \n    # Extract upper triangle indices for constraints\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    \n    A_ub = np.zeros((num_overlap, n))\n    A_ub[np.arange(num_overlap), ii] = 1.0\n    A_ub[np.arange(num_overlap), jj] = 1.0\n    b_ub = dist_matrix[ii, jj]\n    \n    # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n    bounds = []\n    for i in range(n):\n        limit = max(0.0, min(P[i, 0], 1.0 - P[i, 0], P[i, 1], 1.0 - P[i, 1]))\n        bounds.append((0, limit))\n        \n    try:\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0\n\ndef get_constraints(v, n):\n    \"\"\"Vectorized constraints: No overlaps (d^2 - (r1+r2)^2 >= 0) and square boundary checks.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    dx = x[:, np.newaxis] - x[np.newaxis, :]\n    dy = y[:, np.newaxis] - y[np.newaxis, :]\n    d2 = dx**2 + dy**2\n    r_sum2 = (r[:, np.newaxis] + r[np.newaxis, :])**2\n    mask = np.triu(np.ones((n, n), dtype=bool), k=1)\n    # Returns 1D array of all ineq constraints (val >= 0)\n    return np.concatenate([\n        (d2 - r_sum2)[mask], \n        x - r, 1.0 - x - r, \n        y - r, 1.0 - y - r\n    ])\n\ndef get_jacobian(v, n):\n    \"\"\"Vectorized Jacobian for overlap and boundary constraints.\"\"\"\n    x, y, r = v[:n], v[n:2*n], v[2*n:]\n    ii, jj = np.triu_indices(n, k=1)\n    num_overlap = len(ii)\n    J = np.zeros((num_overlap + 4 * n, 3 * n))\n    \n    dx, dy, rs = x[ii] - x[jj], y[ii] - y[jj], r[ii] + r[jj]\n    idx = np.arange(num_overlap)\n    \n    # Overlap derivatives\n    J[idx, ii], J[idx, jj] = 2 * dx, -2 * dx\n    J[idx, n + ii], J[idx, n + jj] = 2 * dy, -2 * dy\n    J[idx, 2 * n + ii], J[idx, 2 * n + jj] = -2 * rs, -2 * rs\n    \n    # Boundary derivatives\n    b_idx = num_overlap\n    J[b_idx : b_idx+n, :n] = np.eye(n)          # x - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, :n] = -np.eye(n)         # 1 - x - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, n:2*n] = np.eye(n)       # y - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    b_idx += n\n    J[b_idx : b_idx+n, n:2*n] = -np.eye(n)      # 1 - y - r\n    J[b_idx : b_idx+n, 2*n:] = -np.eye(n)\n    \n    return J\n\ndef run_packing():\n    n = 26\n    np.random.seed(42)\n    seeds = []\n    \n    # 1. Structural Seeds (Row-based, Grids, and Spirals)\n    # Target configurations for n=26\n    configs = [\n        [5, 5, 6, 5, 5], [6, 7, 7, 6], [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [6, 6, 7, 7], \n        [5, 5, 5, 5, 6], [3, 4, 6, 6, 4, 3], [4, 4, 5, 5, 4, 4]\n    ]\n    for cfg in configs:\n        for m in [0.07, 0.085, 0.1]:\n            pts, rows = [], len(cfg)\n            for r_idx, count in enumerate(cfg):\n                y = m + (1.0 - 2.0 * m) * r_idx / (rows - 1)\n                x_vals = np.linspace(m, 1.0 - m, count)\n                # Stagger alternate rows\n                if r_idx % 2 == 1:\n                    shift = (1.0 - 2.0 * m) / (count - 1) / 2.0\n                    x_vals = np.clip(x_vals + shift, 0.01, 0.99)\n                for x in x_vals: pts.append([x, y])\n            seeds.append(np.array(pts[:n]))\n\n    # Fibonacci spirals with scaling variations\n    phi = (1 + 5**0.5) / 2\n    for scale in [0.42, 0.45, 0.48, 0.50]:\n        indices = np.arange(n) + 0.5\n        r_s, theta = np.sqrt(indices / n), 2 * np.pi * indices * phi\n        seeds.append(np.column_stack([0.5 + scale * r_s * np.cos(theta), 0.5 + scale * r_s * np.sin(theta)]))\n\n    # Repulsion-based randomized seeds\n    for force_p in [1.5, 2.0, 3.0]:\n        for _ in range(12):\n            p = np.random.rand(n, 2)\n            for _ in range(40):\n                diff = p[:, None, :] - p[None, :, :]\n                d2 = np.sum(diff**2, axis=-1) + 1e-9\n                f = np.sum(diff / (d2**(force_p/2 + 0.5))[:, :, None], axis=1)\n                p = np.clip(p + 0.012 * f, 0.005, 0.995)\n            seeds.append(p)\n\n    # 2. Fast LP Screening\n    candidate_data = []\n    for s in seeds:\n        s_cl = np.clip(s, 0.001, 0.999)\n        radii, score = solve_lp(s_cl, n)\n        if radii is not None:\n            candidate_data.append((score, s_cl, radii))\n    \n    # Sort and take the top candidates for full non-linear optimization\n    candidate_data.sort(key=lambda x: x[0], reverse=True)\n    \n    best_v, best_sum = None, 0\n    obj_fn = lambda v: -np.sum(v[2*n:])\n    jac_fn = lambda v: np.concatenate([np.zeros(2*n), -np.ones(n)])\n\n    # 3. SLSQP Polish for top performers\n    for i in range(min(24, len(candidate_data))):\n        _, s_pts, s_rad = candidate_data[i]\n        x0 = np.concatenate([s_pts[:, 0], s_pts[:, 1], s_rad * 0.995])\n        res = minimize(obj_fn, x0, jac=jac_fn, method='SLSQP',\n                       bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                       constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                       options={'maxiter': 600, 'ftol': 1e-12})\n        if res.success and -res.fun > best_sum:\n            best_sum, best_v = -res.fun, res.x\n\n    # 4. Multi-scale Jitter Polish (Basin Hopping step)\n    if best_v is not None:\n        for scale in [0.0003, 0.0001, 0.00005]:\n            for _ in range(3):\n                # Apply small perturbations and re-optimize to escape local minima\n                x_jitter = best_v + (np.random.rand(3 * n) - 0.5) * scale\n                x_jitter[2*n:] = np.clip(x_jitter[2*n:], 1e-9, 0.49)\n                res = minimize(obj_fn, x_jitter, jac=jac_fn, method='SLSQP',\n                               bounds=[(0, 1)] * (2 * n) + [(0, 0.5)] * n,\n                               constraints={'type': 'ineq', 'fun': get_constraints, 'jac': get_jacobian, 'args': (n,)},\n                               options={'maxiter': 500, 'ftol': 1e-15})\n                if res.success and -res.fun > best_sum:\n                    best_sum, best_v = -res.fun, res.x\n\n    # Extract final results with a microscopic safety buffer\n    final_centers = np.column_stack((best_v[:n], best_v[n:2*n]))\n    final_radii = np.maximum(best_v[2*n:] - 1e-14, 1e-15)\n    return final_centers, final_radii, float(np.sum(final_radii))\n\ndef construct_packing():\n    \"\"\"Main entry point for the circle packing optimizer.\"\"\"\n    return run_packing()\n\n```"]}}, "artifacts_json": "{\"execution_time\": \"4.22s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.628315/2.635 = 0.9975\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.7% of target value\", \"radius_stats\": \"Min: 0.066415, Max: 0.136888, Avg: 0.101089\"}", "artifact_dir": null, "embedding": null}