{"id": "714ce42b-e2a7-49cb-99dd-45335623a3df", "code": "import numpy as np\nfrom scipy.optimize import linprog\n\n\"\"\"\nExpert Constructor-based Circle Packing for n=26 Circles in a Unit Square.\nThe goal is to maximize the sum of radii of 26 non-overlapping circles.\nThis implementation explores multiple high-potential geometric topologies (hexagonal rows, \nVogel spirals, and grid patterns), refines them using force-directed relaxation, \nand solves a Linear Programming (LP) problem for each arrangement to find the optimal \nset of radii that maximizes their sum.\n\"\"\"\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    \"\"\"\n    n = 26\n    \n    def solve_for_radii(centers):\n        \"\"\"\n        Calculates optimal radii for fixed centers by maximizing sum(r_i)\n        subject to non-overlap and boundary constraints.\n        \"\"\"\n        num = len(centers)\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c_lp = -np.ones(num)\n        \n        # Non-overlap constraints: r_i + r_j <= distance(c_i, c_j)\n        A_ub = []\n        b_ub = []\n        for i in range(num):\n            for j in range(i + 1, num):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                row = np.zeros(num)\n                row[i], row[j] = 1, 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints: r_i <= distance(c_i, square_walls)\n        # Using bounds parameter for better efficiency\n        bounds = []\n        for i in range(num):\n            x, y = centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max_r))\n        \n        try:\n            # Use HiGHS solver for speed and precision\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x\n        except Exception:\n            pass\n        return None\n\n    def relax_centers(pts, steps=180):\n        \"\"\"\n        Refines center positions using an iterative force-directed repulsion model.\n        Spreads points out to improve the potential for the subsequent LP optimization.\n        \"\"\"\n        pts = pts.copy()\n        for _ in range(steps):\n            f = np.zeros_like(pts)\n            for i in range(n):\n                # Inter-point repulsion (inverse-square law)\n                diff = pts[i] - pts\n                dist_sq = np.sum(diff**2, axis=1).reshape(-1, 1) + 1e-8\n                dist = np.sqrt(dist_sq)\n                f[i] += np.sum((diff / dist) * (0.001 / dist_sq), axis=0)\n                \n                # Boundary repulsion\n                f[i, 0] += 0.001 / (pts[i, 0]**2 + 1e-8) - 0.001 / ((1 - pts[i, 0])**2 + 1e-8)\n                f[i, 1] += 0.001 / (pts[i, 1]**2 + 1e-8) - 0.001 / ((1 - pts[i, 1])**2 + 1e-8)\n                \n            # Update positions with small step size\n            pts = np.clip(pts + 0.004 * f, 0.01, 0.99)\n        return pts\n\n    def generate_hex_seeds():\n        \"\"\"Generates diverse hexagonal-style layouts for n=26.\"\"\"\n        seeds = []\n        patterns = [\n            [5, 6, 5, 6, 4], [6, 5, 4, 5, 6], [5, 5, 6, 5, 5], \n            [4, 5, 4, 5, 4, 4], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6]\n        ]\n        for p in patterns:\n            pad = 0.09 if len(p) == 5 else 0.07\n            c = []\n            y_coords = np.linspace(pad, 1.0 - pad, len(p))\n            for i, count in enumerate(p):\n                # Apply stagger to create hexagonal geometry\n                offset = 0.04 if i % 2 == 1 else 0.0\n                x_coords = np.linspace(pad + offset, 1.0 - pad - offset, count)\n                for x in x_coords:\n                    c.append([x, y_coords[i]])\n            seeds.append(np.array(c)[:n])\n        return seeds\n\n    # 1. Define high-potential center topologies\n    all_seeds = generate_hex_seeds()\n    \n    # Pattern: Vogel (Sunflower) Spirals\n    phi = (1 + np.sqrt(5)) / 2\n    golden_angle = 2 * np.pi * (1 - 1/phi)\n    for scale in [0.42, 0.46]:\n        c = []\n        for i in range(n):\n            r = scale * np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            c.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n        all_seeds.append(np.array(c))\n        \n    # Pattern: Perturbed Grid\n    grid_25 = []\n    vals = np.linspace(0.1, 0.9, 5)\n    for x in vals:\n        for y in vals:\n            grid_25.append([x, y])\n    all_seeds.append(np.vstack([grid_25, [0.5, 0.5]]))\n\n    # 2. Evaluate all topologies (raw and relaxed) using LP\n    best_c, best_r, max_sum = None, None, -1\n    \n    for seed in all_seeds:\n        if len(seed) != n: continue\n        # Evaluate both the initial geometric seed and its relaxed version\n        for variant in [seed, relax_centers(seed)]:\n            rads = solve_for_radii(variant)\n            if rads is not None:\n                current_sum = np.sum(rads)\n                if current_sum > max_sum:\n                    max_sum, best_c, best_r = current_sum, variant, rads\n\n    # 3. Final Verification and Robust Hardening\n    # Enforce strict non-overlap and boundary constraints to handle floating point drift\n    eps = 1e-9\n    best_r = np.array([min(best_r[i], best_c[i, 0] - eps, 1 - best_c[i, 0] - eps, \n                           best_c[i, 1] - eps, 1 - best_c[i, 1] - eps) for i in range(n)])\n    \n    for _ in range(5): # Iterative overlap removal\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((best_c[i] - best_c[j])**2))\n                if best_r[i] + best_r[j] > dist - eps:\n                    overlap = (best_r[i] + best_r[j] - dist + 2*eps) / 2\n                    best_r[i] = max(0, best_r[i] - overlap)\n                    best_r[j] = max(0, best_r[j] - overlap)\n\n    return best_c, best_r, np.sum(best_r)\n\ndef run_packing():\n    \"\"\"Execute the circle packing constructor for n=26\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")", "changes_description": null, "language": "python", "parent_id": "d350d8e7-5d53-430d-9935-c34e101b194a", "generation": 3, "timestamp": 1771623471.4517324, "iteration_found": 27, "metrics": {"validity": 1.0, "sum_radii": 2.411999978, "target_ratio": 0.915370010626186, "combined_score": 0.915370010626186, "radius_variance": 0.004876477676346086, "spatial_spread": 0.19676274115590917, "eval_time": 1.1609110832214355}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.3919997399999997, "target_ratio": 0.9077797874762809, "combined_score": 0.9077797874762809, "radius_variance": 0.0019470769230769162, "spatial_spread": 0.19892660901177986, "eval_time": 0.4623723030090332}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. Your task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. The AlphaEvolve paper achieved a sum of 2.635 for n=26.\n\nKey geometric insights:\n- Circle packings often follow hexagonal patterns in the densest regions\n- Maximum density for infinite circle packing is pi/(2*sqrt(3)) \u2248 0.9069\n- Edge effects make square container packing harder than infinite packing\n- Circles can be placed in layers or shells when confined to a square\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nFocus on designing an explicit constructor that places each circle in a specific position, rather than an iterative search algorithm.\n", "user": "# Current Program Information\n- Fitness: 0.9078\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9078\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n0.46s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.392000/2.635 = 0.9078\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.3920, target_ratio: 0.9078, combined_score: 0.9078, radius_variance: 0.0019, spatial_spread: 0.1989, eval_time: 0.4624\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4140, target_ratio: 0.9161, combined_score: 0.9161, radius_variance: 0.0046, spatial_spread: 0.1806, eval_time: 0.6017\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4800, target_ratio: 0.9412, combined_score: 0.9412, radius_variance: 0.0026, spatial_spread: 0.1951, eval_time: 0.5116\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9412)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nExpert Constructor-based Circle Packing for n=26 Circles in a Unit Square.\nThe goal is to maximize the sum of radii of 26 non-overlapping circles.\nThis implementation uses several high-density candidate arrangements (hexagonal,\nsunflower, and relaxed grids) and then solves a Linear Program (LP) for each \narrangement to find the optimal set of radii that maximizes their sum.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii.\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n    \n    # 1. Define high-potential center patterns\n    configs = []\n    \n    # Pattern A: Sunflower Spirals (Vogel's model)\n    # Good for distributing points uniformly in many container shapes.\n    def generate_sunflower(n, scale=0.45):\n        phi = (1 + np.sqrt(5)) / 2\n        golden_angle = 2 * np.pi * (1 - 1/phi)\n        centers = []\n        for i in range(n):\n            r = np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            x = 0.5 + scale * r * np.cos(theta)\n            y = 0.5 + scale * r * np.sin(theta)\n            centers.append([x, y])\n        return np.clip(np.array(centers), 0.01, 0.99)\n\n    # Pattern B: Hexagonal Row-based Layouts\n    # Hexagonal packing is the densest possible in infinite space.\n    def generate_rows(counts, pad_x=0.1, pad_y=0.1):\n        y_coords = np.linspace(pad_y, 1.0 - pad_y, len(counts))\n        centers = []\n        for i, count in enumerate(counts):\n            x_coords = np.linspace(pad_x, 1.0 - pad_x, count)\n            for x in x_coords:\n                centers.append([x, y_coords[i]])\n        return np.array(centers)\n\n    def generate_staggered_rows(counts, pad=0.1):\n        y_coords = np.linspace(pad, 1.0 - pad, len(counts))\n        centers = []\n        for i, count in enumerate(counts):\n            # Apply slight horizontal stagger to improve interlocking\n            offset = 0.02 if i % 2 == 1 else 0.0\n            x_coords = np.linspace(pad + offset, 1.0 - pad - offset, count)\n            for x in x_coords:\n                centers.append([x, y_coords[i]])\n        return np.array(centers)\n\n    # Pattern C: Deterministic Force-Directed Relaxation\n    # Spreads centers out to find better positions for the LP to exploit.\n    def relax_centers(centers, steps=40):\n        c = centers.copy()\n        n_pts = len(c)\n        for _ in range(steps):\n            forces = np.zeros_like(c)\n            # Mutual repulsion\n            for i in range(n_pts):\n                for j in range(i + 1, n_pts):\n                    diff = c[i] - c[j]\n                    dist_sq = np.sum(diff**2) + 1e-6\n                    dist = np.sqrt(dist_sq)\n                    force = (diff / dist) * (0.01 / dist_sq)\n                    forces[i] += force\n                    forces[j] -= force\n                # Boundary repulsion\n                forces[i, 0] += 0.005 / (c[i, 0]**2 + 1e-5)\n                forces[i, 0] -= 0.005 / ((1.0 - c[i, 0])**2 + 1e-5)\n                forces[i, 1] += 0.005 / (c[i, 1]**2 + 1e-5)\n                forces[i, 1] -= 0.005 / ((1.0 - c[i, 1])**2 + 1e-5)\n            c += 0.002 * forces\n            c = np.clip(c, 0.01, 0.99)\n        return c\n\n    # Add layouts to candidates\n    configs.append(generate_sunflower(n, 0.44))\n    configs.append(generate_sunflower(n, 0.47))\n    \n    hex_patterns = [[5, 6, 5, 6, 4], [6, 5, 4, 5, 6], [5, 5, 6, 5, 5], [6, 5, 5, 5, 5]]\n    for counts in hex_patterns:\n        for p in [0.08, 0.1, 0.12]:\n            configs.append(generate_rows(counts, p, p))\n    \n    configs.append(generate_staggered_rows([5, 5, 6, 5, 5], 0.1))\n    \n    # Add a \"disturbed\" 5x5 grid + 1\n    grid_25 = generate_rows([5, 5, 5, 5, 5], 0.1, 0.1)\n    grid_26 = np.vstack([grid_25, [0.5, 0.5]])\n    configs.append(relax_centers(grid_26))\n    \n    # 2. Optimize radii for each configuration using Linear Programming\n    for c_np in configs:\n        if len(c_np) != n: continue\n        radii = compute_max_radii(c_np)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = c_np\n            best_radii = radii\n            \n    return best_centers, best_radii, best_sum\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes optimal radii for fixed centers by maximizing sum(r_i)\n    subject to non-overlap and boundary constraints.\n    \"\"\"\n    n = len(centers)\n    # Objective: Maximize sum of radii -> Minimize negative sum\n    obj = -np.ones(n)\n    \n    # Non-overlap constraints: r_i + r_j <= distance(c_i, c_j)\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            row = np.zeros(n)\n            row[i] = 1\n            row[j] = 1\n            A_ub.append(row)\n            b_ub.append(dist)\n    \n    # Boundary constraints: r_i <= dist(c_i, wall)\n    bounds = []\n    for i in range(n):\n        x, y = centers[i]\n        max_r = min(x, 1.0 - x, y, 1.0 - y)\n        bounds.append((0, max_r))\n        \n    # Solve the Linear Program\n    try:\n        # Use 'highs' method for efficiency if available\n        res = linprog(obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if res.success:\n            # Ensure strict adherence to constraints by applying a tiny safety margin\n            final_radii = np.maximum(res.x - 1e-10, 0.0)\n            return final_radii\n    except Exception:\n        pass\n        \n    # Fallback: Simple robust inflation if LP fails\n    radii = np.array([min(x, 1.0-x, y, 1.0-y) for x, y in centers])\n    for _ in range(20):\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > d:\n                    scale = (d - 1e-11) / (radii[i] + radii[j] + 1e-12)\n                    radii[i] *= scale\n                    radii[j] *= scale\n    return radii\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4800), Performs well on target_ratio (0.9412), Performs well on combined_score (0.9412), Performs well on radius_variance (0.0026), Performs well on spatial_spread (0.1951), Performs well on eval_time (0.5116)\n\n### Program 2 (Score: 0.9161)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n    \n    configs = []\n    \n    # Config Group 1: Sunflower Spirals (Vogel's model mapped to a square)\n    # This naturally distributes points uniformly but not strictly grid-like, \n    # allowing varying radii perfectly.\n    golden_angle = np.pi * (3 - np.sqrt(5))\n    for scale in [0.4, 0.44, 0.48]:\n        c = []\n        for i in range(n):\n            r = np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            x = 0.5 + scale * r * np.cos(theta)\n            y = 0.5 + scale * r * np.sin(theta)\n            c.append([x, y])\n        configs.append(c)\n        \n    # Config Group 2: Symmetrical Hexagonal Arrays\n    # Try different shapes and paddings to find the optimal boundary interactions.\n    hex_shapes = [[5, 6, 4, 6, 5], [6, 5, 4, 5, 6], [4, 6, 6, 6, 4]]\n    for shape in hex_shapes:\n        for pad in [0.08, 0.1, 0.12]:\n            c = []\n            y_starts = np.linspace(pad, 1 - pad, 5)\n            for r_idx, count in enumerate(shape):\n                y = y_starts[r_idx]\n                xs = np.linspace(pad, 1 - pad, count)\n                for x in xs:\n                    c.append([x, y])\n            if len(c) == n:\n                configs.append(c)\n\n    # Config Group 3: Concentric Patterns\n    for rings, radii_r in [\n        ([1, 6, 9, 10], [0.0, 0.18, 0.35, 0.48]),\n        ([5, 9, 12], [0.15, 0.32, 0.46])\n    ]:\n        c = []\n        for ring_idx, count in enumerate(rings):\n            r = radii_r[ring_idx]\n            if count == 1:\n                c.append([0.5, 0.5])\n            else:\n                for i in range(count):\n                    angle = 2 * np.pi * i / count + (np.pi/count if ring_idx % 2 == 1 else 0)\n                    c.append([0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)])\n        if len(c) == n:\n            configs.append(c)\n            \n    # Config Group 4: Fractal / Apollonian-like structural layout\n    c = [[0.5, 0.5]]\n    for r in [0.15, 0.85]:\n        for p in [0.15, 0.85]:\n            c.append([r, p])\n    for e in [0.1, 0.9]:\n        c.append([0.5, e])\n        c.append([e, 0.5])\n    for i in range(8):\n        a = 2 * np.pi * i / 8 + np.pi/8\n        c.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n    for i in range(9):\n        a = 2 * np.pi * i / 9\n        c.append([0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)])\n    if len(c) == n:\n        configs.append(c)\n        \n    # Config Group 5: Small deterministic perturbations of the 6-5-4-5-6 grid\n    base_shape = [6, 5, 4, 5, 6]\n    base_c = []\n    y_starts = np.linspace(0.1, 0.9, 5)\n    for r_idx, count in enumerate(base_shape):\n        y = y_starts[r_idx]\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            base_c.append([x, y])\n    base_c_np = np.array(base_c)\n    \n    rng = np.random.RandomState(42)\n    for _ in range(3):\n        noise = rng.uniform(-0.015, 0.015, (n, 2))\n        configs.append((base_c_np + noise).tolist())\n        \n    # Evaluate all explicit configurations and choose the absolute best\n    for c_list in configs:\n        c_np = np.clip(np.array(c_list), 0.001, 0.999)\n        radii = compute_max_radii(c_np)\n        s = np.sum(radii)\n        if s > best_sum:\n            best_sum = s\n            best_centers = c_np\n            best_radii = radii\n            \n    return best_centers, best_radii, best_sum\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    by solving a Linear Programming problem to directly maximize sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    radii = None\n    \n    try:\n        from scipy.optimize import linprog\n        c = -np.ones(n) # Maximize sum of radii\n        A_ub = []\n        b_ub = []\n        bounds = []\n        \n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, 1-x, y, 1-y)\n            bounds.append((0, max_r))\n            \n        # Limit by distance to other circles (r_i + r_j <= distance)\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n                \n        # Suppress warnings and execute fast LP solver\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            radii = res.x\n    except Exception:\n        pass\n\n    if radii is None:\n        # Fallback solver: Projected Gradient Ascent physically simulating inflating balloons\n        radii = np.zeros(n)\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(x, 1-x, y, 1-y)\n            \n        lr = 0.02\n        for step in range(800):\n            radii += lr * (1.0 - step/800)\n            # Iteratively resolve constraints\n            for _ in range(2):\n                for i in range(n):\n                    x, y = centers[i]\n                    radii[i] = min(radii[i], x, 1-x, y, 1-y)\n                for i in range(n):\n                    for j in range(i+1, n):\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if radii[i] + radii[j] > dist:\n                            diff = (radii[i] + radii[j] - dist) / 2\n                            radii[i] -= diff\n                            radii[j] -= diff\n\n    # Final robust, strict enforcement to absolutely prevent floating point constraint violations\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x - 1e-8, 1-x - 1e-8, y - 1e-8, 1-y - 1e-8)\n        radii[i] = max(0.0, radii[i])\n        \n    for _ in range(10):\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist + 1e-9:\n                    if dist < 1e-6:\n                        radii[i] = 0.0\n                        radii[j] = 0.0\n                    else:\n                        sum_r = radii[i] + radii[j]\n                        if sum_r > 0:\n                            scale = (dist - 1e-8) / sum_r\n                            radii[i] *= scale\n                            radii[j] *= scale\n                            \n    return radii\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4140), Performs well on target_ratio (0.9161), Performs well on combined_score (0.9161), Performs well on radius_variance (0.0046), Performs well on spatial_spread (0.1806), Performs well on eval_time (0.6017)\n\n### Program 3 (Score: 0.9078)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n# EVOLVE-BLOCK-START\n\"\"\"\nOptimized constructor for packing 26 circles in a unit square to maximize the sum of their radii.\nThe strategy involves testing multiple starting geometric seeds (hexagonal grids and sunflower spirals),\nrefining center positions through a force-based relaxation model, and solving a Linear Programming \nproblem to determine the exact optimal radii for each configuration.\n\"\"\"\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float, total sum of radii\n    \"\"\"\n    n = 26\n    \n    def get_vogel_spiral(n, scale):\n        \"\"\"Generates a sunflower spiral pattern adapted for the square container.\"\"\"\n        phi = (1 + np.sqrt(5)) / 2\n        golden_angle = 2 * np.pi * (1 - 1/phi)\n        c = []\n        for i in range(n):\n            r = scale * np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            c.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n        return np.array(c)\n\n    def get_hex_grid(rows, pad=0.1, shift=0.03):\n        \"\"\"Generates a hexagonal grid with a specified number of circles per row.\"\"\"\n        c = []\n        n_rows = len(rows)\n        y_coords = np.linspace(pad, 1.0 - pad, n_rows)\n        for r_idx, n_cols in enumerate(rows):\n            x_start, x_end = pad, 1.0 - pad\n            if r_idx % 2 == 1:\n                # Shift alternate rows slightly to induce a staggered hexagonal structure\n                x_start += shift\n                x_end -= shift\n            x_coords = np.linspace(x_start, x_end, n_cols)\n            for x in x_coords:\n                c.append([x, y_coords[r_idx]])\n        return np.array(c)\n\n    def relax_centers(centers, steps=150):\n        \"\"\"Refines center positions using an iterative repulsion force model.\"\"\"\n        pts = centers.copy()\n        for _ in range(steps):\n            diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists = np.linalg.norm(diffs, axis=2)\n            np.fill_diagonal(dists, 1.0)\n            \n            # Repulsion force derived from 1/r^2 interaction\n            # Strong forces for points within a specific neighborhood radius\n            mask = dists < 0.25\n            force_mag = np.zeros_like(dists)\n            force_mag[mask] = 1.0 / (dists[mask]**2 + 1e-4)\n            forces = (diffs * force_mag[:, :, np.newaxis]).sum(axis=1)\n            \n            # Update positions and constrain to unit square\n            pts += forces * 0.00025\n            pts = np.clip(pts, 0.02, 0.98)\n        return pts\n\n    def solve_for_max_radii(centers):\n        \"\"\"\n        Calculates the optimal radii for fixed centers to maximize the sum of radii.\n        Solves: maximize sum(r_i)\n        Subject to: r_i + r_j <= distance(c_i, c_j)\n                   r_i <= boundary_dist(c_i)\n        \"\"\"\n        num_circles = len(centers)\n        # Minimize negative sum to maximize positive sum\n        obj = -np.ones(num_circles)\n        \n        A_ub = []\n        b_ub = []\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(num_circles)\n                row[i], row[j] = 1, 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        bounds = []\n        for i in range(num_circles):\n            x, y = centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max_r))\n        \n        try:\n            # Prefer the modern HiGHS solver for efficiency and precision\n            res = linprog(obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x\n        except:\n            # Fallback to the legacy solver if HiGHS is unavailable\n            res = linprog(obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            if res.success:\n                return res.x\n        return None\n\n    # Track the best configuration found across multiple seeds\n    best_sum_radii = -1\n    best_centers = None\n    best_radii = None\n    \n    # Selection of diverse initial patterns to explore different local optima\n    # Rows for hex grids are chosen such that sum(rows) == 26\n    seeds = [\n        get_vogel_spiral(n, 0.45),\n        get_vogel_spiral(n, 0.48),\n        get_hex_grid([5, 6, 5, 6, 4], 0.08, 0.03),\n        get_hex_grid([6, 5, 6, 5, 4], 0.08, 0.03),\n        get_hex_grid([5, 5, 6, 5, 5], 0.09, 0.02),\n        get_hex_grid([4, 6, 6, 6, 4], 0.07, 0.04)\n    ]\n    \n    for s_centers in seeds:\n        # Evaluate both the raw geometric seed and a relaxed version\n        for candidate_centers in [s_centers, relax_centers(s_centers)]:\n            rads = solve_for_max_radii(candidate_centers)\n            if rads is not None:\n                current_sum = np.sum(rads)\n                if current_sum > best_sum_radii:\n                    best_sum_radii, best_centers, best_radii = current_sum, candidate_centers, rads\n                    \n    # Strict validation phase to handle potential floating point precision errors\n    # Ensure circles stay within [0, 1] and don't overlap by a safety margin of 1e-8\n    eps = 1e-8\n    best_radii -= eps\n    for i in range(n):\n        x, y = best_centers[i]\n        best_radii[i] = min(best_radii[i], x - eps, 1.0 - x - eps, y - eps, 1.0 - y - eps)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > dist - eps:\n                overlap = (best_radii[i] + best_radii[j] - dist + 2*eps) / 2\n                best_radii[i] = max(0, best_radii[i] - overlap)\n                best_radii[j] = max(0, best_radii[j] - overlap)\n                \n    best_radii = np.maximum(best_radii, 0.0)\n    final_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, final_sum\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Execute the circle packing constructor\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.3920), Performs well on target_ratio (0.9078), Performs well on combined_score (0.9078), Performs well on radius_variance (0.0019), Performs well on spatial_spread (0.1989), Performs well on eval_time (0.4624)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport math\n\ndef get_circle_packing():\n    \"\"\"\n    Computes an optimized packing of 26 circles in a 1x1 unit square to maximize the sum of their radii.\n    Uses SLSQP optimization with exact Jacobians and multiple restarts from varied initial configurations,\n    followed by a strict monotonic deflation step to guarantee absolute validity of the final packing.\n    \"\"\"\n    n = 26\n    best_sum_r = -1\n    best_centers = []\n    best_radii = []\n    \n    # Set random seed for reproducibility\n    np.random.seed(42)\n    \n    def objective(vars):\n        # We want to maximize the sum of radii, which is equivalent to minimizing the negative sum\n        return -np.sum(vars[2*n:3*n])\n        \n    def gradient(vars):\n        grad = np.zeros(3*n)\n        grad[2*n:3*n] = -1.0\n        return grad\n\n    def cons_non_overlap(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist_sq = dx**2 + dy**2\n        rad_sq = (r[:, None] + r[None, :])**2\n        idx = np.triu_indices(n, 1)\n        return (dist_sq - rad_sq)[idx]\n\n    def jac_non_overlap(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        idx1, idx2 = np.triu_indices(n, 1)\n        num_constraints = len(idx1)\n        jac = np.zeros((num_constraints, 3*n))\n        \n        x_diff = x[idx1] - x[idx2]\n        y_diff = y[idx1] - y[idx2]\n        r_sum = r[idx1] + r[idx2]\n        \n        jac[np.arange(num_constraints), idx1] = 2 * x_diff\n        jac[np.arange(num_constraints), idx2] = -2 * x_diff\n        \n        jac[np.arange(num_constraints), n + idx1] = 2 * y_diff\n        jac[np.arange(num_constraints), n + idx2] = -2 * y_diff\n        \n        jac[np.arange(num_constraints), 2*n + idx1] = -2 * r_sum\n        jac[np.arange(num_constraints), 2*n + idx2] = -2 * r_sum\n        \n        return jac\n\n    def cons_bounds(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        return np.concatenate([\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n\n    def jac_bounds(vars):\n        jac = np.zeros((4*n, 3*n))\n        idx = np.arange(n)\n        \n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*n + idx] = -1\n        \n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*n + idx] = -1\n        \n        jac[4*idx+2, n + idx] = 1\n        jac[4*idx+2, 2*n + idx] = -1\n        \n        jac[4*idx+3, n + idx] = -1\n        jac[4*idx+3, 2*n + idx] = -1\n        \n        return jac\n        \n    constraints = [\n        {'type': 'ineq', 'fun': cons_non_overlap, 'jac': jac_non_overlap},\n        {'type': 'ineq', 'fun': cons_bounds, 'jac': jac_bounds}\n    ]\n    \n    bounds = [(0, 1)]*(2*n) + [(0.001, 0.5)]*n\n    \n    # Run 30 optimization attempts from varied initial states to avoid local minima\n    for attempt in range(30):\n        if attempt == 0:\n            # 5x5 Grid + 1 center\n            x_init = np.linspace(0.1, 0.9, 5)\n            y_init = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(x_init, y_init)\n            x_init = list(xv.flatten()) + [0.5]\n            y_init = list(yv.flatten()) + [0.5]\n            r_init = [0.05]*n\n        elif attempt == 1:\n            # Hexagonal roughly\n            x_init = []\n            y_init = []\n            for i in range(5):\n                for j in range(6):\n                    if len(x_init) < n:\n                        x_init.append(0.1 + j*0.16 + (i%2)*0.08)\n                        y_init.append(0.1 + i*0.18)\n            r_init = [0.05]*n\n        elif attempt == 2:\n            # 4 large circles in the corners, smaller circles elsewhere\n            x_init = np.random.uniform(0.1, 0.9, n)\n            y_init = np.random.uniform(0.1, 0.9, n)\n            r_init = np.full(n, 0.02)\n            x_init[0:4] = [0.2, 0.8, 0.2, 0.8]\n            y_init[0:4] = [0.2, 0.2, 0.8, 0.8]\n            r_init[0:4] = [0.15, 0.15, 0.15, 0.15]\n        else:\n            # Pure random initialization\n            x_init = np.random.uniform(0.05, 0.95, n)\n            y_init = np.random.uniform(0.05, 0.95, n)\n            r_init = np.random.uniform(0.01, 0.08, n)\n            \n        init_vars = np.concatenate([x_init, y_init, r_init])\n        \n        res = minimize(\n            objective, \n            init_vars, \n            method='SLSQP',\n            jac=gradient,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1500, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        x = res.x[0:n].copy()\n        y = res.x[n:2*n].copy()\n        r = res.x[2*n:3*n].copy()\n        \n        # Iterative deflation to rigorously fix any floating point precision overlaps\n        for _ in range(300):\n            overlap = False\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = math.hypot(x[i]-x[j], y[i]-y[j])\n                    if r[i] + r[j] > dist:\n                        diff = r[i] + r[j] - dist + 1e-10\n                        r[i] = max(0.0, r[i] - diff * 0.5001)\n                        r[j] = max(0.0, r[j] - diff * 0.5001)\n                        overlap = True\n                        \n            for i in range(n):\n                r_max = min(x[i], 1-x[i], y[i], 1-y[i]) - 1e-10\n                if r[i] > r_max:\n                    r[i] = max(0.0, r_max)\n                    overlap = True\n                    \n            if not overlap:\n                break\n                \n        sum_r = np.sum(r)\n        \n        if sum_r > best_sum_r:\n            # Final validation check\n            valid = True\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = math.hypot(x[i]-x[j], y[i]-y[j])\n                    if r[i] + r[j] > dist + 1e-9:\n                        valid = False\n                if r[i] > x[i] + 1e-9 or r[i] > 1 - x[i] + 1e-9:\n                    valid = False\n                if r[i] > y[i] + 1e-9 or r[i] > 1 - y[i] + 1e-9:\n                    valid = False\n                    \n            if valid:\n                best_sum_r = sum_r\n                best_centers = list(zip(x, y))\n                best_radii = r.tolist()\n\n    return best_centers, best_radii\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\nres = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nres = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize\nimport math\n\ndef get_circle_packing():\n    \"\"\"\n    Computes an optimized packing of 26 circles in a 1x1 unit square to maximize the sum of their radii.\n    Uses SLSQP optimization with exact Jacobians and multiple restarts from varied initial configurations,\n    followed by a strict monotonic deflation step to guarantee absolute validity of the final packing.\n    \"\"\"\n    n = 26\n    best_sum_r = -1\n    best_centers = []\n    best_radii = []\n    \n    # Set random seed for reproducibility\n    np.random.seed(42)\n    \n    def objective(vars):\n        # We want to maximize the sum of radii, which is equivalent to minimizing the negative sum\n        return -np.sum(vars[2*n:3*n])\n        \n    def gradient(vars):\n        grad = np.zeros(3*n)\n        grad[2*n:3*n] = -1.0\n        return grad\n\n    def cons_non_overlap(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist_sq = dx**2 + dy**2\n        rad_sq = (r[:, None] + r[None, :])**2\n        idx = np.triu_indices(n, 1)\n        return (dist_sq - rad_sq)[idx]\n\n    def jac_non_overlap(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        idx1, idx2 = np.triu_indices(n, 1)\n        num_constraints = len(idx1)\n        jac = np.zeros((num_constraints, 3*n))\n        \n        x_diff = x[idx1] - x[idx2]\n        y_diff = y[idx1] - y[idx2]\n        r_sum = r[idx1] + r[idx2]\n        \n        jac[np.arange(num_constraints), idx1] = 2 * x_diff\n        jac[np.arange(num_constraints), idx2] = -2 * x_diff\n        \n        jac[np.arange(num_constraints), n + idx1] = 2 * y_diff\n        jac[np.arange(num_constraints), n + idx2] = -2 * y_diff\n        \n        jac[np.arange(num_constraints), 2*n + idx1] = -2 * r_sum\n        jac[np.arange(num_constraints), 2*n + idx2] = -2 * r_sum\n        \n        return jac\n\n    def cons_bounds(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        return np.concatenate([\n            x - r,\n            1.0 - x - r,\n            y - r,\n            1.0 - y - r\n        ])\n\n    def jac_bounds(vars):\n        jac = np.zeros((4*n, 3*n))\n        idx = np.arange(n)\n        \n        jac[4*idx, idx] = 1\n        jac[4*idx, 2*n + idx] = -1\n        \n        jac[4*idx+1, idx] = -1\n        jac[4*idx+1, 2*n + idx] = -1\n        \n        jac[4*idx+2, n + idx] = 1\n        jac[4*idx+2, 2*n + idx] = -1\n        \n        jac[4*idx+3, n + idx] = -1\n        jac[4*idx+3, 2*n + idx] = -1\n        \n        return jac\n        \n    constraints = [\n        {'type': 'ineq', 'fun': cons_non_overlap, 'jac': jac_non_overlap},\n        {'type': 'ineq', 'fun': cons_bounds, 'jac': jac_bounds}\n    ]\n    \n    bounds = [(0, 1)]*(2*n) + [(0.001, 0.5)]*n\n    \n    # Run 30 optimization attempts from varied initial states to avoid local minima\n    for attempt in range(30):\n        if attempt == 0:\n            # 5x5 Grid + 1 center\n            x_init = np.linspace(0.1, 0.9, 5)\n            y_init = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(x_init, y_init)\n            x_init = list(xv.flatten()) + [0.5]\n            y_init = list(yv.flatten()) + [0.5]\n            r_init = [0.05]*n\n        elif attempt == 1:\n            # Hexagonal roughly\n            x_init = []\n            y_init = []\n            for i in range(5):\n                for j in range(6):\n                    if len(x_init) < n:\n                        x_init.append(0.1 + j*0.16 + (i%2)*0.08)\n                        y_init.append(0.1 + i*0.18)\n            r_init = [0.05]*n\n        elif attempt == 2:\n            # 4 large circles in the corners, smaller circles elsewhere\n            x_init = np.random.uniform(0.1, 0.9, n)\n            y_init = np.random.uniform(0.1, 0.9, n)\n            r_init = np.full(n, 0.02)\n            x_init[0:4] = [0.2, 0.8, 0.2, 0.8]\n            y_init[0:4] = [0.2, 0.2, 0.8, 0.8]\n            r_init[0:4] = [0.15, 0.15, 0.15, 0.15]\n        else:\n            # Pure random initialization\n            x_init = np.random.uniform(0.05, 0.95, n)\n            y_init = np.random.uniform(0.05, 0.95, n)\n            r_init = np.random.uniform(0.01, 0.08, n)\n            \n        init_vars = np.concatenate([x_init, y_init, r_init])\n        \n        res = minimize(\n            objective, \n            init_vars, \n            method='SLSQP',\n            jac=gradient,\n            bounds=bounds,\n            constraints=constraints,\n            options={'maxiter': 1500, 'ftol': 1e-6, 'disp': False}\n        )\n        \n        x = res.x[0:n].copy()\n        y = res.x[n:2*n].copy()\n        r = res.x[2*n:3*n].copy()\n        \n        # Iterative deflation to rigorously fix any floating point precision overlaps\n        for _ in range(300):\n            overlap = False\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = math.hypot(x[i]-x[j], y[i]-y[j])\n                    if r[i] + r[j] > dist:\n                        diff = r[i] + r[j] - dist + 1e-10\n                        r[i] = max(0.0, r[i] - diff * 0.5001)\n                        r[j] = max(0.0, r[j] - diff * 0.5001)\n                        overlap = True\n                        \n            for i in range(n):\n                r_max = min(x[i], 1-x[i], y[i], 1-y[i]) - 1e-10\n                if r[i] > r_max:\n                    r[i] = max(0.0, r_max)\n                    overlap = True\n                    \n            if not overlap:\n                break\n                \n        sum_r = np.sum(r)\n        \n        if sum_r > best_sum_r:\n            # Final validation check\n            valid = True\n            for i in range(n):\n                for j in range(i+1, n):\n                    dist = math.hypot(x[i]-x[j], y[i]-y[j])\n                    if r[i] + r[j] > dist + 1e-9:\n                        valid = False\n                if r[i] > x[i] + 1e-9 or r[i] > 1 - x[i] + 1e-9:\n                    valid = False\n                if r[i] > y[i] + 1e-9 or r[i] > 1 - y[i] + 1e-9:\n                    valid = False\n                    \n            if valid:\n                best_sum_r = sum_r\n                best_centers = list(zip(x, y))\n                best_radii = r.tolist()\n\n    return best_centers, best_radii\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9161, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    best_centers = None\n    best_radii = None\n    best_sum = -1\n    \n    configs = []\n    \n    # Config Group 1: Sunflower Spirals (Vogel's model mapped to a square)\n    # This naturally distributes points uniformly but not strictly grid-like, \n    # allowing varying radii perfectly.\n    golden_angle = np.pi * (3 - np.sqrt(5))\n    for scale in [0.4, 0.44, 0.48]:\n        c = []\n        for i in range(n):\n            r = np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            x = 0.5 + scale * r * np.cos(theta)\n            y = 0.5 + scale * r * np.sin(theta)\n            c.append([x, y])\n        configs.append(c)\n        \n    # Config Group 2: Symmetrical Hexagonal Arrays\n    # Try different shapes and paddings to find the optimal boundary interactions.\n    hex_shapes = [[5, 6, 4, 6, 5], [6, 5, 4, 5, 6], [4, 6, 6, 6, 4]]\n    for shape in hex_shapes:\n        for pad in [0.08, 0.1, 0.12]:\n            c = []\n            y_starts = np.linspace(pad, 1 - pad, 5)\n            for r_idx, count in enumerate(shape):\n                y = y_starts[r_idx]\n                xs = np.linspace(pad, 1 - pad, count)\n                for x in xs:\n                    c.append([x, y])\n            if len(c) == n:\n                configs.append(c)\n\n    # Config Group 3: Concentric Patterns\n    for rings, radii_r in [\n        ([1, 6, 9, 10], [0.0, 0.18, 0.35, 0.48]),\n        ([5, 9, 12], [0.15, 0.32, 0.46])\n    ]:\n        c = []\n        for ring_idx, count in enumerate(rings):\n            r = radii_r[ring_idx]\n            if count == 1:\n                c.append([0.5, 0.5])\n            else:\n                for i in range(count):\n                    angle = 2 * np.pi * i / count + (np.pi/count if ring_idx % 2 == 1 else 0)\n                    c.append([0.5 + r * np.cos(angle), 0.5 + r * np.sin(angle)])\n        if len(c) == n:\n            configs.append(c)\n            \n    # Config Group 4: Fractal / Apollonian-like structural layout\n    c = [[0.5, 0.5]]\n    for r in [0.15, 0.85]:\n        for p in [0.15, 0.85]:\n            c.append([r, p])\n    for e in [0.1, 0.9]:\n        c.append([0.5, e])\n        c.append([e, 0.5])\n    for i in range(8):\n        a = 2 * np.pi * i / 8 + np.pi/8\n        c.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n    for i in range(9):\n        a = 2 * np.pi * i / 9\n        c.append([0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)])\n    if len(c) == n:\n        configs.append(c)\n        \n    # Config Group 5: Small deterministic perturbations of the 6-5-4-5-6 grid\n    base_shape = [6, 5, 4, 5, 6]\n    base_c = []\n    y_starts = np.linspace(0.1, 0.9, 5)\n    for r_idx, count in enumerate(base_shape):\n        y = y_starts[r_idx]\n        xs = np.linspace(0.1, 0.9, count)\n        for x in xs:\n            base_c.append([x, y])\n    base_c_np = np.array(base_c)\n    \n    rng = np.random.RandomState(42)\n    for _ in range(3):\n        noise = rng.uniform(-0.015, 0.015, (n, 2))\n        configs.append((base_c_np + noise).tolist())\n        \n    # Evaluate all explicit configurations and choose the absolute best\n    for c_list in configs:\n        c_np = np.clip(np.array(c_list), 0.001, 0.999)\n        radii = compute_max_radii(c_np)\n        s = np.sum(radii)\n        if s > best_sum:\n            best_sum = s\n            best_centers = c_np\n            best_radii = radii\n            \n    return best_centers, best_radii, best_sum\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    by solving a Linear Programming problem to directly maximize sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    radii = None\n    \n    try:\n        from scipy.optimize import linprog\n        c = -np.ones(n) # Maximize sum of radii\n        A_ub = []\n        b_ub = []\n        bounds = []\n        \n        # Limit by distance to square borders\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, 1-x, y, 1-y)\n            bounds.append((0, max_r))\n            \n        # Limit by distance to other circles (r_i + r_j <= distance)\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n                \n        # Suppress warnings and execute fast LP solver\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            radii = res.x\n    except Exception:\n        pass\n\n    if radii is None:\n        # Fallback solver: Projected Gradient Ascent physically simulating inflating balloons\n        radii = np.zeros(n)\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(x, 1-x, y, 1-y)\n            \n        lr = 0.02\n        for step in range(800):\n            radii += lr * (1.0 - step/800)\n            # Iteratively resolve constraints\n            for _ in range(2):\n                for i in range(n):\n                    x, y = centers[i]\n                    radii[i] = min(radii[i], x, 1-x, y, 1-y)\n                for i in range(n):\n                    for j in range(i+1, n):\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        if radii[i] + radii[j] > dist:\n                            diff = (radii[i] + radii[j] - dist) / 2\n                            radii[i] -= diff\n                            radii[j] -= diff\n\n    # Final robust, strict enforcement to absolutely prevent floating point constraint violations\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x - 1e-8, 1-x - 1e-8, y - 1e-8, 1-y - 1e-8)\n        radii[i] = max(0.0, radii[i])\n        \n    for _ in range(10):\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                if radii[i] + radii[j] > dist + 1e-9:\n                    if dist < 1e-6:\n                        radii[i] = 0.0\n                        radii[j] = 0.0\n                    else:\n                        sum_r = radii[i] + radii[j]\n                        if sum_r > 0:\n                            scale = (dist - 1e-8) / sum_r\n                            radii[i] *= scale\n                            radii[j] *= scale\n                            \n    return radii\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n# EVOLVE-BLOCK-START\n\"\"\"\nOptimized constructor for packing 26 circles in a unit square to maximize the sum of their radii.\nThe strategy involves testing multiple starting geometric seeds (hexagonal grids and sunflower spirals),\nrefining center positions through a force-based relaxation model, and solving a Linear Programming \nproblem to determine the exact optimal radii for each configuration.\n\"\"\"\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26,)\n        sum_radii: float, total sum of radii\n    \"\"\"\n    n = 26\n    \n    def get_vogel_spiral(n, scale):\n        \"\"\"Generates a sunflower spiral pattern adapted for the square container.\"\"\"\n        phi = (1 + np.sqrt(5)) / 2\n        golden_angle = 2 * np.pi * (1 - 1/phi)\n        c = []\n        for i in range(n):\n            r = scale * np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            c.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n        return np.array(c)\n\n    def get_hex_grid(rows, pad=0.1, shift=0.03):\n        \"\"\"Generates a hexagonal grid with a specified number of circles per row.\"\"\"\n        c = []\n        n_rows = len(rows)\n        y_coords = np.linspace(pad, 1.0 - pad, n_rows)\n        for r_idx, n_cols in enumerate(rows):\n            x_start, x_end = pad, 1.0 - pad\n            if r_idx % 2 == 1:\n                # Shift alternate rows slightly to induce a staggered hexagonal structure\n                x_start += shift\n                x_end -= shift\n            x_coords = np.linspace(x_start, x_end, n_cols)\n            for x in x_coords:\n                c.append([x, y_coords[r_idx]])\n        return np.array(c)\n\n    def relax_centers(centers, steps=150):\n        \"\"\"Refines center positions using an iterative repulsion force model.\"\"\"\n        pts = centers.copy()\n        for _ in range(steps):\n            diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists = np.linalg.norm(diffs, axis=2)\n            np.fill_diagonal(dists, 1.0)\n            \n            # Repulsion force derived from 1/r^2 interaction\n            # Strong forces for points within a specific neighborhood radius\n            mask = dists < 0.25\n            force_mag = np.zeros_like(dists)\n            force_mag[mask] = 1.0 / (dists[mask]**2 + 1e-4)\n            forces = (diffs * force_mag[:, :, np.newaxis]).sum(axis=1)\n            \n            # Update positions and constrain to unit square\n            pts += forces * 0.00025\n            pts = np.clip(pts, 0.02, 0.98)\n        return pts\n\n    def solve_for_max_radii(centers):\n        \"\"\"\n        Calculates the optimal radii for fixed centers to maximize the sum of radii.\n        Solves: maximize sum(r_i)\n        Subject to: r_i + r_j <= distance(c_i, c_j)\n                   r_i <= boundary_dist(c_i)\n        \"\"\"\n        num_circles = len(centers)\n        # Minimize negative sum to maximize positive sum\n        obj = -np.ones(num_circles)\n        \n        A_ub = []\n        b_ub = []\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(num_circles)\n                row[i], row[j] = 1, 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        bounds = []\n        for i in range(num_circles):\n            x, y = centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max_r))\n        \n        try:\n            # Prefer the modern HiGHS solver for efficiency and precision\n            res = linprog(obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x\n        except:\n            # Fallback to the legacy solver if HiGHS is unavailable\n            res = linprog(obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            if res.success:\n                return res.x\n        return None\n\n    # Track the best configuration found across multiple seeds\n    best_sum_radii = -1\n    best_centers = None\n    best_radii = None\n    \n    # Selection of diverse initial patterns to explore different local optima\n    # Rows for hex grids are chosen such that sum(rows) == 26\n    seeds = [\n        get_vogel_spiral(n, 0.45),\n        get_vogel_spiral(n, 0.48),\n        get_hex_grid([5, 6, 5, 6, 4], 0.08, 0.03),\n        get_hex_grid([6, 5, 6, 5, 4], 0.08, 0.03),\n        get_hex_grid([5, 5, 6, 5, 5], 0.09, 0.02),\n        get_hex_grid([4, 6, 6, 6, 4], 0.07, 0.04)\n    ]\n    \n    for s_centers in seeds:\n        # Evaluate both the raw geometric seed and a relaxed version\n        for candidate_centers in [s_centers, relax_centers(s_centers)]:\n            rads = solve_for_max_radii(candidate_centers)\n            if rads is not None:\n                current_sum = np.sum(rads)\n                if current_sum > best_sum_radii:\n                    best_sum_radii, best_centers, best_radii = current_sum, candidate_centers, rads\n                    \n    # Strict validation phase to handle potential floating point precision errors\n    # Ensure circles stay within [0, 1] and don't overlap by a safety margin of 1e-8\n    eps = 1e-8\n    best_radii -= eps\n    for i in range(n):\n        x, y = best_centers[i]\n        best_radii[i] = min(best_radii[i], x - eps, 1.0 - x - eps, y - eps, 1.0 - y - eps)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(best_centers[i] - best_centers[j])\n            if best_radii[i] + best_radii[j] > dist - eps:\n                overlap = (best_radii[i] + best_radii[j] - dist + 2*eps) / 2\n                best_radii[i] = max(0, best_radii[i] - overlap)\n                best_radii[j] = max(0, best_radii[j] - overlap)\n                \n    best_radii = np.maximum(best_radii, 0.0)\n    final_sum = np.sum(best_radii)\n    \n    return best_centers, best_radii, final_sum\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Execute the circle packing constructor\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\"\"\"\nExpert Constructor-based Circle Packing for n=26 Circles in a Unit Square.\nThe goal is to maximize the sum of radii of 26 non-overlapping circles.\nThis implementation explores multiple high-potential geometric topologies (hexagonal rows, \nVogel spirals, and grid patterns), refines them using force-directed relaxation, \nand solves a Linear Programming (LP) problem for each arrangement to find the optimal \nset of radii that maximizes their sum.\n\"\"\"\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the sum of their radii.\n    \"\"\"\n    n = 26\n    \n    def solve_for_radii(centers):\n        \"\"\"\n        Calculates optimal radii for fixed centers by maximizing sum(r_i)\n        subject to non-overlap and boundary constraints.\n        \"\"\"\n        num = len(centers)\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c_lp = -np.ones(num)\n        \n        # Non-overlap constraints: r_i + r_j <= distance(c_i, c_j)\n        A_ub = []\n        b_ub = []\n        for i in range(num):\n            for j in range(i + 1, num):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                row = np.zeros(num)\n                row[i], row[j] = 1, 1\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints: r_i <= distance(c_i, square_walls)\n        # Using bounds parameter for better efficiency\n        bounds = []\n        for i in range(num):\n            x, y = centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max_r))\n        \n        try:\n            # Use HiGHS solver for speed and precision\n            res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x\n        except Exception:\n            pass\n        return None\n\n    def relax_centers(pts, steps=180):\n        \"\"\"\n        Refines center positions using an iterative force-directed repulsion model.\n        Spreads points out to improve the potential for the subsequent LP optimization.\n        \"\"\"\n        pts = pts.copy()\n        for _ in range(steps):\n            f = np.zeros_like(pts)\n            for i in range(n):\n                # Inter-point repulsion (inverse-square law)\n                diff = pts[i] - pts\n                dist_sq = np.sum(diff**2, axis=1).reshape(-1, 1) + 1e-8\n                dist = np.sqrt(dist_sq)\n                f[i] += np.sum((diff / dist) * (0.001 / dist_sq), axis=0)\n                \n                # Boundary repulsion\n                f[i, 0] += 0.001 / (pts[i, 0]**2 + 1e-8) - 0.001 / ((1 - pts[i, 0])**2 + 1e-8)\n                f[i, 1] += 0.001 / (pts[i, 1]**2 + 1e-8) - 0.001 / ((1 - pts[i, 1])**2 + 1e-8)\n                \n            # Update positions with small step size\n            pts = np.clip(pts + 0.004 * f, 0.01, 0.99)\n        return pts\n\n    def generate_hex_seeds():\n        \"\"\"Generates diverse hexagonal-style layouts for n=26.\"\"\"\n        seeds = []\n        patterns = [\n            [5, 6, 5, 6, 4], [6, 5, 4, 5, 6], [5, 5, 6, 5, 5], \n            [4, 5, 4, 5, 4, 4], [4, 6, 6, 6, 4], [5, 5, 5, 5, 6]\n        ]\n        for p in patterns:\n            pad = 0.09 if len(p) == 5 else 0.07\n            c = []\n            y_coords = np.linspace(pad, 1.0 - pad, len(p))\n            for i, count in enumerate(p):\n                # Apply stagger to create hexagonal geometry\n                offset = 0.04 if i % 2 == 1 else 0.0\n                x_coords = np.linspace(pad + offset, 1.0 - pad - offset, count)\n                for x in x_coords:\n                    c.append([x, y_coords[i]])\n            seeds.append(np.array(c)[:n])\n        return seeds\n\n    # 1. Define high-potential center topologies\n    all_seeds = generate_hex_seeds()\n    \n    # Pattern: Vogel (Sunflower) Spirals\n    phi = (1 + np.sqrt(5)) / 2\n    golden_angle = 2 * np.pi * (1 - 1/phi)\n    for scale in [0.42, 0.46]:\n        c = []\n        for i in range(n):\n            r = scale * np.sqrt(i + 0.5) / np.sqrt(n)\n            theta = i * golden_angle\n            c.append([0.5 + r * np.cos(theta), 0.5 + r * np.sin(theta)])\n        all_seeds.append(np.array(c))\n        \n    # Pattern: Perturbed Grid\n    grid_25 = []\n    vals = np.linspace(0.1, 0.9, 5)\n    for x in vals:\n        for y in vals:\n            grid_25.append([x, y])\n    all_seeds.append(np.vstack([grid_25, [0.5, 0.5]]))\n\n    # 2. Evaluate all topologies (raw and relaxed) using LP\n    best_c, best_r, max_sum = None, None, -1\n    \n    for seed in all_seeds:\n        if len(seed) != n: continue\n        # Evaluate both the initial geometric seed and its relaxed version\n        for variant in [seed, relax_centers(seed)]:\n            rads = solve_for_radii(variant)\n            if rads is not None:\n                current_sum = np.sum(rads)\n                if current_sum > max_sum:\n                    max_sum, best_c, best_r = current_sum, variant, rads\n\n    # 3. Final Verification and Robust Hardening\n    # Enforce strict non-overlap and boundary constraints to handle floating point drift\n    eps = 1e-9\n    best_r = np.array([min(best_r[i], best_c[i, 0] - eps, 1 - best_c[i, 0] - eps, \n                           best_c[i, 1] - eps, 1 - best_c[i, 1] - eps) for i in range(n)])\n    \n    for _ in range(5): # Iterative overlap removal\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((best_c[i] - best_c[j])**2))\n                if best_r[i] + best_r[j] > dist - eps:\n                    overlap = (best_r[i] + best_r[j] - dist + 2*eps) / 2\n                    best_r[i] = max(0, best_r[i] - overlap)\n                    best_r[j] = max(0, best_r[j] - overlap)\n\n    return best_c, best_r, np.sum(best_r)\n\ndef run_packing():\n    \"\"\"Execute the circle packing constructor for n=26\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"1.16s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.412000/2.635 = 0.9154\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}