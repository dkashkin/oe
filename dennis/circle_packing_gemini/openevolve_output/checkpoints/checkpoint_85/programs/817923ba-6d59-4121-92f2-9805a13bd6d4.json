{"id": "817923ba-6d59-4121-92f2-9805a13bd6d4", "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_lp(P):\n    \"\"\"\n    Given a fixed set of centers P, uses Linear Programming to determine the \n    maximum possible radii that satisfy non-overlap and boundary constraints.\n    Returns the array of radii and their total sum.\n    \"\"\"\n    n = P.shape[0]\n    # Objective: Maximize sum(r_i) which is equivalent to minimizing -sum(r_i)\n    c = -np.ones(n)\n    \n    # Precompute pairwise distances between centers\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=2))\n    \n    # Non-overlap constraints: r_i + r_j <= distance(center_i, center_j)\n    num_constraints = n * (n - 1) // 2\n    A_ub = np.zeros((num_constraints, n))\n    b_ub = np.zeros(num_constraints)\n    \n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[k, i] = 1.0\n            A_ub[k, j] = 1.0\n            # Subtract tiny epsilon to handle float precision and ensure no overlap\n            b_ub[k] = max(0.0, dist[i, j] - 1e-12)\n            k += 1\n            \n    # Boundary constraints: r_i <= distance from center to nearest wall\n    # 0 <= x_i - r_i  => r_i <= x_i\n    # x_i + r_i <= 1  => r_i <= 1 - x_i\n    bounds = []\n    for i in range(n):\n        x, y = P[i]\n        d_wall = min(x, 1.0 - x, y, 1.0 - y)\n        bounds.append((0, max(0.0, d_wall - 1e-12)))\n        \n    try:\n        # Solve using the 'highs' method for speed and robustness\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if not res.success:\n            # Fallback to default if 'highs' fails\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0.0\n\ndef construct_packing():\n    \"\"\"\n    Main constructor for a 26-circle packing in a unit square.\n    Combines varied structural layout seeds with local stochastic refinement.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    np.random.seed(42)\n    \n    # Generate diverse candidate seeds based on staggered row layouts\n    seeds = []\n    # Structural row configurations that total at least 26 circles\n    configs = [\n        [5, 5, 6, 5, 5], \n        [6, 5, 5, 5, 5], \n        [5, 6, 5, 6, 4], \n        [4, 6, 6, 6, 4], \n        [4, 5, 4, 5, 4, 4],\n        [6, 6, 7, 7]\n    ]\n    \n    for cfg in configs:\n        # Try variations in row-staggering and boundary padding\n        for stagger_val in [0.0, 0.3, 0.6]:\n            for margin_y in [0.07, 0.1, 0.13]:\n                pts = []\n                num_rows = len(cfg)\n                for r_idx, num_cols in enumerate(cfg):\n                    # Distribute rows vertically\n                    y = margin_y + (1.0 - 2.0 * margin_y) * r_idx / (num_rows - 1)\n                    for c_idx in range(num_cols):\n                        # Distribute circles horizontally, staggering alternating rows\n                        offset = stagger_val if r_idx % 2 == 1 else 0.0\n                        x = (c_idx + 0.5 + offset) / num_cols\n                        pts.append([x, y])\n                # Clip to unit square and take exactly n circles\n                seeds.append(np.clip(np.array(pts[:n]), 0.01, 0.99))\n                \n    # Add grid-based seeds (5x5 grid + 1 extra circle in a gap)\n    grid = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n    seeds.append(np.vstack([grid, [0.5, 0.5]]))\n    seeds.append(np.vstack([grid, [0.2, 0.2]]))\n\n    # Evaluate all initial seeds\n    for initial_pts in seeds:\n        radii, current_sum = solve_lp(initial_pts)\n        if current_sum > best_sum:\n            best_sum, best_r, best_p = current_sum, radii, initial_pts\n\n    # Refine the best layout found using stochastic hill-climbing\n    if best_p is not None:\n        current_refined_p = best_p.copy()\n        # Perform iterative jittering of center positions\n        for i in range(25):\n            # Decrease the perturbation scale over time\n            jitter_scale = 0.008 / (1.0 + i**0.5)\n            test_p = current_refined_p + np.random.normal(0, jitter_scale, (n, 2))\n            test_p = np.clip(test_p, 0.001, 0.999)\n            \n            radii, current_sum = solve_lp(test_p)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_r = radii\n                best_p = test_p\n                current_refined_p = test_p\n\n    # Convert results to expected formats\n    final_centers = np.array(best_p)\n    final_radii = np.array(best_r)\n    final_sum = float(best_sum)\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Alias for construct_packing to match typical evaluator calls.\"\"\"\n    return construct_packing()", "changes_description": null, "language": "python", "parent_id": "357c0807-f09d-495d-b3de-097e454b9413", "generation": 5, "timestamp": 1771624748.2212067, "iteration_found": 81, "metrics": {"validity": 1.0, "sum_radii": 2.541421356217309, "target_ratio": 0.9644862831944248, "combined_score": 0.9644862831944248, "radius_variance": 0.0020304482278002767, "spatial_spread": 0.19189580122579092, "eval_time": 0.5067074298858643}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.495210369506389, "target_ratio": 0.9469489068335444, "combined_score": 0.9469489068335444, "radius_variance": 0.0009111763350835624, "spatial_spread": 0.19479252852800483, "eval_time": 1.2371466159820557}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. Your task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. The AlphaEvolve paper achieved a sum of 2.635 for n=26.\n\nKey geometric insights:\n- Circle packings often follow hexagonal patterns in the densest regions\n- Maximum density for infinite circle packing is pi/(2*sqrt(3)) \u2248 0.9069\n- Edge effects make square container packing harder than infinite packing\n- Circles can be placed in layers or shells when confined to a square\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nFocus on designing an explicit constructor that places each circle in a specific position, rather than an iterative search algorithm.\n", "user": "# Current Program Information\n- Fitness: 0.9469\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.0000 \u2192 0.9469\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n1.24s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.495210/2.635 = 0.9469\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4952, target_ratio: 0.9469, combined_score: 0.9469, radius_variance: 0.0009, spatial_spread: 0.1948, eval_time: 1.2371\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5414, target_ratio: 0.9645, combined_score: 0.9645, radius_variance: 0.0020, spatial_spread: 0.1919, eval_time: 0.3657\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9645)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the sum of radii.\n    \n    The strategy utilizes several candidate structural layouts (primarily row-based \n    staggered configurations) and then applies Linear Programming (LP) to determine \n    the optimal radii for those fixed centers. This ensures that the circles \n    maximize the total sum while strictly adhering to non-overlap and boundary constraints.\n    \"\"\"\n    n = 26\n    \n    def solve_lp(P):\n        \"\"\"\n        Solves a Linear Program to maximize the sum of radii for a fixed set of centers.\n        Objective: Maximize sum(r_i)\n        Constraints:\n            r_i + r_j <= distance between center_i and center_j\n            r_i <= distance from center_i to any wall\n        \"\"\"\n        # Objective: minimize -sum(r_i) which is maximizing sum(r_i)\n        c_obj = -np.ones(n)\n        \n        # Non-overlapping constraints: r_i + r_j <= dist(C_i, C_j)\n        num_constraints = n * (n - 1) // 2\n        A_ub = np.zeros((num_constraints, n))\n        b_ub = np.zeros(num_constraints)\n        \n        curr = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(P[i] - P[j])\n                A_ub[curr, i] = 1.0\n                A_ub[curr, j] = 1.0\n                # Subtract tiny epsilon to ensure strict non-overlap and account for float precision\n                b_ub[curr] = max(0, dist - 1e-12)\n                curr += 1\n        \n        # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            # Ensure radius is non-negative and fits within the square\n            bounds.append((0, max(0, d_wall - 1e-12)))\n            \n        try:\n            # Use 'highs' method for efficiency if available (Scipy >= 1.5.0)\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success:\n                res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        except Exception:\n            # Fallback for older Scipy versions or environments\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0.0\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    # Define several candidate staggered row configurations to evaluate\n    # These represent row counts that total 26 circles\n    configs = [\n        [5, 5, 6, 5, 5],\n        [5, 5, 5, 5, 6],\n        [6, 5, 5, 5, 5],\n        [4, 5, 4, 5, 4, 4],\n        [5, 4, 5, 4, 5, 3],\n        [5, 6, 5, 6, 4],\n        [4, 6, 6, 6, 4]\n    ]\n\n    seeds = []\n    for cfg in configs:\n        pts = []\n        rows = len(cfg)\n        for i, nx in enumerate(cfg):\n            # Distribute rows in the y-dimension from 0.1 to 0.9\n            y = 0.1 + 0.8 * i / (rows - 1)\n            for j in range(nx):\n                # Standard horizontal spacing\n                x = 0.1 + 0.8 * j / (nx - 1)\n                # Stagger alternate rows to achieve hexagonal-like efficiency\n                if i % 2 == 1:\n                    x = 0.12 + 0.76 * j / (nx - 1)\n                pts.append([x, y])\n        seeds.append(np.array(pts[:n]))\n    \n    # Add a grid-based seed: 5x5 grid plus one circle tucked in a gap\n    grid_seed = [[0.1 + 0.2*i, 0.1 + 0.2*j] for i in range(5) for j in range(5)]\n    grid_seed.append([0.2, 0.2]) # Placing 26th circle at an internal gap\n    seeds.append(np.array(grid_seed[:n]))\n\n    # Evaluate all candidate structural seeds using LP\n    for p_arr in seeds:\n        # Clip centers to ensure they are strictly within the unit square\n        p_arr = np.clip(p_arr, 0.001, 0.999)\n        radii, current_sum = solve_lp(p_arr)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii\n            best_centers = p_arr\n\n    # Return the configuration with the highest sum of radii found\n    final_centers = np.array(best_centers)\n    final_radii = np.array(best_radii)\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n\ndef construct_packing():\n    \"\"\"Alias for run_packing to ensure compatibility with different evaluator calls.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5414), Performs well on target_ratio (0.9645), Performs well on combined_score (0.9645), Performs well on radius_variance (0.0020), Performs well on spatial_spread (0.1919), Performs well on eval_time (0.3657)\n\n### Program 2 (Score: 0.9469)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the sum of radii.\n    \n    The strategy combines a force-directed (repulsion) simulation for center placement\n    with Linear Programming (LP) for optimal radius determination. \n    1. Multiple diverse seeds (row-based, grid, and random) are generated.\n    2. Each seed is refined using a repulsion-based particle simulation that pushes\n       circles apart and away from boundaries to find promising layouts.\n    3. For each refined layout, LP calculates the maximum possible radii for the fixed centers.\n    4. The configuration yielding the highest sum of radii is returned.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def solve_lp(P):\n        \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Non-overlapping constraints: r_i + r_j <= distance(C_i, C_j)\n        diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diff**2, axis=2))\n        \n        num_c = n * (n - 1) // 2\n        A = np.zeros((num_c, n))\n        b = np.zeros(num_c)\n        \n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A[k, i] = 1.0\n                A[k, j] = 1.0\n                # Small epsilon to prevent overlap due to float precision\n                b[k] = max(0.0, dists[i, j] - 1e-13)\n                k += 1\n        \n        # Boundary constraints: r_i <= distance to nearest wall\n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0.0, d_wall - 1e-13)))\n            \n        try:\n            # Highs is efficient and accurate for this LP size\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n            if res.success:\n                return res.x, -res.fun\n        except Exception:\n            pass\n        return np.zeros(n), 0.0\n\n    def refine_centers(P, d_ideal, steps=150):\n        \"\"\"Simulates circle-circle and circle-wall repulsion to improve layout.\"\"\"\n        P_curr = P.copy()\n        r_ideal = d_ideal / 2.0\n        for _ in range(steps):\n            # Inter-circle repulsion forces\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx, dy = P_curr[i, 0] - P_curr[j, 0], P_curr[i, 1] - P_curr[j, 1]\n                    d = (dx*dx + dy*dy)**0.5\n                    if d < d_ideal:\n                        # Prevent division by zero if centers coincide\n                        if d < 1e-10:\n                            P_curr[i, 0] += 0.001; continue\n                        # Push centers away proportionally to the overlap\n                        force = (d_ideal - d) * 0.1\n                        nx, ny = dx/d, dy/d\n                        P_curr[i, 0] += nx * force\n                        P_curr[i, 1] += ny * force\n                        P_curr[j, 0] -= nx * force\n                        P_curr[j, 1] -= ny * force\n            # Boundary (wall) repulsion forces\n            for i in range(n):\n                # Apply soft boundary push to keep circles inside the box\n                if P_curr[i, 0] < r_ideal: P_curr[i, 0] += (r_ideal - P_curr[i, 0]) * 0.15\n                elif P_curr[i, 0] > 1-r_ideal: P_curr[i, 0] -= (P_curr[i, 0] - (1-r_ideal)) * 0.15\n                if P_curr[i, 1] < r_ideal: P_curr[i, 1] += (r_ideal - P_curr[i, 1]) * 0.15\n                elif P_curr[i, 1] > 1-r_ideal: P_curr[i, 1] -= (P_curr[i, 1] - (1-r_ideal)) * 0.15\n            # Strictly clip to the unit square\n            P_curr = np.clip(P_curr, 0.0001, 0.9999)\n        return P_curr\n\n    # Candidate configurations to explore the solution space\n    configs = [\n        [5, 5, 6, 5, 5], [6, 5, 5, 5, 5], [5, 6, 5, 6, 4], \n        [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4]\n    ]\n    \n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Process structured row seeds\n    for cfg in configs:\n        pts = []\n        n_rows = len(cfg)\n        for r_idx, n_cols in enumerate(cfg):\n            y = (r_idx + 0.5) / n_rows\n            for c_idx in range(n_cols):\n                # Staggered hexagonal-like initialization\n                offset = 0.25 if r_idx % 2 == 1 else 0.5\n                x = (c_idx + offset) / n_cols\n                pts.append([x, y])\n        \n        base_P = np.array(pts[:n])\n        # Try different 'tightness' parameters for repulsion\n        for d_ideal in [0.20, 0.21]:\n            refined_P = refine_centers(base_P, d_ideal)\n            radii, current_sum = solve_lp(refined_P)\n            if current_sum > best_sum:\n                best_sum, best_centers, best_radii = current_sum, refined_P, radii\n\n    # Process grid-based seeds\n    grid = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n    grid_seed = np.vstack([grid, [0.5, 0.5]]) # 25 + 1 = 26 circles\n    for d_ideal in [0.20, 0.21]:\n        refined_P = refine_centers(grid_seed, d_ideal)\n        radii, current_sum = solve_lp(refined_P)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, refined_P, radii\n            \n    # Process random seeds to escape local row/grid optima\n    for _ in range(5):\n        random_P = np.random.uniform(0.1, 0.9, (n, 2))\n        refined_P = refine_centers(random_P, 0.205, steps=200)\n        radii, current_sum = solve_lp(refined_P)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, refined_P, radii\n\n    # Standardize result formats\n    return np.array(best_centers), np.array(best_radii), float(best_sum)\n\ndef construct_packing():\n    \"\"\"Wrapper to comply with execution call requirements.\"\"\"\n    return run_packing()\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4952), Performs well on target_ratio (0.9469), Performs well on combined_score (0.9469), Performs well on radius_variance (0.0009), Performs well on spatial_spread (0.1948), Performs well on eval_time (1.2371)\n\n### Program 3 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square maximizing the sum of radii.\n    The constructor uses several row-based structural configurations and applies \n    Linear Programming (LP) to find the optimal radii for the fixed center layouts.\n    \n    Returns:\n        centers (np.ndarray): (26, 2) array of circle centers.\n        radii (np.ndarray): (26,) array of circle radii.\n        sum_radii (float): Total sum of all 26 radii.\n    \"\"\"\n    n = 26\n\n    def solve_for_radii(centers):\n        \"\"\"\n        Calculates the maximum possible radii for a fixed set of centers \n        using Linear Programming to maximize the sum of radii.\n        \"\"\"\n        num_circles = centers.shape[0]\n        # Objective: maximize sum(radii), so minimize -sum(radii)\n        c = -np.ones(num_circles)\n        \n        # Non-overlapping constraints: r_i + r_j <= distance(C_i, C_j)\n        A_ub = []\n        b_ub = []\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                row = np.zeros(num_circles)\n                row[i], row[j] = 1.0, 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n        bounds = []\n        for i in range(num_circles):\n            x, y = centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0.0, max_r)))\n            \n        # Try solving with 'highs' method, fallback if necessary\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        except Exception:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n\n        if res and res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(num_circles), 0.0\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Define candidate row-based layouts that total 26 circles\n    # These structures allow for dense hexagonal-like packing\n    configs = [\n        [5, 5, 6, 5, 5],\n        [5, 6, 5, 6, 4],\n        [6, 5, 5, 5, 5],\n        [4, 6, 6, 6, 4]\n    ]\n\n    for config in configs:\n        # Create a layout based on the row configuration\n        centers_list = []\n        num_rows = len(config)\n        for i, count in enumerate(config):\n            # Distribute rows evenly in the y-direction\n            y = 0.1 + i * 0.2\n            # Stagger alternate rows to encourage density\n            offset = 0.05 if i % 2 == 1 else 0.0\n            # Distribute circles in the row\n            x_vals = np.linspace(0.1 + offset, 0.9 - offset, count)\n            for x in x_vals:\n                centers_list.append([x, y])\n        \n        # Use exactly 26 points\n        candidate_centers = np.array(centers_list[:n])\n        \n        # Calculate optimal radii for this layout\n        radii, current_sum = solve_for_radii(candidate_centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_radii = radii\n            best_overall_centers = candidate_centers\n\n    # Clean up the output\n    final_centers = np.array(best_overall_centers)\n    final_radii = np.array(best_overall_radii)\n    final_sum = float(np.sum(final_radii))\n\n    return final_centers, final_radii, final_sum\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square maximizing the sum of radii.\n    \n    The algorithm utilizes a two-stage approach:\n    1. Seed Generation & Evaluation: Generate numerous candidate layouts (row-based \n       hexagonal configurations, perturbed variations, and random layouts). \n       Linear Programming (LP) evaluates the optimal radii for each layout.\n    2. Gradient-based Joint Optimization: The top promising configurations are jointly \n       optimized using SLSQP (Sequential Least Squares Programming). By providing \n       the exact analytical Jacobian for both the objective and all constraints \n       (non-overlapping and boundary constraints), SLSQP rapidly refines the center \n       positions and radii to maximize the total sum of radii.\n       \n    Returns:\n        centers (np.ndarray): (26, 2) array of circle centers.\n        radii (np.ndarray): (26,) array of circle radii.\n        sum_radii (float): Total sum of all 26 radii.\n    \"\"\"\n    n = 26\n    \n    def solve_lp(P):\n        \"\"\"\n        Calculates the maximum possible radii for fixed centers using LP.\n        Ensures strictly valid boundaries and non-overlap.\n        \"\"\"\n        c_obj = -np.ones(n)\n        num_constraints = n * (n - 1) // 2\n        A_ub = np.zeros((num_constraints, n))\n        b_ub = np.zeros(num_constraints)\n        \n        curr = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(P[i] - P[j])\n                A_ub[curr, i] = 1.0\n                A_ub[curr, j] = 1.0\n                b_ub[curr] = max(0.0, dist - 1e-12)\n                curr += 1\n                \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0.0, max(0.0, d_wall - 1e-12)))\n            \n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success:\n                res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='interior-point')\n        except Exception:\n            try:\n                res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            except Exception:\n                return np.zeros(n), 0.0\n                \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0.0\n\n    # Ensure reproducibility\n    np.random.seed(42)\n    \n    # Diverse candidate structural row layouts totaling 26 circles\n    configs = [\n        [5, 5, 6, 5, 5], \n        [6, 5, 4, 5, 6], \n        [5, 6, 4, 6, 5], \n        [4, 5, 8, 5, 4], \n        [6, 5, 5, 5, 5], \n        [5, 5, 5, 5, 6], \n        [5, 5, 5, 6, 5], \n        [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], \n        [4, 5, 4, 5, 4, 4], \n        [4, 4, 5, 4, 4, 5], \n        [6, 4, 6, 4, 6], \n        [7, 6, 6, 7],    \n        [6, 7, 7, 6],    \n        [3, 5, 5, 5, 5, 3],\n        [5, 4, 4, 4, 4, 5]\n    ]\n\n    seeds = []\n    for cfg in configs:\n        pts = []\n        rows = len(cfg)\n        for i, nx in enumerate(cfg):\n            y = 0.1 + 0.8 * i / (rows - 1) if rows > 1 else 0.5\n            for j in range(nx):\n                x = 0.1 + 0.8 * j / (nx - 1) if nx > 1 else 0.5\n                if i % 2 == 1:\n                    if nx > 1:\n                        offset = 0.8 / (nx - 1) / 2.0\n                        x += offset\n                    x = min(max(x, 0.05), 0.95)\n                pts.append([x, y])\n        \n        base_pts = np.array(pts[:n])\n        seeds.append(base_pts)\n        # Add varying degrees of perturbation to escape strict symmetries\n        seeds.append(base_pts + np.random.uniform(-0.015, 0.015, (n, 2)))\n        seeds.append(base_pts + np.random.uniform(-0.03, 0.03, (n, 2)))\n\n    # Extra grid-based seed with one overlap to challenge the optimizer\n    grid_seed = [[0.1 + 0.2*i, 0.1 + 0.2*j] for i in range(5) for j in range(5)]\n    grid_seed.append([0.5, 0.5]) \n    seeds.append(np.array(grid_seed[:n]))\n\n    # Pure random seeds for broad exploration\n    for _ in range(5):\n        seeds.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    best_configs = []\n    for p_arr in seeds:\n        p_arr = np.clip(p_arr, 0.001, 0.999)\n        # Add tiny noise to prevent identical points causing zero-gradients in SLSQP\n        p_arr += np.random.uniform(-1e-5, 1e-5, p_arr.shape)\n        p_arr = np.clip(p_arr, 0.001, 0.999)\n        \n        radii, current_sum = solve_lp(p_arr)\n        best_configs.append((current_sum, p_arr, radii))\n        \n    best_configs.sort(key=lambda x: x[0], reverse=True)\n    \n    # ---------------- SLSQP Joint Optimization Setup ----------------\n    def obj(vars):\n        return -np.sum(vars[2*n:3*n])\n        \n    def jac_obj(vars):\n        g = np.zeros(3*n)\n        g[2*n:3*n] = -1.0\n        return g\n        \n    def constr_ineq(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        c = []\n        for i in range(n):\n            for j in range(i+1, n):\n                c.append((x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2)\n        for i in range(n):\n            c.append(x[i] - r[i])\n            c.append(1.0 - x[i] - r[i])\n            c.append(y[i] - r[i])\n            c.append(1.0 - y[i] - r[i])\n        return np.array(c)\n        \n    def jac_constr_ineq(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        \n        num_c = n*(n-1)//2 + 4*n\n        J = np.zeros((num_c, 3*n))\n        row = 0\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dx, dy, dr = x[i]-x[j], y[i]-y[j], r[i]+r[j]\n                J[row, i], J[row, j] = 2*dx, -2*dx\n                J[row, n+i], J[row, n+j] = 2*dy, -2*dy\n                J[row, 2*n+i], J[row, 2*n+j] = -2*dr, -2*dr\n                row += 1\n                \n        for i in range(n):\n            J[row, i], J[row, 2*n+i] = 1.0, -1.0\n            row += 1\n            J[row, i], J[row, 2*n+i] = -1.0, -1.0\n            row += 1\n            J[row, n+i], J[row, 2*n+i] = 1.0, -1.0\n            row += 1\n            J[row, n+i], J[row, 2*n+i] = -1.0, -1.0\n            row += 1\n            \n        return J\n\n    bnds = [(0.0, 1.0)]*(2*n) + [(0.0, 0.5)]*n\n    top_k = 20\n    \n    global_best_sum = -1.0\n    global_best_centers = None\n    global_best_radii = None\n    \n    # Run joint local search on the top best initializations\n    for idx in range(min(top_k, len(best_configs))):\n        init_sum, init_centers, init_radii = best_configs[idx]\n        x0 = np.concatenate([init_centers[:, 0], init_centers[:, 1], init_radii])\n        \n        res = minimize(obj, x0, method='SLSQP', jac=jac_obj, bounds=bnds,\n                       constraints={'type': 'ineq', 'fun': constr_ineq, 'jac': jac_constr_ineq},\n                       options={'maxiter': 500, 'ftol': 1e-6})\n        \n        final_x = res.x[0:n]\n        final_y = res.x[n:2*n]\n        final_centers = np.column_stack((\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the sum of radii.\n    \n    The strategy utilizes several candidate structural layouts, including varied row-based \n    staggered configurations, grids, and hexagonal patterns. Linear Programming (LP) is then \n    applied to determine the optimal radii for each fixed set of centers. This approach \n    ensures that the circles maximize the total sum while strictly adhering to non-overlap \n    and boundary constraints.\n    \"\"\"\n    n = 26\n    \n    def solve_lp_for_radii(P):\n        \"\"\"\n        Solves a Linear Program to maximize the sum of radii for a fixed set of centers.\n        Objective: Maximize sum(r_i)\n        Constraints:\n            r_i + r_j <= distance(center_i, center_j)\n            r_i <= distance(center_i, wall)\n        \"\"\"\n        num_circles = P.shape[0]\n        # Objective: minimize -sum(r_i) which is maximizing sum(r_i)\n        c_obj = -np.ones(num_circles)\n        \n        # Non-overlapping constraints: r_i + r_j <= dist(C_i, C_j)\n        num_constraints = num_circles * (num_circles - 1) // 2\n        A_ub = np.zeros((num_constraints, num_circles))\n        b_ub = np.zeros(num_constraints)\n        \n        # Precompute distances\n        dists = np.linalg.norm(P[:, np.newaxis, :] - P[np.newaxis, :, :], axis=2)\n        \n        curr = 0\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                A_ub[curr, i] = 1.0\n                A_ub[curr, j] = 1.0\n                # Subtract tiny epsilon for numerical precision and validity\n                b_ub[curr] = max(0, dists[i, j] - 1e-11)\n                curr += 1\n        \n        # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n        bounds = []\n        for i in range(num_circles):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            # Ensure radius is non-negative and fits within the square\n            bounds.append((0, max(0, d_wall - 1e-11)))\n            \n        try:\n            # Highs is faster and more robust (Scipy >= 1.5.0)\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success:\n                res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        except Exception:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            \n        if res and res.success:\n            return res.x, -res.fun\n        return np.zeros(num_circles), 0.0\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    # Define candidate layouts\n    seeds = []\n\n    # 1. Staggered Row Configurations\n    # Row counts that total 26 circles\n    row_configs = [\n        [5, 5, 6, 5, 5],\n        [6, 5, 5, 5, 5],\n        [4, 5, 4, 5, 4, 4],\n        [5, 4, 5, 4, 5, 3],\n        [5, 6, 5, 6, 4],\n        [4, 6, 6, 6, 4],\n        [4, 5, 5, 5, 4, 3],\n        [4, 4, 4, 4, 4, 6]\n    ]\n\n    for cfg in row_configs:\n        pts = []\n        rows = len(cfg)\n        for i, nx in enumerate(cfg):\n            # Vertical distribution\n            y = 0.09 + 0.82 * i / (rows - 1)\n            for j in range(nx):\n                # Basic horizontal distribution\n                x = 0.09 + 0.82 * j / (nx - 1)\n                # Stagger alternate rows to allow potentially larger radii\n                if i % 2 == 1:\n                    x = 0.11 + 0.78 * j / (nx - 1)\n                pts.append([x, y])\n        seeds.append(np.array(pts[:n]))\n\n    # 2. Base Grid-based Layouts (n=25) with a 26th circle added\n    # 5x5 grid with one circle in a significant gap\n    grid_seed = []\n    for i in range(5):\n        for j in range(5):\n            grid_seed.append([0.1 + 0.2*i, 0.1 + 0.2*j])\n    grid_seed.append([0.2, 0.2]) # Add 26th circle in the first internal gap\n    seeds.append(np.array(grid_seed[:n]))\n    \n    # 3. Tilted or Hexagonal-like Dense Grid\n    # Using a 4x7 structure adapted to 26\n    hex_pts = []\n    for r in range(6):\n        for c in range(5 if r % 2 == 0 else 4):\n            x = 0.1 + c * 0.2 + (0.1 if r % 2 == 1 else 0)\n            y = 0.1 + r * 0.16\n            hex_pts.append([x, y])\n    seeds.append(np.array(hex_pts[:n]))\n\n    # Evaluate candidate layouts using the LP solver\n    for p_arr in seeds:\n        # Clip centers to ensure they are strictly inside the unit square\n        p_arr = np.clip(p_arr, 0.001, 0.999)\n        radii, current_sum = solve_lp_for_radii(p_arr)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii\n            best_centers = p_arr\n\n    # Ensure final output is strictly valid and return results\n    final_centers = np.array(best_centers)\n    final_radii = np.array(best_radii)\n    final_sum = float(np.sum(final_radii))\n    \n    return final_centers, final_radii, final_sum\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n```python\nimport numpy as np\nfrom scipy.optimize import linprog, minimize\n\ndef run_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square maximizing the sum of radii.\n    \n    The algorithm utilizes a two-stage approach:\n    1. Seed Generation & Evaluation: Generate numerous candidate layouts (row-based \n       hexagonal configurations, perturbed variations, and random layouts). \n       Linear Programming (LP) evaluates the optimal radii for each layout.\n    2. Gradient-based Joint Optimization: The top promising configurations are jointly \n       optimized using SLSQP (Sequential Least Squares Programming). By providing \n       the exact analytical Jacobian for both the objective and all constraints \n       (non-overlapping and boundary constraints), SLSQP rapidly refines the center \n       positions and radii to maximize the total sum of radii.\n       \n    Returns:\n        centers (np.ndarray): (26, 2) array of circle centers.\n        radii (np.ndarray): (26,) array of circle radii.\n        sum_radii (float): Total sum of all 26 radii.\n    \"\"\"\n    n = 26\n    \n    def solve_lp(P):\n        \"\"\"\n        Calculates the maximum possible radii for fixed centers using LP.\n        Ensures strictly valid boundaries and non-overlap.\n        \"\"\"\n        c_obj = -np.ones(n)\n        num_constraints = n * (n - 1) // 2\n        A_ub = np.zeros((num_constraints, n))\n        b_ub = np.zeros(num_constraints)\n        \n        curr = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(P[i] - P[j])\n                A_ub[curr, i] = 1.0\n                A_ub[curr, j] = 1.0\n                b_ub[curr] = max(0.0, dist - 1e-12)\n                curr += 1\n                \n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0.0, max(0.0, d_wall - 1e-12)))\n            \n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success:\n                res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='interior-point')\n        except Exception:\n            try:\n                res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n            except Exception:\n                return np.zeros(n), 0.0\n                \n        if res.success:\n            return res.x, -res.fun\n        return np.zeros(n), 0.0\n\n    # Ensure reproducibility\n    np.random.seed(42)\n    \n    # Diverse candidate structural row layouts totaling 26 circles\n    configs = [\n        [5, 5, 6, 5, 5], \n        [6, 5, 4, 5, 6], \n        [5, 6, 4, 6, 5], \n        [4, 5, 8, 5, 4], \n        [6, 5, 5, 5, 5], \n        [5, 5, 5, 5, 6], \n        [5, 5, 5, 6, 5], \n        [4, 6, 6, 6, 4], \n        [5, 6, 5, 6, 4], \n        [4, 5, 4, 5, 4, 4], \n        [4, 4, 5, 4, 4, 5], \n        [6, 4, 6, 4, 6], \n        [7, 6, 6, 7],    \n        [6, 7, 7, 6],    \n        [3, 5, 5, 5, 5, 3],\n        [5, 4, 4, 4, 4, 5]\n    ]\n\n    seeds = []\n    for cfg in configs:\n        pts = []\n        rows = len(cfg)\n        for i, nx in enumerate(cfg):\n            y = 0.1 + 0.8 * i / (rows - 1) if rows > 1 else 0.5\n            for j in range(nx):\n                x = 0.1 + 0.8 * j / (nx - 1) if nx > 1 else 0.5\n                if i % 2 == 1:\n                    if nx > 1:\n                        offset = 0.8 / (nx - 1) / 2.0\n                        x += offset\n                    x = min(max(x, 0.05), 0.95)\n                pts.append([x, y])\n        \n        base_pts = np.array(pts[:n])\n        seeds.append(base_pts)\n        # Add varying degrees of perturbation to escape strict symmetries\n        seeds.append(base_pts + np.random.uniform(-0.015, 0.015, (n, 2)))\n        seeds.append(base_pts + np.random.uniform(-0.03, 0.03, (n, 2)))\n\n    # Extra grid-based seed with one overlap to challenge the optimizer\n    grid_seed = [[0.1 + 0.2*i, 0.1 + 0.2*j] for i in range(5) for j in range(5)]\n    grid_seed.append([0.5, 0.5]) \n    seeds.append(np.array(grid_seed[:n]))\n\n    # Pure random seeds for broad exploration\n    for _ in range(5):\n        seeds.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    best_configs = []\n    for p_arr in seeds:\n        p_arr = np.clip(p_arr, 0.001, 0.999)\n        # Add tiny noise to prevent identical points causing zero-gradients in SLSQP\n        p_arr += np.random.uniform(-1e-5, 1e-5, p_arr.shape)\n        p_arr = np.clip(p_arr, 0.001, 0.999)\n        \n        radii, current_sum = solve_lp(p_arr)\n        best_configs.append((current_sum, p_arr, radii))\n        \n    best_configs.sort(key=lambda x: x[0], reverse=True)\n    \n    # ---------------- SLSQP Joint Optimization Setup ----------------\n    def obj(vars):\n        return -np.sum(vars[2*n:3*n])\n        \n    def jac_obj(vars):\n        g = np.zeros(3*n)\n        g[2*n:3*n] = -1.0\n        return g\n        \n    def constr_ineq(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        c = []\n        for i in range(n):\n            for j in range(i+1, n):\n                c.append((x[i]-x[j])**2 + (y[i]-y[j])**2 - (r[i]+r[j])**2)\n        for i in range(n):\n            c.append(x[i] - r[i])\n            c.append(1.0 - x[i] - r[i])\n            c.append(y[i] - r[i])\n            c.append(1.0 - y[i] - r[i])\n        return np.array(c)\n        \n    def jac_constr_ineq(vars):\n        x = vars[0:n]\n        y = vars[n:2*n]\n        r = vars[2*n:3*n]\n        \n        num_c = n*(n-1)//2 + 4*n\n        J = np.zeros((num_c, 3*n))\n        row = 0\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dx, dy, dr = x[i]-x[j], y[i]-y[j], r[i]+r[j]\n                J[row, i], J[row, j] = 2*dx, -2*dx\n                J[row, n+i], J[row, n+j] = 2*dy, -2*dy\n                J[row, 2*n+i], J[row, 2*n+j] = -2*dr, -2*dr\n                row += 1\n                \n        for i in range(n):\n            J[row, i], J[row, 2*n+i] = 1.0, -1.0\n            row += 1\n            J[row, i], J[row, 2*n+i] = -1.0, -1.0\n            row += 1\n            J[row, n+i], J[row, 2*n+i] = 1.0, -1.0\n            row += 1\n            J[row, n+i], J[row, 2*n+i] = -1.0, -1.0\n            row += 1\n            \n        return J\n\n    bnds = [(0.0, 1.0)]*(2*n) + [(0.0, 0.5)]*n\n    top_k = 20\n    \n    global_best_sum = -1.0\n    global_best_centers = None\n    global_best_radii = None\n    \n    # Run joint local search on the top best initializations\n    for idx in range(min(top_k, len(best_configs))):\n        init_sum, init_centers, init_radii = best_configs[idx]\n        x0 = np.concatenate([init_centers[:, 0], init_centers[:, 1], init_radii])\n        \n        res = minimize(obj, x0, method='SLSQP', jac=jac_obj, bounds=bnds,\n                       constraints={'type': 'ineq', 'fun': constr_ineq, 'jac': jac_constr_ineq},\n                       options={'maxiter': 500, 'ftol': 1e-6})\n        \n        final_x = res.x[0:n]\n        final_y = res.x[n:2*n]\n        final_centers = np.column_stack((\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square maximizing the sum of radii.\n    The strategy uses multiple candidate structural layouts (row-based and hexagonal),\n    then applies Linear Programming (LP) to find the optimal radii for fixed centers,\n    and finally refines the best layout with a local stochastic hill-climbing search.\n    \"\"\"\n    n = 26\n\n    def solve_for_radii(centers):\n        \"\"\"Finds optimal radii for given centers using Linear Programming.\"\"\"\n        num_c = centers.shape[0]\n        # Maximize sum(r_i) => Minimize -sum(r_i)\n        c_obj = -np.ones(num_c)\n        \n        # Constraints: r_i + r_j <= distance(C_i, C_j)\n        num_constraints = num_c * (num_c - 1) // 2\n        A_ub = np.zeros((num_constraints, num_c))\n        b_ub = np.zeros(num_constraints)\n        \n        idx = 0\n        for i in range(num_c):\n            for j in range(i + 1, num_c):\n                # Distance between centers i and j\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                A_ub[idx, i] = 1.0\n                A_ub[idx, j] = 1.0\n                # Subtract small epsilon to avoid floating point overlaps\n                b_ub[idx] = max(0, dist - 1e-11)\n                idx += 1\n        \n        # Boundary constraints: r_i <= distance to nearest wall\n        bounds = []\n        for i in range(num_c):\n            x, y = centers[i]\n            max_r = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0, max_r - 1e-11)))\n            \n        try:\n            # Attempt to use 'highs' method for efficiency\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        except Exception:\n            # Fallback to default interior-point method\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(num_c), 0.0\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    # Part 1: Evaluate candidate staggered row-based layouts\n    # These configs all sum to exactly 26 circles\n    configs = [\n        [5, 5, 6, 5, 5],\n        [5, 6, 5, 6, 4],\n        [6, 5, 6, 5, 4],\n        [4, 6, 6, 6, 4],\n        [5, 5, 5, 5, 6]\n    ]\n\n    for row_counts in configs:\n        for margin_y in [0.08, 0.1, 0.12]:\n            centers = []\n            ny = len(row_counts)\n            y_coords = np.linspace(margin_y, 1.0 - margin_y, ny)\n            for i, nx in enumerate(row_counts):\n                y = y_coords[i]\n                # Distribute circles evenly in the row\n                x_coords = (np.arange(nx) + 0.5) / nx\n                for x in x_coords:\n                    centers.append([x, y])\n            \n            candidate_centers = np.array(centers[:n])\n            radii, current_sum = solve_for_radii(candidate_centers)\n            \n            if current_sum > best_sum:\n                best_sum, best_centers, best_radii = current_sum, candidate_centers, radii\n\n    # Part 2: Evaluate hexagonal grid variations\n    for d in [0.18, 0.2, 0.22]:\n        hex_centers = []\n        for r in range(7):\n            for c in range(7):\n                # Standard hexagonal packing coordinates\n                x = (c + 0.5 * (r % 2)) * d\n                y = r * d * 0.866\n                hex_centers.append([x, y])\n        \n        c_arr = np.array(hex_centers[:n])\n        # Center the grid within the unit square\n        c_arr -= (np.mean(c_arr, axis=0) - 0.5)\n        c_arr = np.clip(c_arr, 1e-8, 1.0 - 1e-8)\n        \n        radii, current_sum = solve_for_radii(c_arr)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, c_arr, radii\n\n    # Part 3: Local Refinement (Stochastic Hill-Climbing)\n    if best_centers is not None:\n        np.random.seed(42) # Ensure consistency\n        curr_centers = best_centers.copy()\n        # Refine the best layout found to allow radii to expand\n        for step in range(30):\n            # Gradually decrease the intensity of perturbations\n            scale = 0.008 * (1.0 - step / 30.0)\n            jitter = np.random.normal(0, scale, size=curr_centers.shape)\n            test_centers = np.clip(curr_centers + jitter, 1e-8, 1.0 - 1e-8)\n            \n            test_radii, test_sum = solve_for_radii(test_centers)\n            if test_sum > best_sum:\n                best_sum, best_centers, best_radii = test_sum, test_centers, test_radii\n                curr_centers = test_centers\n\n    # Convert to expected output types\n    final_centers = np.array(best_centers)\n    final_radii = np.array(best_radii)\n    final_sum = float(np.sum(final_radii))\n\n    return final_centers, final_radii, final_sum\n\nif __name__ == \"__main__\":\n    centers, radii, sum_r = construct_packing()\n    print(f\"Total sum of radii: {sum_r:.5f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square maximizing the sum of radii.\n    \n    This constructor uses multiple candidate structural layouts (primarily row-based \n    staggered configurations and a grid-plus-one approach). For each layout, \n    Linear Programming (LP) is used to determine the optimal radii that maximize \n    the total sum while ensuring no overlaps and remaining within the unit square \n    boundaries [0, 1] x [0, 1].\n    \n    Returns:\n        centers (np.ndarray): (26, 2) array of circle centers.\n        radii (np.ndarray): (26,) array of circle radii.\n        sum_radii (float): Total sum of all 26 radii.\n    \"\"\"\n    n = 26\n    \n    def solve_for_radii(centers):\n        \"\"\"\n        Calculates the maximum possible radii for a fixed set of centers \n        using Linear Programming to maximize the sum of radii.\n        \"\"\"\n        centers = np.array(centers)\n        num_circles = centers.shape[0]\n        \n        # Objective: minimize -sum(radii) which is maximizing sum(radii)\n        c = -np.ones(num_circles)\n        \n        # Non-overlapping constraints: r_i + r_j <= distance(C_i, C_j)\n        A_ub = []\n        b_ub = []\n        for i in range(num_circles):\n            for j in range(i + 1, num_circles):\n                dist = np.sqrt(np.sum((centers[i] - centers[j])**2))\n                row = np.zeros(num_circles)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist)\n        \n        # Boundary constraints: r_i <= min(x_i, 1-x_i, y_i, 1-y_i)\n        bounds = []\n        for i in range(num_circles):\n            max_r = min(float(centers[i][0]), 1.0 - float(centers[i][0]),\n                        float(centers[i][1]), 1.0 - float(centers[i][1]))\n            # Ensure radius is non-negative\n            bounds.append((0, max(0.0, max_r)))\n            \n        # Try solving with the 'highs' method for efficiency\n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if not res.success:\n                # Fallback to interior-point if highs fails\n                res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='interior-point')\n        except Exception:\n            # Final fallback\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n\n        if res.success:\n            return res.x, -res.fun\n        else:\n            return np.zeros(num_circles), 0.0\n\n    # Initialize best results\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Define several candidate structural layouts\n    candidate_centers_list = []\n\n    # Configuration 1: 5-5-6-5-5 Row-based layout (Staggered)\n    c1 = []\n    rows1 = [5, 5, 6, 5, 5]\n    y_vals1 = np.linspace(0.1, 0.9, 5)\n    for i, count in enumerate(rows1):\n        y = y_vals1[i]\n        offset = 0.05 if i % 2 == 1 else 0.0\n        x_vals = np.linspace(0.1 + offset, 0.9 - offset, count)\n        for x in x_vals:\n            c1.append([x, y])\n    candidate_centers_list.append(np.array(c1))\n\n    # Configuration 2: 6-5-5-5-5 Row-based layout (Bottom-heavy)\n    c2 = []\n    rows2 = [6, 5, 5, 5, 5]\n    y_vals2 = np.linspace(0.09, 0.91, 5)\n    for i, count in enumerate(rows2):\n        y = y_vals2[i]\n        offset = 0.04 if i % 2 == 1 else 0.0\n        x_vals = np.linspace(0.09 + offset, 0.91 - offset, count)\n        for x in x_vals:\n            c2.append([x, y])\n    candidate_centers_list.append(np.array(c2))\n\n    # Configuration 3: 5x5 Grid with one extra circle in a central gap\n    c3 = []\n    # Create standard 5x5 grid\n    for i in range(5):\n        for j in range(5):\n            c3.append([0.1 + i * 0.2, 0.1 + j * 0.2])\n    # Add 26th circle in the gap between (0.1, 0.1) and (0.3, 0.3)\n    c3.append([0.2, 0.2])\n    candidate_centers_list.append(np.array(c3))\n\n    # Configuration 4: 5-5-5-6-5 Row-based layout (Top-heavy)\n    c4 = []\n    rows4 = [5, 5, 5, 6, 5]\n    y_vals4 = np.linspace(0.1, 0.9, 5)\n    for i, count in enumerate(rows4):\n        y = y_vals4[i]\n        # Alternate offsets for a staggered hexagonal feel\n        offset = 0.06 if i % 2 == 1 else 0.0\n        x_vals = np.linspace(0.1 + offset, 0.9 - offset, count)\n        for x in x_vals:\n            c4.append([x, y])\n    candidate_centers_list.append(np.array(c4))\n\n    # Evaluate each layout using LP\n    for centers in candidate_centers_list:\n        # Check if center count is correct\n        if centers.shape[0] != n:\n            continue\n            \n        # Ensure centers are strictly inside the unit square boundaries\n        centers = np.clip(centers, 0.0001, 0.9999)\n        \n        radii, current_sum = solve_for_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_radii = radii\n            best_overall_centers = centers\n\n    # Final cleanup: subtract a tiny epsilon to avoid potential floating-point overlaps\n    # and ensure non-negativity\n    final_radii = np.maximum(0.0, best_overall_radii - 1e-10)\n    final_sum = float(np.sum(final_radii))\n\n    return best_overall_centers, final_radii, final_sum\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the sum of radii.\n    \n    The strategy combines a force-directed (repulsion) simulation for center placement\n    with Linear Programming (LP) for optimal radius determination. \n    1. Multiple diverse seeds (row-based, grid, and random) are generated.\n    2. Each seed is refined using a repulsion-based particle simulation that pushes\n       circles apart and away from boundaries to find promising layouts.\n    3. For each refined layout, LP calculates the maximum possible radii for the fixed centers.\n    4. The configuration yielding the highest sum of radii is returned.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def solve_lp(P):\n        \"\"\"Calculates optimal radii for fixed centers using Linear Programming.\"\"\"\n        # Objective: Maximize sum(r_i) -> Minimize -sum(r_i)\n        c = -np.ones(n)\n        \n        # Non-overlapping constraints: r_i + r_j <= distance(C_i, C_j)\n        diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diff**2, axis=2))\n        \n        num_c = n * (n - 1) // 2\n        A = np.zeros((num_c, n))\n        b = np.zeros(num_c)\n        \n        k = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A[k, i] = 1.0\n                A[k, j] = 1.0\n                # Small epsilon to prevent overlap due to float precision\n                b[k] = max(0.0, dists[i, j] - 1e-13)\n                k += 1\n        \n        # Boundary constraints: r_i <= distance to nearest wall\n        bounds = []\n        for i in range(n):\n            x, y = P[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0.0, d_wall - 1e-13)))\n            \n        try:\n            # Highs is efficient and accurate for this LP size\n            res = linprog(c, A_ub=A, b_ub=b, bounds=bounds, method='highs')\n            if res.success:\n                return res.x, -res.fun\n        except Exception:\n            pass\n        return np.zeros(n), 0.0\n\n    def refine_centers(P, d_ideal, steps=150):\n        \"\"\"Simulates circle-circle and circle-wall repulsion to improve layout.\"\"\"\n        P_curr = P.copy()\n        r_ideal = d_ideal / 2.0\n        for _ in range(steps):\n            # Inter-circle repulsion forces\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx, dy = P_curr[i, 0] - P_curr[j, 0], P_curr[i, 1] - P_curr[j, 1]\n                    d = (dx*dx + dy*dy)**0.5\n                    if d < d_ideal:\n                        # Prevent division by zero if centers coincide\n                        if d < 1e-10:\n                            P_curr[i, 0] += 0.001; continue\n                        # Push centers away proportionally to the overlap\n                        force = (d_ideal - d) * 0.1\n                        nx, ny = dx/d, dy/d\n                        P_curr[i, 0] += nx * force\n                        P_curr[i, 1] += ny * force\n                        P_curr[j, 0] -= nx * force\n                        P_curr[j, 1] -= ny * force\n            # Boundary (wall) repulsion forces\n            for i in range(n):\n                # Apply soft boundary push to keep circles inside the box\n                if P_curr[i, 0] < r_ideal: P_curr[i, 0] += (r_ideal - P_curr[i, 0]) * 0.15\n                elif P_curr[i, 0] > 1-r_ideal: P_curr[i, 0] -= (P_curr[i, 0] - (1-r_ideal)) * 0.15\n                if P_curr[i, 1] < r_ideal: P_curr[i, 1] += (r_ideal - P_curr[i, 1]) * 0.15\n                elif P_curr[i, 1] > 1-r_ideal: P_curr[i, 1] -= (P_curr[i, 1] - (1-r_ideal)) * 0.15\n            # Strictly clip to the unit square\n            P_curr = np.clip(P_curr, 0.0001, 0.9999)\n        return P_curr\n\n    # Candidate configurations to explore the solution space\n    configs = [\n        [5, 5, 6, 5, 5], [6, 5, 5, 5, 5], [5, 6, 5, 6, 4], \n        [4, 6, 6, 6, 4], [4, 5, 4, 5, 4, 4]\n    ]\n    \n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Process structured row seeds\n    for cfg in configs:\n        pts = []\n        n_rows = len(cfg)\n        for r_idx, n_cols in enumerate(cfg):\n            y = (r_idx + 0.5) / n_rows\n            for c_idx in range(n_cols):\n                # Staggered hexagonal-like initialization\n                offset = 0.25 if r_idx % 2 == 1 else 0.5\n                x = (c_idx + offset) / n_cols\n                pts.append([x, y])\n        \n        base_P = np.array(pts[:n])\n        # Try different 'tightness' parameters for repulsion\n        for d_ideal in [0.20, 0.21]:\n            refined_P = refine_centers(base_P, d_ideal)\n            radii, current_sum = solve_lp(refined_P)\n            if current_sum > best_sum:\n                best_sum, best_centers, best_radii = current_sum, refined_P, radii\n\n    # Process grid-based seeds\n    grid = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n    grid_seed = np.vstack([grid, [0.5, 0.5]]) # 25 + 1 = 26 circles\n    for d_ideal in [0.20, 0.21]:\n        refined_P = refine_centers(grid_seed, d_ideal)\n        radii, current_sum = solve_lp(refined_P)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, refined_P, radii\n            \n    # Process random seeds to escape local row/grid optima\n    for _ in range(5):\n        random_P = np.random.uniform(0.1, 0.9, (n, 2))\n        refined_P = refine_centers(random_P, 0.205, steps=200)\n        radii, current_sum = solve_lp(refined_P)\n        if current_sum > best_sum:\n            best_sum, best_centers, best_radii = current_sum, refined_P, radii\n\n    # Standardize result formats\n    return np.array(best_centers), np.array(best_radii), float(best_sum)\n\ndef construct_packing():\n    \"\"\"Wrapper to comply with execution call requirements.\"\"\"\n    return run_packing()\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef solve_lp(P):\n    \"\"\"\n    Given a fixed set of centers P, uses Linear Programming to determine the \n    maximum possible radii that satisfy non-overlap and boundary constraints.\n    Returns the array of radii and their total sum.\n    \"\"\"\n    n = P.shape[0]\n    # Objective: Maximize sum(r_i) which is equivalent to minimizing -sum(r_i)\n    c = -np.ones(n)\n    \n    # Precompute pairwise distances between centers\n    diff = P[:, np.newaxis, :] - P[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=2))\n    \n    # Non-overlap constraints: r_i + r_j <= distance(center_i, center_j)\n    num_constraints = n * (n - 1) // 2\n    A_ub = np.zeros((num_constraints, n))\n    b_ub = np.zeros(num_constraints)\n    \n    k = 0\n    for i in range(n):\n        for j in range(i + 1, n):\n            A_ub[k, i] = 1.0\n            A_ub[k, j] = 1.0\n            # Subtract tiny epsilon to handle float precision and ensure no overlap\n            b_ub[k] = max(0.0, dist[i, j] - 1e-12)\n            k += 1\n            \n    # Boundary constraints: r_i <= distance from center to nearest wall\n    # 0 <= x_i - r_i  => r_i <= x_i\n    # x_i + r_i <= 1  => r_i <= 1 - x_i\n    bounds = []\n    for i in range(n):\n        x, y = P[i]\n        d_wall = min(x, 1.0 - x, y, 1.0 - y)\n        bounds.append((0, max(0.0, d_wall - 1e-12)))\n        \n    try:\n        # Solve using the 'highs' method for speed and robustness\n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        if not res.success:\n            # Fallback to default if 'highs' fails\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            return res.x, -res.fun\n    except:\n        pass\n    return None, 0.0\n\ndef construct_packing():\n    \"\"\"\n    Main constructor for a 26-circle packing in a unit square.\n    Combines varied structural layout seeds with local stochastic refinement.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    np.random.seed(42)\n    \n    # Generate diverse candidate seeds based on staggered row layouts\n    seeds = []\n    # Structural row configurations that total at least 26 circles\n    configs = [\n        [5, 5, 6, 5, 5], \n        [6, 5, 5, 5, 5], \n        [5, 6, 5, 6, 4], \n        [4, 6, 6, 6, 4], \n        [4, 5, 4, 5, 4, 4],\n        [6, 6, 7, 7]\n    ]\n    \n    for cfg in configs:\n        # Try variations in row-staggering and boundary padding\n        for stagger_val in [0.0, 0.3, 0.6]:\n            for margin_y in [0.07, 0.1, 0.13]:\n                pts = []\n                num_rows = len(cfg)\n                for r_idx, num_cols in enumerate(cfg):\n                    # Distribute rows vertically\n                    y = margin_y + (1.0 - 2.0 * margin_y) * r_idx / (num_rows - 1)\n                    for c_idx in range(num_cols):\n                        # Distribute circles horizontally, staggering alternating rows\n                        offset = stagger_val if r_idx % 2 == 1 else 0.0\n                        x = (c_idx + 0.5 + offset) / num_cols\n                        pts.append([x, y])\n                # Clip to unit square and take exactly n circles\n                seeds.append(np.clip(np.array(pts[:n]), 0.01, 0.99))\n                \n    # Add grid-based seeds (5x5 grid + 1 extra circle in a gap)\n    grid = np.array([[x, y] for x in np.linspace(0.1, 0.9, 5) for y in np.linspace(0.1, 0.9, 5)])\n    seeds.append(np.vstack([grid, [0.5, 0.5]]))\n    seeds.append(np.vstack([grid, [0.2, 0.2]]))\n\n    # Evaluate all initial seeds\n    for initial_pts in seeds:\n        radii, current_sum = solve_lp(initial_pts)\n        if current_sum > best_sum:\n            best_sum, best_r, best_p = current_sum, radii, initial_pts\n\n    # Refine the best layout found using stochastic hill-climbing\n    if best_p is not None:\n        current_refined_p = best_p.copy()\n        # Perform iterative jittering of center positions\n        for i in range(25):\n            # Decrease the perturbation scale over time\n            jitter_scale = 0.008 / (1.0 + i**0.5)\n            test_p = current_refined_p + np.random.normal(0, jitter_scale, (n, 2))\n            test_p = np.clip(test_p, 0.001, 0.999)\n            \n            radii, current_sum = solve_lp(test_p)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_r = radii\n                best_p = test_p\n                current_refined_p = test_p\n\n    # Convert results to expected formats\n    final_centers = np.array(best_p)\n    final_radii = np.array(best_r)\n    final_sum = float(best_sum)\n    \n    return final_centers, final_radii, final_sum\n\ndef run_packing():\n    \"\"\"Alias for construct_packing to match typical evaluator calls.\"\"\"\n    return construct_packing()\n```"]}}, "artifacts_json": "{\"execution_time\": \"0.51s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.541421/2.635 = 0.9645\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 96.4% of target value\", \"radius_stats\": \"Min: 0.041421, Max: 0.100000, Avg: 0.097747\"}", "artifact_dir": null, "embedding": null}