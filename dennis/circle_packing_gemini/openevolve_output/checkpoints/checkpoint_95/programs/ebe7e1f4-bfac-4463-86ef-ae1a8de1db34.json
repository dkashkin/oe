{"id": "ebe7e1f4-bfac-4463-86ef-ae1a8de1db34", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis implementation uses a multi-start strategy with physics-based relaxation\nand an iterative radius optimizer to maximize the total sum of radii.\n\"\"\"\nimport numpy as np\n\ndef compute_max_radii(centers, iterations=400):\n    \"\"\"\n    Maximizes the sum of radii for fixed centers using iterative coordinate descent.\n    Constraints: \n      1) r_i + r_j <= distance(c_i, c_j)\n      2) r_i <= distance(c_i, boundary)\n    Coordinate descent for this linear problem converges to a near-optimal set of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Pairwise distance matrix\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Fill diagonal with a large value to ignore self-constraints during minimization\n    np.fill_diagonal(dists, 10.0)\n    \n    # Boundary distances for each center\n    b_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    \n    # Initialize radii with a balanced guess to prevent early 'stealing' of space\n    radii = np.full(n, 0.05)\n    \n    # Iterative coordinate descent to maximize the objective function sum(radii)\n    for _ in range(iterations):\n        for i in range(n):\n            # The radius of circle i is limited by its neighbors and the boundary\n            # r_i <= min(dist(i, j) - r_j)\n            r_neighbor_limit = np.min(dists[i] - radii)\n            radii[i] = max(0.0, min(b_dist[i], r_neighbor_limit))\n            \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 by evaluating multiple initialization strategies.\n    1. Fibonacci Spiral: Excellent for dense, uniform distributions.\n    2. Staggered Row Configuration: Adaptable to square boundary effects.\n    3. Grid-based Initialization: A 5x5 square grid with a 26th circle inserted.\n    Refines each using force-directed relaxation.\n    \"\"\"\n    n = 26\n    phi = (1 + np.sqrt(5)) / 2\n    best_sum = -1\n    best_res = (None, None, 0)\n    \n    # Multi-start loop to find the best configuration\n    for mode in range(3):\n        if mode == 0:\n            # Seed 1: Fibonacci Spiral (Golden Spiral)\n            theta = 2 * np.pi * np.arange(n) / (phi**2)\n            r_vals = np.sqrt(np.arange(n) + 0.5) / np.sqrt(n)\n            pts = 0.5 + 0.48 * np.column_stack([r_vals * np.cos(theta), r_vals * np.sin(theta)])\n        elif mode == 1:\n            # Seed 2: Staggered row arrangement [4, 5, 4, 5, 4, 4] = 26\n            pts = np.array([[(c + 0.5 + (r % 2) * 0.2) / (nc + 0.2), (r + 0.5) / 6] \n                            for r, nc in enumerate([4, 5, 4, 5, 4, 4]) for c in range(nc)])\n        else:\n            # Seed 3: 5x5 Grid with one additional circle breaking symmetry\n            v = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(v, v)\n            pts = np.vstack([np.column_stack([xv.ravel(), yv.ravel()]), [0.51, 0.51]])\n        \n        # Apply small jitter to break symmetry traps during physics relaxation\n        np.random.seed(mode)\n        pts += np.random.normal(0, 1e-4, (n, 2))\n        \n        # Force-Directed Relaxation (Physics Step)\n        # target_d is chosen based on the theoretical optimum for n=26 equal circles\n        target_d = 0.2035\n        for i in range(1600):\n            # Linear cooling schedule for convergence stability\n            dt = 0.05 * (1 - i / 1600)\n            \n            diff = pts[:, np.newaxis, :] - pts\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-9\n            \n            # Repulsion only occurs if circles overlap the target distance\n            overlap = np.maximum(0, target_d - dist)\n            np.fill_diagonal(overlap, 0)\n            forces = np.sum(diff * (overlap / dist)[:, :, np.newaxis], axis=1)\n            \n            # Boundary repulsion forces to keep centers within the valid margin\n            margin = target_d / 2.0\n            b_forces = np.zeros_like(pts)\n            b_forces[:, 0] += np.maximum(0, margin - pts[:, 0]) - np.maximum(0, pts[:, 0] - (1.0 - margin))\n            b_forces[:, 1] += np.maximum(0, margin - pts[:, 1]) - np.maximum(0, pts[:, 1] - (1.0 - margin))\n            \n            pts = np.clip(pts + (forces + b_forces) * dt, 0.0, 1.0)\n        \n        # Calculate maximum possible radii for the resulting center positions\n        radii = compute_max_radii(pts)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_res = (pts, radii, current_sum)\n            \n    return best_res\n\ndef run_packing():\n    \"\"\"Main execution entry point.\"\"\"\n    return construct_packing()\n# EVOLVE-BLOCK-END", "changes_description": null, "language": "python", "parent_id": "b78cefea-acc6-4964-af46-3db0af8688af", "generation": 4, "timestamp": 1771624909.558058, "iteration_found": 87, "metrics": {"validity": 1.0, "sum_radii": 2.4433208839204923, "target_ratio": 0.9272565024366195, "combined_score": 0.9272565024366195, "radius_variance": 0.0006047520104028407, "spatial_spread": 0.18649526271557132, "eval_time": 0.6056699752807617}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.1778825777616726, "target_ratio": 0.8265209023763465, "combined_score": 0.8265209023763465, "radius_variance": 0.02388729499363575, "spatial_spread": 0.1992960741096901, "eval_time": 0.2315657138824463}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. Your task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. The AlphaEvolve paper achieved a sum of 2.635 for n=26.\n\nKey geometric insights:\n- Circle packings often follow hexagonal patterns in the densest regions\n- Maximum density for infinite circle packing is pi/(2*sqrt(3)) \u2248 0.9069\n- Edge effects make square container packing harder than infinite packing\n- Circles can be placed in layers or shells when confined to a square\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nFocus on designing an explicit constructor that places each circle in a specific position, rather than an iterative search algorithm.\n", "user": "# Current Program Information\n- Fitness: 0.8265\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.8537 \u2192 0.8265. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n0.23s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.177883/2.635 = 0.8265\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.2495, target_ratio: 0.8537, combined_score: 0.8537, radius_variance: 0.0083, spatial_spread: 0.1882, eval_time: 0.1766\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.2545, target_ratio: 0.8556, combined_score: 0.8556, radius_variance: 0.0081, spatial_spread: 0.1843, eval_time: 0.2394\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4651, target_ratio: 0.9355, combined_score: 0.9355, radius_variance: 0.0002, spatial_spread: 0.1839, eval_time: 0.9396\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9355)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis implementation uses a multi-start strategy with physics-based relaxation\nand an iterative radius optimizer to maximize the sum of radii.\n\"\"\"\nimport numpy as np\n\ndef compute_max_radii(centers, iterations=200):\n    \"\"\"\n    Maximizes the sum of radii for fixed centers using iterative coordinate descent.\n    Constraints: \n      1) r_i + r_j <= distance(c_i, c_j)\n      2) r_i <= distance(c_i, boundary)\n    The sum is maximized by updating each radius to its maximum valid value.\n    \"\"\"\n    n = centers.shape[0]\n    # Pairwise distance matrix\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=-1))\n    np.fill_diagonal(dists, 1e6)\n    \n    # Boundary distances\n    b_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    \n    # Initialize radii\n    radii = np.zeros(n)\n    \n    # Coordinate descent with multiple passes\n    for _ in range(iterations):\n        for i in range(n):\n            # Constraint: r_i <= dist(i, j) - r_j\n            r_neighbor_limit = np.min(dists[i] - radii)\n            # Combine with boundary\n            radii[i] = max(0.0, min(b_dist[i], r_neighbor_limit))\n            \n    return radii\n\ndef relax_positions(centers, target_d=0.203, iterations=1800):\n    \"\"\"\n    Refines center positions using force-directed repulsion.\n    target_d is the ideal diameter for the circles.\n    \"\"\"\n    n = len(centers)\n    dt = 0.04\n    \n    for i in range(iterations):\n        # Cooling schedule for the step size\n        cooling = (1.0 - i / iterations)\n        current_dt = dt * cooling\n        \n        # Calculate pairwise vectors and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=-1)\n        dists = np.sqrt(dist_sq + 1e-12)\n        np.fill_diagonal(dists, 1.0)\n        \n        # Repulsion force only if circles overlap the target diameter\n        overlap = np.maximum(0, target_d - dists)\n        force_mag = (overlap / dists)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n        \n        # Boundary forces to keep centers away from the wall\n        margin = target_d / 2.0\n        b_forces = np.zeros_like(centers)\n        b_forces[:, 0] += np.maximum(0, margin - centers[:, 0])\n        b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - margin))\n        b_forces[:, 1] += np.maximum(0, margin - centers[:, 1])\n        b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - margin))\n        \n        centers += (forces + b_forces * 1.5) * current_dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n    return centers\n\ndef construct_packing():\n    \"\"\"\n    Constructs the circle packing for n=26.\n    Tries multiple initializations and selects the one with the highest radius sum.\n    \"\"\"\n    n = 26\n    best_sum = -1\n    best_centers = None\n    best_radii = None\n    \n    # Define several initialization strategies\n    seeds = [42, 123, 999]\n    \n    # Strategy 1: Fibonacci Spirals with different offsets\n    for seed in seeds:\n        np.random.seed(seed)\n        phi = (1 + 5**0.5) / 2\n        indices = np.arange(n)\n        theta = 2 * np.pi * indices / (phi**2)\n        r_vals = np.sqrt(indices + 0.5) / np.sqrt(n)\n        \n        centers = 0.5 + 0.48 * np.column_stack([r_vals * np.cos(theta), r_vals * np.sin(theta)])\n        centers += (np.random.rand(n, 2) - 0.5) * 1e-3\n        \n        relaxed = relax_positions(centers, target_d=0.2035)\n        radii = compute_max_radii(relaxed)\n        s = np.sum(radii)\n        \n        if s > best_sum:\n            best_sum, best_centers, best_radii = s, relaxed, radii\n\n    # Strategy 2: Perturbed 5x5 Grid + 1\n    x_grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(x_grid, x_grid)\n    grid_centers = np.column_stack([xv.ravel(), yv.ravel()])\n    extra = np.array([[0.5, 0.5]]) # Add 26th circle at the center\n    centers_grid = np.vstack([grid_centers, extra])\n    centers_grid += (np.random.rand(n, 2) - 0.5) * 0.02\n    \n    relaxed = relax_positions(centers_grid, target_d=0.2045)\n    radii = compute_max_radii(relaxed)\n    s = np.sum(radii)\n    if s > best_sum:\n        best_sum, best_centers, best_radii = s, relaxed, radii\n        \n    # Strategy 3: Staggered Hexagonal Rows\n    c_hex = []\n    rows = [5, 4, 5, 4, 5, 3] # Sums to 26\n    for i, count in enumerate(rows):\n        y = 0.1 + i * 0.16\n        x_start = 0.1 if i % 2 == 0 else 0.18\n        for j in range(count):\n            c_hex.append([x_start + j * 0.2, y])\n    centers_hex = np.array(c_hex)\n    \n    relaxed = relax_positions(centers_hex, target_d=0.203)\n    radii = compute_max_radii(relaxed)\n    s = np.sum(radii)\n    if s > best_sum:\n        best_sum, best_centers, best_radii = s, relaxed, radii\n\n    return best_centers, best_radii, best_sum\n\ndef run_packing():\n    \"\"\"Entry point for evaluation.\"\"\"\n    return construct_packing()\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Total sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/26:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4651), Performs well on target_ratio (0.9355), Performs well on combined_score (0.9355), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1839), Performs well on eval_time (0.9396)\n\n### Program 2 (Score: 0.8556)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\ndef construct_packing():\n    \"\"\"\n    Construct an arrangement of 26 circles in a unit square aiming to maximize the sum of radii.\n    The target sum for n=26 is approximately 2.635, which corresponds to an average radius\n    of ~0.10135. This is achieved through a specific hexagonal-like arrangement \n    found via force-directed relaxation starting from a Fibonacci lattice.\n    \"\"\"\n    n = 26\n    np.random.seed(42)  # For reproducibility\n\n    # 1. Initialization using a Golden Spiral (Fibonacci Lattice)\n    # This provides a dense, near-uniform distribution that serves as a \n    # superior starting point for square packing compared to a simple grid.\n    phi = (1 + np.sqrt(5)) / 2\n    indices = np.arange(n)\n    theta = 2 * np.pi * indices / (phi ** 2)\n    # Spreading points according to area density\n    r_vals = np.sqrt(indices + 0.5) / np.sqrt(n)\n    \n    centers = np.zeros((n, 2))\n    # Map the circular spiral distribution into the unit square\n    centers[:, 0] = 0.5 + 0.49 * r_vals * np.cos(theta)\n    centers[:, 1] = 0.5 + 0.49 * r_vals * np.sin(theta)\n\n    # Add a tiny amount of noise to break potential symmetry traps during relaxation\n    centers += (np.random.rand(n, 2) - 0.5) * 1e-3\n\n    # 2. Force-Directed Relaxation (Physics-based refinement)\n    # Target diameter derived from the known optimal packing for n=26 equal circles.\n    target_dist = 0.202692  # 2 * 0.101346\n    dt = 0.02\n    \n    for i in range(1500):\n        # Calculate pairwise differences and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=-1)) + 1e-12\n        np.fill_diagonal(dists, 1.0)\n        \n        # Calculate repulsion forces for overlapping circles\n        overlap = np.maximum(0, target_dist - dists)\n        # Force magnitude proportional to overlap\n        force_mag = overlap / dists\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n        \n        # Update center positions\n        centers += dt * forces\n        \n        # Boundary constraints: Keep centers at least target_radius away from the edge\n        # This prevents circles from being squeezed out and losing their radius.\n        target_r = target_dist / 2.0\n        centers = np.clip(centers, target_r, 1.0 - target_r)\n        \n        # Optional: very slight step size decay for convergence stability\n        if i > 1000:\n            dt *= 0.995\n\n    # 3. Radius Optimization (Maximize Sum of Radii)\n    # Once centers are placed, the problem of maximizing the sum of radii is a \n    # Linear Programming problem. Coordinate descent is an effective way to solve it.\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Calculates the maximum possible radii for fixed centers by solving \n    the optimization problem: Maximize \u03a3 r_i subject to:\n    1) r_i + r_j <= distance(c_i, c_j) for all i, j\n    2) r_i <= distance(c_i, boundary) for all i\n    \"\"\"\n    n = centers.shape[0]\n    # Pairwise distance matrix\n    dists = np.sqrt(np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=-1))\n    np.fill_diagonal(dists, 1e6)  # Ignore self-distance\n    \n    # Pre-calculate boundary constraints for each center\n    b_dist = np.min(np.hstack([centers, 1 - centers]), axis=1)\n    \n    # Iterative coordinate descent to maximize the sum\n    # Initializing with a small radius allows for a balanced growth\n    radii = np.ones(n) * 0.05\n    for _ in range(300):\n        for i in range(n):\n            # The radius of circle i is limited by its nearest neighbor and the boundary\n            r_limit_neighbors = np.min(dists[i] - radii)\n            radii[i] = max(0.0, min(b_dist[i], r_limit_neighbors))\n            \n    return radii\n\ndef run_packing():\n    \"\"\"Execution entry point for the evaluator\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Total sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/26:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.2545), Performs well on target_ratio (0.8556), Performs well on combined_score (0.8556), Performs well on radius_variance (0.0081), Performs well on spatial_spread (0.1843), Performs well on eval_time (0.2394)\n\n### Program 3 (Score: 0.8537)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    using a relaxation-based constructor followed by a greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2)\n        radii: np.array of shape (26)\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # 1. Initialize with a 5x5 grid plus one circle slightly offset from the center\n    # This starting point breaks symmetry and provides a good dense foundation.\n    grid_points = np.linspace(0.1, 0.9, 5)\n    centers = np.array([[x, y] for x in grid_points for y in grid_points] + [[0.51, 0.51]])\n    \n    # 2. Force-directed relaxation (repulsion)\n    # This pushes circles apart to maximize the minimum distance between them.\n    # We use a target diameter slightly over 0.2 to encourage radii ~0.1.\n    for _ in range(800):\n        # Compute pairwise distance vectors\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        # Compute distances (adding epsilon to avoid division by zero)\n        dists = np.sqrt(np.sum(diffs**2, axis=-1)) + 1e-10\n        \n        # Calculate repulsion: push only if circles are within the target distance\n        # Target distance 0.203 is chosen based on n=26 optimal packing studies\n        overlap = np.maximum(0, 0.203 - dists)\n        forces = np.sum(diffs * (overlap[:, :, np.newaxis] / dists[:, :, np.newaxis]), axis=1)\n        \n        # Update centers and keep them within the unit square\n        centers += forces * 0.05\n        centers = np.clip(centers, 0.01, 0.99)\n    \n    # 3. Compute maximum radii for the final positions\n    # We use a coordinate descent approach to maximize the sum of radii.\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Greedy coordinate descent to maximize the sum of radii for fixed centers.\n    Linear objective (sum) subject to r_i + r_j <= d_ij and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Pre-calculate pairwise distances\n    dists = np.sqrt(np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=-1))\n    np.fill_diagonal(dists, 1e6) # Distance to self is irrelevant\n    \n    # Initialize radii at zero\n    radii = np.zeros(n)\n    \n    # Iterate to converge on a set of radii that maximize the sum\n    # Updating one radius at a time given current others\n    for _ in range(150):\n        for i in range(n):\n            # Limit by boundary distance\n            r_bound = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            # Limit by all other neighbors: r_i <= d_ij - r_j\n            r_neighbors = np.min(dists[i] - radii)\n            # Update to the largest possible valid value\n            radii[i] = max(0.0, min(r_bound, r_neighbors))\n            \n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# Fixed helper functions\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"Visualize the circle packing\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5, color='blue')\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\", fontsize=8)\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Target AlphaEvolve sum: 2.635\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.2495), Performs well on target_ratio (0.8537), Performs well on combined_score (0.8537), Performs well on radius_variance (0.0083), Performs well on spatial_spread (0.1882), Performs well on eval_time (0.1766)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8109)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis implementation uses a Fibonacci Lattice (Golden Spiral) initialization \nfollowed by a force-directed relaxation to maximize minimum separation, \nand finally solves for the maximum sum of radii using coordinate descent.\n\"\"\"\nimport numpy as np\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for fixed centers using iterative coordinate descent.\n    Constraints: \n      1) r_i + r_j <= distance(c_i, c_j) for all i, j\n      2) r_i <= distance(c_i, boundary) for all i\n    Starting with a balanced initial radius helps the greedy solver find a higher total sum.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate pairwise distances between all centers\n    dists = np.linalg.norm(centers[:, np.newaxis, :] - centers[np.newaxis, :, :], axis=2)\n    # Set diagonal to a large value to ignore self-distance in the minimization\n    np.fill_diagonal(dists, 1e6)\n    \n    # Calculate distance to the four boundaries of the unit square\n    b_limit = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    \n    # Balanced initialization (0.05 is approx half the target radius for n=26)\n    radii = np.full(n, 0.05)\n    \n    # Coordinate descent iterations\n    for _ in range(250):\n        for i in range(n):\n            # The radius of circle i is limited by its neighbors: r_i <= dist(i, j) - r_j\n            neighbor_limit = np.min(dists[i] - radii)\n            # Combine neighbor limit with boundary limit\n            radii[i] = max(0.0, min(b_limit[i], neighbor_limit))\n            \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square.\n    Strategy:\n    1. Fibonacci Spiral Initialization: Distributes points uniformly in a square domain.\n    2. Force-Directed Relaxation: Pushes circles apart using a cooling repulsive force.\n    3. Radius Optimization: Finalizes radii to maximize the total sum for the fixed centers.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # 1. Initialization: Fibonacci Lattice (Golden Spiral mapping)\n    phi = (1 + 5**0.5) / 2\n    indices = np.arange(n)\n    # The golden angle 2*pi / phi^2 provides optimal density for circular spirals\n    theta = 2 * np.pi * indices / (phi**2)\n    r_vals = np.sqrt(indices + 0.5) / np.sqrt(n)\n    \n    # Map the spiral into the central region of the unit square\n    centers = 0.5 + 0.48 * r_vals[:, np.newaxis] * np.column_stack([np.cos(theta), np.sin(theta)])\n    \n    # 2. Force-Directed Relaxation\n    # Target diameter slightly larger than the optimal equal-circle diameter (~0.2027)\n    target_d = 0.203\n    for i in range(1600):\n        # Linear cooling schedule for the simulation step size\n        dt = 0.03 * (1.0 - i / 1600)\n        \n        # Calculate pairwise displacement vectors and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.linalg.norm(diffs, axis=2) + 1e-12\n        np.fill_diagonal(dists, 1.0)\n        \n        # Calculate repulsion forces proportional to overlap depth\n        overlap = np.maximum(0, target_d - dists)\n        forces = np.sum(diffs * (overlap / dists)[:, :, np.newaxis], axis=1)\n        \n        # Boundary wall repulsion: pushes centers toward a margin of target_d/2\n        m = target_d / 2\n        forces[:, 0] += np.maximum(0, m - centers[:, 0]) - np.maximum(0, centers[:, 0] - (1.0 - m))\n        forces[:, 1] += np.maximum(0, m - centers[:, 1]) - np.maximum(0, centers[:, 1] - (1.0 - m))\n        \n        # Update center positions and strictly clip to unit square\n        centers = np.clip(centers + forces * dt, 0.0, 1.0)\n        \n    # 3. Radius Optimization\n    # Solve for the set of radii that maximize the sum for these refined coordinates.\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\ndef run_packing():\n    \"\"\"Execution entry point for the evaluator.\"\"\"\n    return construct_packing()\n\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.8265)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Greedy coordinate descent to maximize the sum of radii for fixed centers.\n    Linear objective (sum) subject to r_i + r_j <= d_ij and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Pre-calculate pairwise distances\n    dist_mat = np.sqrt(np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=2))\n    # Distance to self is not a constraint\n    np.fill_diagonal(dist_mat, 10.0)\n    \n    # Initialize radii\n    radii = np.zeros(n)\n    \n    # Iterate to converge on a set of radii that maximize the sum\n    # Updating one radius at a time given current others\n    for _ in range(250):\n        for i in range(n):\n            # Limit by distance to the four boundaries of the unit square\n            r_bound = min(centers[i, 0], centers[i, 1], 1.0 - centers[i, 0], 1.0 - centers[i, 1])\n            # Limit by distance to all other circles: r_i <= d_ij - r_j\n            # This is efficient using NumPy's min over the distance matrix row\n            r_neighbor = np.min(dist_mat[i] - radii)\n            # Update to the largest possible valid value\n            radii[i] = max(0.0, min(r_bound, r_neighbor))\n            \n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a dense arrangement of 26 circles in a unit square using \n    force-directed relaxation followed by a coordinate-descent radius optimizer.\n    \n    The strategy involves starting from a 5x5 grid (optimal for n=25) \n    and inserting a 26th circle, then allowing the system to relax into a \n    more efficient configuration that moves beyond simple square grid packing.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialize with a 5x5 grid plus a 26th circle in one of the gaps\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    centers = np.array([[x, y] for x in grid_coords for y in grid_coords] + [[0.2, 0.2]], dtype=float)\n    \n    # Seed for reproducibility and apply small jitter to break grid symmetry\n    np.random.seed(42)\n    centers += np.random.uniform(-0.01, 0.01, size=centers.shape)\n    \n    # 2. Force-directed relaxation (Repulsion)\n    # We use a target distance that encourages radii slightly above 0.1 (diameter 0.2)\n    target_dist = 0.204\n    iterations = 1000\n    \n    for i in range(iterations):\n        # Calculate pairwise displacement vectors and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=-1)) + 1e-9\n        \n        # Calculate repulsion: push only if circles are within the target distance\n        overlap = np.maximum(0, target_dist - dists)\n        np.fill_diagonal(overlap, 0)\n        \n        # Aggregate forces on each circle and update positions\n        # Cooling schedule applied to step size to ensure convergence\n        eta = 0.05 * (1.0 - i / iterations)\n        repulsion_forces = np.sum(overlap[:, :, np.newaxis] * (diffs / dists[:, :, np.newaxis]), axis=1)\n        centers += repulsion_forces * eta\n        \n        # Boundary wall repulsion: pushes circles away from the edges\n        tr = target_dist / 2\n        centers[:, 0] += np.maximum(0, tr - centers[:, 0]) * eta\n        centers[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - tr)) * eta\n        centers[:, 1] += np.maximum(0, tr - centers[:, 1]) * eta\n        centers[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - tr)) * eta\n        \n        # Enforce boundary constraints (keep center inside the unit square)\n        centers = np.clip(centers, 0, 1)\n    \n    # 3. Radius Optimization (Coordinate Descent)\n    # Solve for the maximum possible radii given the final center positions.\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# Fixed helper functions\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"Visualize the circle packing\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5, color='blue', ec='black')\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\", fontsize=8)\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Target AlphaEvolve sum for n=26: 2.635\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Direct constructor for packing 26 circles in a unit square.\n    Combines diverse row-based staggered initializations with an \n    enhanced force-directed relaxation and Linear Programming (LP) \n    to maximize the total sum of radii.\n    \n    The strategy involves:\n    1. Seeding with multiple row-based configurations likely to form dense regions.\n    2. A physics-inspired relaxation that uses a hard-core power-law repulsion \n       and boundary potential to spread circles evenly.\n    3. Global LP optimization to find the exact radii that maximize the sum \n       for each resulting configuration.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Define staggered row configurations that sum exactly to 26.\n    # Diverse configurations explore different local packing topologies.\n    configs = [\n        [5, 5, 6, 5, 5],\n        [4, 5, 4, 5, 4, 4],\n        [6, 5, 6, 5, 4],\n        [5, 5, 5, 5, 6],\n        [4, 4, 5, 4, 4, 5]\n    ]\n    \n    # Initialize best found result with random safety fallback\n    best_centers = np.random.rand(n, 2)\n    best_radii = np.full(n, 0.01)\n    best_sum = 0.26\n    \n    for cfg in configs:\n        # Step 1: Initialize centers based on the row configuration.\n        # Staggered rows help form denser hexagonal sub-patterns.\n        pts_init = []\n        num_rows = len(cfg)\n        for r_idx, num_cols in enumerate(cfg):\n            for c_idx in range(num_cols):\n                # Distribute points in staggered grid\n                x = (c_idx + 0.5 + (0.1 if r_idx % 2 == 1 else 0)) / (num_cols + 0.2)\n                y = (r_idx + 0.5) / num_rows\n                pts_init.append([x, y])\n        \n        pts = np.array(pts_init)[:n]\n        # Jitter the seed to break symmetry and explore asymmetric arrangements\n        pts += np.random.normal(0, 0.01, pts.shape)\n        pts = np.clip(pts, 0.001, 0.999)\n        \n        # Step 2: Enhanced force-directed relaxation.\n        # Uses a \"harder\" repulsion (1/d^3 force) and normalized steps.\n        num_iters = 450\n        for step in range(num_iters):\n            # Calculate pairwise vectors and distances\n            diffs = pts[:, np.newaxis, :] - pts[np.newaxis, :, :]\n            dists_sq = np.sum(diffs**2, axis=2)\n            \n            # 1/d^3 force magnitude (vector form: diff / dist^4)\n            # Higher power repulsion creates a more rigid hard-core effect.\n            forces = np.sum(diffs / (dists_sq[:, :, np.newaxis]**2 + 1e-7), axis=1)\n            \n            # Strong wall repulsion (1/d^3 force) to keep points from getting trapped on edges\n            forces[:, 0] += 0.01 / (pts[:, 0]**3 + 1e-7) - 0.01 / ((1.0 - pts[:, 0])**3 + 1e-7)\n            forces[:, 1] += 0.01 / (pts[:, 1]**3 + 1e-7) - 0.01 / ((1.0 - pts[:, 1])**3 + 1e-7)\n            \n            # Cooling schedule for the step size\n            cooling = 0.994 ** step\n            # Normalize displacement magnitude for stable, reliable spreading\n            mag = np.linalg.norm(forces, axis=1, keepdims=True)\n            pts += (forces / (mag + 1e-7)) * 0.012 * cooling\n            pts = np.clip(pts, 0.0001, 0.9999)\n            \n        # Step 3: Optimal Radius Maximization via Linear Programming.\n        # Given the refined centers c_i, maximize sum(r_i) subject to:\n        # r_i + r_j <= distance(c_i, c_j) and r_i <= distance(c_i, wall)\n        c_lp = -np.ones(n) # Objective: maximize sum of r_i\n        \n        # Distance constraints for all pairs\n        num_pairs = n * (n - 1) // 2\n        A_dist = np.zeros((num_pairs, n))\n        b_dist = np.zeros(num_pairs)\n        \n        idx = 0\n        for i in range(n):\n            for j in range(i + 1, n):\n                A_dist[idx, i] = 1.0\n                A_dist[idx, j] = 1.0\n                b_dist[idx] = np.linalg.norm(pts[i] - pts[j])\n                idx += 1\n        \n        # Boundary constraints: r_i <= wall_dist_i\n        bounds = [(0, min(pts[k, 0], 1.0 - pts[k, 0], pts[k, 1], 1.0 - pts[k, 1])) for k in range(n)]\n        \n        try:\n            # Solve using the HiGHS solver (robust and high-performance)\n            res = linprog(c_lp, A_ub=A_dist, b_ub=b_dist, bounds=bounds, method='highs')\n            if not res.success:\n                res = linprog(c_lp, A_ub=A_dist, b_ub=b_dist, bounds=bounds)\n                \n            if res.success:\n                current_sum = -res.fun\n                if current_sum > best_sum:\n                    best_sum = current_sum\n                    best_centers = pts.copy()\n                    best_radii = res.x\n        except:\n            # Skip failures and proceed with next seed\n            continue\n            \n    return best_centers, best_radii, float(best_sum)\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii for n=26: {total_sum:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.5709, Type: Experimental)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Maximizes the sum of radii for n=26 circles in a unit square.\n    \n    Approach:\n    1.  Uses multiple geometrically-inspired initial grid seeds (staggered and varied rows).\n    2.  Applies a force-directed relaxation to spread circles into efficient arrangements.\n    3.  Uses Linear Programming (LP) with the HiGHS solver to find the optimal radii\n        for each arrangement of centers, maximizing the objective function sum(r_i).\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def solve_radii_lp(pts):\n        \"\"\"\n        Solves for the maximum possible sum of radii given fixed center points.\n        Optimization via Linear Programming: Maximize sum(r_i)\n        Subject to:\n            r_i + r_j <= distance(i, j)\n            r_i <= distance to nearest square boundary\n        \"\"\"\n        n_pts = len(pts)\n        # Minimize -sum(r_i) to maximize sum(r_i)\n        c = -np.ones(n_pts)\n        \n        # Non-overlap constraints: r_i + r_j <= distance between centers\n        num_pairs = n_pts * (n_pts - 1) // 2\n        A_ub = np.zeros((num_pairs, n_pts))\n        b_ub = np.zeros(num_pairs)\n        \n        idx = 0\n        for i in range(n_pts):\n            for j in range(i + 1, n_pts):\n                A_ub[idx, i] = 1.0\n                A_ub[idx, j] = 1.0\n                # Using a tiny safety epsilon to prevent numerical precision issues\n                dist = np.linalg.norm(pts[i] - pts[j])\n                b_ub[idx] = dist - 1e-12\n                idx += 1\n                \n        # Boundary constraints: r_i <= wall_distance\n        bounds = []\n        for i in range(n_pts):\n            x, y = pts[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0, d_wall - 1e-12)))\n            \n        try:\n            # Using 'highs' for efficiency; 'interior-point' as a fallback\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x, -res.fun\n        except Exception:\n            pass\n        return np.full(n_pts, 0.01), 0.01 * n_pts\n\n    def relax_centers(pts, iters=800):\n        \"\"\"\n        Physics-inspired relaxation using repulsive forces between circles \n        and between circles and square boundaries to optimize space distribution.\n        \"\"\"\n        curr_pts = pts.copy()\n        for i in range(iters):\n            # Cooling schedule: gradually reduce displacement size for convergence\n            dt = 0.02 * (0.995 ** i)\n            \n            # Pairwise vectors and distances\n            diff = curr_pts[:, np.newaxis, :] - curr_pts[np.newaxis, :, :]\n            dists_sq = np.sum(diff**2, axis=2)\n            np.fill_diagonal(dists_sq, 1.0) # Avoid self-interaction\n            dist = np.sqrt(dists_sq)\n            \n            # Force inversely proportional to distance cubed (corresponds to 1/d^2 force)\n            # F = (p_i - p_j) / |p_i - p_j|^3\n            f_repel = np.sum(diff / (dists_sq[:, :, np.newaxis] * dist[:, :, np.newaxis] + 1e-9), axis=1)\n            \n            # Boundary repulsion: keeping points away from the square edges\n            f_wall = np.zeros_like(curr_pts)\n            f_wall[:, 0] = 0.01 / (curr_pts[:, 0]**2 + 1e-9) - 0.01 / ((1.0 - curr_pts[:, 0])**2 + 1e-9)\n            f_wall[:, 1] = 0.01 / (curr_pts[:, 1]**2 + 1e-9) - 0.01 / ((1.0 - curr_pts[:, 1])**2 + 1e-9)\n            \n            total_force = f_repel + f_wall\n            \n            # Dampening/clipping for stability\n            force_mag = np.linalg.norm(total_force, axis=1, keepdims=True)\n            max_step = 0.05\n            total_force = (total_force / (force_mag + 1e-9)) * np.minimum(force_mag, max_step)\n            \n            curr_pts += dt * total_force\n            curr_pts = np.clip(curr_pts, 1e-6, 1.0 - 1e-6)\n        return curr_pts\n\n    # Various row configurations summing exactly to 26\n    configs = [\n        [5, 5, 6, 5, 5],\n        [6, 5, 6, 5, 4],\n        [4, 5, 4, 5, 4, 4],\n        [7, 6, 7, 6],\n        [5, 5, 5, 5, 5, 1],\n        [5, 4, 5, 4, 5, 3]\n    ]\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    for cfg in configs:\n        init_pts = []\n        n_rows = len(cfg)\n        for r_idx, n_cols in enumerate(cfg):\n            y = (r_idx + 0.5) / n_rows\n            # Staggered grid distribution (hexagonal-like)\n            stagger = 0.5 if r_idx % 2 == 1 else 0.0\n            for c_idx in range(n_cols):\n                x = (c_idx + 0.5 + stagger) / (n_cols + stagger)\n                init_pts.append([x, y])\n        \n        # Truncate or pad to exactly 26 points\n        pts_array = np.array(init_pts)[:n]\n        if len(pts_array) < n:\n            pts_array = np.vstack([pts_array, np.random.rand(n - len(pts_array), 2)])\n            \n        # Refine through relaxation\n        refined_pts = relax_centers(pts_array, iters=800)\n        \n        # Calculate optimal radii for this layout\n        radii, total_sum = solve_radii_lp(refined_pts)\n        \n        if total_sum > best_sum:\n            best_sum = total_sum\n            best_centers = refined_pts\n            best_radii = radii\n\n    # Final randomized global searches to explore non-structured areas\n    for _ in range(3):\n        rand_relaxed = relax_centers(np.random.rand(n, 2), iters=700)\n        r_rand, s_rand = solve_radii_lp(rand_relaxed)\n        if s_rand > best_sum:\n            best_sum = s_rand\n            best_centers = rand_relaxed\n            best_radii = r_rand\n\n    return best_centers, best_radii, float(best_sum)\n\ndef construct_packing():\n    \"\"\"Compatibility interface for the packing constructor.\"\"\"\n    return run_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()\n    print(f\"Circles packed: {len(radii)}\")\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.5244, Type: Experimental)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Direct constructor to pack 26 circles in a unit square to maximize the sum of radii.\n    The approach utilizes multi-start geometric seeds, force-directed relaxation,\n    and Linear Programming for precise radius optimization.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n\n    def solve_radii_lp(pts):\n        \"\"\"Finds optimal radii r_i maximizing sum(r_i) for fixed center points.\"\"\"\n        n_pts = len(pts)\n        c = -np.ones(n_pts)\n        \n        # Non-overlap: r_i + r_j <= distance between centers\n        num_pairs = n_pts * (n_pts - 1) // 2\n        A_ub = np.zeros((num_pairs, n_pts))\n        b_ub = np.zeros(num_pairs)\n        \n        idx = 0\n        for i in range(n_pts):\n            for j in range(i + 1, n_pts):\n                A_ub[idx, i], A_ub[idx, j] = 1.0, 1.0\n                dist = np.sqrt(np.sum((pts[i] - pts[j])**2))\n                b_ub[idx] = dist - 1e-11 # Precision safety margin\n                idx += 1\n                \n        # Boundary constraints: r_i <= wall distance\n        bounds = []\n        for i in range(n_pts):\n            x, y = pts[i]\n            d_wall = min(x, 1.0 - x, y, 1.0 - y)\n            bounds.append((0, max(0, d_wall - 1e-11)))\n            \n        try:\n            res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                return res.x, -res.fun\n        except Exception:\n            pass\n        return np.full(n_pts, 0.01), 0.01 * n_pts\n\n    def relax_centers(pts, iters=700):\n        \"\"\"Physics-inspired relaxation to distribute centers efficiently.\"\"\"\n        curr_pts = pts.copy()\n        dt = 0.025\n        for step in range(iters):\n            diff = curr_pts[:, np.newaxis, :] - curr_pts[np.newaxis, :, :]\n            dists_sq = np.sum(diff**2, axis=2)\n            np.fill_diagonal(dists_sq, 1.0)\n            dist = np.sqrt(dists_sq)\n            \n            # Repulsion force inversely proportional to distance squared\n            f_mag = 1.0 / (dists_sq * dist + 1e-9)\n            np.fill_diagonal(f_mag, 0)\n            f_repel = np.sum(diff * f_mag[:, :, np.newaxis], axis=1)\n            \n            # Wall repulsion to keep centers from collapsing into boundaries\n            f_wall = np.zeros_like(curr_pts)\n            f_wall[:, 0] = 0.006 / (curr_pts[:, 0]**2 + 1e-9) - 0.006 / ((1.0 - curr_pts[:, 0])**2 + 1e-9)\n            f_wall[:, 1] = 0.006 / (curr_pts[:, 1]**2 + 1e-9) - 0.006 / ((1.0 - curr_pts[:, 1])**2 + 1e-9)\n            \n            total_force = f_repel + f_wall\n            force_mag = np.linalg.norm(total_force, axis=1, keepdims=True)\n            max_move = 0.07\n            total_force = (total_force / (force_mag + 1e-9)) * np.minimum(force_mag, max_move)\n            \n            curr_pts += dt * total_force\n            curr_pts = np.clip(curr_pts, 0.0001, 0.9999)\n            dt *= 0.993 # Cooling schedule\n        return curr_pts\n\n    # Diversity of starting seeds: specialized staggered grid configurations\n    configs = [\n        [5, 5, 6, 5, 5],\n        [6, 5, 6, 5, 4],\n        [4, 5, 4, 5, 4, 4],\n        [5, 4, 5, 4, 5, 3],\n        [7, 6, 7, 6],\n        [5, 5, 5, 5, 5, 1],\n        [4, 4, 4, 4, 4, 6],\n        [6, 7, 7, 6]\n    ]\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    for cfg in configs:\n        init_pts = []\n        n_rows = len(cfg)\n        for r_idx, n_cols in enumerate(cfg):\n            y = (r_idx + 0.5) / n_rows\n            # Apply stagger for hexagonal-like spacing\n            x_offset = 0.35 if r_idx % 2 == 1 else 0.0\n            for c_idx in range(n_cols):\n                x = (c_idx + 0.5 + x_offset) / (n_cols + 0.4)\n                init_pts.append([x, y])\n        \n        pts_array = np.array(init_pts)[:n]\n        if len(pts_array) < n:\n            pts_array = np.vstack([pts_array, np.random.rand(n - len(pts_array), 2)])\n            \n        # Refine distribution through physics relaxation\n        refined_pts = relax_centers(pts_array)\n        radii, total_sum = solve_radii_lp(refined_pts)\n        \n        if total_sum > best_sum:\n            best_sum, best_centers, best_radii = total_sum, refined_pts, radii\n\n    # Final randomized search to check for non-grid optima\n    for _ in range(2):\n        rand_pts = relax_centers(np.random.rand(n, 2), iters=800)\n        r_rand, s_rand = solve_radii_lp(rand_pts)\n        if s_rand > best_sum:\n            best_sum, best_centers, best_radii = s_rand, rand_pts, r_rand\n\n    return best_centers, best_radii, float(best_sum)\n\ndef construct_packing():\n    \"\"\"Interface compatibility for circle packing evaluation.\"\"\"\n    return run_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Greedy coordinate descent to maximize the sum of radii for fixed centers.\n    Linear objective (sum) subject to r_i + r_j <= d_ij and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Pre-calculate pairwise distances\n    dist_mat = np.sqrt(np.sum((centers[:, np.newaxis, :] - centers[np.newaxis, :, :])**2, axis=2))\n    # Distance to self is not a constraint\n    np.fill_diagonal(dist_mat, 10.0)\n    \n    # Initialize radii\n    radii = np.zeros(n)\n    \n    # Iterate to converge on a set of radii that maximize the sum\n    # Updating one radius at a time given current others\n    for _ in range(250):\n        for i in range(n):\n            # Limit by distance to the four boundaries of the unit square\n            r_bound = min(centers[i, 0], centers[i, 1], 1.0 - centers[i, 0], 1.0 - centers[i, 1])\n            # Limit by distance to all other circles: r_i <= d_ij - r_j\n            # This is efficient using NumPy's min over the distance matrix row\n            r_neighbor = np.min(dist_mat[i] - radii)\n            # Update to the largest possible valid value\n            radii[i] = max(0.0, min(r_bound, r_neighbor))\n            \n    return radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a dense arrangement of 26 circles in a unit square using \n    force-directed relaxation followed by a coordinate-descent radius optimizer.\n    \n    The strategy involves starting from a 5x5 grid (optimal for n=25) \n    and inserting a 26th circle, then allowing the system to relax into a \n    more efficient configuration that moves beyond simple square grid packing.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialize with a 5x5 grid plus a 26th circle in one of the gaps\n    grid_coords = np.linspace(0.1, 0.9, 5)\n    centers = np.array([[x, y] for x in grid_coords for y in grid_coords] + [[0.2, 0.2]], dtype=float)\n    \n    # Seed for reproducibility and apply small jitter to break grid symmetry\n    np.random.seed(42)\n    centers += np.random.uniform(-0.01, 0.01, size=centers.shape)\n    \n    # 2. Force-directed relaxation (Repulsion)\n    # We use a target distance that encourages radii slightly above 0.1 (diameter 0.2)\n    target_dist = 0.204\n    iterations = 1000\n    \n    for i in range(iterations):\n        # Calculate pairwise displacement vectors and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=-1)) + 1e-9\n        \n        # Calculate repulsion: push only if circles are within the target distance\n        overlap = np.maximum(0, target_dist - dists)\n        np.fill_diagonal(overlap, 0)\n        \n        # Aggregate forces on each circle and update positions\n        # Cooling schedule applied to step size to ensure convergence\n        eta = 0.05 * (1.0 - i / iterations)\n        repulsion_forces = np.sum(overlap[:, :, np.newaxis] * (diffs / dists[:, :, np.newaxis]), axis=1)\n        centers += repulsion_forces * eta\n        \n        # Boundary wall repulsion: pushes circles away from the edges\n        tr = target_dist / 2\n        centers[:, 0] += np.maximum(0, tr - centers[:, 0]) * eta\n        centers[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - tr)) * eta\n        centers[:, 1] += np.maximum(0, tr - centers[:, 1]) * eta\n        centers[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - tr)) * eta\n        \n        # Enforce boundary constraints (keep center inside the unit square)\n        centers = np.clip(centers, 0, 1)\n    \n    # 3. Radius Optimization (Coordinate Descent)\n    # Solve for the maximum possible radii given the final center positions.\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# Fixed helper functions\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"Visualize the circle packing\"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5, color='blue', ec='black')\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\", fontsize=8)\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # Target AlphaEvolve sum for n=26: 2.635\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis implementation uses a multi-start strategy with physics-based relaxation\nand an iterative radius optimizer to maximize the total sum of radii.\n\"\"\"\nimport numpy as np\n\ndef compute_max_radii(centers, iterations=400):\n    \"\"\"\n    Maximizes the sum of radii for fixed centers using iterative coordinate descent.\n    Constraints: \n      1) r_i + r_j <= distance(c_i, c_j)\n      2) r_i <= distance(c_i, boundary)\n    Coordinate descent for this linear problem converges to a near-optimal set of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Pairwise distance matrix\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Fill diagonal with a large value to ignore self-constraints during minimization\n    np.fill_diagonal(dists, 10.0)\n    \n    # Boundary distances for each center\n    b_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    \n    # Initialize radii with a balanced guess to prevent early 'stealing' of space\n    radii = np.full(n, 0.05)\n    \n    # Iterative coordinate descent to maximize the objective function sum(radii)\n    for _ in range(iterations):\n        for i in range(n):\n            # The radius of circle i is limited by its neighbors and the boundary\n            # r_i <= min(dist(i, j) - r_j)\n            r_neighbor_limit = np.min(dists[i] - radii)\n            radii[i] = max(0.0, min(b_dist[i], r_neighbor_limit))\n            \n    return radii\n\ndef construct_packing():\n    \"\"\"\n    Constructs a circle packing for n=26 by evaluating multiple initialization strategies.\n    1. Fibonacci Spiral: Excellent for dense, uniform distributions.\n    2. Staggered Row Configuration: Adaptable to square boundary effects.\n    3. Grid-based Initialization: A 5x5 square grid with a 26th circle inserted.\n    Refines each using force-directed relaxation.\n    \"\"\"\n    n = 26\n    phi = (1 + np.sqrt(5)) / 2\n    best_sum = -1\n    best_res = (None, None, 0)\n    \n    # Multi-start loop to find the best configuration\n    for mode in range(3):\n        if mode == 0:\n            # Seed 1: Fibonacci Spiral (Golden Spiral)\n            theta = 2 * np.pi * np.arange(n) / (phi**2)\n            r_vals = np.sqrt(np.arange(n) + 0.5) / np.sqrt(n)\n            pts = 0.5 + 0.48 * np.column_stack([r_vals * np.cos(theta), r_vals * np.sin(theta)])\n        elif mode == 1:\n            # Seed 2: Staggered row arrangement [4, 5, 4, 5, 4, 4] = 26\n            pts = np.array([[(c + 0.5 + (r % 2) * 0.2) / (nc + 0.2), (r + 0.5) / 6] \n                            for r, nc in enumerate([4, 5, 4, 5, 4, 4]) for c in range(nc)])\n        else:\n            # Seed 3: 5x5 Grid with one additional circle breaking symmetry\n            v = np.linspace(0.1, 0.9, 5)\n            xv, yv = np.meshgrid(v, v)\n            pts = np.vstack([np.column_stack([xv.ravel(), yv.ravel()]), [0.51, 0.51]])\n        \n        # Apply small jitter to break symmetry traps during physics relaxation\n        np.random.seed(mode)\n        pts += np.random.normal(0, 1e-4, (n, 2))\n        \n        # Force-Directed Relaxation (Physics Step)\n        # target_d is chosen based on the theoretical optimum for n=26 equal circles\n        target_d = 0.2035\n        for i in range(1600):\n            # Linear cooling schedule for convergence stability\n            dt = 0.05 * (1 - i / 1600)\n            \n            diff = pts[:, np.newaxis, :] - pts\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-9\n            \n            # Repulsion only occurs if circles overlap the target distance\n            overlap = np.maximum(0, target_d - dist)\n            np.fill_diagonal(overlap, 0)\n            forces = np.sum(diff * (overlap / dist)[:, :, np.newaxis], axis=1)\n            \n            # Boundary repulsion forces to keep centers within the valid margin\n            margin = target_d / 2.0\n            b_forces = np.zeros_like(pts)\n            b_forces[:, 0] += np.maximum(0, margin - pts[:, 0]) - np.maximum(0, pts[:, 0] - (1.0 - margin))\n            b_forces[:, 1] += np.maximum(0, margin - pts[:, 1]) - np.maximum(0, pts[:, 1] - (1.0 - margin))\n            \n            pts = np.clip(pts + (forces + b_forces) * dt, 0.0, 1.0)\n        \n        # Calculate maximum possible radii for the resulting center positions\n        radii = compute_max_radii(pts)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_res = (pts, radii, current_sum)\n            \n    return best_res\n\ndef run_packing():\n    \"\"\"Main execution entry point.\"\"\"\n    return construct_packing()\n# EVOLVE-BLOCK-END\n```"]}}, "artifacts_json": "{\"execution_time\": \"0.61s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.443321/2.635 = 0.9273\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}