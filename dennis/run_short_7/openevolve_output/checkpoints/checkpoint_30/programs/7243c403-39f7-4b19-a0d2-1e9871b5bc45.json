{"id": "7243c403-39f7-4b19-a0d2-1e9871b5bc45", "code": "\"\"\"Iterative Adam optimization mapping physics configurations constraints seamlessly for exactly 26 unequal circles optimally\"\"\"\nimport numpy as np\n\n\ndef init_seed(n, idx):\n    \"\"\"\n    Generate systematically robust structurally distributed layout seeds.\n    Employs various geometry heuristics effectively pushing symmetry overlaps explicitly.\n    \"\"\"\n    np.random.seed(idx + 1024)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.random.uniform(0.01, 0.05, n)\n\n    cat = idx % 5\n    if cat == 0:\n        # Concentrically biased ring arrangement specifically fitting exactly\n        X[0], Y[0] = 0.5, 0.5\n        angles1 = np.linspace(0, 2 * np.pi, 9)[:-1]\n        X[1:9] = 0.5 + 0.22 * np.cos(angles1)\n        Y[1:9] = 0.5 + 0.22 * np.sin(angles1)\n        angles2 = np.linspace(0, 2 * np.pi, 18)[:-1]\n        X[9:] = 0.5 + 0.44 * np.cos(angles2)\n        Y[9:] = 0.5 + 0.44 * np.sin(angles2)\n    elif cat == 1:\n        # Corner-anchored configurations inducing complex broad boundaries structures precisely\n        cents = [[0.5, 0.5], [0.15, 0.15], [0.85, 0.85], [0.15, 0.85], [0.85, 0.15]]\n        for i, c in enumerate(cents):\n            X[i], Y[i] = c\n    elif cat == 2:\n        # Swirling layouts natively avoiding straight-edge symmetry deadlocks precisely\n        angles = np.linspace(0, 5 * np.pi, n)\n        rads = np.linspace(0.0, 0.42, n)\n        X = 0.5 + rads * np.cos(angles)\n        Y = 0.5 + rads * np.sin(angles)\n    elif cat == 3:\n        # Pseudo-hexagonal interleaved spacing efficiently matching density safely\n        rows = [4, 5, 4, 5, 4, 4]\n        i = 0\n        for r, cnt in enumerate(rows):\n            for c in range(cnt):\n                if i < n:\n                    offset = 0.05 if r % 2 else 0\n                    scale = 0.64 / max(1, cnt - 1)\n                    X[i] = 0.18 + c * scale + offset\n                    Y[i] = 0.18 + r * 0.128\n                    i += 1\n    elif cat == 4:\n        # Explicit horizontal mapping tightly aligned safely\n        X[:12] = np.linspace(0.1, 0.9, 12)\n        Y[:12] = 0.15\n        X[12:24] = np.linspace(0.1, 0.9, 12)\n        Y[12:24] = 0.85\n        X[24], Y[24] = 0.5, 0.5\n        X[25], Y[25] = 0.2, 0.5\n\n    # Break absolute initial mapping symmetrically to safely navigate gradients exactly!\n    X += np.random.normal(0, 0.005, n)\n    Y += np.random.normal(0, 0.005, n)\n    X = np.clip(X, 0.05, 0.95)\n    Y = np.clip(Y, 0.05, 0.95)\n    \n    # Establish structurally sound variable size distributions precisely efficiently!\n    if idx % 2 == 0:\n        dists = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n    else:\n        # Re-target largest boundaries cleanly effectively strictly into mapping perfectly \n        dists = np.minimum.reduce([\n            np.sqrt(X**2 + Y**2),\n            np.sqrt((X - 1)**2 + Y**2),\n            np.sqrt(X**2 + (Y - 1)**2),\n            np.sqrt((X - 1)**2 + (Y - 1)**2)\n        ])\n    \n    order = np.argsort(dists)\n    sizes = np.linspace(0.09, 0.015, n)\n    np.random.shuffle(sizes[n//3 : 2*n//3])\n    R[order] = sizes\n\n    return np.column_stack([X, Y, R])\n\n\ndef make_strictly_valid(params):\n    \"\"\"\n    Applies strict geometrical intersection verifications dynamically maintaining validity flawlessly!\n    Safely enforces boundary constraints iteratively trimming artifacts precisely efficiently strictly correctly cleanly!\n    \"\"\"\n    centers = np.clip(params[:, :2], 0.0, 1.0)\n    radii = params[:, 2].copy()\n\n    # Apply rigid containment correctly mapped smoothly limits natively cleanly practically\n    b_rad = np.min([\n        centers[:, 0], 1.0 - centers[:, 0],\n        centers[:, 1], 1.0 - centers[:, 1]\n    ], axis=0)\n    \n    radii = np.clip(radii, 1e-9, b_rad)\n    n = len(radii)\n\n    # Precisely clean pairwise constraints directly logically reliably successfully!\n    for _ in range(150):\n        diff = centers[:, None, :] - centers[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        if np.max(radii[:, None] + radii[None, :] - dist) <= 1e-12:\n            break\n\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dist[i, j]\n                overlap = radii[i] + radii[j] - d\n                if overlap > 1e-12:\n                    if overlap > max_ov:\n                        max_ov = overlap\n                    \n                    sum_r = radii[i] + radii[j]\n                    if sum_r > 1e-10:\n                        factor = max(0.0, d - 1e-11) / sum_r\n                        radii[i] *= factor\n                        radii[j] *= factor\n\n        if max_ov <= 1e-12:\n            break\n\n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Search configuration layouts correctly successfully logically resolving mathematical forces comprehensively effectively smoothly dynamically! \n    Directly maximizes dynamically correctly successfully securely seamlessly securely strictly precisely!\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_seeds = 16\n    iters = 5200\n    base_lr = 0.015\n\n    for seed_id in range(num_seeds):\n        params = init_seed(n, seed_id)\n        \n        m = np.zeros_like(params)\n        v = np.zeros_like(params)\n\n        for step in range(1, iters + 1):\n            prog = step / iters\n            # Precise exponential descent logically tightening cleanly seamlessly successfully dependably cleanly accurately efficiently!\n            clr = base_lr * (0.01 ** prog) + 1e-5\n            P = 10.0 * (4000.0 ** prog)\n\n            # Shatter symmetrical plateaus dependably natively mapped flawlessly robustly\n            if step % 400 == 0 and prog < 0.65:\n                params[:, :2] += np.random.normal(0, 0.005, (n, 2))\n                params[:, :2] = np.clip(params[:, :2], 0.01, 0.99)\n\n            grad = np.zeros_like(params)\n            \n            # Static expansion strictly properly continuously practically cleanly reliably gracefully exactly accurately mapped\n            grad[:, 2] = -1.0\n\n            C = params[:, :2]\n            R = params[:, 2]\n\n            diff = C[:, None, :] - C[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n\n            overlap = np.maximum(0, R[:, None] + R[None, :] - dist)\n            if np.any(overlap > 0):\n                force = 2 * P * overlap\n                grad[:, 2] += np.sum(force, axis=1)\n\n                valid_mask = dist > 1e-12\n                dir_norm = np.zeros_like(diff)\n                dir_norm[valid_mask] = diff[valid_mask] / dist[valid_mask][..., np.newaxis]\n\n                # Propagates cleanly successfully completely symmetrically seamlessly\n                grad[:, :2] -= np.sum(force[..., np.newaxis] * dir_norm, axis=1)\n\n            # Walls safely mapping flawlessly comprehensively practically seamlessly dependably gracefully correctly seamlessly!\n            w_L = np.maximum(0, R - C[:, 0])\n            grad[:, 2] += 2 * P * w_L\n            grad[:, 0] -= 2 * P * w_L\n\n            w_R = np.maximum(0, C[:, 0] + R - 1.0)\n            grad[:, 2] += 2 * P * w_R\n            grad[:, 0] += 2 * P * w_R\n\n            w_B = np.maximum(0, R - C[:, 1])\n            grad[:, 2] += 2 * P * w_B\n            grad[:, 1] -= 2 * P * w_B\n\n            w_T = np.maximum(0, C[:, 1] + R - 1.0)\n            grad[:, 2] += 2 * P * w_T\n            grad[:, 1] += 2 * P * w_T\n            \n            w_min = np.maximum(0, 0.001 - R)\n            grad[:, 2] -= 2 * P * w_min\n\n            # Adam strictly consistently functionally gracefully dependably efficiently exactly safely perfectly completely\n            m = 0.9 * m + 0.1 * grad\n            v = 0.999 * v + 0.001 * (grad ** 2)\n            m_h = m / (1 - 0.9 ** step)\n            v_h = v / (1 - 0.999 ** step)\n\n            params -= clr * m_h / (np.sqrt(v_h) + 1e-8)\n            params[:, :2] = np.clip(params[:, :2], 0.0001, 0.9999)\n            params[:, 2] = np.clip(params[:, 2], 0.0001, 1.0)\n\n        # Confirm strictly exact values securely accurately dependably fully flawlessly strictly correctly securely!\n        c_final, r_final = make_strictly_valid(params)\n        \n        valid_sum = np.sum(r_final)\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = c_final.copy()\n            best_r = r_final.copy()\n\n    return best_c, best_r, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"Fallback mapped correctly directly accurately practically seamlessly successfully practically practically functionally precisely\"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n) * 0.5\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / max(1e-12, radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    return radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "195372bc-0a0c-4f52-a955-d8f3c7a0c3eb", "generation": 2, "timestamp": 1772006878.8413076, "iteration_found": 23, "metrics": {"validity": 1.0, "sum_radii": 2.6250090713135217, "target_ratio": 0.9962083762100652, "combined_score": 0.9962083762100652, "radius_variance": 0.005640993869826602, "spatial_spread": 0.19362006049756533, "eval_time": 15.684970378875732}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.481714228101068, "target_ratio": 0.9418270315374073, "combined_score": 0.9418270315374073, "radius_variance": 0.006344179733861973, "spatial_spread": 0.19059811724900427, "eval_time": 12.676793336868286}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9418\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.8177 \u2192 0.9418\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n12.68s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.481714/2.635 = 0.9418\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.1546, target_ratio: 0.8177, combined_score: 0.8177, radius_variance: 0.0171, spatial_spread: 0.1930, eval_time: 9.3011\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4817, target_ratio: 0.9418, combined_score: 0.9418, radius_variance: 0.0063, spatial_spread: 0.1906, eval_time: 12.6768\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6278, target_ratio: 0.9973, combined_score: 0.9973, radius_variance: 0.0057, spatial_spread: 0.1926, eval_time: 10.9853\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9973)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam-based optimizer for packing n=26 unequal circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an arrangement of 26 circles using iterative gradient \n    optimization with Adam. Maximizes sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_radii)\n    \"\"\"\n    np.random.seed(42)\n    n = 26\n    \n    # 1. Initialize strategically biased starting configurations\n    inits = []\n    \n    # Initialization A: Hexagonal layout broadly adapted for N=26\n    c_hex = []\n    for row in range(6):\n        for col in range(5):\n            if len(c_hex) < n:\n                x = 0.15 + col * 0.15 + (0.075 if row % 2 else 0)\n                y = 0.15 + row * 0.14\n                c_hex.append([x, y])\n    inits.append((np.clip(c_hex, 0.05, 0.95), np.ones(n) * 0.03))\n    \n    # Initialization B: Center-biased symmetric pattern layout\n    c_ring = np.zeros((n, 2))\n    c_ring[0] = [0.5, 0.5]\n    for i in range(8):\n        c_ring[i+1] = [0.5 + 0.2*np.cos(2*np.pi*i/8), 0.5 + 0.2*np.sin(2*np.pi*i/8)]\n    for i in range(17):\n        c_ring[i+9] = [0.5 + 0.4*np.cos(2*np.pi*i/17), 0.5 + 0.4*np.sin(2*np.pi*i/17)]\n    inits.append((np.clip(c_ring, 0.05, 0.95), np.ones(n) * 0.02))\n    \n    # Initializations C: Random starts mimicking spatial variations\n    for _ in range(8):\n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.01, 0.06, n)\n        inits.append((c, r))\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Perform simulation steps across different seed spaces\n    for c_init, r_init in inits:\n        c_final, r_final = optimize_single(c_init, r_init, steps=6000)\n        \n        # Eliminate floating precision issues enforcing perfectly safe bounding boxes\n        r_valid = make_strictly_valid(c_final, r_final)\n        \n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = c_final\n            best_radii = r_valid\n            \n    return best_centers, best_radii, best_sum\n\n\ndef optimize_single(c_init, r_init, steps=6000):\n    \"\"\"Core computational physics optimization kernel for a single setup\"\"\"\n    n = len(r_init)\n    params = np.zeros((n, 3))\n    params[:, :2] = c_init\n    params[:, 2] = r_init\n    \n    # Adam optim parameters\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    base_lr = 0.01\n    wp = 20.0 \n    \n    for step in range(steps):\n        # 1. Distances and continuous overlaps evaluations\n        diff = params[:, np.newaxis, :2] - params[np.newaxis, :, :2]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        \n        target = params[:, np.newaxis, 2] + params[np.newaxis, :, 2]\n        overlap = np.maximum(0, target - dist)\n        \n        grad = np.zeros_like(params)\n        \n        # Uniform force pulling radius sizes up!\n        grad[:, 2] = -1.0 \n        \n        # Simulated simulated annealing / symmetry momentum breaker \n        if step < 2000 and step % 250 == 0:\n            grad[:, :2] += np.random.normal(0, 0.5, (n, 2))\n            \n        if np.any(overlap > 0):\n            # Enact heavy force pushing overlapping neighbors away directly proportional to overlap\n            overlap_grad = 2 * wp * overlap\n            grad[:, 2] += np.sum(overlap_grad, axis=1)\n            \n            valid_dist = dist > 1e-12\n            dir_norm = np.zeros_like(diff)\n            dir_norm[valid_dist] = diff[valid_dist] / dist[valid_dist][..., np.newaxis]\n            \n            c_grad = -overlap_grad[..., np.newaxis] * dir_norm\n            grad[:, :2] += np.sum(c_grad, axis=1)\n            \n        # Hard limits boundary constraints enforcement penalty calculation\n        bx1 = np.maximum(0, params[:, 2] - params[:, 0])\n        grad[:, 2] += 2 * wp * bx1\n        grad[:, 0] -= 2 * wp * bx1\n        \n        bx2 = np.maximum(0, params[:, 0] + params[:, 2] - 1.0)\n        grad[:, 2] += 2 * wp * bx2\n        grad[:, 0] += 2 * wp * bx2\n        \n        by1 = np.maximum(0, params[:, 2] - params[:, 1])\n        grad[:, 2] += 2 * wp * by1\n        grad[:, 1] -= 2 * wp * by1\n        \n        by2 = np.maximum(0, params[:, 1] + params[:, 2] - 1.0)\n        grad[:, 2] += 2 * wp * by2\n        grad[:, 1] += 2 * wp * by2\n        \n        # Floor boundaries minimum \n        min_rad = 0.005\n        neg_r = np.maximum(0, min_rad - params[:, 2])\n        grad[:, 2] -= 2 * wp * neg_r\n        \n        # Exponential decreasing decay scale learning phase rate limit factor map parameter down!\n        lr = base_lr * (0.01 ** (step / max(1, steps - 1)))\n        \n        # Applying iterative adam states transition variables momentum array combinations smoothing gradient updates  \n        t = step + 1\n        m = 0.9 * m + 0.1 * grad\n        v = 0.999 * v + 0.001 * (grad ** 2)\n        m_hat = m / (1 - 0.9 ** t)\n        v_hat = v / (1 - 0.999 ** t)\n        \n        params -= lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n        \n        # Iteratively strengthening restrictions gradually tightening overlapping limit gaps limits tolerances bounds values! \n        if step % 500 == 499:\n            wp *= 1.4\n\n    return params[:, :2], params[:, 2]\n\n\ndef make_strictly_valid(centers, radii):\n    \"\"\"\n    Absolute final constraint cleanup safety wrapper ensuring perfectly validated valid radius arrays returns\n    Strictly trims and ensures sizes stay structurally locked internally!\n    \"\"\"\n    centers = np.clip(centers, 0.0, 1.0)\n    \n    # Establish borders distance sizes absolute limiting boundaries mapping\n    b_rad = np.min([\n        centers[:, 0], \n        1.0 - centers[:, 0], \n        centers[:, 1], \n        1.0 - centers[:, 1]\n    ], axis=0)\n    \n    radii = np.minimum(radii, b_rad)\n    radii = np.maximum(0.0, radii)\n    \n    n = len(radii)\n    # Strictly execute non overlapping reduction pairwise loops! \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                margin_dist = max(0.0, dist - 1e-7)\n                if radii[i] + radii[j] > 1e-9:\n                    scale = margin_dist / (radii[i] + radii[j])\n                    scale = min(1.0, scale)\n                    radii[i] *= scale\n                    radii[j] *= scale\n    return radii\n\n\n# Alias retaining structure interface from legacy wrapper if used\ndef compute_max_radii(centers):\n    \"\"\"Compatibility method.\"\"\"\n    radii = np.ones(len(centers)) * 0.01\n    return make_strictly_valid(centers, radii)\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6278), Performs well on target_ratio (0.9973), Performs well on combined_score (0.9973), Performs well on radius_variance (0.0057), Performs well on spatial_spread (0.1926), Performs well on eval_time (10.9853)\n\n### Program 2 (Score: 0.9418)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative gradient-based optimizer combining physical analogies for packing N=26 unequal circles\"\"\"\nimport numpy as np\n\n\ndef init_seed(n, idx):\n    \"\"\"\n    Seed initial layout structures logically exploring geometries:\n    Corners, edges and symmetry combinations bias the structural configuration seeds\n    before initiating physics simulations naturally mapping.\n    \"\"\"\n    np.random.seed(idx + 1024)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.random.uniform(0.01, 0.05, n)\n\n    cat = idx % 4\n    if cat == 0:\n        # Dense concentrically biased arrangement \n        X[0], Y[0] = 0.5, 0.5\n        angles = np.linspace(0, 2 * np.pi, 9)[:-1]\n        X[1:9] = 0.5 + 0.2 * np.cos(angles)\n        Y[1:9] = 0.5 + 0.2 * np.sin(angles)\n        angles2 = np.linspace(0, 2 * np.pi, 18)[:-1]\n        X[9:26] = 0.5 + 0.4 * np.cos(angles2)\n        Y[9:26] = 0.5 + 0.4 * np.sin(angles2)\n    elif cat == 1:\n        # Symmetry-inducing sub-hubs targeting broader spread patterns\n        cents = [[0.5, 0.5], [0.2, 0.2], [0.8, 0.8], [0.2, 0.8], [0.8, 0.2]]\n        for i, c in enumerate(cents):\n            X[i], Y[i] = c\n    elif cat == 2:\n        # Rotational spatial sweeps\n        angles = np.linspace(0, 5 * np.pi, n)\n        rads = np.linspace(0.0, 0.45, n)\n        X = 0.5 + rads * np.cos(angles)\n        Y = 0.5 + rads * np.sin(angles)\n    elif cat == 3:\n        # Aggregated perimeter biases forcing complex natural internal resolutions\n        X[:13] = np.linspace(0.1, 0.9, 13)\n        Y[:13] = 0.1 + np.random.normal(0, 0.02, 13)\n        X[13:] = np.linspace(0.1, 0.9, 13)\n        Y[13:] = 0.9 + np.random.normal(0, 0.02, 13)\n\n    # Spatial scaling size variations naturally positioning large towards the centers limits\n    dist_to_center = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n    order = np.argsort(dist_to_center)\n    sizes = np.linspace(0.07, 0.01, n)\n    np.random.shuffle(sizes[n//2:])\n    R[order] = sizes\n\n    X += np.random.normal(0, 0.01, n)\n    Y += np.random.normal(0, 0.01, n)\n    X = np.clip(X, 0.1, 0.9)\n    Y = np.clip(Y, 0.1, 0.9)\n\n    return np.column_stack([X, Y, R])\n\n\ndef make_strictly_valid(params):\n    \"\"\"\n    Cleans spatial artifacts strictly mapping values definitively against border\n    constraints perfectly sealing boundaries correctly returning sizes mappings!\n    \"\"\"\n    centers = np.clip(params[:, :2], 0.0, 1.0)\n    radii = params[:, 2].copy()\n\n    # Apply rigid wall bounds limitations iteratively checking limits mapped edges correctly\n    b_rad = np.min([\n        centers[:, 0], 1.0 - centers[:, 0],\n        centers[:, 1], 1.0 - centers[:, 1]\n    ], axis=0)\n    \n    radii = np.clip(radii, 1e-8, b_rad)\n    n = len(radii)\n\n    # Interconnected overlaps strictly trimming iteratively symmetrically smoothly mapped sizes constraints variables loops precisely scaling values \n    for _ in range(150):\n        max_overlap = 0.0\n        diff = centers[:, None, :] - centers[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        if np.max(radii[:, None] + radii[None, :] - dist) <= 1e-12:\n            break\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dist[i, j]\n                overlap = radii[i] + radii[j] - d\n                if overlap > 1e-12:\n                    if overlap > max_overlap:\n                        max_overlap = overlap\n                    \n                    # Proportional mapping distribution constraint sizes shrinks strictly limiting ratios precisely limiting\n                    sum_r = max(1e-10, radii[i] + radii[j])\n                    f = max(0.0, d - 1e-11) / sum_r\n                    radii[i] *= f\n                    radii[j] *= f\n\n        if max_overlap <= 1e-12:\n            break\n\n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct optimal combinations iterating simulated configurations enforcing mapping logic\n    strictly optimizing dynamically overlapping gradient spaces. Maximizes accumulated final true sum limits radii naturally!\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_seeds = 16\n    iters = 4500\n    base_lr = 0.02\n\n    # Searching space optimization dynamics mapping globally traversing variables constraints seamlessly integrating arrays correctly mathematically resolving values\n    for seed_id in range(num_seeds):\n        params = init_seed(n, seed_id)\n        \n        m = np.zeros_like(params)\n        v = np.zeros_like(params)\n\n        for step in range(1, iters + 1):\n            prog = step / iters\n            clr = base_lr * (1.0 - prog)**2 + 0.001\n            P = 10.0 * (5000.0 ** prog)\n\n            # Simulated structural cooling random steps injections jumping escaping barriers structurally resolving correctly scaling arrays properly mapped limits \n            if step % 300 == 0 and prog < 0.7:\n                params[:, :2] += np.random.normal(0, 0.005, (n, 2))\n                params[:, :2] = np.clip(params[:, :2], 0.01, 0.99)\n\n            grad = np.zeros_like(params)\n            \n            # Radii size expansion pull directly uniformly uniformly maximizing sum limits precisely natively evaluating forces boundaries accurately!\n            grad[:, 2] = -1.0\n\n            C = params[:, :2]\n            R = params[:, 2]\n\n            diff = C[:, None, :] - C[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n\n            overlap = np.maximum(0, R[:, None] + R[None, :] - dist)\n            if np.any(overlap > 0):\n                force = 2 * P * overlap\n                grad[:, 2] += np.sum(force, axis=1)\n\n                valid_mask = dist > 1e-12\n                dir_norm = np.zeros_like(diff)\n                dir_norm[valid_mask] = diff[valid_mask] / dist[valid_mask][..., np.newaxis]\n\n                grad[:, :2] -= np.sum(force[..., np.newaxis] * dir_norm, axis=1)\n\n            # Edge mappings penalties checking mapping uniformly boundaries enforcing correct mathematical resolutions strictly evaluating\n            w_L = np.maximum(0, R - C[:, 0])\n            grad[:, 2] += 2 * P * w_L\n            grad[:, 0] -= 2 * P * w_L\n\n            w_R = np.maximum(0, C[:, 0] + R - 1.0)\n            grad[:, 2] += 2 * P * w_R\n            grad[:, 0] += 2 * P * w_R\n\n            w_B = np.maximum(0, R - C[:, 1])\n            grad[:, 2] += 2 * P * w_B\n            grad[:, 1] -= 2 * P * w_B\n\n            w_T = np.maximum(0, C[:, 1] + R - 1.0)\n            grad[:, 2] += 2 * P * w_T\n            grad[:, 1] += 2 * P * w_T\n\n            # Execute variables Adam updating state scaling moments seamlessly handling limits updating arrays gradients\n            m = 0.9 * m + 0.1 * grad\n            v = 0.999 * v + 0.001 * (grad ** 2)\n            m_h = m / (1 - 0.9 ** step)\n            v_h = v / (1 - 0.999 ** step)\n\n            params -= clr * m_h / (np.sqrt(v_h) + 1e-8)\n            params[:, :2] = np.clip(params[:, :2], 0.001, 0.999)\n            params[:, 2] = np.clip(params[:, 2], 0.001, 1.0)\n\n        # Complete resolving clean valid limitations coordinates outputs extracting correctly cleanly mapped sizes\n        c_final, r_final = make_strictly_valid(params)\n        \n        valid_sum = np.sum(r_final)\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = c_final.copy()\n            best_r = r_final.copy()\n\n    return best_c, best_r, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Retained purely strictly maintaining complete interfaces alias seamlessly matching environments limitations configurations logic! \n    In practically circumvented logic customized returned outputs accurately structured dynamically mapping coordinates correctly outputs.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n) * 0.5\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / max(1e-12, radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4817), Performs well on target_ratio (0.9418), Performs well on combined_score (0.9418), Performs well on radius_variance (0.0063), Performs well on spatial_spread (0.1906), Performs well on eval_time (12.6768)\n\n### Program 3 (Score: 0.8177)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam-based optimizer for natively packing n=26 unequal circles cleanly securely dynamically fully\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an arrangement of 26 circles using iterative gradient \n    optimization smoothly structured properly practically mappings optimally functionally perfectly dynamically cleanly correctly flawlessly strictly strictly correctly efficiently dynamically reliably dynamically flawlessly accurately flawlessly structurally seamlessly strictly reliably perfectly perfectly functionally smoothly completely cleanly securely securely dependably correctly efficiently efficiently properly exactly strictly cleanly smoothly accurately precisely accurately systematically safely smoothly smoothly safely accurately properly securely cleanly smoothly flawlessly strictly practically properly dynamically safely\n    \n    Returns:\n        Tuple of (centers, radii, sum_radii) structurally smoothly fully precisely comprehensively practically reliably cleanly efficiently securely practically safely correctly predictably exactly cleanly seamlessly smoothly gracefully gracefully strictly accurately accurately precisely strictly dynamically comprehensively efficiently\n    \"\"\"\n    np.random.seed(42)\n    n = 26\n    \n    inits = []\n    \n    # 1. Broadly spread hex grid initialization structure gracefully biased toward bounds seamlessly mapping seamlessly completely flawlessly efficiently reliably mapping predictably strictly optimally strictly properly reliably seamlessly safely correctly perfectly efficiently dependably correctly properly\n    c_hex = []\n    for row in range(6):\n        for col in range(5):\n            c_hex.append([0.15 + col * 0.16 + (0.08 if row % 2 else 0), 0.15 + row * 0.145])\n    inits.append((np.clip(c_hex[:n], 0.05, 0.95), np.ones(n) * 0.035))\n    \n    # 2. Concentric ring mapping smoothly safely practically seamlessly optimally flawlessly systematically efficiently cleanly securely flawlessly dynamically correctly cleanly properly strictly strictly efficiently securely precisely dependably smoothly efficiently reliably accurately efficiently dependably accurately perfectly\n    c_ring = np.zeros((n, 2))\n    c_ring[0] = [0.5, 0.5]\n    for i in range(8):\n        a = 2 * np.pi * i / 8\n        c_ring[i+1] = [0.5 + 0.2 * np.cos(a), 0.5 + 0.2 * np.sin(a)]\n    for i in range(17):\n        a = 2 * np.pi * i / 17\n        c_ring[i+9] = [0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)]\n    inits.append((np.clip(c_ring, 0.05, 0.95), np.ones(n) * 0.025))\n    \n    # 3. Dynamic layout structures robustly efficiently practically properly predictably efficiently seamlessly precisely fully strictly completely securely comprehensively predictably predictably strictly dependably exactly structurally mapping properly properly properly\n    for seed in range(10):\n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.015, 0.055, n)\n        if seed % 2 == 0:\n            c[:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[:4] = 0.07\n        if seed % 3 == 0:\n            c[-1] = [0.5, 0.5]\n            r[-1] = 0.18\n        inits.append((c, r))\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n    \n    for c_init, r_init in inits:\n        c_final, r_final = optimize_single_seed(c_init, r_init)\n        \n        valid_sum = np.sum(r_final)\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = c_final\n            best_r = r_final\n            \n    return best_c, best_r, best_sum\n\n\ndef optimize_single_seed(c_init, r_init, steps=4500):\n    \"\"\"Execution step gracefully mapping accurately fully accurately dynamically accurately seamlessly securely smoothly seamlessly smoothly strictly precisely gracefully flawlessly properly correctly flawlessly securely strictly strictly structurally cleanly cleanly precisely correctly systematically accurately properly reliably reliably structurally structurally perfectly properly efficiently cleanly efficiently predictably safely practically seamlessly correctly smoothly properly dependably smoothly safely reliably\"\"\"\n    n = len(r_init)\n    params = np.zeros((n, 3))\n    params[:, :2] = c_init\n    params[:, 2] = r_init\n    \n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    for step in range(steps):\n        prog = step / steps\n        wp = 20.0 * (1500.0 ** prog)\n        lr = 0.012 * ((0.001 / 0.012) ** prog)\n        \n        diff = params[:, np.newaxis, :2] - params[np.newaxis, :, :2]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        \n        target = params[:, np.newaxis, 2] + params[np.newaxis, :, 2]\n        overlap = np.maximum(0, target - dist)\n        \n        grad = np.zeros_like(params)\n        grad[:, 2] = -1.0 \n        \n        if step < int(steps * 0.45) and step % 200 == 0:\n            mag = 2.0 * (0.45 - prog)\n            grad[:, :2] += np.random.normal(0, mag, (n, 2))\n            \n        if np.any(overlap > 0):\n            ov_grad = 2 * wp * overlap\n            grad[:, 2] += np.sum(ov_grad, axis=1)\n            \n            valid = dist > 1e-12\n            dir_n = np.zeros_like(diff)\n            dir_n[valid] = diff[valid] / dist[valid][..., np.newaxis]\n            \n            c_g = -ov_grad[..., np.newaxis] * dir_n\n            grad[:, :2] += np.sum(c_g, axis=1)\n            \n        b_l = np.maximum(0, params[:, 2] - params[:, 0])\n        grad[:, 2] += 2 * wp * b_l\n        grad[:, 0] -= 2 * wp * b_l\n        \n        b_r = np.maximum(0, params[:, 0] + params[:, 2] - 1.0)\n        grad[:, 2] += 2 * wp * b_r\n        grad[:, 0] += 2 * wp * b_r\n        \n        b_b = np.maximum(0, params[:, 2] - params[:, 1])\n        grad[:, 2] += 2 * wp * b_b\n        grad[:, 1] -= 2 * wp * b_b\n        \n        b_t = np.maximum(0, params[:, 1] + params[:, 2] - 1.0)\n        grad[:, 2] += 2 * wp * b_t\n        grad[:, 1] += 2 * wp * b_t\n        \n        min_r = np.maximum(0, 0.002 - params[:, 2])\n        grad[:, 2] -= 2 * wp * min_r\n        \n        t = step + 1\n        m = 0.9 * m + 0.1 * grad\n        v = 0.999 * v + 0.001 * (grad ** 2)\n        \n        m_hat = m / (1 - 0.9 ** t)\n        v_hat = v / (1 - 0.999 ** t)\n        \n        params -= lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n\n    c_final = np.clip(params[:, :2], 0.0, 1.0)\n    r_final = compute_max_radii(c_final)\n    \n    # Overwrite radii securely reliably efficiently completely mapping flawlessly mapping precisely structurally strictly systematically efficiently structurally fully gracefully strictly securely flawlessly securely dependably correctly accurately effectively reliably seamlessly structurally flawlessly directly smoothly exactly dependably accurately efficiently safely gracefully smoothly properly directly effectively dependably robustly correctly fully seamlessly accurately dependably gracefully safely accurately perfectly accurately gracefully\n    return c_final, r_final\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Absolutely securely seamlessly dependably strictly smoothly gracefully systematically safely efficiently strictly dynamically practically securely efficiently structurally effectively predictably robustly structurally precisely completely safely structurally mapping reliably accurately safely smoothly accurately directly exactly flawlessly strictly robustly correctly predictably cleanly effectively smoothly efficiently smoothly accurately mapping dynamically accurately practically correctly perfectly gracefully exactly fully perfectly cleanly cleanly directly practically fully mapping\n    \"\"\"\n    centers = np.clip(centers, 0.0, 1.0)\n    n = len(centers)\n    \n    b_r = np.min([centers[:, 0], 1.0 - centers[:, 0], \n                  centers[:, 1], 1.0 - centers[:, 1]], axis=0)\n    \n    r_final = np.maximum(0.0, np.minimum(b_r, 0.5))\n    \n    for _ in range(50):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                if r_final[i] + r_final[j] > d:\n                    o = r_final[i] + r_final[j] - d\n                    if o > max_ov:\n                        max_ov = o\n                    if r_final[i] + r_final[j] > 1e-12:\n                        f = max(0.0, d - 1e-11) / (r_final[i] + r_final[j])\n                        r_final[i] *= f\n                        r_final[j] *= f\n        if max_ov <= 1e-11:\n            break\n            \n    return r_final\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.1546), Performs well on target_ratio (0.8177), Performs well on combined_score (0.8177), Performs well on radius_variance (0.0171), Performs well on spatial_spread (0.1930), Performs well on eval_time (9.3011)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.6721)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam optimization for n=26 circle packing\"\"\"\nimport numpy as np\n\n\ndef init_seed(seed, n):\n    \"\"\"Seed initial position configurations with heuristic and noise to break symmetry.\"\"\"\n    np.random.seed(seed + 100)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.random.uniform(0.01, 0.05, n)\n\n    if seed == 0:\n        # Bias towards one center and 4 corners\n        X[0:5] = [0.5, 0.1, 0.9, 0.1, 0.9]\n        Y[0:5] = [0.5, 0.1, 0.1, 0.9, 0.9]\n        R[0:5] = [0.2, 0.1, 0.1, 0.1, 0.1]\n    elif seed == 1:\n        # Lattice structure base\n        grid = np.linspace(0.15, 0.85, 5)\n        xg, yg = np.meshgrid(grid, grid)\n        X[:25] = xg.flatten()\n        Y[:25] = yg.flatten()\n        X[25], Y[25] = 0.5, 0.5\n        R[:25] = 0.06\n        R[25] = 0.02\n        # Break perfect symmetry gently\n        X += np.random.normal(0, 0.005, n)\n        Y += np.random.normal(0, 0.005, n)\n    elif seed == 2:\n        # Concentric rings layout\n        angles1 = np.linspace(0, 2 * np.pi, 9)[:-1]\n        X[0:8] = 0.5 + 0.25 * np.cos(angles1)\n        Y[0:8] = 0.5 + 0.25 * np.sin(angles1)\n        angles2 = np.linspace(0, 2 * np.pi, 18)[:-1]\n        X[8:25] = 0.5 + 0.45 * np.cos(angles2)\n        Y[8:25] = 0.5 + 0.45 * np.sin(angles2)\n        X[25], Y[25] = 0.5, 0.5\n        R[:] = 0.04\n        # Add random kicks\n        X += np.random.normal(0, 0.01, n)\n        Y += np.random.normal(0, 0.01, n)\n\n    X = np.clip(X, 0, 1)\n    Y = np.clip(Y, 0, 1)\n    return X, Y, R\n\n\ndef make_valid(X, Y, R):\n    \"\"\"Feasibility projection to strictly enforce boundary and overlap rules.\"\"\"\n    X = np.copy(X)\n    Y = np.copy(Y)\n    R = np.copy(R)\n    n = len(R)\n\n    # Strictly lock into unit square bounds\n    for i in range(n):\n        R[i] = max(1e-6, min(R[i], X[i], 1 - X[i], Y[i], 1 - Y[i]) - 1e-11)\n\n    # Clean overlaps down precisely monotonically\n    for _ in range(50):\n        max_overlap = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((X[i] - X[j])**2 + (Y[i] - Y[j])**2)\n                overlap = R[i] + R[j] - dist\n                if overlap > 1e-12:\n                    if overlap > max_overlap:\n                        max_overlap = overlap\n                    factor = (dist - 1e-11) / (R[i] + R[j])\n                    R[i] *= factor\n                    R[j] *= factor\n        if max_overlap <= 1e-12:\n            break\n\n    return R\n\n\ndef construct_packing():\n    \"\"\"\n    Search optimally configured circles layout combining numerical continuation\n    on penalty boundaries using customized Adam. Maximize final sum of true Radii.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_X = None\n    best_Y = None\n    best_R = None\n\n    num_seeds = 8\n    iters = 3000\n    lr, beta1, beta2, eps = 0.01, 0.9, 0.999, 1e-8\n\n    for seed in range(num_seeds):\n        X, Y, R = init_seed(seed, n)\n\n        m_X, m_Y, m_R = np.zeros(n), np.zeros(n), np.zeros(n)\n        v_X, v_Y, v_R = np.zeros(n), np.zeros(n), np.zeros(n)\n\n        for t in range(1, iters + 1):\n            progress = t / iters\n            # Continuously expand barrier to tightly push towards constraints smoothly\n            P = 10.0 * (100000.0 ** progress)\n            # Decaying learning rate mimicking a cool down procedure\n            current_lr = lr * (1 - progress) + 0.001 * progress\n\n            if t % 100 == 0 and progress < 0.8:\n                noise = 0.01 * (0.8 - progress)\n                X += np.random.normal(0, noise, n)\n                Y += np.random.normal(0, noise, n)\n                X = np.clip(X, 0.01, 0.99)\n                Y = np.clip(Y, 0.01, 0.99)\n\n            grad_X = np.zeros(n)\n            grad_Y = np.zeros(n)\n            # Maximizing Sum(R), essentially giving a static initial pull on radii.\n            grad_R = np.full(n, -1.0)\n\n            dx = X[:, None] - X[None, :]\n            dy = Y[:, None] - Y[None, :]\n            dist = np.sqrt(dx**2 + dy**2)\n            np.fill_diagonal(dist, np.inf)\n            dist = np.maximum(dist, 1e-12)\n\n            O_mat = np.maximum(0, R[:, None] + R[None, :] - dist)\n            \n            # Radii adjustments regarding overlap matrices \n            grad_R += 2 * P * np.sum(O_mat, axis=1)\n\n            inv_dist = np.zeros_like(dist)\n            mask = dist < np.inf\n            inv_dist[mask] = 1.0 / dist[mask]\n\n            grad_X += 2 * P * np.sum(O_mat * (-dx * inv_dist), axis=1)\n            grad_Y += 2 * P * np.sum(O_mat * (-dy * inv_dist), axis=1)\n\n            # Walls boundaries penalty \n            w_L = np.maximum(0, R - X)\n            grad_R += 2 * P * w_L\n            grad_X -= 2 * P * w_L\n\n            w_R = np.maximum(0, X + R - 1)\n            grad_R += 2 * P * w_R\n            grad_X += 2 * P * w_R\n\n            w_B = np.maximum(0, R - Y)\n            grad_R += 2 * P * w_B\n            grad_Y -= 2 * P * w_B\n\n            w_T = np.maximum(0, Y + R - 1)\n            grad_R += 2 * P * w_T\n            grad_Y += 2 * P * w_T\n\n            # Execute vanilla Adam stepping dynamics\n            m_X = beta1 * m_X + (1 - beta1) * grad_X\n            v_X = beta2 * v_X + (1 - beta2) * (grad_X ** 2)\n            m_hat_X = m_X / (1 - beta1 ** t)\n            v_hat_X = v_X / (1 - beta2 ** t)\n            X -= current_lr * m_hat_X / (np.sqrt(v_hat_X) + eps)\n\n            m_Y = beta1 * m_Y + (1 - beta1) * grad_Y\n            v_Y = beta2 * v_Y + (1 - beta2) * (grad_Y ** 2)\n            m_hat_Y = m_Y / (1 - beta1 ** t)\n            v_hat_Y = v_Y / (1 - beta2 ** t)\n            Y -= current_lr * m_hat_Y / (np.sqrt(v_hat_Y) + eps)\n\n            m_R = beta1 * m_R + (1 - beta1) * grad_R\n            v_R = beta2 * v_R + (1 - beta2) * (grad_R ** 2)\n            m_hat_R = m_R / (1 - beta1 ** t)\n            v_hat_R = v_R / (1 - beta2 ** t)\n            R -= current_lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n\n            X = np.clip(X, 0.001, 0.999)\n            Y = np.clip(Y, 0.001, 0.999)\n            R = np.clip(R, 0.001, 1.0)\n\n        # Confirm strictly resolved valid structures over final converged coordinates \n        final_R = make_valid(X, Y, R)\n        valid_sum = np.sum(final_R)\n\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_X = np.copy(X)\n            best_Y = np.copy(Y)\n            best_R = np.copy(final_R)\n\n    centers = np.column_stack((best_X, best_Y))\n    return centers, best_R, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Retained purely as compatibility hook strictly satisfying requirements limits.\n    In practice locally circumvented entirely by custom constructed output from make_valid.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    return radii\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.5450)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam optimization with geometrical heuristics for circle packing\"\"\"\nimport numpy as np\n\ndef init_seed(n, idx):\n    \"\"\"\n    Seed initial positions strategically: Bias initial placements toward \n    corners and edges, and determine size hierarchies based on center proximity.\n    \"\"\"\n    np.random.seed(idx + 2025)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.zeros(n)\n    \n    if idx % 4 == 0:\n        X[0], Y[0] = 0.5, 0.5\n        X[1:5] = [0.15, 0.85, 0.15, 0.85]\n        Y[1:5] = [0.15, 0.15, 0.85, 0.85]\n    elif idx % 4 == 1:\n        angles = np.linspace(0, 4 * np.pi, n)\n        rad = np.linspace(0, 0.45, n)\n        X = 0.5 + rad * np.cos(angles)\n        Y = 0.5 + rad * np.sin(angles)\n    elif idx % 4 == 2:\n        c1 = min(n, 12)\n        ang = np.linspace(0, 2 * np.pi, c1, endpoint=False)\n        X[0:c1] = 0.5 + 0.4 * np.cos(ang)\n        Y[0:c1] = 0.5 + 0.4 * np.sin(ang)\n        if n > c1:\n            X[c1], Y[c1] = 0.5, 0.5\n            \n    # Break perfect symmetry gently via random perturbation\n    X += np.random.normal(0, 0.02, n)\n    Y += np.random.normal(0, 0.02, n)\n    X = np.clip(X, 0.05, 0.95)\n    Y = np.clip(Y, 0.05, 0.95)\n    \n    # Placement by size heuristic: larger toward the center, smaller in gaps\n    dist_to_center = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n    sorted_idx = np.argsort(dist_to_center) \n    \n    initial_r = np.linspace(0.12, 0.01, n)\n    np.random.shuffle(initial_r[n//2:])\n    R[sorted_idx] = initial_r\n    \n    return X, Y, R\n\ndef force_valid(X, Y, R):\n    \"\"\"\n    Project strictly to feasibility by cleaning out constraints exactly.\n    \"\"\"\n    R = np.clip(R, 1e-8, np.minimum(np.minimum(X, 1 - X), np.minimum(Y, 1 - Y)))\n    n = len(R)\n    \n    for _ in range(100):\n        dx = X[:, None] - X[None, :]\n        dy = Y[:, None] - Y[None, :]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        if np.max(R[:, None] + R[None, :] - dist) <= 1e-12:\n            break\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dist[i, j]\n                sum_R = R[i] + R[j]\n                if sum_R > d:\n                    f = d / sum_R if sum_R > 1e-12 else 0.0\n                    R[i] *= f\n                    R[j] *= f\n                    \n    return R\n\ndef construct_packing():\n    n = 26\n    best_sum = -1.0\n    best_c, best_r = None, None\n    iters = 3000\n    lr = 0.02\n    \n    for seed_id in range(16):\n        X, Y, R = init_seed(n, seed_id)\n        m_X, m_Y, m_R = np.zeros(n), np.zeros(n), np.zeros(n)\n        v_X, v_Y, v_R = np.zeros(n), np.zeros(n), np.zeros(n)\n        \n        for t in range(1, iters + 1):\n            prog = t / iters\n            clr = lr * (1 - prog) + 0.001 * prog\n            P = 10.0 * (100000.0 ** prog)\n            \n            # Simulated annealing perturbation injection mapping smoothly out over time\n            if t % 200 == 0 and prog < 0.7:\n                noise = 0.005 * (0.7 - prog)\n                X += np.random.normal(0, noise, n)\n                Y += np.random.normal(0, noise, n)\n                \n            dx = X[:, None] - X[None, :]\n            dy = Y[:, None] - Y[None, :]\n            dist = np.maximum(np.sqrt(dx**2 + dy**2), 1e-12)\n            np.fill_diagonal(dist, np.inf)\n            \n            O_mat = np.maximum(0, R[:, None] + R[None, :] - dist)\n            grad_R = np.full(n, -1.0)\n            grad_R += 2 * P * np.sum(O_mat, axis=1)\n            \n            inv = np.where(dist < np.inf, 1.0 / dist, 0.0)\n            force = 2 * P * O_mat * inv\n            grad_X = np.sum(-force * dx, axis=1)\n            grad_Y = np.sum(-force * dy, axis=1)\n            \n            walls = [\n                (R - X, 1, -1, 0),    \n                (X + R - 1, 1, 1, 0), \n                (R - Y, 1, 0, -1),    \n                (Y + R - 1, 1, 0, 1)  \n            ]\n            \n            for viol, gR_s, gX_s, gY_s in walls:\n                w = np.maximum(0, viol)\n                grad_R += 2 * P * w * gR_s\n                grad_X += 2 * P * w * gX_s\n                grad_Y += 2 * P * w * gY_s\n                \n            for val, grad, m, v in zip([X, Y, R], \n                                       [grad_X, grad_Y, grad_R], \n                                       [m_X, m_Y, m_R], \n                                       [v_X, v_Y, v_R]):\n                m[:] = 0.9 * m + 0.1 * grad\n                v[:] = 0.999 * v + 0.001 * (grad**2)\n                m_h = m / (1 - 0.9**t)\n                v_h = v / (1 - 0.999**t)\n                val -= clr * m_h / (np.sqrt(v_h) + 1e-8)\n                \n            X = np.clip(X, 0.001, 0.999)\n            Y = np.clip(Y, 0.001, 0.999)\n            R = np.clip(R, 0.001, 1.0)\n            \n        final_R = force_valid(X, Y, R)\n        valid_sum = np.sum(final_R)\n        \n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = np.column_stack((X, Y))\n            best_r = np.copy(final_R)\n            \n    return best_c, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.6721, Type: Alternative)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam optimization for n=26 circle packing\"\"\"\nimport numpy as np\n\n\ndef init_seed(seed, n):\n    \"\"\"Seed initial position configurations with heuristic and noise to break symmetry.\"\"\"\n    np.random.seed(seed + 100)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.random.uniform(0.01, 0.05, n)\n\n    if seed == 0:\n        # Bias towards one center and 4 corners\n        X[0:5] = [0.5, 0.1, 0.9, 0.1, 0.9]\n        Y[0:5] = [0.5, 0.1, 0.1, 0.9, 0.9]\n        R[0:5] = [0.2, 0.1, 0.1, 0.1, 0.1]\n    elif seed == 1:\n        # Lattice structure base\n        grid = np.linspace(0.15, 0.85, 5)\n        xg, yg = np.meshgrid(grid, grid)\n        X[:25] = xg.flatten()\n        Y[:25] = yg.flatten()\n        X[25], Y[25] = 0.5, 0.5\n        R[:25] = 0.06\n        R[25] = 0.02\n        # Break perfect symmetry gently\n        X += np.random.normal(0, 0.005, n)\n        Y += np.random.normal(0, 0.005, n)\n    elif seed == 2:\n        # Concentric rings layout\n        angles1 = np.linspace(0, 2 * np.pi, 9)[:-1]\n        X[0:8] = 0.5 + 0.25 * np.cos(angles1)\n        Y[0:8] = 0.5 + 0.25 * np.sin(angles1)\n        angles2 = np.linspace(0, 2 * np.pi, 18)[:-1]\n        X[8:25] = 0.5 + 0.45 * np.cos(angles2)\n        Y[8:25] = 0.5 + 0.45 * np.sin(angles2)\n        X[25], Y[25] = 0.5, 0.5\n        R[:] = 0.04\n        # Add random kicks\n        X += np.random.normal(0, 0.01, n)\n        Y += np.random.normal(0, 0.01, n)\n\n    X = np.clip(X, 0, 1)\n    Y = np.clip(Y, 0, 1)\n    return X, Y, R\n\n\ndef make_valid(X, Y, R):\n    \"\"\"Feasibility projection to strictly enforce boundary and overlap rules.\"\"\"\n    X = np.copy(X)\n    Y = np.copy(Y)\n    R = np.copy(R)\n    n = len(R)\n\n    # Strictly lock into unit square bounds\n    for i in range(n):\n        R[i] = max(1e-6, min(R[i], X[i], 1 - X[i], Y[i], 1 - Y[i]) - 1e-11)\n\n    # Clean overlaps down precisely monotonically\n    for _ in range(50):\n        max_overlap = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((X[i] - X[j])**2 + (Y[i] - Y[j])**2)\n                overlap = R[i] + R[j] - dist\n                if overlap > 1e-12:\n                    if overlap > max_overlap:\n                        max_overlap = overlap\n                    factor = (dist - 1e-11) / (R[i] + R[j])\n                    R[i] *= factor\n                    R[j] *= factor\n        if max_overlap <= 1e-12:\n            break\n\n    return R\n\n\ndef construct_packing():\n    \"\"\"\n    Search optimally configured circles layout combining numerical continuation\n    on penalty boundaries using customized Adam. Maximize final sum of true Radii.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_X = None\n    best_Y = None\n    best_R = None\n\n    num_seeds = 8\n    iters = 3000\n    lr, beta1, beta2, eps = 0.01, 0.9, 0.999, 1e-8\n\n    for seed in range(num_seeds):\n        X, Y, R = init_seed(seed, n)\n\n        m_X, m_Y, m_R = np.zeros(n), np.zeros(n), np.zeros(n)\n        v_X, v_Y, v_R = np.zeros(n), np.zeros(n), np.zeros(n)\n\n        for t in range(1, iters + 1):\n            progress = t / iters\n            # Continuously expand barrier to tightly push towards constraints smoothly\n            P = 10.0 * (100000.0 ** progress)\n            # Decaying learning rate mimicking a cool down procedure\n            current_lr = lr * (1 - progress) + 0.001 * progress\n\n            if t % 100 == 0 and progress < 0.8:\n                noise = 0.01 * (0.8 - progress)\n                X += np.random.normal(0, noise, n)\n                Y += np.random.normal(0, noise, n)\n                X = np.clip(X, 0.01, 0.99)\n                Y = np.clip(Y, 0.01, 0.99)\n\n            grad_X = np.zeros(n)\n            grad_Y = np.zeros(n)\n            # Maximizing Sum(R), essentially giving a static initial pull on radii.\n            grad_R = np.full(n, -1.0)\n\n            dx = X[:, None] - X[None, :]\n            dy = Y[:, None] - Y[None, :]\n            dist = np.sqrt(dx**2 + dy**2)\n            np.fill_diagonal(dist, np.inf)\n            dist = np.maximum(dist, 1e-12)\n\n            O_mat = np.maximum(0, R[:, None] + R[None, :] - dist)\n            \n            # Radii adjustments regarding overlap matrices \n            grad_R += 2 * P * np.sum(O_mat, axis=1)\n\n            inv_dist = np.zeros_like(dist)\n            mask = dist < np.inf\n            inv_dist[mask] = 1.0 / dist[mask]\n\n            grad_X += 2 * P * np.sum(O_mat * (-dx * inv_dist), axis=1)\n            grad_Y += 2 * P * np.sum(O_mat * (-dy * inv_dist), axis=1)\n\n            # Walls boundaries penalty \n            w_L = np.maximum(0, R - X)\n            grad_R += 2 * P * w_L\n            grad_X -= 2 * P * w_L\n\n            w_R = np.maximum(0, X + R - 1)\n            grad_R += 2 * P * w_R\n            grad_X += 2 * P * w_R\n\n            w_B = np.maximum(0, R - Y)\n            grad_R += 2 * P * w_B\n            grad_Y -= 2 * P * w_B\n\n            w_T = np.maximum(0, Y + R - 1)\n            grad_R += 2 * P * w_T\n            grad_Y += 2 * P * w_T\n\n            # Execute vanilla Adam stepping dynamics\n            m_X = beta1 * m_X + (1 - beta1) * grad_X\n            v_X = beta2 * v_X + (1 - beta2) * (grad_X ** 2)\n            m_hat_X = m_X / (1 - beta1 ** t)\n            v_hat_X = v_X / (1 - beta2 ** t)\n            X -= current_lr * m_hat_X / (np.sqrt(v_hat_X) + eps)\n\n            m_Y = beta1 * m_Y + (1 - beta1) * grad_Y\n            v_Y = beta2 * v_Y + (1 - beta2) * (grad_Y ** 2)\n            m_hat_Y = m_Y / (1 - beta1 ** t)\n            v_hat_Y = v_Y / (1 - beta2 ** t)\n            Y -= current_lr * m_hat_Y / (np.sqrt(v_hat_Y) + eps)\n\n            m_R = beta1 * m_R + (1 - beta1) * grad_R\n            v_R = beta2 * v_R + (1 - beta2) * (grad_R ** 2)\n            m_hat_R = m_R / (1 - beta1 ** t)\n            v_hat_R = v_R / (1 - beta2 ** t)\n            R -= current_lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n\n            X = np.clip(X, 0.001, 0.999)\n            Y = np.clip(Y, 0.001, 0.999)\n            R = np.clip(R, 0.001, 1.0)\n\n        # Confirm strictly resolved valid structures over final converged coordinates \n        final_R = make_valid(X, Y, R)\n        valid_sum = np.sum(final_R)\n\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_X = np.copy(X)\n            best_Y = np.copy(Y)\n            best_R = np.copy(final_R)\n\n    centers = np.column_stack((best_X, best_Y))\n    return centers, best_R, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Retained purely as compatibility hook strictly satisfying requirements limits.\n    In practice locally circumvented entirely by custom constructed output from make_valid.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    return radii\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9973, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam-based optimizer for packing n=26 unequal circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an arrangement of 26 circles using iterative gradient \n    optimization with Adam. Maximizes sum of their radii without overlapping.\n    \n    Returns:\n        Tuple of (centers, radii, sum_radii)\n    \"\"\"\n    np.random.seed(42)\n    n = 26\n    \n    # 1. Initialize strategically biased starting configurations\n    inits = []\n    \n    # Initialization A: Hexagonal layout broadly adapted for N=26\n    c_hex = []\n    for row in range(6):\n        for col in range(5):\n            if len(c_hex) < n:\n                x = 0.15 + col * 0.15 + (0.075 if row % 2 else 0)\n                y = 0.15 + row * 0.14\n                c_hex.append([x, y])\n    inits.append((np.clip(c_hex, 0.05, 0.95), np.ones(n) * 0.03))\n    \n    # Initialization B: Center-biased symmetric pattern layout\n    c_ring = np.zeros((n, 2))\n    c_ring[0] = [0.5, 0.5]\n    for i in range(8):\n        c_ring[i+1] = [0.5 + 0.2*np.cos(2*np.pi*i/8), 0.5 + 0.2*np.sin(2*np.pi*i/8)]\n    for i in range(17):\n        c_ring[i+9] = [0.5 + 0.4*np.cos(2*np.pi*i/17), 0.5 + 0.4*np.sin(2*np.pi*i/17)]\n    inits.append((np.clip(c_ring, 0.05, 0.95), np.ones(n) * 0.02))\n    \n    # Initializations C: Random starts mimicking spatial variations\n    for _ in range(8):\n        c = np.random.uniform(0.1, 0.9, (n, 2))\n        r = np.random.uniform(0.01, 0.06, n)\n        inits.append((c, r))\n\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Perform simulation steps across different seed spaces\n    for c_init, r_init in inits:\n        c_final, r_final = optimize_single(c_init, r_init, steps=6000)\n        \n        # Eliminate floating precision issues enforcing perfectly safe bounding boxes\n        r_valid = make_strictly_valid(c_final, r_final)\n        \n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = c_final\n            best_radii = r_valid\n            \n    return best_centers, best_radii, best_sum\n\n\ndef optimize_single(c_init, r_init, steps=6000):\n    \"\"\"Core computational physics optimization kernel for a single setup\"\"\"\n    n = len(r_init)\n    params = np.zeros((n, 3))\n    params[:, :2] = c_init\n    params[:, 2] = r_init\n    \n    # Adam optim parameters\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    base_lr = 0.01\n    wp = 20.0 \n    \n    for step in range(steps):\n        # 1. Distances and continuous overlaps evaluations\n        diff = params[:, np.newaxis, :2] - params[np.newaxis, :, :2]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n        \n        target = params[:, np.newaxis, 2] + params[np.newaxis, :, 2]\n        overlap = np.maximum(0, target - dist)\n        \n        grad = np.zeros_like(params)\n        \n        # Uniform force pulling radius sizes up!\n        grad[:, 2] = -1.0 \n        \n        # Simulated simulated annealing / symmetry momentum breaker \n        if step < 2000 and step % 250 == 0:\n            grad[:, :2] += np.random.normal(0, 0.5, (n, 2))\n            \n        if np.any(overlap > 0):\n            # Enact heavy force pushing overlapping neighbors away directly proportional to overlap\n            overlap_grad = 2 * wp * overlap\n            grad[:, 2] += np.sum(overlap_grad, axis=1)\n            \n            valid_dist = dist > 1e-12\n            dir_norm = np.zeros_like(diff)\n            dir_norm[valid_dist] = diff[valid_dist] / dist[valid_dist][..., np.newaxis]\n            \n            c_grad = -overlap_grad[..., np.newaxis] * dir_norm\n            grad[:, :2] += np.sum(c_grad, axis=1)\n            \n        # Hard limits boundary constraints enforcement penalty calculation\n        bx1 = np.maximum(0, params[:, 2] - params[:, 0])\n        grad[:, 2] += 2 * wp * bx1\n        grad[:, 0] -= 2 * wp * bx1\n        \n        bx2 = np.maximum(0, params[:, 0] + params[:, 2] - 1.0)\n        grad[:, 2] += 2 * wp * bx2\n        grad[:, 0] += 2 * wp * bx2\n        \n        by1 = np.maximum(0, params[:, 2] - params[:, 1])\n        grad[:, 2] += 2 * wp * by1\n        grad[:, 1] -= 2 * wp * by1\n        \n        by2 = np.maximum(0, params[:, 1] + params[:, 2] - 1.0)\n        grad[:, 2] += 2 * wp * by2\n        grad[:, 1] += 2 * wp * by2\n        \n        # Floor boundaries minimum \n        min_rad = 0.005\n        neg_r = np.maximum(0, min_rad - params[:, 2])\n        grad[:, 2] -= 2 * wp * neg_r\n        \n        # Exponential decreasing decay scale learning phase rate limit factor map parameter down!\n        lr = base_lr * (0.01 ** (step / max(1, steps - 1)))\n        \n        # Applying iterative adam states transition variables momentum array combinations smoothing gradient updates  \n        t = step + 1\n        m = 0.9 * m + 0.1 * grad\n        v = 0.999 * v + 0.001 * (grad ** 2)\n        m_hat = m / (1 - 0.9 ** t)\n        v_hat = v / (1 - 0.999 ** t)\n        \n        params -= lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n        \n        # Iteratively strengthening restrictions gradually tightening overlapping limit gaps limits tolerances bounds values! \n        if step % 500 == 499:\n            wp *= 1.4\n\n    return params[:, :2], params[:, 2]\n\n\ndef make_strictly_valid(centers, radii):\n    \"\"\"\n    Absolute final constraint cleanup safety wrapper ensuring perfectly validated valid radius arrays returns\n    Strictly trims and ensures sizes stay structurally locked internally!\n    \"\"\"\n    centers = np.clip(centers, 0.0, 1.0)\n    \n    # Establish borders distance sizes absolute limiting boundaries mapping\n    b_rad = np.min([\n        centers[:, 0], \n        1.0 - centers[:, 0], \n        centers[:, 1], \n        1.0 - centers[:, 1]\n    ], axis=0)\n    \n    radii = np.minimum(radii, b_rad)\n    radii = np.maximum(0.0, radii)\n    \n    n = len(radii)\n    # Strictly execute non overlapping reduction pairwise loops! \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                margin_dist = max(0.0, dist - 1e-7)\n                if radii[i] + radii[j] > 1e-9:\n                    scale = margin_dist / (radii[i] + radii[j])\n                    scale = min(1.0, scale)\n                    radii[i] *= scale\n                    radii[j] *= scale\n    return radii\n\n\n# Alias retaining structure interface from legacy wrapper if used\ndef compute_max_radii(centers):\n    \"\"\"Compatibility method.\"\"\"\n    radii = np.ones(len(centers)) * 0.01\n    return make_strictly_valid(centers, radii)\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.5450, Type: Experimental)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Adam optimization with geometrical heuristics for circle packing\"\"\"\nimport numpy as np\n\ndef init_seed(n, idx):\n    \"\"\"\n    Seed initial positions strategically: Bias initial placements toward \n    corners and edges, and determine size hierarchies based on center proximity.\n    \"\"\"\n    np.random.seed(idx + 2025)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.zeros(n)\n    \n    if idx % 4 == 0:\n        X[0], Y[0] = 0.5, 0.5\n        X[1:5] = [0.15, 0.85, 0.15, 0.85]\n        Y[1:5] = [0.15, 0.15, 0.85, 0.85]\n    elif idx % 4 == 1:\n        angles = np.linspace(0, 4 * np.pi, n)\n        rad = np.linspace(0, 0.45, n)\n        X = 0.5 + rad * np.cos(angles)\n        Y = 0.5 + rad * np.sin(angles)\n    elif idx % 4 == 2:\n        c1 = min(n, 12)\n        ang = np.linspace(0, 2 * np.pi, c1, endpoint=False)\n        X[0:c1] = 0.5 + 0.4 * np.cos(ang)\n        Y[0:c1] = 0.5 + 0.4 * np.sin(ang)\n        if n > c1:\n            X[c1], Y[c1] = 0.5, 0.5\n            \n    # Break perfect symmetry gently via random perturbation\n    X += np.random.normal(0, 0.02, n)\n    Y += np.random.normal(0, 0.02, n)\n    X = np.clip(X, 0.05, 0.95)\n    Y = np.clip(Y, 0.05, 0.95)\n    \n    # Placement by size heuristic: larger toward the center, smaller in gaps\n    dist_to_center = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n    sorted_idx = np.argsort(dist_to_center) \n    \n    initial_r = np.linspace(0.12, 0.01, n)\n    np.random.shuffle(initial_r[n//2:])\n    R[sorted_idx] = initial_r\n    \n    return X, Y, R\n\ndef force_valid(X, Y, R):\n    \"\"\"\n    Project strictly to feasibility by cleaning out constraints exactly.\n    \"\"\"\n    R = np.clip(R, 1e-8, np.minimum(np.minimum(X, 1 - X), np.minimum(Y, 1 - Y)))\n    n = len(R)\n    \n    for _ in range(100):\n        dx = X[:, None] - X[None, :]\n        dy = Y[:, None] - Y[None, :]\n        dist = np.sqrt(dx**2 + dy**2)\n        np.fill_diagonal(dist, np.inf)\n        \n        if np.max(R[:, None] + R[None, :] - dist) <= 1e-12:\n            break\n            \n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dist[i, j]\n                sum_R = R[i] + R[j]\n                if sum_R > d:\n                    f = d / sum_R if sum_R > 1e-12 else 0.0\n                    R[i] *= f\n                    R[j] *= f\n                    \n    return R\n\ndef construct_packing():\n    n = 26\n    best_sum = -1.0\n    best_c, best_r = None, None\n    iters = 3000\n    lr = 0.02\n    \n    for seed_id in range(16):\n        X, Y, R = init_seed(n, seed_id)\n        m_X, m_Y, m_R = np.zeros(n), np.zeros(n), np.zeros(n)\n        v_X, v_Y, v_R = np.zeros(n), np.zeros(n), np.zeros(n)\n        \n        for t in range(1, iters + 1):\n            prog = t / iters\n            clr = lr * (1 - prog) + 0.001 * prog\n            P = 10.0 * (100000.0 ** prog)\n            \n            # Simulated annealing perturbation injection mapping smoothly out over time\n            if t % 200 == 0 and prog < 0.7:\n                noise = 0.005 * (0.7 - prog)\n                X += np.random.normal(0, noise, n)\n                Y += np.random.normal(0, noise, n)\n                \n            dx = X[:, None] - X[None, :]\n            dy = Y[:, None] - Y[None, :]\n            dist = np.maximum(np.sqrt(dx**2 + dy**2), 1e-12)\n            np.fill_diagonal(dist, np.inf)\n            \n            O_mat = np.maximum(0, R[:, None] + R[None, :] - dist)\n            grad_R = np.full(n, -1.0)\n            grad_R += 2 * P * np.sum(O_mat, axis=1)\n            \n            inv = np.where(dist < np.inf, 1.0 / dist, 0.0)\n            force = 2 * P * O_mat * inv\n            grad_X = np.sum(-force * dx, axis=1)\n            grad_Y = np.sum(-force * dy, axis=1)\n            \n            walls = [\n                (R - X, 1, -1, 0),    \n                (X + R - 1, 1, 1, 0), \n                (R - Y, 1, 0, -1),    \n                (Y + R - 1, 1, 0, 1)  \n            ]\n            \n            for viol, gR_s, gX_s, gY_s in walls:\n                w = np.maximum(0, viol)\n                grad_R += 2 * P * w * gR_s\n                grad_X += 2 * P * w * gX_s\n                grad_Y += 2 * P * w * gY_s\n                \n            for val, grad, m, v in zip([X, Y, R], \n                                       [grad_X, grad_Y, grad_R], \n                                       [m_X, m_Y, m_R], \n                                       [v_X, v_Y, v_R]):\n                m[:] = 0.9 * m + 0.1 * grad\n                v[:] = 0.999 * v + 0.001 * (grad**2)\n                m_h = m / (1 - 0.9**t)\n                v_h = v / (1 - 0.999**t)\n                val -= clr * m_h / (np.sqrt(v_h) + 1e-8)\n                \n            X = np.clip(X, 0.001, 0.999)\n            Y = np.clip(Y, 0.001, 0.999)\n            R = np.clip(R, 0.001, 1.0)\n            \n        final_R = force_valid(X, Y, R)\n        valid_sum = np.sum(final_R)\n        \n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = np.column_stack((X, Y))\n            best_r = np.copy(final_R)\n            \n    return best_c, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative gradient-based optimizer combining physical analogies for packing N=26 unequal circles\"\"\"\nimport numpy as np\n\n\ndef init_seed(n, idx):\n    \"\"\"\n    Seed initial layout structures logically exploring geometries:\n    Corners, edges and symmetry combinations bias the structural configuration seeds\n    before initiating physics simulations naturally mapping.\n    \"\"\"\n    np.random.seed(idx + 1024)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.random.uniform(0.01, 0.05, n)\n\n    cat = idx % 4\n    if cat == 0:\n        # Dense concentrically biased arrangement \n        X[0], Y[0] = 0.5, 0.5\n        angles = np.linspace(0, 2 * np.pi, 9)[:-1]\n        X[1:9] = 0.5 + 0.2 * np.cos(angles)\n        Y[1:9] = 0.5 + 0.2 * np.sin(angles)\n        angles2 = np.linspace(0, 2 * np.pi, 18)[:-1]\n        X[9:26] = 0.5 + 0.4 * np.cos(angles2)\n        Y[9:26] = 0.5 + 0.4 * np.sin(angles2)\n    elif cat == 1:\n        # Symmetry-inducing sub-hubs targeting broader spread patterns\n        cents = [[0.5, 0.5], [0.2, 0.2], [0.8, 0.8], [0.2, 0.8], [0.8, 0.2]]\n        for i, c in enumerate(cents):\n            X[i], Y[i] = c\n    elif cat == 2:\n        # Rotational spatial sweeps\n        angles = np.linspace(0, 5 * np.pi, n)\n        rads = np.linspace(0.0, 0.45, n)\n        X = 0.5 + rads * np.cos(angles)\n        Y = 0.5 + rads * np.sin(angles)\n    elif cat == 3:\n        # Aggregated perimeter biases forcing complex natural internal resolutions\n        X[:13] = np.linspace(0.1, 0.9, 13)\n        Y[:13] = 0.1 + np.random.normal(0, 0.02, 13)\n        X[13:] = np.linspace(0.1, 0.9, 13)\n        Y[13:] = 0.9 + np.random.normal(0, 0.02, 13)\n\n    # Spatial scaling size variations naturally positioning large towards the centers limits\n    dist_to_center = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n    order = np.argsort(dist_to_center)\n    sizes = np.linspace(0.07, 0.01, n)\n    np.random.shuffle(sizes[n//2:])\n    R[order] = sizes\n\n    X += np.random.normal(0, 0.01, n)\n    Y += np.random.normal(0, 0.01, n)\n    X = np.clip(X, 0.1, 0.9)\n    Y = np.clip(Y, 0.1, 0.9)\n\n    return np.column_stack([X, Y, R])\n\n\ndef make_strictly_valid(params):\n    \"\"\"\n    Cleans spatial artifacts strictly mapping values definitively against border\n    constraints perfectly sealing boundaries correctly returning sizes mappings!\n    \"\"\"\n    centers = np.clip(params[:, :2], 0.0, 1.0)\n    radii = params[:, 2].copy()\n\n    # Apply rigid wall bounds limitations iteratively checking limits mapped edges correctly\n    b_rad = np.min([\n        centers[:, 0], 1.0 - centers[:, 0],\n        centers[:, 1], 1.0 - centers[:, 1]\n    ], axis=0)\n    \n    radii = np.clip(radii, 1e-8, b_rad)\n    n = len(radii)\n\n    # Interconnected overlaps strictly trimming iteratively symmetrically smoothly mapped sizes constraints variables loops precisely scaling values \n    for _ in range(150):\n        max_overlap = 0.0\n        diff = centers[:, None, :] - centers[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        if np.max(radii[:, None] + radii[None, :] - dist) <= 1e-12:\n            break\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dist[i, j]\n                overlap = radii[i] + radii[j] - d\n                if overlap > 1e-12:\n                    if overlap > max_overlap:\n                        max_overlap = overlap\n                    \n                    # Proportional mapping distribution constraint sizes shrinks strictly limiting ratios precisely limiting\n                    sum_r = max(1e-10, radii[i] + radii[j])\n                    f = max(0.0, d - 1e-11) / sum_r\n                    radii[i] *= f\n                    radii[j] *= f\n\n        if max_overlap <= 1e-12:\n            break\n\n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Construct optimal combinations iterating simulated configurations enforcing mapping logic\n    strictly optimizing dynamically overlapping gradient spaces. Maximizes accumulated final true sum limits radii naturally!\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_seeds = 16\n    iters = 4500\n    base_lr = 0.02\n\n    # Searching space optimization dynamics mapping globally traversing variables constraints seamlessly integrating arrays correctly mathematically resolving values\n    for seed_id in range(num_seeds):\n        params = init_seed(n, seed_id)\n        \n        m = np.zeros_like(params)\n        v = np.zeros_like(params)\n\n        for step in range(1, iters + 1):\n            prog = step / iters\n            clr = base_lr * (1.0 - prog)**2 + 0.001\n            P = 10.0 * (5000.0 ** prog)\n\n            # Simulated structural cooling random steps injections jumping escaping barriers structurally resolving correctly scaling arrays properly mapped limits \n            if step % 300 == 0 and prog < 0.7:\n                params[:, :2] += np.random.normal(0, 0.005, (n, 2))\n                params[:, :2] = np.clip(params[:, :2], 0.01, 0.99)\n\n            grad = np.zeros_like(params)\n            \n            # Radii size expansion pull directly uniformly uniformly maximizing sum limits precisely natively evaluating forces boundaries accurately!\n            grad[:, 2] = -1.0\n\n            C = params[:, :2]\n            R = params[:, 2]\n\n            diff = C[:, None, :] - C[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n\n            overlap = np.maximum(0, R[:, None] + R[None, :] - dist)\n            if np.any(overlap > 0):\n                force = 2 * P * overlap\n                grad[:, 2] += np.sum(force, axis=1)\n\n                valid_mask = dist > 1e-12\n                dir_norm = np.zeros_like(diff)\n                dir_norm[valid_mask] = diff[valid_mask] / dist[valid_mask][..., np.newaxis]\n\n                grad[:, :2] -= np.sum(force[..., np.newaxis] * dir_norm, axis=1)\n\n            # Edge mappings penalties checking mapping uniformly boundaries enforcing correct mathematical resolutions strictly evaluating\n            w_L = np.maximum(0, R - C[:, 0])\n            grad[:, 2] += 2 * P * w_L\n            grad[:, 0] -= 2 * P * w_L\n\n            w_R = np.maximum(0, C[:, 0] + R - 1.0)\n            grad[:, 2] += 2 * P * w_R\n            grad[:, 0] += 2 * P * w_R\n\n            w_B = np.maximum(0, R - C[:, 1])\n            grad[:, 2] += 2 * P * w_B\n            grad[:, 1] -= 2 * P * w_B\n\n            w_T = np.maximum(0, C[:, 1] + R - 1.0)\n            grad[:, 2] += 2 * P * w_T\n            grad[:, 1] += 2 * P * w_T\n\n            # Execute variables Adam updating state scaling moments seamlessly handling limits updating arrays gradients\n            m = 0.9 * m + 0.1 * grad\n            v = 0.999 * v + 0.001 * (grad ** 2)\n            m_h = m / (1 - 0.9 ** step)\n            v_h = v / (1 - 0.999 ** step)\n\n            params -= clr * m_h / (np.sqrt(v_h) + 1e-8)\n            params[:, :2] = np.clip(params[:, :2], 0.001, 0.999)\n            params[:, 2] = np.clip(params[:, 2], 0.001, 1.0)\n\n        # Complete resolving clean valid limitations coordinates outputs extracting correctly cleanly mapped sizes\n        c_final, r_final = make_strictly_valid(params)\n        \n        valid_sum = np.sum(r_final)\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = c_final.copy()\n            best_r = r_final.copy()\n\n    return best_c, best_r, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Retained purely strictly maintaining complete interfaces alias seamlessly matching environments limitations configurations logic! \n    In practically circumvented logic customized returned outputs accurately structured dynamically mapping coordinates correctly outputs.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n) * 0.5\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / max(1e-12, radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    return radii\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["\"\"\"Iterative Adam optimization mapping physics configurations constraints seamlessly for exactly 26 unequal circles optimally\"\"\"\nimport numpy as np\n\n\ndef init_seed(n, idx):\n    \"\"\"\n    Generate systematically robust structurally distributed layout seeds.\n    Employs various geometry heuristics effectively pushing symmetry overlaps explicitly.\n    \"\"\"\n    np.random.seed(idx + 1024)\n    X = np.random.uniform(0.1, 0.9, n)\n    Y = np.random.uniform(0.1, 0.9, n)\n    R = np.random.uniform(0.01, 0.05, n)\n\n    cat = idx % 5\n    if cat == 0:\n        # Concentrically biased ring arrangement specifically fitting exactly\n        X[0], Y[0] = 0.5, 0.5\n        angles1 = np.linspace(0, 2 * np.pi, 9)[:-1]\n        X[1:9] = 0.5 + 0.22 * np.cos(angles1)\n        Y[1:9] = 0.5 + 0.22 * np.sin(angles1)\n        angles2 = np.linspace(0, 2 * np.pi, 18)[:-1]\n        X[9:] = 0.5 + 0.44 * np.cos(angles2)\n        Y[9:] = 0.5 + 0.44 * np.sin(angles2)\n    elif cat == 1:\n        # Corner-anchored configurations inducing complex broad boundaries structures precisely\n        cents = [[0.5, 0.5], [0.15, 0.15], [0.85, 0.85], [0.15, 0.85], [0.85, 0.15]]\n        for i, c in enumerate(cents):\n            X[i], Y[i] = c\n    elif cat == 2:\n        # Swirling layouts natively avoiding straight-edge symmetry deadlocks precisely\n        angles = np.linspace(0, 5 * np.pi, n)\n        rads = np.linspace(0.0, 0.42, n)\n        X = 0.5 + rads * np.cos(angles)\n        Y = 0.5 + rads * np.sin(angles)\n    elif cat == 3:\n        # Pseudo-hexagonal interleaved spacing efficiently matching density safely\n        rows = [4, 5, 4, 5, 4, 4]\n        i = 0\n        for r, cnt in enumerate(rows):\n            for c in range(cnt):\n                if i < n:\n                    offset = 0.05 if r % 2 else 0\n                    scale = 0.64 / max(1, cnt - 1)\n                    X[i] = 0.18 + c * scale + offset\n                    Y[i] = 0.18 + r * 0.128\n                    i += 1\n    elif cat == 4:\n        # Explicit horizontal mapping tightly aligned safely\n        X[:12] = np.linspace(0.1, 0.9, 12)\n        Y[:12] = 0.15\n        X[12:24] = np.linspace(0.1, 0.9, 12)\n        Y[12:24] = 0.85\n        X[24], Y[24] = 0.5, 0.5\n        X[25], Y[25] = 0.2, 0.5\n\n    # Break absolute initial mapping symmetrically to safely navigate gradients exactly!\n    X += np.random.normal(0, 0.005, n)\n    Y += np.random.normal(0, 0.005, n)\n    X = np.clip(X, 0.05, 0.95)\n    Y = np.clip(Y, 0.05, 0.95)\n    \n    # Establish structurally sound variable size distributions precisely efficiently!\n    if idx % 2 == 0:\n        dists = np.sqrt((X - 0.5)**2 + (Y - 0.5)**2)\n    else:\n        # Re-target largest boundaries cleanly effectively strictly into mapping perfectly \n        dists = np.minimum.reduce([\n            np.sqrt(X**2 + Y**2),\n            np.sqrt((X - 1)**2 + Y**2),\n            np.sqrt(X**2 + (Y - 1)**2),\n            np.sqrt((X - 1)**2 + (Y - 1)**2)\n        ])\n    \n    order = np.argsort(dists)\n    sizes = np.linspace(0.09, 0.015, n)\n    np.random.shuffle(sizes[n//3 : 2*n//3])\n    R[order] = sizes\n\n    return np.column_stack([X, Y, R])\n\n\ndef make_strictly_valid(params):\n    \"\"\"\n    Applies strict geometrical intersection verifications dynamically maintaining validity flawlessly!\n    Safely enforces boundary constraints iteratively trimming artifacts precisely efficiently strictly correctly cleanly!\n    \"\"\"\n    centers = np.clip(params[:, :2], 0.0, 1.0)\n    radii = params[:, 2].copy()\n\n    # Apply rigid containment correctly mapped smoothly limits natively cleanly practically\n    b_rad = np.min([\n        centers[:, 0], 1.0 - centers[:, 0],\n        centers[:, 1], 1.0 - centers[:, 1]\n    ], axis=0)\n    \n    radii = np.clip(radii, 1e-9, b_rad)\n    n = len(radii)\n\n    # Precisely clean pairwise constraints directly logically reliably successfully!\n    for _ in range(150):\n        diff = centers[:, None, :] - centers[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        if np.max(radii[:, None] + radii[None, :] - dist) <= 1e-12:\n            break\n\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = dist[i, j]\n                overlap = radii[i] + radii[j] - d\n                if overlap > 1e-12:\n                    if overlap > max_ov:\n                        max_ov = overlap\n                    \n                    sum_r = radii[i] + radii[j]\n                    if sum_r > 1e-10:\n                        factor = max(0.0, d - 1e-11) / sum_r\n                        radii[i] *= factor\n                        radii[j] *= factor\n\n        if max_ov <= 1e-12:\n            break\n\n    return centers, radii\n\n\ndef construct_packing():\n    \"\"\"\n    Search configuration layouts correctly successfully logically resolving mathematical forces comprehensively effectively smoothly dynamically! \n    Directly maximizes dynamically correctly successfully securely seamlessly securely strictly precisely!\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    num_seeds = 16\n    iters = 5200\n    base_lr = 0.015\n\n    for seed_id in range(num_seeds):\n        params = init_seed(n, seed_id)\n        \n        m = np.zeros_like(params)\n        v = np.zeros_like(params)\n\n        for step in range(1, iters + 1):\n            prog = step / iters\n            # Precise exponential descent logically tightening cleanly seamlessly successfully dependably cleanly accurately efficiently!\n            clr = base_lr * (0.01 ** prog) + 1e-5\n            P = 10.0 * (4000.0 ** prog)\n\n            # Shatter symmetrical plateaus dependably natively mapped flawlessly robustly\n            if step % 400 == 0 and prog < 0.65:\n                params[:, :2] += np.random.normal(0, 0.005, (n, 2))\n                params[:, :2] = np.clip(params[:, :2], 0.01, 0.99)\n\n            grad = np.zeros_like(params)\n            \n            # Static expansion strictly properly continuously practically cleanly reliably gracefully exactly accurately mapped\n            grad[:, 2] = -1.0\n\n            C = params[:, :2]\n            R = params[:, 2]\n\n            diff = C[:, None, :] - C[None, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, np.inf)\n\n            overlap = np.maximum(0, R[:, None] + R[None, :] - dist)\n            if np.any(overlap > 0):\n                force = 2 * P * overlap\n                grad[:, 2] += np.sum(force, axis=1)\n\n                valid_mask = dist > 1e-12\n                dir_norm = np.zeros_like(diff)\n                dir_norm[valid_mask] = diff[valid_mask] / dist[valid_mask][..., np.newaxis]\n\n                # Propagates cleanly successfully completely symmetrically seamlessly\n                grad[:, :2] -= np.sum(force[..., np.newaxis] * dir_norm, axis=1)\n\n            # Walls safely mapping flawlessly comprehensively practically seamlessly dependably gracefully correctly seamlessly!\n            w_L = np.maximum(0, R - C[:, 0])\n            grad[:, 2] += 2 * P * w_L\n            grad[:, 0] -= 2 * P * w_L\n\n            w_R = np.maximum(0, C[:, 0] + R - 1.0)\n            grad[:, 2] += 2 * P * w_R\n            grad[:, 0] += 2 * P * w_R\n\n            w_B = np.maximum(0, R - C[:, 1])\n            grad[:, 2] += 2 * P * w_B\n            grad[:, 1] -= 2 * P * w_B\n\n            w_T = np.maximum(0, C[:, 1] + R - 1.0)\n            grad[:, 2] += 2 * P * w_T\n            grad[:, 1] += 2 * P * w_T\n            \n            w_min = np.maximum(0, 0.001 - R)\n            grad[:, 2] -= 2 * P * w_min\n\n            # Adam strictly consistently functionally gracefully dependably efficiently exactly safely perfectly completely\n            m = 0.9 * m + 0.1 * grad\n            v = 0.999 * v + 0.001 * (grad ** 2)\n            m_h = m / (1 - 0.9 ** step)\n            v_h = v / (1 - 0.999 ** step)\n\n            params -= clr * m_h / (np.sqrt(v_h) + 1e-8)\n            params[:, :2] = np.clip(params[:, :2], 0.0001, 0.9999)\n            params[:, 2] = np.clip(params[:, 2], 0.0001, 1.0)\n\n        # Confirm strictly exact values securely accurately dependably fully flawlessly strictly correctly securely!\n        c_final, r_final = make_strictly_valid(params)\n        \n        valid_sum = np.sum(r_final)\n        if valid_sum > best_sum:\n            best_sum = valid_sum\n            best_c = c_final.copy()\n            best_r = r_final.copy()\n\n    return best_c, best_r, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"Fallback mapped correctly directly accurately practically seamlessly successfully practically practically functionally precisely\"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n) * 0.5\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = dist / max(1e-12, radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n    return radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)"]}}, "artifacts_json": "{\"execution_time\": \"15.68s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.625009/2.635 = 0.9962\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.6% of target value\", \"radius_stats\": \"Min: 0.054752, Max: 0.135531, Avg: 0.100962\"}", "artifact_dir": null, "embedding": null}