{"id": "2b21aa2e-6f0d-4c6e-a984-ab6bb95309d9", "code": "# Constructor-based circle packing for n=26 circles using parallel Adam optimizer\nimport numpy as np\n\n\ndef initialize_batch(B, N):\n    \"\"\"Generate diverse seeds for batch optimization.\"\"\"\n    np.random.seed(88)  # Fixed robust seed\n    C = np.zeros((B, N, 2))\n    R = np.full((B, N), 0.05)\n\n    for b in range(B):\n        ptype = b % 5\n        if ptype == 0:\n            C[b] = np.random.rand(N, 2) * 0.9 + 0.05\n        elif ptype == 1:\n            C[b] = np.clip(np.random.randn(N, 2) * 0.2 + 0.5, 0.05, 0.95)\n        elif ptype == 2:\n            # 1 - 8 - 17 Rings structure\n            pts = [[0.5, 0.5]]\n            for i in range(8):\n                a = 2 * np.pi * i / 8\n                pts.append([0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)])\n            for i in range(17):\n                a = 2 * np.pi * i / 17\n                pts.append([0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)])\n            jitter = (np.random.rand(N, 2) - 0.5) * 0.03\n            C[b] = np.clip(np.array(pts) + jitter, 0.05, 0.95)\n        elif ptype == 3:\n            # Grid structure dynamically perturbed\n            X, Y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            pts = np.c_[X.ravel(), Y.ravel()].tolist()\n            # Adding one central piece to make 26 total items\n            pts.append([0.5 + np.random.rand() * 0.01, 0.5 + np.random.rand() * 0.01])\n            jitter = (np.random.rand(N, 2) - 0.5) * 0.04\n            C[b] = np.clip(np.array(pts) + jitter, 0.05, 0.95)\n        else:\n            # Hollow center focus generating heavy density variations seamlessly\n            pts = []\n            while len(pts) < N:\n                p = np.random.rand(2) * 0.9 + 0.05\n                dist = np.linalg.norm(p - 0.5)\n                if dist > 0.35 or dist < 0.1:\n                    pts.append(p)\n            C[b] = np.array(pts)\n\n    return C, R\n\n\ndef get_gradients(C, R, P):\n    \"\"\"Compute vectorized penalty-based optimization gradients.\"\"\"\n    grad_C = np.zeros_like(C)\n    grad_R = np.full_like(R, -1.0)  # Core gradient pushing sums strictly upwards\n\n    # Border boundary physics violations resolving elegantly\n    err_x0 = R - C[..., 0]\n    mask_x0 = err_x0 > 0\n    grad_R[mask_x0] += P * 2 * err_x0[mask_x0]\n    grad_C[..., 0][mask_x0] -= P * 2 * err_x0[mask_x0]\n\n    err_x1 = R - (1.0 - C[..., 0])\n    mask_x1 = err_x1 > 0\n    grad_R[mask_x1] += P * 2 * err_x1[mask_x1]\n    grad_C[..., 0][mask_x1] += P * 2 * err_x1[mask_x1]\n\n    err_y0 = R - C[..., 1]\n    mask_y0 = err_y0 > 0\n    grad_R[mask_y0] += P * 2 * err_y0[mask_y0]\n    grad_C[..., 1][mask_y0] -= P * 2 * err_y0[mask_y0]\n\n    err_y1 = R - (1.0 - C[..., 1])\n    mask_y1 = err_y1 > 0\n    grad_R[mask_y1] += P * 2 * err_y1[mask_y1]\n    grad_C[..., 1][mask_y1] += P * 2 * err_y1[mask_y1]\n\n    # Interstitial geometric overlap penalty and distancing logic \n    diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n    dist_sq = np.sum(diff ** 2, axis=-1)\n\n    I = np.eye(C.shape[1], dtype=bool)[np.newaxis, :, :]\n    dist_sq = np.where(I, 1.0, dist_sq)\n    dist = np.sqrt(dist_sq)\n\n    R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n    err_ov = R_sum - dist\n    err_ov = np.where(I, -1.0, err_ov)\n\n    mask_ov = err_ov > 0\n\n    grad_R += P * np.sum(np.where(mask_ov, 2 * err_ov, 0.0), axis=2)\n\n    weight = np.where(mask_ov, -2 * err_ov / dist, 0.0)\n    grad_C[..., 0] += P * np.sum(weight * diff[..., 0], axis=2)\n    grad_C[..., 1] += P * np.sum(weight * diff[..., 1], axis=2)\n\n    return grad_C, grad_R\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs optimally dense circle packing via simultaneous batch runs utilizing \n    decayed penalty models bridging smoothly into hard mathematical solvers strictly.\n    \"\"\"\n    B = 80\n    N = 26\n\n    C, R = initialize_batch(B, N)\n\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n\n    T = 8500\n    P_start = 0.5\n    P_end = 25000.0\n    lr_start = 0.02\n    lr_end = 0.0002\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n\n    for step in range(1, T + 1):\n        progress = step / T\n        lr = lr_start * (lr_end / lr_start) ** progress\n        P = P_start * (P_end / P_start) ** progress\n\n        R_eff = np.maximum(R, 1e-6)\n\n        grad_C, grad_R = get_gradients(C, R_eff, P)\n\n        # Gradients strictly bounded neutralizing possible float instabilities naturally\n        grad_C = np.clip(grad_C, -50.0, 50.0)\n        grad_R = np.clip(grad_R, -50.0, 50.0)\n\n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * grad_C ** 2\n        m_C_hat = m_C / (1 - beta1 ** step)\n        v_C_hat = v_C / (1 - beta2 ** step)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n\n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * grad_R ** 2\n        m_R_hat = m_R / (1 - beta1 ** step)\n        v_R_hat = v_R / (1 - beta2 ** step)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n\n    best_score = -1.0\n    best_C = None\n    best_R = None\n\n    for b in range(B):\n        c_b = C[b].copy()\n        r_b = R[b].copy()\n\n        # Mathematically guaranteeing legal configuration topologies inherently\n        r_b = np.minimum(r_b, 0.499)\n        r_b = np.maximum(r_b, 1e-6)\n        c_b = np.clip(c_b, r_b[:, None], 1.0 - r_b[:, None])\n\n        # Absolute overlapping constraint shrink-wrapping eliminating deadlocks seamlessly \n        for _ in range(2):\n            diff = c_b[:, None, :] - c_b[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, np.inf)\n\n            S = r_b[:, None] + r_b[None, :]\n            violation_ratio = S / (D + 1e-12)\n            max_ratio = np.max(violation_ratio, axis=1)\n\n            r_b = r_b / np.maximum(1.0, max_ratio)\n\n        # Correcting isolated outer border limits uniformly independent\n        b_slack = np.min(np.hstack([c_b, 1.0 - c_b]), axis=1)\n        r_b = np.minimum(r_b, b_slack)\n\n        r_b *= 0.99999\n\n        # Continuous perfect local maximizing phase utilizing geometry strictly dynamically\n        for _ in range(120):\n            diff = c_b[:, None, :] - c_b[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, np.inf)\n            S = D - (r_b[:, None] + r_b[None, :])\n\n            B0 = c_b - r_b[:, None]\n            B1 = 1.0 - c_b - r_b[:, None]\n            bound_slack = np.min(np.hstack([B0, B1]), axis=1)\n\n            min_pair_slack = np.min(S, axis=1)\n\n            max_inc = np.minimum(bound_slack, min_pair_slack / 2.0)\n            max_inc = np.maximum(max_inc, 0.0)\n\n            r_b += max_inc * 0.98\n\n        r_b *= 0.9999999\n\n        score = np.sum(r_b)\n        if score > best_score:\n            best_score = score\n            best_C = c_b\n            best_R = r_b\n\n    return best_C, best_R, best_score\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor strictly\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize geometrically output rendering for deep geometric checks.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")", "changes_description": null, "language": "python", "parent_id": "fd24df28-7415-4000-95f0-b67f00c1988f", "generation": 2, "timestamp": 1772005871.957056, "iteration_found": 9, "metrics": {"validity": 1.0, "sum_radii": 2.624661150554694, "target_ratio": 0.996076337971421, "combined_score": 0.996076337971421, "radius_variance": 0.006092276251092446, "spatial_spread": 0.18236634420447806, "eval_time": 40.94198036193848}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.5471047599910426, "target_ratio": 0.9666431726721225, "combined_score": 0.9666431726721225, "radius_variance": 0.01306528574172565, "spatial_spread": 0.18006655409429795, "eval_time": 3.603672504425049}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9666\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9666\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n3.60s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.547105/2.635 = 0.9666\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 96.7% of target value\n```\n\n### radius_stats\n```\nMin: 0.061733, Max: 0.161809, Avg: 0.097966\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5471, target_ratio: 0.9666, combined_score: 0.9666, radius_variance: 0.0131, spatial_spread: 0.1801, eval_time: 3.6037\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9666)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles using Interior Point method\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using an Adam-based Log-Barrier Interior Point Method to maximize\n    the sum of the radii, exploring multiple random initializations.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    best_sum = -1.0\n    best_C = None\n    best_R = None\n    \n    # We do a few different attempts with random structures to find optimal local minima\n    for attempt in range(5):\n        # Slightly alter the initialization for each attempt\n        np.random.seed(42 + attempt * 10)\n        \n        # Initialize centers strategically: Bias toward corners, edges, and central points\n        centers = []\n        if attempt == 0:\n            seeds = [\n                [0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9], \n                [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],     \n                [0.5, 0.5], \n                [0.3, 0.3], [0.3, 0.7], [0.7, 0.3], [0.7, 0.7]  \n            ]\n        elif attempt == 1:\n            seeds = [[0.5, 0.5]]\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                seeds.append([0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)])\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                seeds.append([0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)])\n        else:\n            seeds = []\n            \n        # Add random microscopic perturbations to break symmetries gracefully\n        for s in seeds:\n            centers.append(np.array(s) + (np.random.rand(2) - 0.5) * 0.02)\n            \n        attempts_random = 0\n        while len(centers) < n and attempts_random < 1000:\n            pt = np.random.rand(2) * 0.8 + 0.1\n            if not centers:\n                centers.append(pt)\n                continue\n            dists = [np.linalg.norm(pt - c) for c in centers]\n            if min(dists) > 0.06:\n                centers.append(pt)\n            attempts_random += 1\n            \n        # Complete placement by aggressively placing without care if it was tightly packed\n        while len(centers) < n:\n            pt = np.random.rand(2) * 0.9 + 0.05\n            dists = [np.linalg.norm(pt - c) for c in centers]\n            if min(dists) > 0.02:\n                centers.append(pt)\n                \n        C = np.array(centers)\n        R = np.ones(n) * 0.005\n        \n        # Optimizer: Custom Adam with gradient clipping and line-search barrier constraints\n        lr = 0.005\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n        m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n\n        T = 2500\n        mu_start = 0.05\n        mu_end = 1e-7\n        # Logarithmic decay scheduler\n        mu_decay = (mu_end / mu_start) ** (1.0 / T)\n        mu = mu_start\n\n        for step_idx in range(1, T + 1):\n            diff = C[:, None, :] - C[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, 1.0)\n            \n            R_sum = R[:, None] + R[None, :]\n            S = D - R_sum\n            np.fill_diagonal(S, 1.0)\n            \n            B0 = C - R[:, None]\n            B1 = 1.0 - C - R[:, None]\n            \n            # Formulating objective gradients under rigorous log-barriers\n            S_inv = 1.0 / S\n            np.fill_diagonal(S_inv, 0.0)\n            \n            grad_R = 1.0 + mu * (\n                np.sum(-S_inv, axis=1) - \n                1.0 / B0[:, 0] - 1.0 / B1[:, 0] - \n                1.0 / B0[:, 1] - 1.0 / B1[:, 1]\n            )\n            \n            D_inv = 1.0 / D\n            np.fill_diagonal(D_inv, 0.0)\n            \n            weight = S_inv * D_inv\n            grad_C = np.zeros_like(C)\n            grad_C[:, 0] = mu * (\n                np.sum(weight * diff[..., 0], axis=1) + \n                1.0 / B0[:, 0] - 1.0 / B1[:, 0]\n            )\n            grad_C[:, 1] = mu * (\n                np.sum(weight * diff[..., 1], axis=1) + \n                1.0 / B0[:, 1] - 1.0 / B1[:, 1]\n            )\n            \n            # Momentum equations (Adam Standard Formulas)\n            m_R = beta1 * m_R + (1 - beta1) * grad_R\n            v_R = beta2 * v_R + (1 - beta2) * grad_R**2\n            m_hat_R = m_R / (1 - beta1**step_idx)\n            v_hat_R = v_R / (1 - beta2**step_idx)\n            dR = lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n            \n            m_C = beta1 * m_C + (1 - beta1) * grad_C\n            v_C = beta2 * v_C + (1 - beta2) * grad_C**2\n            m_hat_C = m_C / (1 - beta1**step_idx)\n            v_hat_C = v_C / (1 - beta2**step_idx)\n            dC = lr * m_hat_C / (np.sqrt(v_hat_C) + eps)\n            \n            # Magnitude clipping dynamically secures boundary non-violating stability\n            max_dR = np.max(np.abs(dR))\n            if max_dR > 0.01:\n                dR *= 0.01 / max_dR\n            max_dC = np.max(np.abs(dC))\n            if max_dC > 0.01:\n                dC *= 0.01 / max_dC\n                \n            step_size = 1.0\n            \n            # Dynamic Step Line Search ensuring no circles overlap or fall off valid boxes strictly\n            for _ in range(12):\n                new_C = C + step_size * dC\n                new_R = R + step_size * dR\n                \n                # Asserting constraints within floating barrier safety gaps\n                if np.any(new_R <= 1e-6):\n                    step_size *= 0.5\n                    continue\n                    \n                new_B0 = new_C - new_R[:, None]\n                new_B1 = 1.0 - new_C - new_R[:, None]\n                if np.any(new_B0 <= 1e-6) or np.any(new_B1 <= 1e-6):\n                    step_size *= 0.5\n                    continue\n                    \n                diff_new = new_C[:, None, :] - new_C[None, :, :]\n                D_new = np.linalg.norm(diff_new, axis=-1)\n                np.fill_diagonal(D_new, 1.0)\n                S_new = D_new - (new_R[:, None] + new_R[None, :])\n                np.fill_diagonal(S_new, 1.0)\n                \n                if np.any(S_new <= 1e-6):\n                    step_size *= 0.5\n                    continue\n                    \n                # The step remains physically stable. Proceed.\n                C = new_C\n                R = new_R\n                break\n                \n            mu *= mu_decay\n            \n        # Simulated-annealing Phase: Perfect filling with geometric limits.\n        # Once spatial centers settle down, monotonically scale all radiuses independently tight.\n        R_expanded = R.copy()\n        for _ in range(80):\n            diff = C[:, None, :] - C[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, np.inf)\n            S = D - (R_expanded[:, None] + R_expanded[None, :])\n            \n            B0 = C - R_expanded[:, None]\n            B1 = 1.0 - C - R_expanded[:, None]\n            bound_slack = np.min(np.hstack([B0, B1]), axis=1)\n            \n            min_pair_slack = np.min(S, axis=1)\n            \n            max_inc = np.minimum(bound_slack, min_pair_slack / 2.0)\n            max_inc = np.maximum(max_inc, 0.0)\n            \n            R_expanded += max_inc * 0.95\n            \n        # Float protection\n        R_expanded *= 0.9999999\n        s = np.sum(R_expanded)\n        \n        # Maintain overall champion\n        if s > best_sum:\n            best_sum = s\n            best_C = C\n            best_R = R_expanded\n            \n    return best_C, best_R, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5471), Performs well on target_ratio (0.9666), Performs well on combined_score (0.9666), Performs well on radius_variance (0.0131), Performs well on spatial_spread (0.1801), Performs well on eval_time (3.6037)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles using Interior Point method\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using an Adam-based Log-Barrier Interior Point Method to maximize\n    the sum of the radii, exploring multiple random initializations.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    \n    best_sum = -1.0\n    best_C = None\n    best_R = None\n    \n    # We do a few different attempts with random structures to find optimal local minima\n    for attempt in range(5):\n        # Slightly alter the initialization for each attempt\n        np.random.seed(42 + attempt * 10)\n        \n        # Initialize centers strategically: Bias toward corners, edges, and central points\n        centers = []\n        if attempt == 0:\n            seeds = [\n                [0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9], \n                [0.5, 0.1], [0.5, 0.9], [0.1, 0.5], [0.9, 0.5],     \n                [0.5, 0.5], \n                [0.3, 0.3], [0.3, 0.7], [0.7, 0.3], [0.7, 0.7]  \n            ]\n        elif attempt == 1:\n            seeds = [[0.5, 0.5]]\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                seeds.append([0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)])\n            for i in range(12):\n                angle = 2 * np.pi * i / 12\n                seeds.append([0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)])\n        else:\n            seeds = []\n            \n        # Add random microscopic perturbations to break symmetries gracefully\n        for s in seeds:\n            centers.append(np.array(s) + (np.random.rand(2) - 0.5) * 0.02)\n            \n        attempts_random = 0\n        while len(centers) < n and attempts_random < 1000:\n            pt = np.random.rand(2) * 0.8 + 0.1\n            if not centers:\n                centers.append(pt)\n                continue\n            dists = [np.linalg.norm(pt - c) for c in centers]\n            if min(dists) > 0.06:\n                centers.append(pt)\n            attempts_random += 1\n            \n        # Complete placement by aggressively placing without care if it was tightly packed\n        while len(centers) < n:\n            pt = np.random.rand(2) * 0.9 + 0.05\n            dists = [np.linalg.norm(pt - c) for c in centers]\n            if min(dists) > 0.02:\n                centers.append(pt)\n                \n        C = np.array(centers)\n        R = np.ones(n) * 0.005\n        \n        # Optimizer: Custom Adam with gradient clipping and line-search barrier constraints\n        lr = 0.005\n        beta1, beta2 = 0.9, 0.999\n        eps = 1e-8\n        m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n        m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n\n        T = 2500\n        mu_start = 0.05\n        mu_end = 1e-7\n        # Logarithmic decay scheduler\n        mu_decay = (mu_end / mu_start) ** (1.0 / T)\n        mu = mu_start\n\n        for step_idx in range(1, T + 1):\n            diff = C[:, None, :] - C[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, 1.0)\n            \n            R_sum = R[:, None] + R[None, :]\n            S = D - R_sum\n            np.fill_diagonal(S, 1.0)\n            \n            B0 = C - R[:, None]\n            B1 = 1.0 - C - R[:, None]\n            \n            # Formulating objective gradients under rigorous log-barriers\n            S_inv = 1.0 / S\n            np.fill_diagonal(S_inv, 0.0)\n            \n            grad_R = 1.0 + mu * (\n                np.sum(-S_inv, axis=1) - \n                1.0 / B0[:, 0] - 1.0 / B1[:, 0] - \n                1.0 / B0[:, 1] - 1.0 / B1[:, 1]\n            )\n            \n            D_inv = 1.0 / D\n            np.fill_diagonal(D_inv, 0.0)\n            \n            weight = S_inv * D_inv\n            grad_C = np.zeros_like(C)\n            grad_C[:, 0] = mu * (\n                np.sum(weight * diff[..., 0], axis=1) + \n                1.0 / B0[:, 0] - 1.0 / B1[:, 0]\n            )\n            grad_C[:, 1] = mu * (\n                np.sum(weight * diff[..., 1], axis=1) + \n                1.0 / B0[:, 1] - 1.0 / B1[:, 1]\n            )\n            \n            # Momentum equations (Adam Standard Formulas)\n            m_R = beta1 * m_R + (1 - beta1) * grad_R\n            v_R = beta2 * v_R + (1 - beta2) * grad_R**2\n            m_hat_R = m_R / (1 - beta1**step_idx)\n            v_hat_R = v_R / (1 - beta2**step_idx)\n            dR = lr * m_hat_R / (np.sqrt(v_hat_R) + eps)\n            \n            m_C = beta1 * m_C + (1 - beta1) * grad_C\n            v_C = beta2 * v_C + (1 - beta2) * grad_C**2\n            m_hat_C = m_C / (1 - beta1**step_idx)\n            v_hat_C = v_C / (1 - beta2**step_idx)\n            dC = lr * m_hat_C / (np.sqrt(v_hat_C) + eps)\n            \n            # Magnitude clipping dynamically secures boundary non-violating stability\n            max_dR = np.max(np.abs(dR))\n            if max_dR > 0.01:\n                dR *= 0.01 / max_dR\n            max_dC = np.max(np.abs(dC))\n            if max_dC > 0.01:\n                dC *= 0.01 / max_dC\n                \n            step_size = 1.0\n            \n            # Dynamic Step Line Search ensuring no circles overlap or fall off valid boxes strictly\n            for _ in range(12):\n                new_C = C + step_size * dC\n                new_R = R + step_size * dR\n                \n                # Asserting constraints within floating barrier safety gaps\n                if np.any(new_R <= 1e-6):\n                    step_size *= 0.5\n                    continue\n                    \n                new_B0 = new_C - new_R[:, None]\n                new_B1 = 1.0 - new_C - new_R[:, None]\n                if np.any(new_B0 <= 1e-6) or np.any(new_B1 <= 1e-6):\n                    step_size *= 0.5\n                    continue\n                    \n                diff_new = new_C[:, None, :] - new_C[None, :, :]\n                D_new = np.linalg.norm(diff_new, axis=-1)\n                np.fill_diagonal(D_new, 1.0)\n                S_new = D_new - (new_R[:, None] + new_R[None, :])\n                np.fill_diagonal(S_new, 1.0)\n                \n                if np.any(S_new <= 1e-6):\n                    step_size *= 0.5\n                    continue\n                    \n                # The step remains physically stable. Proceed.\n                C = new_C\n                R = new_R\n                break\n                \n            mu *= mu_decay\n            \n        # Simulated-annealing Phase: Perfect filling with geometric limits.\n        # Once spatial centers settle down, monotonically scale all radiuses independently tight.\n        R_expanded = R.copy()\n        for _ in range(80):\n            diff = C[:, None, :] - C[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, np.inf)\n            S = D - (R_expanded[:, None] + R_expanded[None, :])\n            \n            B0 = C - R_expanded[:, None]\n            B1 = 1.0 - C - R_expanded[:, None]\n            bound_slack = np.min(np.hstack([B0, B1]), axis=1)\n            \n            min_pair_slack = np.min(S, axis=1)\n            \n            max_inc = np.minimum(bound_slack, min_pair_slack / 2.0)\n            max_inc = np.maximum(max_inc, 0.0)\n            \n            R_expanded += max_inc * 0.95\n            \n        # Float protection\n        R_expanded *= 0.9999999\n        s = np.sum(R_expanded)\n        \n        # Maintain overall champion\n        if s > best_sum:\n            best_sum = s\n            best_C = C\n            best_R = R_expanded\n            \n    return best_C, best_R, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["# Constructor-based circle packing for n=26 circles using parallel Adam optimizer\nimport numpy as np\n\n\ndef initialize_batch(B, N):\n    \"\"\"Generate diverse seeds for batch optimization.\"\"\"\n    np.random.seed(88)  # Fixed robust seed\n    C = np.zeros((B, N, 2))\n    R = np.full((B, N), 0.05)\n\n    for b in range(B):\n        ptype = b % 5\n        if ptype == 0:\n            C[b] = np.random.rand(N, 2) * 0.9 + 0.05\n        elif ptype == 1:\n            C[b] = np.clip(np.random.randn(N, 2) * 0.2 + 0.5, 0.05, 0.95)\n        elif ptype == 2:\n            # 1 - 8 - 17 Rings structure\n            pts = [[0.5, 0.5]]\n            for i in range(8):\n                a = 2 * np.pi * i / 8\n                pts.append([0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)])\n            for i in range(17):\n                a = 2 * np.pi * i / 17\n                pts.append([0.5 + 0.42 * np.cos(a), 0.5 + 0.42 * np.sin(a)])\n            jitter = (np.random.rand(N, 2) - 0.5) * 0.03\n            C[b] = np.clip(np.array(pts) + jitter, 0.05, 0.95)\n        elif ptype == 3:\n            # Grid structure dynamically perturbed\n            X, Y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            pts = np.c_[X.ravel(), Y.ravel()].tolist()\n            # Adding one central piece to make 26 total items\n            pts.append([0.5 + np.random.rand() * 0.01, 0.5 + np.random.rand() * 0.01])\n            jitter = (np.random.rand(N, 2) - 0.5) * 0.04\n            C[b] = np.clip(np.array(pts) + jitter, 0.05, 0.95)\n        else:\n            # Hollow center focus generating heavy density variations seamlessly\n            pts = []\n            while len(pts) < N:\n                p = np.random.rand(2) * 0.9 + 0.05\n                dist = np.linalg.norm(p - 0.5)\n                if dist > 0.35 or dist < 0.1:\n                    pts.append(p)\n            C[b] = np.array(pts)\n\n    return C, R\n\n\ndef get_gradients(C, R, P):\n    \"\"\"Compute vectorized penalty-based optimization gradients.\"\"\"\n    grad_C = np.zeros_like(C)\n    grad_R = np.full_like(R, -1.0)  # Core gradient pushing sums strictly upwards\n\n    # Border boundary physics violations resolving elegantly\n    err_x0 = R - C[..., 0]\n    mask_x0 = err_x0 > 0\n    grad_R[mask_x0] += P * 2 * err_x0[mask_x0]\n    grad_C[..., 0][mask_x0] -= P * 2 * err_x0[mask_x0]\n\n    err_x1 = R - (1.0 - C[..., 0])\n    mask_x1 = err_x1 > 0\n    grad_R[mask_x1] += P * 2 * err_x1[mask_x1]\n    grad_C[..., 0][mask_x1] += P * 2 * err_x1[mask_x1]\n\n    err_y0 = R - C[..., 1]\n    mask_y0 = err_y0 > 0\n    grad_R[mask_y0] += P * 2 * err_y0[mask_y0]\n    grad_C[..., 1][mask_y0] -= P * 2 * err_y0[mask_y0]\n\n    err_y1 = R - (1.0 - C[..., 1])\n    mask_y1 = err_y1 > 0\n    grad_R[mask_y1] += P * 2 * err_y1[mask_y1]\n    grad_C[..., 1][mask_y1] += P * 2 * err_y1[mask_y1]\n\n    # Interstitial geometric overlap penalty and distancing logic \n    diff = C[:, :, np.newaxis, :] - C[:, np.newaxis, :, :]\n    dist_sq = np.sum(diff ** 2, axis=-1)\n\n    I = np.eye(C.shape[1], dtype=bool)[np.newaxis, :, :]\n    dist_sq = np.where(I, 1.0, dist_sq)\n    dist = np.sqrt(dist_sq)\n\n    R_sum = R[:, :, np.newaxis] + R[:, np.newaxis, :]\n    err_ov = R_sum - dist\n    err_ov = np.where(I, -1.0, err_ov)\n\n    mask_ov = err_ov > 0\n\n    grad_R += P * np.sum(np.where(mask_ov, 2 * err_ov, 0.0), axis=2)\n\n    weight = np.where(mask_ov, -2 * err_ov / dist, 0.0)\n    grad_C[..., 0] += P * np.sum(weight * diff[..., 0], axis=2)\n    grad_C[..., 1] += P * np.sum(weight * diff[..., 1], axis=2)\n\n    return grad_C, grad_R\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs optimally dense circle packing via simultaneous batch runs utilizing \n    decayed penalty models bridging smoothly into hard mathematical solvers strictly.\n    \"\"\"\n    B = 80\n    N = 26\n\n    C, R = initialize_batch(B, N)\n\n    m_C, v_C = np.zeros_like(C), np.zeros_like(C)\n    m_R, v_R = np.zeros_like(R), np.zeros_like(R)\n\n    T = 8500\n    P_start = 0.5\n    P_end = 25000.0\n    lr_start = 0.02\n    lr_end = 0.0002\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n\n    for step in range(1, T + 1):\n        progress = step / T\n        lr = lr_start * (lr_end / lr_start) ** progress\n        P = P_start * (P_end / P_start) ** progress\n\n        R_eff = np.maximum(R, 1e-6)\n\n        grad_C, grad_R = get_gradients(C, R_eff, P)\n\n        # Gradients strictly bounded neutralizing possible float instabilities naturally\n        grad_C = np.clip(grad_C, -50.0, 50.0)\n        grad_R = np.clip(grad_R, -50.0, 50.0)\n\n        m_C = beta1 * m_C + (1 - beta1) * grad_C\n        v_C = beta2 * v_C + (1 - beta2) * grad_C ** 2\n        m_C_hat = m_C / (1 - beta1 ** step)\n        v_C_hat = v_C / (1 - beta2 ** step)\n        C -= lr * m_C_hat / (np.sqrt(v_C_hat) + eps)\n\n        m_R = beta1 * m_R + (1 - beta1) * grad_R\n        v_R = beta2 * v_R + (1 - beta2) * grad_R ** 2\n        m_R_hat = m_R / (1 - beta1 ** step)\n        v_R_hat = v_R / (1 - beta2 ** step)\n        R -= lr * m_R_hat / (np.sqrt(v_R_hat) + eps)\n\n    best_score = -1.0\n    best_C = None\n    best_R = None\n\n    for b in range(B):\n        c_b = C[b].copy()\n        r_b = R[b].copy()\n\n        # Mathematically guaranteeing legal configuration topologies inherently\n        r_b = np.minimum(r_b, 0.499)\n        r_b = np.maximum(r_b, 1e-6)\n        c_b = np.clip(c_b, r_b[:, None], 1.0 - r_b[:, None])\n\n        # Absolute overlapping constraint shrink-wrapping eliminating deadlocks seamlessly \n        for _ in range(2):\n            diff = c_b[:, None, :] - c_b[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, np.inf)\n\n            S = r_b[:, None] + r_b[None, :]\n            violation_ratio = S / (D + 1e-12)\n            max_ratio = np.max(violation_ratio, axis=1)\n\n            r_b = r_b / np.maximum(1.0, max_ratio)\n\n        # Correcting isolated outer border limits uniformly independent\n        b_slack = np.min(np.hstack([c_b, 1.0 - c_b]), axis=1)\n        r_b = np.minimum(r_b, b_slack)\n\n        r_b *= 0.99999\n\n        # Continuous perfect local maximizing phase utilizing geometry strictly dynamically\n        for _ in range(120):\n            diff = c_b[:, None, :] - c_b[None, :, :]\n            D = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(D, np.inf)\n            S = D - (r_b[:, None] + r_b[None, :])\n\n            B0 = c_b - r_b[:, None]\n            B1 = 1.0 - c_b - r_b[:, None]\n            bound_slack = np.min(np.hstack([B0, B1]), axis=1)\n\n            min_pair_slack = np.min(S, axis=1)\n\n            max_inc = np.minimum(bound_slack, min_pair_slack / 2.0)\n            max_inc = np.maximum(max_inc, 0.0)\n\n            r_b += max_inc * 0.98\n\n        r_b *= 0.9999999\n\n        score = np.sum(r_b)\n        if score > best_score:\n            best_score = score\n            best_C = c_b\n            best_R = r_b\n\n    return best_C, best_R, best_score\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor strictly\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize geometrically output rendering for deep geometric checks.\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")"]}}, "artifacts_json": "{\"execution_time\": \"40.94s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.624661/2.635 = 0.9961\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.6% of target value\", \"radius_stats\": \"Min: 0.066166, Max: 0.131237, Avg: 0.100949\"}", "artifact_dir": null, "embedding": null}