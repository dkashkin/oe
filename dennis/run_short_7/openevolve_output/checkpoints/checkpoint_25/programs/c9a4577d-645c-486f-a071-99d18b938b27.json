{"id": "c9a4577d-645c-486f-a071-99d18b938b27", "code": "import numpy as np\n\n\ndef init_layout_batch(m_batch, n):\n    \"\"\"\n    Generate heuristic initialization geometries mapped tightly into batched \n    structures perfectly resolving strategic initial spatial topology seamlessly.\n    \"\"\"\n    np.random.seed(42)\n    P = np.zeros((m_batch, n, 2))\n    R = np.zeros((m_batch, n))\n    \n    for b in range(m_batch):\n        mode = b % 6\n        if mode == 0:\n            P[b, 0], R[b, 0] = [0.5, 0.5], 0.20\n            P[b, 1:] = np.random.uniform(0.1, 0.9, (n - 1, 2))\n            R[b, 1:] = np.random.uniform(0.02, 0.08, n - 1)\n        elif mode == 1:\n            P[b, :4] = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n            R[b, :4] = 0.12\n            P[b, 4:] = np.random.uniform(0.1, 0.9, (n - 4, 2))\n            R[b, 4:] = np.random.uniform(0.01, 0.08, n - 4)\n        elif mode == 2:\n            a = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n            P[b, :8, 0] = 0.5 + 0.3 * np.cos(a)\n            P[b, :8, 1] = 0.5 + 0.3 * np.sin(a)\n            R[b, :8] = 0.12\n            P[b, 8:] = np.random.uniform(0.1, 0.9, (n - 8, 2))\n            R[b, 8:] = np.random.uniform(0.01, 0.08, n - 8)\n        elif mode == 3:\n            grid_w, grid_h = 5, 6\n            idx = 0\n            for i in range(grid_w):\n                for j in range(grid_h):\n                    if idx < n:\n                        P[b, idx] = [(i + 0.5) / grid_w, (j + 0.5) / grid_h]\n                        R[b, idx] = 0.08\n                        idx += 1\n            if idx < n:\n                P[b, idx:] = np.random.uniform(0.1, 0.9, (n - idx, 2))\n                R[b, idx:] = np.random.uniform(0.01, 0.05, n - idx)\n        elif mode == 4:\n            P[b, 0:5, 0] = np.linspace(0.1, 0.9, 5)\n            P[b, 0:5, 1] = 0.5\n            R[b, 0:5] = 0.1\n            P[b, 5:] = np.random.uniform(0.1, 0.9, (n - 5, 2))\n            R[b, 5:] = np.random.uniform(0.01, 0.07, n - 5)\n        else:\n            P[b] = np.random.uniform(0.05, 0.95, (n, 2))\n            R[b] = np.random.uniform(0.03, 0.1, n)\n            \n    # Add varying random noise smoothly\n    P += np.random.normal(0, 0.01, P.shape)\n    R += np.random.normal(0, 0.005, R.shape)\n    \n    P = np.clip(P, 0.05, 0.95)\n    R = np.clip(R, 0.01, 0.3)\n    \n    return P, R\n\n\ndef optimize_batch(n=26, m_batch=120, steps=6500):\n    \"\"\"\n    Robust natively batched physics Adam simulation iteratively searching for \n    perfect geometry boundaries and dense structural topologies efficiently globally.\n    \"\"\"\n    P, R = init_layout_batch(m_batch, n)\n    \n    m_p, v_p = np.zeros_like(P), np.zeros_like(P)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    I = np.eye(n)[np.newaxis, :, :]\n    \n    for step in range(steps):\n        t = step / max(1, steps - 1)\n        # Logarithmic schedule safely forcing structural convergence globally\n        lr = 0.03 * (0.0005 / 0.03)**t \n        k = 10.0 * (100000.0 / 10.0)**t\n        \n        grad_p = np.zeros_like(P)\n        grad_r = np.full((m_batch, n), -1.0)\n        \n        # Exact Boundary Penalty Constraints natively linearly mapping cleanly\n        d_xmin = np.maximum(0.0, R - P[..., 0])\n        d_xmax = np.maximum(0.0, R + P[..., 0] - 1.0)\n        d_ymin = np.maximum(0.0, R - P[..., 1])\n        d_ymax = np.maximum(0.0, R + P[..., 1] - 1.0)\n        \n        grad_r += 2 * k * (d_xmin + d_xmax + d_ymin + d_ymax)\n        grad_p[..., 0] -= 2 * k * d_xmin\n        grad_p[..., 0] += 2 * k * d_xmax\n        grad_p[..., 1] -= 2 * k * d_ymin\n        grad_p[..., 1] += 2 * k * d_ymax\n        \n        # Native pairwise geometry cross intersection matrices efficiently\n        P_i = P[:, :, np.newaxis, :]\n        P_j = P[:, np.newaxis, :, :]\n        \n        dx = P_i[..., 0] - P_j[..., 0]\n        dy = P_i[..., 1] - P_j[..., 1]\n        \n        dist_sq = dx**2 + dy**2\n        dist = np.sqrt(dist_sq + I)\n        \n        R_i = R[:, :, np.newaxis]\n        R_j = R[:, np.newaxis, :]\n        \n        # Suppress identical overlap perfectly with diagonal suppression correctly\n        ov = R_i + R_j - dist - I * 10.0\n        ov_masked = np.maximum(0.0, ov)\n        \n        grad_r += 2 * k * np.sum(ov_masked, axis=2)\n        \n        force_scalar = -2 * k * ov_masked / dist\n        grad_p[..., 0] += np.sum(force_scalar * dx, axis=2)\n        grad_p[..., 1] += np.sum(force_scalar * dy, axis=2)\n        \n        # Dynamic Adam update compactly evaluating properly functionally\n        si = step + 1\n        m_p = 0.9 * m_p + 0.1 * grad_p\n        v_p = 0.999 * v_p + 0.001 * (grad_p**2)\n        P -= lr * (m_p / (1 - 0.9**si)) / (np.sqrt(v_p / (1 - 0.999**si)) + 1e-8)\n        \n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * (grad_r**2)\n        R -= lr * (m_r / (1 - 0.9**si)) / (np.sqrt(v_r / (1 - 0.999**si)) + 1e-8)\n        \n        P = np.clip(P, 0.001, 0.999)\n        R = np.maximum(R, 1e-4)\n        \n    return P, R\n\n\ndef make_valid(P_opt, R_opt):\n    \"\"\"\n    Ensure precisely mathematically rigid overlaps and geometries cleanly flawlessly safely.\n    \"\"\"\n    P = np.copy(P_opt)\n    R = np.copy(R_opt)\n    n = len(R)\n    \n    # Strictly bind maximum valid ranges effectively smartly successfully\n    for i in range(n):\n        R[i] = min(R[i], P[i][0], P[i][1], 1.0 - P[i][0], 1.0 - P[i][1])\n        if R[i] < 0:\n            R[i] = 0.0\n            \n    # Solve any fractional residual geometry overlaps natively logically compactly exactly\n    for _ in range(1500):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(P[i] - P[j])\n                if R[i] + R[j] > dist:\n                    ov = R[i] + R[j] - dist\n                    if ov > max_ov:\n                        max_ov = ov\n                    if dist > 1e-12:\n                        scale = dist / (R[i] + R[j])\n                        R[i] *= scale\n                        R[j] *= scale\n                    else:\n                        R[i] *= 0.5\n                        R[j] *= 0.5\n        if max_ov < 1e-13:\n            break\n            \n    for i in range(n):\n        bound_val = min(P[i][0], P[i][1], 1.0 - P[i][0], 1.0 - P[i][1])\n        if R[i] > bound_val:\n            R[i] = bound_val\n        if R[i] < 0:\n            R[i] = 0.0\n            \n    return R * 0.999995\n\n\ndef run_packing():\n    \"\"\"\n    Top-level extraction logically constructing highly optimal globally successfully geometries.\n    Returns precisely evaluated functional packing centers appropriately optimally tightly compactly.\n    \"\"\"\n    n = 26\n    m_batch = 120\n    \n    P_batch, R_batch = optimize_batch(n=n, m_batch=m_batch, steps=6500)\n    \n    best_P, best_R, best_sum = None, None, -1.0\n    \n    for b in range(m_batch):\n        R_val = make_valid(P_batch[b], R_batch[b])\n        s = float(np.sum(R_val))\n        \n        if s > best_sum:\n            best_sum = s\n            best_P = P_batch[b].copy()\n            best_R = R_val.copy()\n            \n    return best_P.tolist(), best_R.tolist(), float(best_sum)", "changes_description": null, "language": "python", "parent_id": "c2e22690-9ae6-4780-8150-17d6b31ef956", "generation": 3, "timestamp": 1772006721.4270132, "iteration_found": 21, "metrics": {"validity": 1.0, "sum_radii": 2.5642196932855446, "target_ratio": 0.9731384035239259, "combined_score": 0.9731384035239259, "radius_variance": 0.006851992671580254, "spatial_spread": 0.1859945507669243, "eval_time": 9.212573528289795}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"stage1_passed": 0.0, "error": 0.0, "timeout": true}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.3333\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.0000 \u2192 0.3333\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### timeout\n```\nTrue\n```\n\n### timeout_duration\n```\n60\n```\n\n### failure_stage\n```\nstage1\n```\n\n### error_type\n```\ntimeout\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: stage1_passed: 0.0000, error: 0.0000, timeout: 1.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3333)\n```python\nimport numpy as np\n\n\ndef compute_valid_radii(P, R_opt, max_iters=1000):\n    \"\"\"\n    Ensure the geometry is strictly valid by rectifying residual numeric constraints.\n    Returns structurally guaranteed overlapping-free scaling arrays natively precisely.\n    \"\"\"\n    R = np.copy(R_opt)\n    n = len(R)\n    \n    # Boundary constraints enforcement linearly evaluating overlaps dynamically\n    for i in range(n):\n        R[i] = min(R[i], P[i][0], P[i][1], 1.0 - P[i][0], 1.0 - P[i][1])\n        if R[i] < 0:\n            R[i] = 0.0\n            \n    # Resolve all paired overlapping events iteratively ensuring robust containment\n    for _ in range(max_iters):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((P[i][0] - P[j][0])**2 + (P[i][1] - P[j][1])**2)\n                if R[i] + R[j] > dist:\n                    ov = R[i] + R[j] - dist\n                    if ov > max_ov:\n                        max_ov = ov\n                    if dist > 1e-12:\n                        scale = dist / (R[i] + R[j])\n                        R[i] *= scale\n                        R[j] *= scale\n                    else:\n                        R[i] *= 0.5\n                        R[j] *= 0.5\n                        \n        if max_ov < 1e-12:\n            break\n            \n    return R * 0.99995\n\n\ndef init_layout(seed, n):\n    \"\"\"\n    Generates dynamic distinct heuristic packing variations systematically.\n    \"\"\"\n    np.random.seed(seed)\n    P = np.zeros((n, 2))\n    R = np.zeros(n)\n    \n    mode = seed % 5\n    if mode == 0:\n        P[0], R[0] = [0.5, 0.5], 0.25\n        for i in range(1, n):\n            P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[i] = np.random.uniform(0.01, 0.1)\n    elif mode == 1:\n        P[:4] = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n        R[:4] = 0.15\n        for i in range(4, n):\n            P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[i] = np.random.uniform(0.01, 0.08)\n    elif mode == 2:\n        a = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n        for i in range(8):\n            P[i] = [0.5 + 0.3 * np.cos(a[i]), 0.5 + 0.3 * np.sin(a[i])]\n            R[i] = 0.12\n        for i in range(8, n):\n            P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[i] = np.random.uniform(0.02, 0.06)\n    elif mode == 3:\n        idx = 0\n        for px in [0.25, 0.5, 0.75]:\n            for py in [0.25, 0.5, 0.75]:\n                if idx < n:\n                    P[idx], R[idx] = [px, py], 0.10\n                    idx += 1\n        while idx < n:\n            P[idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[idx] = np.random.uniform(0.01, 0.05)\n            idx += 1\n    else:\n        for i in range(n):\n            P[i] = [np.random.uniform(0.05, 0.95), np.random.uniform(0.05, 0.95)]\n            R[i] = np.random.uniform(0.05, 0.12)\n            \n    P += np.random.normal(0, 0.01, P.shape)\n    R += np.random.normal(0, 0.005, R.shape)\n    \n    P = np.clip(P, 0.05, 0.95)\n    R = np.clip(R, 0.01, 0.3)\n    return P, R\n\n\ndef optimize_arrangement(seed, n=26, steps=7500):\n    \"\"\"\n    Robust vectorized adam gradients targeting minimal functional configurations structurally iteratively dynamically uniformly globally linearly safely seamlessly mapping.\n    \"\"\"\n    P, R = init_layout(seed, n)\n    m_p, v_p = np.zeros_like(P), np.zeros_like(P)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    for step in range(steps):\n        t = step / max(1, steps - 1)\n        lr = 0.015 * (0.01)**t \n        k = 10.0 * (1e5)**t\n        \n        grad_p, grad_r = np.zeros_like(P), np.full(n, -1.0)\n        \n        d_xmin = np.maximum(0, R - P[:, 0])\n        grad_r += 2 * k * d_xmin\n        grad_p[:, 0] -= 2 * k * d_xmin\n        \n        d_xmax = np.maximum(0, R + P[:, 0] - 1.0)\n        grad_r += 2 * k * d_xmax\n        grad_p[:, 0] += 2 * k * d_xmax\n        \n        d_ymin = np.maximum(0, R - P[:, 1])\n        grad_r += 2 * k * d_ymin\n        grad_p[:, 1] -= 2 * k * d_ymin\n        \n        d_ymax = np.maximum(0, R + P[:, 1] - 1.0)\n        grad_r += 2 * k * d_ymax\n        grad_p[:, 1] += 2 * k * d_ymax\n        \n        dx = P[:, None, 0] - P[None, :, 0]\n        dy = P[:, None, 1] - P[None, :, 1]\n        dist_sq = dx**2 + dy**2\n        np.fill_diagonal(dist_sq, 1.0)\n        dist = np.maximum(np.sqrt(dist_sq), 1e-12)\n        \n        ov = R[:, None] + R[None, :] - dist\n        np.fill_diagonal(ov, -1.0)\n        ov_masked = np.maximum(0, ov)\n        \n        grad_r += 2 * k * np.sum(ov_masked, axis=1)\n        force = -2 * k * ov_masked / dist\n        grad_p[:, 0] += np.sum(force * dx, axis=1)\n        grad_p[:, 1] += np.sum(force * dy, axis=1)\n        \n        si = step + 1\n        m_p = 0.9 * m_p + 0.1 * grad_p\n        v_p = 0.999 * v_p + 0.001 * (grad_p**2)\n        P -= lr * (m_p / (1 - 0.9**si)) / (np.sqrt(v_p / (1 - 0.999**si)) + 1e-8)\n        \n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * (grad_r**2)\n        R -= lr * (m_r / (1 - 0.9**si)) / (np.sqrt(v_r / (1 - 0.999**si)) + 1e-8)\n        \n        R = np.maximum(R, 0.001)\n        \n    return P, R\n\n\ndef run_packing():\n    \"\"\"\n    Search looping explicitly aggressively evaluating limits directly optimizing mapping totally sequentially comprehensively targeting density thoroughly globally flawlessly neatly nicely properly exactly elegantly logically linearly fully properly seamlessly securely reliably universally smartly optimally correctly exactly smartly fully reliably accurately neatly efficiently smoothly linearly nicely functionally completely properly thoroughly uniformly perfectly reliably mapping structurally cleanly perfectly functionally effectively universally elegantly accurately neatly correctly robustly securely strongly seamlessly structurally effectively optimally structurally completely flawlessly successfully directly compactly flawlessly exactly successfully safely.\n    \"\"\"\n    best_P, best_R, best_sum = None, None, -1.0\n    \n    for seed in range(125):\n        P, R = optimize_arrangement(seed=seed, n=26, steps=7500)\n        R_val = compute_valid_radii(P, R)\n        s = float(np.sum(R_val))\n        \n        if s > best_sum:\n            best_sum = s\n            best_P = P.copy()\n            best_R = R_val.copy()\n            \n    return best_P.tolist(), best_R.tolist(), best_sum\n```\nKey features: Performs well on stage1_passed (0.0000), Performs well on error (0.0000), Performs well on timeout (1.0000)\n\n### Program 2 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative optimization-based circle packing for N=26 circles\"\"\"\nimport numpy as np\n\n\ndef make_valid(p, r):\n    \"\"\"Ensure circles are fully non-overlapping and strictly inside the box.\"\"\"\n    p = np.copy(p)\n    r = np.copy(r)\n    n = len(r)\n\n    # Pre-constrain with boundaries\n    for i in range(n):\n        bound_limit = min(p[i, 0], p[i, 1], 1.0 - p[i, 0], 1.0 - p[i, 1])\n        r[i] = max(1e-6, min(r[i], bound_limit) - 1e-7)\n\n    for _ in range(300):\n        changed = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((p[i] - p[j])**2))\n                if r[i] + r[j] > dist:\n                    changed = True\n                    excess = (r[i] + r[j] - dist) + 1e-9\n                    r_i_new = r[i] - excess * 0.5\n                    r_j_new = r[j] - excess * 0.5\n                    \n                    if r_i_new < 1e-6:\n                        r_j_new -= (1e-6 - r_i_new)\n                        r_i_new = 1e-6\n                    elif r_j_new < 1e-6:\n                        r_i_new -= (1e-6 - r_j_new)\n                        r_j_new = 1e-6\n                        \n                    r[i] = r_i_new\n                    r[j] = r_j_new\n                    \n        if not changed:\n            break\n\n    # One last pure safety pass\n    for i in range(n):\n        bound_limit = min(p[i, 0], p[i, 1], 1.0 - p[i, 0], 1.0 - p[i, 1])\n        r[i] = max(0.0, min(r[i], bound_limit))\n\n    return p, r\n\n\ndef optimize_packing():\n    \"\"\"\n    Run parallel physics-based optimization to arrange N circles\n    with constraints formulated as soft penalties inside an Adam descent.\n    Includes initial strategic topological heuristics to explore varying configurations.\n    \"\"\"\n    np.random.seed(42)\n    m_batch = 40\n    n = 26\n    pos = np.random.uniform(0.1, 0.9, (m_batch, n, 2))\n    r = np.full((m_batch, n), 0.05)\n\n    # 1. Hexagonal Grid Initialization\n    grid_w = 6\n    grid_h = 5\n    hex_pos = []\n    for i in range(grid_h):\n        for j in range(grid_w):\n            x = (j + 0.5 + 0.5 * (i % 2)) / (grid_w + 0.5)\n            y = (i + 0.5) / grid_h\n            hex_pos.append([x, y])\n    hex_pos = np.array(hex_pos)[:n]\n    pos[0:10, :, :] = 0.1 + 0.8 * hex_pos + np.random.normal(0, 0.005, (10, n, 2))\n\n    # 2. Central Big Pattern Optimization\n    pos[10:20, 0, :] = [0.5, 0.5]\n    r[10:20, 0] = 0.3\n    angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n    for k, angle in enumerate(angles):\n        pos[10:20, k + 1, 0] = 0.5 + 0.3 * np.cos(angle)\n        pos[10:20, k + 1, 1] = 0.5 + 0.3 * np.sin(angle)\n    pos[10:20, 9:, :] = np.random.uniform(0.1, 0.9, (10, 17, 2))\n\n    # 3. Four Corners Emphasized Topology\n    corners = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n    for k, c in enumerate(corners):\n        pos[20:30, k, :] = c\n        r[20:30, k] = 0.15\n    pos[20:30, 4:, :] = np.random.uniform(0.1, 0.9, (10, 22, 2))\n\n    # 4. Ring Topology Model\n    pos[30:40, 0, :] = [0.5, 0.5]\n    r[30:40, 0] = 0.2\n    for k in range(10):\n        angle = 2 * np.pi * k / 10\n        pos[30:40, k + 1, :] = [0.5 + 0.35 * np.cos(angle), 0.5 + 0.35 * np.sin(angle)]\n        r[30:40, k + 1] = 0.1\n    pos[30:40, 11:, :] = np.random.uniform(0.1, 0.9, (10, 15, 2))\n\n    # Define Adam Optimizer internal states\n    m_pos = np.zeros_like(pos)\n    v_pos = np.zeros_like(pos)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    steps = 4000\n    lr = 0.01\n    i_idx = np.arange(n)\n\n    for step in range(1, steps + 1):\n        # Penalty rises exponentially over the steps acting like simulated annealing constraints\n        c_pen = 10.0 * (10000.0) ** (step / steps)\n        lr_t = lr * (1.0 - step / (steps + 1))\n\n        # Tensor Broadcasting 2D differences mapping pairwise combinations\n        pos_exp0 = pos[:, :, np.newaxis, :]\n        pos_exp1 = pos[:, np.newaxis, :, :]\n        diff = pos_exp0 - pos_exp1\n        dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-12)\n\n        r_sum = r[:, :, np.newaxis] + r[:, np.newaxis, :]\n        overlap = np.maximum(0.0, r_sum - dist)\n        overlap[:, i_idx, i_idx] = 0.0  # Strip explicit diagonal identical checks\n\n        # Outer walls physics constraints\n        bound_x0 = np.maximum(0.0, r - pos[:, :, 0])\n        bound_x1 = np.maximum(0.0, pos[:, :, 0] + r - 1.0)\n        bound_y0 = np.maximum(0.0, r - pos[:, :, 1])\n        bound_y1 = np.maximum(0.0, pos[:, :, 1] + r - 1.0)\n\n        # Derivatives related strictly to varying node sizes uniformly\n        grad_r_overlap = c_pen * np.sum(overlap, axis=2)\n        grad_r_bound = c_pen * (bound_x0 + bound_x1 + bound_y0 + bound_y1)\n\n        d_center = np.sqrt((pos[:, :, 0] - 0.5)**2 + (pos[:, :, 1] - 0.5)**2)\n        bias_decay = (1.0 - step / steps)**2\n        grad_r_bias = 0.5 * d_center * bias_decay\n\n        grad_r = -1.0 + grad_r_overlap + grad_r_bound + grad_r_bias\n\n        # Force directed resolution positioning\n        dir_ij = diff / dist[..., np.newaxis]\n        grad_pos_overlap = -c_pen * np.sum(overlap[..., np.newaxis] * dir_ij, axis=2)\n\n        grad_pos_bound = np.zeros_like\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based optimization circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_valid_radii(P, R_opt):\n    \"\"\"\n    Ensure the geometry is strictly valid. Boundary limits apply instantly,\n    and iterative scaling eliminates any microscopic remaining overlaps.\n    \"\"\"\n    R = np.copy(R_opt)\n    n = len(R)\n    \n    # Square border limits\n    for i in range(n):\n        x, y = P[i]\n        R[i] = min(R[i], x, y, 1.0 - x, 1.0 - y)\n    \n    # Resolve intersecting overlaps completely \n    for _ in range(30):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((P[i] - P[j])**2))\n                if R[i] + R[j] > dist:\n                    ov = R[i] + R[j] - dist\n                    max_ov = max(max_ov, ov)\n                    scale = dist / (R[i] + R[j]) if dist > 1e-8 else 0\n                    R[i] *= scale\n                    R[j] *= scale\n                    \n        if max_ov < 1e-10:\n            break\n            \n    return R * 0.9999999  # Absolute structural clearance\n\n\ndef optimize_arrangement(seed, n=26, steps=6000):\n    \"\"\"\n    Vectorized Gradient Descent optimizer using Simulated Adam physics.\n    Optimizes unconstrained states mapped internally via strict boundary penalties.\n    \"\"\"\n    np.random.seed(seed)\n    P, R = np.zeros((n, 2)), np.zeros(n)\n    \n    # Stratified Placements by size heuristics \n    P[0], R[0] = [0.5, 0.5], 0.20\n    P[1:5] = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n    R[1:5] = 0.12\n    \n    # Distribute middle rim dynamically adjusting angles based on seed\n    a = np.linspace(0, 2 * np.pi, 8, endpoint=False) + (0.1 if seed % 2 == 0 else 0)\n    for i in range(8):\n        P[i+5], R[i+5] = [0.5 + 0.35 * np.cos(a[i]), 0.5 + 0.35 * np.sin(a[i])], 0.09\n        \n    for i in range(13, n):\n        P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n        R[i] = np.random.uniform(0.02, 0.05)\n        \n    # Break total alignment to escape saddle spots easily\n    P = np.clip(P + np.random.normal(0, 0.005, P.shape), 0.05, 0.95)\n    R = np.clip(R + np.random.normal(0, 0.002, R.shape), 0.01, 0.3)\n    \n    m_p, v_p = np.zeros_like(P), np.zeros_like(P)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    for step in range(steps):\n        t = step / max(1, steps - 1)\n        # Decaying Adam Learning Rate and Annelaing Constraint Modulator\n        lr = 0.01 * (0.01)**t \n        k = 10.0 * (1e5)**t\n        \n        grad_p, grad_r = np.zeros_like(P), np.full(n, -1.0)\n        \n        # Evaluative Boundaries Penality Force\n        d_xmin = np.maximum(0, R - P[:, 0])\n        grad_r += 2 * k * d_xmin\n        grad_p[:, 0] -= 2 * k * d_xmin\n        \n        d_xmax = np.maximum(0, R + P[:, 0] - 1.0)\n        grad_r += 2 * k * d_xmax\n        grad_p[:, 0] += 2 * k * d_xmax\n        \n        d_ymin = np.maximum(0, R - P[:, 1])\n        grad_r += 2 * k * d_ymin\n        grad_p[:, 1] -= 2 * k * d_ymin\n        \n        d_ymax = np.maximum(0, R + P[:, 1] - 1.0)\n        grad_r += 2 * k * d_ymax\n        grad_p[:, 1] += 2 * k * d_ymax\n        \n        # Geometric Matrix Cross Intersect Checking \n        dx, dy = P[:, None, 0] - P[None, :, 0], P[:, None, 1] - P[None, :, 1]\n        dist_sq = dx**2 + dy**2\n        np.fill_diagonal(dist_sq, 1.0)\n        dist = np.sqrt(dist_sq)\n        \n        ov = R[:, None] + R[None, :] - dist\n        np.fill_diagonal(ov, -1.0)\n        ov_masked = np.maximum(0, ov)\n        \n        # Accumulate symmetric tensor gradient reactions natively\n        grad_r += 2 * k * np.sum(ov_masked, axis=1)\n        force = -2 * k * ov_masked / dist\n        grad_p[:, 0] += np.sum(force * dx, axis=1)\n        grad_p[:, 1] += np.sum(force * dy, axis=1)\n        \n        # Pure Adam iteration loop without expensive API abstraction overhead\n        si = step + 1\n        m_p = 0.9 * m_p + 0.1 * grad_p\n        v_p = 0.999 * v_p + 0.001 * (grad_p**2)\n        P -= lr * (m_p / (1 - 0.9**si)) / (np.sqrt(v_p / (1 - 0.999**si)) + 1e-8)\n        \n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * (grad_r**2)\n        R -= lr * (m_r / (1 - 0.9**si)) / (np.sqrt(v_r / (1 - 0.999**si)) + 1e-8)\n        R = np.clip(R, 0.001, 0.5)\n        \n    return P, R\n\n\ndef construct_packing():\n    \"\"\"\n    Search sequence loop constructing maximum 26 bounded objects fitting pattern rules.\n    Yields strictly verified configuration values mapping centers and maximum bounds ratios.\n    \"\"\"\n    best_P, best_R, best_sum = None, None, -1.0\n    \n    # Execute batch variations seeking highest optimized density plateau escapes\n    for seed in range(42, 50): \n        P, R = optimize_arrangement(seed=seed, steps=6000)\n        R_val = compute_valid_radii(P, R)\n        s = np.sum(R_val)\n        \n        if s > best_sum:\n            best_sum = s\n            best_P = P.copy()\n            best_R = R_val.copy()\n            \n    return best_P, best_R, best_sum\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative optimization-based circle packing for N=26 circles\"\"\"\nimport numpy as np\n\n\ndef make_valid(p, r):\n    \"\"\"Ensure circles are fully non-overlapping and strictly inside the box.\"\"\"\n    p = np.copy(p)\n    r = np.copy(r)\n    n = len(r)\n\n    # Pre-constrain with boundaries\n    for i in range(n):\n        bound_limit = min(p[i, 0], p[i, 1], 1.0 - p[i, 0], 1.0 - p[i, 1])\n        r[i] = max(1e-6, min(r[i], bound_limit) - 1e-7)\n\n    for _ in range(300):\n        changed = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((p[i] - p[j])**2))\n                if r[i] + r[j] > dist:\n                    changed = True\n                    excess = (r[i] + r[j] - dist) + 1e-9\n                    r_i_new = r[i] - excess * 0.5\n                    r_j_new = r[j] - excess * 0.5\n                    \n                    if r_i_new < 1e-6:\n                        r_j_new -= (1e-6 - r_i_new)\n                        r_i_new = 1e-6\n                    elif r_j_new < 1e-6:\n                        r_i_new -= (1e-6 - r_j_new)\n                        r_j_new = 1e-6\n                        \n                    r[i] = r_i_new\n                    r[j] = r_j_new\n                    \n        if not changed:\n            break\n\n    # One last pure safety pass\n    for i in range(n):\n        bound_limit = min(p[i, 0], p[i, 1], 1.0 - p[i, 0], 1.0 - p[i, 1])\n        r[i] = max(0.0, min(r[i], bound_limit))\n\n    return p, r\n\n\ndef optimize_packing():\n    \"\"\"\n    Run parallel physics-based optimization to arrange N circles\n    with constraints formulated as soft penalties inside an Adam descent.\n    Includes initial strategic topological heuristics to explore varying configurations.\n    \"\"\"\n    np.random.seed(42)\n    m_batch = 40\n    n = 26\n    pos = np.random.uniform(0.1, 0.9, (m_batch, n, 2))\n    r = np.full((m_batch, n), 0.05)\n\n    # 1. Hexagonal Grid Initialization\n    grid_w = 6\n    grid_h = 5\n    hex_pos = []\n    for i in range(grid_h):\n        for j in range(grid_w):\n            x = (j + 0.5 + 0.5 * (i % 2)) / (grid_w + 0.5)\n            y = (i + 0.5) / grid_h\n            hex_pos.append([x, y])\n    hex_pos = np.array(hex_pos)[:n]\n    pos[0:10, :, :] = 0.1 + 0.8 * hex_pos + np.random.normal(0, 0.005, (10, n, 2))\n\n    # 2. Central Big Pattern Optimization\n    pos[10:20, 0, :] = [0.5, 0.5]\n    r[10:20, 0] = 0.3\n    angles = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n    for k, angle in enumerate(angles):\n        pos[10:20, k + 1, 0] = 0.5 + 0.3 * np.cos(angle)\n        pos[10:20, k + 1, 1] = 0.5 + 0.3 * np.sin(angle)\n    pos[10:20, 9:, :] = np.random.uniform(0.1, 0.9, (10, 17, 2))\n\n    # 3. Four Corners Emphasized Topology\n    corners = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n    for k, c in enumerate(corners):\n        pos[20:30, k, :] = c\n        r[20:30, k] = 0.15\n    pos[20:30, 4:, :] = np.random.uniform(0.1, 0.9, (10, 22, 2))\n\n    # 4. Ring Topology Model\n    pos[30:40, 0, :] = [0.5, 0.5]\n    r[30:40, 0] = 0.2\n    for k in range(10):\n        angle = 2 * np.pi * k / 10\n        pos[30:40, k + 1, :] = [0.5 + 0.35 * np.cos(angle), 0.5 + 0.35 * np.sin(angle)]\n        r[30:40, k + 1] = 0.1\n    pos[30:40, 11:, :] = np.random.uniform(0.1, 0.9, (10, 15, 2))\n\n    # Define Adam Optimizer internal states\n    m_pos = np.zeros_like(pos)\n    v_pos = np.zeros_like(pos)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    steps = 4000\n    lr = 0.01\n    i_idx = np.arange(n)\n\n    for step in range(1, steps + 1):\n        # Penalty rises exponentially over the steps acting like simulated annealing constraints\n        c_pen = 10.0 * (10000.0) ** (step / steps)\n        lr_t = lr * (1.0 - step / (steps + 1))\n\n        # Tensor Broadcasting 2D differences mapping pairwise combinations\n        pos_exp0 = pos[:, :, np.newaxis, :]\n        pos_exp1 = pos[:, np.newaxis, :, :]\n        diff = pos_exp0 - pos_exp1\n        dist = np.sqrt(np.sum(diff**2, axis=-1) + 1e-12)\n\n        r_sum = r[:, :, np.newaxis] + r[:, np.newaxis, :]\n        overlap = np.maximum(0.0, r_sum - dist)\n        overlap[:, i_idx, i_idx] = 0.0  # Strip explicit diagonal identical checks\n\n        # Outer walls physics constraints\n        bound_x0 = np.maximum(0.0, r - pos[:, :, 0])\n        bound_x1 = np.maximum(0.0, pos[:, :, 0] + r - 1.0)\n        bound_y0 = np.maximum(0.0, r - pos[:, :, 1])\n        bound_y1 = np.maximum(0.0, pos[:, :, 1] + r - 1.0)\n\n        # Derivatives related strictly to varying node sizes uniformly\n        grad_r_overlap = c_pen * np.sum(overlap, axis=2)\n        grad_r_bound = c_pen * (bound_x0 + bound_x1 + bound_y0 + bound_y1)\n\n        d_center = np.sqrt((pos[:, :, 0] - 0.5)**2 + (pos[:, :, 1] - 0.5)**2)\n        bias_decay = (1.0 - step / steps)**2\n        grad_r_bias = 0.5 * d_center * bias_decay\n\n        grad_r = -1.0 + grad_r_overlap + grad_r_bound + grad_r_bias\n\n        # Force directed resolution positioning\n        dir_ij = diff / dist[..., np.newaxis]\n        grad_pos_overlap = -c_pen * np.sum(overlap[..., np.newaxis] * dir_ij, axis=2)\n\n        grad_pos_bound = np.zeros_like\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based optimization circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_valid_radii(P, R_opt):\n    \"\"\"\n    Ensure the geometry is strictly valid. Boundary limits apply instantly,\n    and iterative scaling eliminates any microscopic remaining overlaps.\n    \"\"\"\n    R = np.copy(R_opt)\n    n = len(R)\n    \n    # Square border limits\n    for i in range(n):\n        x, y = P[i]\n        R[i] = min(R[i], x, y, 1.0 - x, 1.0 - y)\n    \n    # Resolve intersecting overlaps completely \n    for _ in range(30):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt(np.sum((P[i] - P[j])**2))\n                if R[i] + R[j] > dist:\n                    ov = R[i] + R[j] - dist\n                    max_ov = max(max_ov, ov)\n                    scale = dist / (R[i] + R[j]) if dist > 1e-8 else 0\n                    R[i] *= scale\n                    R[j] *= scale\n                    \n        if max_ov < 1e-10:\n            break\n            \n    return R * 0.9999999  # Absolute structural clearance\n\n\ndef optimize_arrangement(seed, n=26, steps=6000):\n    \"\"\"\n    Vectorized Gradient Descent optimizer using Simulated Adam physics.\n    Optimizes unconstrained states mapped internally via strict boundary penalties.\n    \"\"\"\n    np.random.seed(seed)\n    P, R = np.zeros((n, 2)), np.zeros(n)\n    \n    # Stratified Placements by size heuristics \n    P[0], R[0] = [0.5, 0.5], 0.20\n    P[1:5] = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n    R[1:5] = 0.12\n    \n    # Distribute middle rim dynamically adjusting angles based on seed\n    a = np.linspace(0, 2 * np.pi, 8, endpoint=False) + (0.1 if seed % 2 == 0 else 0)\n    for i in range(8):\n        P[i+5], R[i+5] = [0.5 + 0.35 * np.cos(a[i]), 0.5 + 0.35 * np.sin(a[i])], 0.09\n        \n    for i in range(13, n):\n        P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n        R[i] = np.random.uniform(0.02, 0.05)\n        \n    # Break total alignment to escape saddle spots easily\n    P = np.clip(P + np.random.normal(0, 0.005, P.shape), 0.05, 0.95)\n    R = np.clip(R + np.random.normal(0, 0.002, R.shape), 0.01, 0.3)\n    \n    m_p, v_p = np.zeros_like(P), np.zeros_like(P)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    for step in range(steps):\n        t = step / max(1, steps - 1)\n        # Decaying Adam Learning Rate and Annelaing Constraint Modulator\n        lr = 0.01 * (0.01)**t \n        k = 10.0 * (1e5)**t\n        \n        grad_p, grad_r = np.zeros_like(P), np.full(n, -1.0)\n        \n        # Evaluative Boundaries Penality Force\n        d_xmin = np.maximum(0, R - P[:, 0])\n        grad_r += 2 * k * d_xmin\n        grad_p[:, 0] -= 2 * k * d_xmin\n        \n        d_xmax = np.maximum(0, R + P[:, 0] - 1.0)\n        grad_r += 2 * k * d_xmax\n        grad_p[:, 0] += 2 * k * d_xmax\n        \n        d_ymin = np.maximum(0, R - P[:, 1])\n        grad_r += 2 * k * d_ymin\n        grad_p[:, 1] -= 2 * k * d_ymin\n        \n        d_ymax = np.maximum(0, R + P[:, 1] - 1.0)\n        grad_r += 2 * k * d_ymax\n        grad_p[:, 1] += 2 * k * d_ymax\n        \n        # Geometric Matrix Cross Intersect Checking \n        dx, dy = P[:, None, 0] - P[None, :, 0], P[:, None, 1] - P[None, :, 1]\n        dist_sq = dx**2 + dy**2\n        np.fill_diagonal(dist_sq, 1.0)\n        dist = np.sqrt(dist_sq)\n        \n        ov = R[:, None] + R[None, :] - dist\n        np.fill_diagonal(ov, -1.0)\n        ov_masked = np.maximum(0, ov)\n        \n        # Accumulate symmetric tensor gradient reactions natively\n        grad_r += 2 * k * np.sum(ov_masked, axis=1)\n        force = -2 * k * ov_masked / dist\n        grad_p[:, 0] += np.sum(force * dx, axis=1)\n        grad_p[:, 1] += np.sum(force * dy, axis=1)\n        \n        # Pure Adam iteration loop without expensive API abstraction overhead\n        si = step + 1\n        m_p = 0.9 * m_p + 0.1 * grad_p\n        v_p = 0.999 * v_p + 0.001 * (grad_p**2)\n        P -= lr * (m_p / (1 - 0.9**si)) / (np.sqrt(v_p / (1 - 0.999**si)) + 1e-8)\n        \n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * (grad_r**2)\n        R -= lr * (m_r / (1 - 0.9**si)) / (np.sqrt(v_r / (1 - 0.999**si)) + 1e-8)\n        R = np.clip(R, 0.001, 0.5)\n        \n    return P, R\n\n\ndef construct_packing():\n    \"\"\"\n    Search sequence loop constructing maximum 26 bounded objects fitting pattern rules.\n    Yields strictly verified configuration values mapping centers and maximum bounds ratios.\n    \"\"\"\n    best_P, best_R, best_sum = None, None, -1.0\n    \n    # Execute batch variations seeking highest optimized density plateau escapes\n    for seed in range(42, 50): \n        P, R = optimize_arrangement(seed=seed, steps=6000)\n        R_val = compute_valid_radii(P, R)\n        s = np.sum(R_val)\n        \n        if s > best_sum:\n            best_sum = s\n            best_P = P.copy()\n            best_R = R_val.copy()\n            \n    return best_P, best_R, best_sum\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\n\n\ndef compute_valid_radii(P, R_opt, max_iters=1000):\n    \"\"\"\n    Ensure the geometry is strictly valid by rectifying residual numeric constraints.\n    Returns structurally guaranteed overlapping-free scaling arrays natively precisely.\n    \"\"\"\n    R = np.copy(R_opt)\n    n = len(R)\n    \n    # Boundary constraints enforcement linearly evaluating overlaps dynamically\n    for i in range(n):\n        R[i] = min(R[i], P[i][0], P[i][1], 1.0 - P[i][0], 1.0 - P[i][1])\n        if R[i] < 0:\n            R[i] = 0.0\n            \n    # Resolve all paired overlapping events iteratively ensuring robust containment\n    for _ in range(max_iters):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.sqrt((P[i][0] - P[j][0])**2 + (P[i][1] - P[j][1])**2)\n                if R[i] + R[j] > dist:\n                    ov = R[i] + R[j] - dist\n                    if ov > max_ov:\n                        max_ov = ov\n                    if dist > 1e-12:\n                        scale = dist / (R[i] + R[j])\n                        R[i] *= scale\n                        R[j] *= scale\n                    else:\n                        R[i] *= 0.5\n                        R[j] *= 0.5\n                        \n        if max_ov < 1e-12:\n            break\n            \n    return R * 0.99995\n\n\ndef init_layout(seed, n):\n    \"\"\"\n    Generates dynamic distinct heuristic packing variations systematically.\n    \"\"\"\n    np.random.seed(seed)\n    P = np.zeros((n, 2))\n    R = np.zeros(n)\n    \n    mode = seed % 5\n    if mode == 0:\n        P[0], R[0] = [0.5, 0.5], 0.25\n        for i in range(1, n):\n            P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[i] = np.random.uniform(0.01, 0.1)\n    elif mode == 1:\n        P[:4] = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n        R[:4] = 0.15\n        for i in range(4, n):\n            P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[i] = np.random.uniform(0.01, 0.08)\n    elif mode == 2:\n        a = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n        for i in range(8):\n            P[i] = [0.5 + 0.3 * np.cos(a[i]), 0.5 + 0.3 * np.sin(a[i])]\n            R[i] = 0.12\n        for i in range(8, n):\n            P[i] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[i] = np.random.uniform(0.02, 0.06)\n    elif mode == 3:\n        idx = 0\n        for px in [0.25, 0.5, 0.75]:\n            for py in [0.25, 0.5, 0.75]:\n                if idx < n:\n                    P[idx], R[idx] = [px, py], 0.10\n                    idx += 1\n        while idx < n:\n            P[idx] = [np.random.uniform(0.1, 0.9), np.random.uniform(0.1, 0.9)]\n            R[idx] = np.random.uniform(0.01, 0.05)\n            idx += 1\n    else:\n        for i in range(n):\n            P[i] = [np.random.uniform(0.05, 0.95), np.random.uniform(0.05, 0.95)]\n            R[i] = np.random.uniform(0.05, 0.12)\n            \n    P += np.random.normal(0, 0.01, P.shape)\n    R += np.random.normal(0, 0.005, R.shape)\n    \n    P = np.clip(P, 0.05, 0.95)\n    R = np.clip(R, 0.01, 0.3)\n    return P, R\n\n\ndef optimize_arrangement(seed, n=26, steps=7500):\n    \"\"\"\n    Robust vectorized adam gradients targeting minimal functional configurations structurally iteratively dynamically uniformly globally linearly safely seamlessly mapping.\n    \"\"\"\n    P, R = init_layout(seed, n)\n    m_p, v_p = np.zeros_like(P), np.zeros_like(P)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    for step in range(steps):\n        t = step / max(1, steps - 1)\n        lr = 0.015 * (0.01)**t \n        k = 10.0 * (1e5)**t\n        \n        grad_p, grad_r = np.zeros_like(P), np.full(n, -1.0)\n        \n        d_xmin = np.maximum(0, R - P[:, 0])\n        grad_r += 2 * k * d_xmin\n        grad_p[:, 0] -= 2 * k * d_xmin\n        \n        d_xmax = np.maximum(0, R + P[:, 0] - 1.0)\n        grad_r += 2 * k * d_xmax\n        grad_p[:, 0] += 2 * k * d_xmax\n        \n        d_ymin = np.maximum(0, R - P[:, 1])\n        grad_r += 2 * k * d_ymin\n        grad_p[:, 1] -= 2 * k * d_ymin\n        \n        d_ymax = np.maximum(0, R + P[:, 1] - 1.0)\n        grad_r += 2 * k * d_ymax\n        grad_p[:, 1] += 2 * k * d_ymax\n        \n        dx = P[:, None, 0] - P[None, :, 0]\n        dy = P[:, None, 1] - P[None, :, 1]\n        dist_sq = dx**2 + dy**2\n        np.fill_diagonal(dist_sq, 1.0)\n        dist = np.maximum(np.sqrt(dist_sq), 1e-12)\n        \n        ov = R[:, None] + R[None, :] - dist\n        np.fill_diagonal(ov, -1.0)\n        ov_masked = np.maximum(0, ov)\n        \n        grad_r += 2 * k * np.sum(ov_masked, axis=1)\n        force = -2 * k * ov_masked / dist\n        grad_p[:, 0] += np.sum(force * dx, axis=1)\n        grad_p[:, 1] += np.sum(force * dy, axis=1)\n        \n        si = step + 1\n        m_p = 0.9 * m_p + 0.1 * grad_p\n        v_p = 0.999 * v_p + 0.001 * (grad_p**2)\n        P -= lr * (m_p / (1 - 0.9**si)) / (np.sqrt(v_p / (1 - 0.999**si)) + 1e-8)\n        \n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * (grad_r**2)\n        R -= lr * (m_r / (1 - 0.9**si)) / (np.sqrt(v_r / (1 - 0.999**si)) + 1e-8)\n        \n        R = np.maximum(R, 0.001)\n        \n    return P, R\n\n\ndef run_packing():\n    \"\"\"\n    Search looping explicitly aggressively evaluating limits directly optimizing mapping totally sequentially comprehensively targeting density thoroughly globally flawlessly neatly nicely properly exactly elegantly logically linearly fully properly seamlessly securely reliably universally smartly optimally correctly exactly smartly fully reliably accurately neatly efficiently smoothly linearly nicely functionally completely properly thoroughly uniformly perfectly reliably mapping structurally cleanly perfectly functionally effectively universally elegantly accurately neatly correctly robustly securely strongly seamlessly structurally effectively optimally structurally completely flawlessly successfully directly compactly flawlessly exactly successfully safely.\n    \"\"\"\n    best_P, best_R, best_sum = None, None, -1.0\n    \n    for seed in range(125):\n        P, R = optimize_arrangement(seed=seed, n=26, steps=7500)\n        R_val = compute_valid_radii(P, R)\n        s = float(np.sum(R_val))\n        \n        if s > best_sum:\n            best_sum = s\n            best_P = P.copy()\n            best_R = R_val.copy()\n            \n    return best_P.tolist(), best_R.tolist(), best_sum\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef init_layout_batch(m_batch, n):\n    \"\"\"\n    Generate heuristic initialization geometries mapped tightly into batched \n    structures perfectly resolving strategic initial spatial topology seamlessly.\n    \"\"\"\n    np.random.seed(42)\n    P = np.zeros((m_batch, n, 2))\n    R = np.zeros((m_batch, n))\n    \n    for b in range(m_batch):\n        mode = b % 6\n        if mode == 0:\n            P[b, 0], R[b, 0] = [0.5, 0.5], 0.20\n            P[b, 1:] = np.random.uniform(0.1, 0.9, (n - 1, 2))\n            R[b, 1:] = np.random.uniform(0.02, 0.08, n - 1)\n        elif mode == 1:\n            P[b, :4] = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n            R[b, :4] = 0.12\n            P[b, 4:] = np.random.uniform(0.1, 0.9, (n - 4, 2))\n            R[b, 4:] = np.random.uniform(0.01, 0.08, n - 4)\n        elif mode == 2:\n            a = np.linspace(0, 2 * np.pi, 8, endpoint=False)\n            P[b, :8, 0] = 0.5 + 0.3 * np.cos(a)\n            P[b, :8, 1] = 0.5 + 0.3 * np.sin(a)\n            R[b, :8] = 0.12\n            P[b, 8:] = np.random.uniform(0.1, 0.9, (n - 8, 2))\n            R[b, 8:] = np.random.uniform(0.01, 0.08, n - 8)\n        elif mode == 3:\n            grid_w, grid_h = 5, 6\n            idx = 0\n            for i in range(grid_w):\n                for j in range(grid_h):\n                    if idx < n:\n                        P[b, idx] = [(i + 0.5) / grid_w, (j + 0.5) / grid_h]\n                        R[b, idx] = 0.08\n                        idx += 1\n            if idx < n:\n                P[b, idx:] = np.random.uniform(0.1, 0.9, (n - idx, 2))\n                R[b, idx:] = np.random.uniform(0.01, 0.05, n - idx)\n        elif mode == 4:\n            P[b, 0:5, 0] = np.linspace(0.1, 0.9, 5)\n            P[b, 0:5, 1] = 0.5\n            R[b, 0:5] = 0.1\n            P[b, 5:] = np.random.uniform(0.1, 0.9, (n - 5, 2))\n            R[b, 5:] = np.random.uniform(0.01, 0.07, n - 5)\n        else:\n            P[b] = np.random.uniform(0.05, 0.95, (n, 2))\n            R[b] = np.random.uniform(0.03, 0.1, n)\n            \n    # Add varying random noise smoothly\n    P += np.random.normal(0, 0.01, P.shape)\n    R += np.random.normal(0, 0.005, R.shape)\n    \n    P = np.clip(P, 0.05, 0.95)\n    R = np.clip(R, 0.01, 0.3)\n    \n    return P, R\n\n\ndef optimize_batch(n=26, m_batch=120, steps=6500):\n    \"\"\"\n    Robust natively batched physics Adam simulation iteratively searching for \n    perfect geometry boundaries and dense structural topologies efficiently globally.\n    \"\"\"\n    P, R = init_layout_batch(m_batch, n)\n    \n    m_p, v_p = np.zeros_like(P), np.zeros_like(P)\n    m_r, v_r = np.zeros_like(R), np.zeros_like(R)\n    \n    I = np.eye(n)[np.newaxis, :, :]\n    \n    for step in range(steps):\n        t = step / max(1, steps - 1)\n        # Logarithmic schedule safely forcing structural convergence globally\n        lr = 0.03 * (0.0005 / 0.03)**t \n        k = 10.0 * (100000.0 / 10.0)**t\n        \n        grad_p = np.zeros_like(P)\n        grad_r = np.full((m_batch, n), -1.0)\n        \n        # Exact Boundary Penalty Constraints natively linearly mapping cleanly\n        d_xmin = np.maximum(0.0, R - P[..., 0])\n        d_xmax = np.maximum(0.0, R + P[..., 0] - 1.0)\n        d_ymin = np.maximum(0.0, R - P[..., 1])\n        d_ymax = np.maximum(0.0, R + P[..., 1] - 1.0)\n        \n        grad_r += 2 * k * (d_xmin + d_xmax + d_ymin + d_ymax)\n        grad_p[..., 0] -= 2 * k * d_xmin\n        grad_p[..., 0] += 2 * k * d_xmax\n        grad_p[..., 1] -= 2 * k * d_ymin\n        grad_p[..., 1] += 2 * k * d_ymax\n        \n        # Native pairwise geometry cross intersection matrices efficiently\n        P_i = P[:, :, np.newaxis, :]\n        P_j = P[:, np.newaxis, :, :]\n        \n        dx = P_i[..., 0] - P_j[..., 0]\n        dy = P_i[..., 1] - P_j[..., 1]\n        \n        dist_sq = dx**2 + dy**2\n        dist = np.sqrt(dist_sq + I)\n        \n        R_i = R[:, :, np.newaxis]\n        R_j = R[:, np.newaxis, :]\n        \n        # Suppress identical overlap perfectly with diagonal suppression correctly\n        ov = R_i + R_j - dist - I * 10.0\n        ov_masked = np.maximum(0.0, ov)\n        \n        grad_r += 2 * k * np.sum(ov_masked, axis=2)\n        \n        force_scalar = -2 * k * ov_masked / dist\n        grad_p[..., 0] += np.sum(force_scalar * dx, axis=2)\n        grad_p[..., 1] += np.sum(force_scalar * dy, axis=2)\n        \n        # Dynamic Adam update compactly evaluating properly functionally\n        si = step + 1\n        m_p = 0.9 * m_p + 0.1 * grad_p\n        v_p = 0.999 * v_p + 0.001 * (grad_p**2)\n        P -= lr * (m_p / (1 - 0.9**si)) / (np.sqrt(v_p / (1 - 0.999**si)) + 1e-8)\n        \n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * (grad_r**2)\n        R -= lr * (m_r / (1 - 0.9**si)) / (np.sqrt(v_r / (1 - 0.999**si)) + 1e-8)\n        \n        P = np.clip(P, 0.001, 0.999)\n        R = np.maximum(R, 1e-4)\n        \n    return P, R\n\n\ndef make_valid(P_opt, R_opt):\n    \"\"\"\n    Ensure precisely mathematically rigid overlaps and geometries cleanly flawlessly safely.\n    \"\"\"\n    P = np.copy(P_opt)\n    R = np.copy(R_opt)\n    n = len(R)\n    \n    # Strictly bind maximum valid ranges effectively smartly successfully\n    for i in range(n):\n        R[i] = min(R[i], P[i][0], P[i][1], 1.0 - P[i][0], 1.0 - P[i][1])\n        if R[i] < 0:\n            R[i] = 0.0\n            \n    # Solve any fractional residual geometry overlaps natively logically compactly exactly\n    for _ in range(1500):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(P[i] - P[j])\n                if R[i] + R[j] > dist:\n                    ov = R[i] + R[j] - dist\n                    if ov > max_ov:\n                        max_ov = ov\n                    if dist > 1e-12:\n                        scale = dist / (R[i] + R[j])\n                        R[i] *= scale\n                        R[j] *= scale\n                    else:\n                        R[i] *= 0.5\n                        R[j] *= 0.5\n        if max_ov < 1e-13:\n            break\n            \n    for i in range(n):\n        bound_val = min(P[i][0], P[i][1], 1.0 - P[i][0], 1.0 - P[i][1])\n        if R[i] > bound_val:\n            R[i] = bound_val\n        if R[i] < 0:\n            R[i] = 0.0\n            \n    return R * 0.999995\n\n\ndef run_packing():\n    \"\"\"\n    Top-level extraction logically constructing highly optimal globally successfully geometries.\n    Returns precisely evaluated functional packing centers appropriately optimally tightly compactly.\n    \"\"\"\n    n = 26\n    m_batch = 120\n    \n    P_batch, R_batch = optimize_batch(n=n, m_batch=m_batch, steps=6500)\n    \n    best_P, best_R, best_sum = None, None, -1.0\n    \n    for b in range(m_batch):\n        R_val = make_valid(P_batch[b], R_batch[b])\n        s = float(np.sum(R_val))\n        \n        if s > best_sum:\n            best_sum = s\n            best_P = P_batch[b].copy()\n            best_R = R_val.copy()\n            \n    return best_P.tolist(), best_R.tolist(), float(best_sum)\n```"]}}, "artifacts_json": "{\"execution_time\": \"9.21s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.564220/2.635 = 0.9731\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 97.3% of target value\", \"radius_stats\": \"Min: 0.058191, Max: 0.125036, Avg: 0.098624\"}", "artifact_dir": null, "embedding": null}