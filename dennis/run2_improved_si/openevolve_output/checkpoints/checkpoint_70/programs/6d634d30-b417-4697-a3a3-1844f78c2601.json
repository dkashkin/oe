{"id": "6d634d30-b417-4697-a3a3-1844f78c2601", "code": "import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 56\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]\n            r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]\n            r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]\n            r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]\n            r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing", "changes_description": null, "language": "python", "parent_id": "65a15161-baef-46ed-a339-8a9ad827cecf", "generation": 2, "timestamp": 1771876552.2376316, "iteration_found": 68, "metrics": {"validity": 1.0, "sum_radii": 2.6170181736741327, "target_ratio": 0.9931757774854394, "combined_score": 0.9931757774854394, "radius_variance": 0.0055828838710428, "spatial_spread": 0.19268513842131038, "eval_time": 36.11625599861145}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Size placement: Bias the initialization to push larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9908 \u2192 0.0000. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: '[' was never closed (tmp6wuuolkj.py, line 62)\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run2_improved_si/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run2_improved_si/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: '[' was never closed (tmp6wuuolkj.py, line 62)\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6109, target_ratio: 0.9908, combined_score: 0.9908, radius_variance: 0.0055, spatial_spread: 0.1935, eval_time: 30.1283\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6119, target_ratio: 0.9912, combined_score: 0.9912, radius_variance: 0.0056, spatial_spread: 0.1934, eval_time: 31.4919\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6144, target_ratio: 0.9922, combined_score: 0.9922, radius_variance: 0.0045, spatial_spread: 0.1921, eval_time: 38.8016\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9922)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 60\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 6\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        else:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    for b in range(B):\n        cb = c[b]\n        dist_matrix = np.linalg.norm(cb[:, None, :] - cb[None, :, :], axis=-1)\n        \n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_matrix[i, j])\n                \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        c_obj = -np.ones(n)\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6144), Performs well on target_ratio (0.9922), Performs well on combined_score (0.9922), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1921), Performs well on eval_time (38.8016)\n\n### Program 2 (Score: 0.9912)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 50\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # Initialize seeds with structurally diverse geometrical priors\n    for b in range(B):\n        mode = b % 7\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor large circles in the corners, leaving a hollow middle for scattering\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution + central disruption\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: \n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # Alternative tight concentric shells\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            # 5 large circles: 4 corners + 1 center\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.15\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.15\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        else:\n            # Random scattering\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n\n        # Add random noise to break perfect symmetries and escape saddle points\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    # Keep initial guesses strictly inside feasible boundaries\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state tracking\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Physics-inspired iterative penalty method for joint optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        # Exponential learning rate decay and escalating penalty enforcement\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Vectorized pairwise distance computation\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps penalty and gradients\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0  # Erase self-overlaps\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Wall boundary penalties and gradients\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Combine objectives: max sum(r) subject to min(violations)\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like random exploration in early stages\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam update mechanics for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam update mechanics for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft physical bounding box\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Pre-compute static LP constraint matrix to severely reduce overhead\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    # Post-process with exact linear programming for pristine mathematical validity\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            # Include a strict safety epsilon to obliterate floating point error risk\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            # Guarantee bounds definitively\n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    # Fallback to defaults in case of catastrophic solver failure\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6119), Performs well on target_ratio (0.9912), Performs well on combined_score (0.9912), Performs well on radius_variance (0.0056), Performs well on spatial_spread (0.1934), Performs well on eval_time (31.4919)\n\n### Program 3 (Score: 0.9908)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 48  # Number of parallel initializations to search diverse topologies\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]; r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6109), Performs well on target_ratio (0.9908), Performs well on combined_score (0.9908), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1935), Performs well on eval_time (30.1283)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.3333)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 96  # Number of parallel initializations to search diverse topologies\n    iters = 15000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    # Initialize with heuristics to bias toward corners, edges, and dense center\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor largest possible circles in the corners\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: \n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # 1 massive center, 10 around, 15 around\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            # 5 large: 1 center, 4 corners\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.2\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.15\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.15\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.6 + 0.2\n            r[b, 5:] = 0.05\n        elif mode == 6:\n            # 2 large in opposite corners\n            c[b, 0] = [0.2, 0.2]; r[b, 0] = 0.2\n            c[b, 1] = [0.8, 0.8]; r[b, 1] = 0.2\n            c[b, 2:] = np.random.rand(n - 2, 2) * 0.8 + 0.1\n            r[b, 2:] = 0.05\n        elif mode == 7:\n            # Spiral distribution (Golden angle)\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1))\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n        else:\n            # Random scattering\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n\n        # Add random noise to break perfect symmetry\n        c[b] += np.random.randn(n, 2) * 0.02\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Iterative penalty method optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        # Decaying learning rate and exponentially increasing penalty weight\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Pairwise distances\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps computation\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        \n        # Zero out diagonal self-overlap\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Boundary violations\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Gradients aggregation\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like perturbation\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam updates for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam updates for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft boundary clipping\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Resolve finalized radii via exact linear programming for maximum possible fit\n    for b in range(B):\n        cb = c[b]\n        dist_matrix = np.linalg.norm(cb[:, None, :] - cb[None, :, :], axis=-1)\n        \n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_matrix[i, j])\n                \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        c_obj = -np.ones(n)\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            r_opt = res.x.copy()\n            \n            # Enforce boundaries strictly\n            max_bounds = np.minimum.reduce([cb[:, 0], 1.0 - cb[:, 0], cb[:, 1], 1.0 - cb[:, 1]])\n            r_opt = np.minimum(r_opt, np.maximum(0.0, max_bounds))\n            \n            # Enforce overlaps strictly using proportional reduction fallback\n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(5):\n                r_sum_opt = r_opt[:, None] + r_opt[None, :]\n                overlap_mask = r_sum_opt > dist_fallback - 1e-11\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback - 1e-11, r_sum_opt, out=scales, where=valid_mask)\n                r_opt *= np.min(scales, axis=1)\n\n            # Safety margin to cleanly handle any remaining micro floating point inaccuracies\n            r_opt = np.maximum(0.0, r_opt - 1e-11)\n\n            s = np.sum(r_opt)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = r_opt.copy()\n\n    # Fallback to defaults if LP fails on all topologies\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n### Program D2 (Score: 0.3333)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a fully vectorized\n    iterative Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 120  # Extensive batch size for parallel topology exploration\n    iters = 18000  # High iteration count for deep convergence\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n\n    # Initialize seeds with structurally diverse geometrical priors\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor large circles in the corners, leaving a hollow middle for scattering\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution + central disruption\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n: \n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # Alternative tight concentric shells\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            # 5 large circles: 4 corners + 1 center\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.15\n            c[b, 1] = [0.15, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.85, 0.15]; r[b, 2] = 0.15\n            c[b, 3] = [0.15, 0.85]; r[b, 3] = 0.15\n            c[b, 4] = [0.85, 0.85]; r[b, 4] = 0.15\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            # Mostly random but dominated by 3 massive circles acting as repellers\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.02 + 0.01\n            for i in range(3):\n                r[b, i] = 0.15\n        else:\n            # Radial size gradient: large in the center, smaller towards edges\n            for i in range(n):\n                c[b, i] = np.random.rand(2) * 0.8 + 0.1\n                d_center = np.linalg.norm(c[b, i] - [0.5, 0.5])\n                r[b, i] = max(0.01, 0.12 - 0.15 * d_center)\n\n        # Add random noise to break perfect symmetries and escape saddle points\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    # Keep initial guesses strictly inside feasible boundaries\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state tracking\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Physics-inspired iterative penalty method for joint optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        \n        # Exponential learning rate decay and escalating penalty enforcement\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (1000000.0 ** progress)\n\n        # Vectorized pairwise distance computation\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps penalty and gradients\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0  # Erase self-overlaps\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Wall boundary penalties and gradients\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Combine objectives: max sum(r) subject to min(violations)\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like random exploration in early stages\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam update mechanics for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam update mechanics for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft physical bounding box\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Pre-compute static LP constraint matrix to severely reduce overhead\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    # Post-process with exact linear programming for pristine mathematical validity\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            # Include a strict safety epsilon to obliterate floating point error risk\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            # Guarantee bounds definitively\n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    # Fallback to defaults in case of catastrophic solver failure (highly unlikely)\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nKey features: Alternative approach to stage1_passed, Alternative approach to error\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a simulated\n    physics model with Adam optimization and exact linear programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 60  # Number of parallel initializations to search diverse topologies\n    iters = 8000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    # Initialize with heuristics to bias toward corners, edges, and dense center\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 5\n        \n        # Base random scattering for all circles\n        c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n        r[b] = np.random.rand(n) * 0.05 + 0.01\n\n        if mode == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            # Anchor largest possible circles in the corners\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            # Rough grid-like distribution\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]; r[b, 25] = 0.05\n        elif mode == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n: break\n                if idx == n: break\n        elif mode == 4:\n            # 1 massive center, others scattered\n            c[b, 0] = [0.5, 0.5]; r[b, 0] = 0.45\n            c[b, 1:] = np.random.rand(n - 1, 2) * 0.9 + 0.05\n            r[b, 1:] = 0.02\n\n        # Add random noise to break perfect symmetry\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    mask = np.eye(n, dtype=bool)[None, :, :]\n\n    # Iterative penalty method optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        # Decaying learning rate and exponentially increasing penalty weight\n        lr = 0.01 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Pairwise distances\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps computation\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        \n        # Zero out diagonal self-overlap\n        overlap[mask] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Boundary violations\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Gradients aggregation\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like perturbation\n        if progress < 0.7:\n            noise_scale = 1e-3 * (1.0 - progress / 0.7)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam updates for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam updates for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft boundary clipping\n        c = np.clip(c, 0.001, 0.999)\n        r = np.clip(r, 0.001, 0.5)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Resolve finalized radii via exact linear programming for maximum possible fit\n    for b in range(B):\n        cb = c[b].copy()\n        \n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist_val = np.linalg.norm(cb[i] - cb[j])\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_val)\n                \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        c_obj = -np.ones(n)\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        try:\n            res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n            if res.success:\n                rb = res.x\n                # Ensure a slight numerical buffer to prevent invalid intersection\n                rb = np.maximum(rb - 1e-8, 0)\n                \n                sum_r = np.sum(rb)\n                if sum_r > best_sum:\n                    best_sum = sum_r\n                    best_c = cb.copy()\n                    best_r = rb.copy()\n        except Exception:\n            pass\n\n    # Fallback to defaults\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based iterative circle packing for n=26 circles\"\"\"\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a simulated\n    physics model with Adam optimization and final linear programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 60  # Number of parallel restarts to explore different topologies\n    iters = 15000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    # Heuristic Initialization: Bias toward corners, edges, and center\n    # Introducing structural diversity and breaking symmetry.\n    for b in range(B):\n        if b % 5 == 0:\n            # Pattern 1: One huge center, others in concentric rings\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [\n                    0.5 + 0.25 * np.cos(angle),\n                    0.5 + 0.25 * np.sin(angle)\n                ]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [\n                    0.5 + 0.45 * np.cos(angle),\n                    0.5 + 0.45 * np.sin(angle)\n                ]\n                r[b, i + 9] = 0.05\n            c[b] += np.random.randn(n, 2) * 0.01\n        elif b % 5 == 1:\n            # Pattern 2: Four massive circles in corners to maximize space, rest scattered\n            c[b, 0] = [0.15, 0.15]; r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]; r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]; r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]; r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif b % 5 == 2:\n            # Pattern 3: 5x5 Grid + 1\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n            c[b] += np.random.randn(n, 2) * 0.02\n        elif b % 5 == 3:\n            # Pattern 4: Roughly hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > 26: \n                    cols = 26 - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == 26: \n                        break\n                if idx == 26: \n                    break\n            c[b] += np.random.randn(n, 2) * 0.01\n        else:\n            # Pattern 5: Random scattering\n            c[b] = np.random.rand(n, 2)\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n\n    # Keep initial guesses strictly inside bounds\n    c = np.clip(c, 0.05, 0.95)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam Optimizer State\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    mask = np.eye(n, dtype=bool)[None, :, :]\n\n    # Physics-based iterative penalty method optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.01 * (0.01 ** progress)\n        w_pen = 10.0 * (10000.0 ** progress)\n\n        # Compute pairwise distances\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Compute overlap violations\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[mask] = 0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Compute boundary violations\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Combine gradients (maximize sum of radii, penalize violations)\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like random perturbation to escape local minima\n        if progress < 0.8:\n            noise_scale = 1e-4 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Apply Adam Updates\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Clip variables to feasible numerical ranges\n\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 30  # Number of parallel initializations to search diverse topologies\n    iters = 10000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    # Initialize with heuristics to bias toward corners, edges, and dense center\n    np.random.seed(42)\n    for b in range(B):\n        if b % 4 == 0:\n            # Concentric rings around a massive center\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [\n                    0.5 + 0.25 * np.cos(angle),\n                    0.5 + 0.25 * np.sin(angle)\n                ]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [\n                    0.5 + 0.45 * np.cos(angle),\n                    0.5 + 0.45 * np.sin(angle)\n                ]\n                r[b, i + 9] = 0.05\n        elif b % 4 == 1:\n            # Anchor largest possible circles in the corners\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif b % 4 == 2:\n            # Rough grid-like distribution\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif b % 4 == 3:\n            # Hexagonal dense packing\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > 26: \n                    cols = 26 - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == 26:\n                        break\n                if idx == 26:\n                    break\n                    \n        # Add random noise to break perfect symmetry\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    # Iterative penalty method optimization\n    for step in range(1, iters + 1):\n        progress = step / iters\n        # Decaying learning rate and exponentially increasing penalty weight\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        # Pairwise distances\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        # Overlaps computation\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        \n        # Zero out diagonal self-overlap\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        # Boundary violations\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        # Gradients aggregation\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        # Simulated annealing-like perturbation\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        # Adam updates for centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        # Adam updates for radii\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        # Soft boundary clipping\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Resolve finalized radii via exact linear programming for maximum possible fit\n    for b in range(B):\n        cb = c[b]\n        dist_matrix = np.linalg.norm(cb[:, None, :] - cb[None, :, :], axis=-1)\n        \n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                row[j] = 1.0\n                A_ub.append(row)\n                b_ub.append(dist_matrix[i, j])\n                \n        A_ub = np.array(A_ub)\n        b_ub = np.array(b_ub)\n        c_obj = -np.ones(n)\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            # Include a strict safety margin to handle floating point accuracy\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    # Fallback to defaults\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based iterative circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses a simulated\n    physics model with Adam optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    b_count = 16  # Number of parallel restarts to explore different topologies\n    iters = 3500\n\n    centers = np.zeros((b_count, n, 2))\n    radii = np.ones((b_count, n)) * 0.001\n\n    # Heuristic Initialization: Bias toward corners, edges, and center\n    # Introducing structural diversity and breaking symmetry.\n    for b in range(b_count):\n        if b % 4 == 0:\n            # Pattern 1: One huge center, others in rings\n            centers[b, 0] = [0.5, 0.5]\n            radii[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8 + np.random.rand() * 0.2\n                centers[b, i + 1] = [\n                    0.5 + 0.25 * np.cos(angle),\n                    0.5 + 0.25 * np.sin(angle)\n                ]\n                radii[b, i + 1] = 0.05\n            for i in range(17):\n                angle = 2 * np.pi * i / 17 + np.random.rand() * 0.2\n                centers[b, i + 9] = [\n                    0.5 + 0.45 * np.cos(angle),\n                    0.5 + 0.45 * np.sin(angle)\n                ]\n                radii[b, i + 9] = 0.01\n        elif b % 4 == 1:\n            # Pattern 2: Four massive circles in corners to maximize space, rest scattered\n            centers[b, 0] = [0.2, 0.2]\n            radii[b, 0] = 0.15\n            centers[b, 1] = [0.8, 0.2]\n            radii[b, 1] = 0.15\n            centers[b, 2] = [0.2, 0.8]\n            radii[b, 2] = 0.15\n            centers[b, 3] = [0.8, 0.8]\n            radii[b, 3] = 0.15\n            centers[b, 4:] = np.random.rand(n - 4, 2)\n            radii[b, 4:] = 0.01\n        elif b % 4 == 2:\n            # Pattern 3: Biased mostly towards edges to fill boundaries\n            for i in range(n):\n                if i < 2:\n                    centers[b,\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["import numpy as np\nfrom scipy.optimize import linprog\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii. Uses an iterative\n    Adam-based penalty method followed by exact Linear Programming.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    B = 56\n    iters = 12000\n\n    c = np.zeros((B, n, 2))\n    r = np.zeros((B, n))\n\n    np.random.seed(42)\n    for b in range(B):\n        mode = b % 8\n        if mode == 0:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.2\n            for i in range(8):\n                angle = 2 * np.pi * i / 8\n                c[b, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n                r[b, i + 1] = 0.1\n            for i in range(17):\n                angle = 2 * np.pi * i / 17\n                c[b, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 9] = 0.05\n        elif mode == 1:\n            c[b, 0] = [0.15, 0.15]\n            r[b, 0] = 0.15\n            c[b, 1] = [0.85, 0.15]\n            r[b, 1] = 0.15\n            c[b, 2] = [0.15, 0.85]\n            r[b, 2] = 0.15\n            c[b, 3] = [0.85, 0.85]\n            r[b, 3] = 0.15\n            c[b, 4:] = np.random.rand(n - 4, 2) * 0.6 + 0.2\n            r[b, 4:] = 0.05\n        elif mode == 2:\n            for i in range(25):\n                row, col = divmod(i, 5)\n                c[b, i] = [0.1 + 0.2 * col, 0.1 + 0.2 * row]\n                r[b, i] = 0.08\n            c[b, 25] = [0.5, 0.5]\n            r[b, 25] = 0.05\n        elif mode == 3:\n            idx = 0\n            for row in range(6):\n                cols = 5 if row % 2 == 0 else 4\n                if idx + cols > n:\n                    cols = n - idx\n                for col in range(cols):\n                    x = 0.1 + col * 0.2 + (0.1 if row % 2 != 0 else 0)\n                    y = 0.1 + row * 0.16\n                    c[b, idx] = [x, y]\n                    r[b, idx] = 0.08\n                    idx += 1\n                    if idx == n:\n                        break\n                if idx == n:\n                    break\n        elif mode == 4:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.25\n            for i in range(10):\n                angle = 2 * np.pi * i / 10\n                c[b, i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n                r[b, i + 1] = 0.08\n            for i in range(15):\n                angle = 2 * np.pi * i / 15\n                c[b, i + 11] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n                r[b, i + 11] = 0.04\n        elif mode == 5:\n            c[b, 0] = [0.5, 0.5]\n            r[b, 0] = 0.18\n            c[b, 1] = [0.15, 0.15]\n            r[b, 1] = 0.12\n            c[b, 2] = [0.85, 0.15]\n            r[b, 2] = 0.12\n            c[b, 3] = [0.15, 0.85]\n            r[b, 3] = 0.12\n            c[b, 4] = [0.85, 0.85]\n            r[b, 4] = 0.12\n            c[b, 5:] = np.random.rand(n - 5, 2) * 0.8 + 0.1\n            r[b, 5:] = 0.04\n        elif mode == 6:\n            c[b] = np.random.rand(n, 2) * 0.8 + 0.1\n            r[b] = np.random.rand(n) * 0.05 + 0.01\n        elif mode == 7:\n            for i in range(n):\n                theta = i * np.pi * (3 - np.sqrt(5))\n                radius = 0.45 * np.sqrt(i / (n - 1)) if n > 1 else 0\n                c[b, i] = [0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)]\n                r[b, i] = 0.05\n\n        c[b] += np.random.randn(n, 2) * 0.01\n\n    c = np.clip(c, 0.01, 0.99)\n    r = np.clip(r, 0.01, 0.5)\n\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n\n    for step in range(1, iters + 1):\n        progress = step / iters\n        lr = 0.02 * (0.01 ** progress)\n        w_pen = 10.0 * (100000.0 ** progress)\n\n        diff = c[:, :, None, :] - c[:, None, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + 1e-12)\n\n        r_sum = r[:, :, None] + r[:, None, :]\n        overlap = np.maximum(0, r_sum - dist)\n        overlap[:, np.arange(n), np.arange(n)] = 0.0\n\n        grad_r_overlap = np.sum(overlap, axis=2)\n        direction = diff / dist[..., None]\n        grad_c_overlap = np.sum(-overlap[..., None] * direction, axis=2)\n\n        viol_x_low = np.maximum(0, r - c[:, :, 0])\n        viol_x_high = np.maximum(0, c[:, :, 0] + r - 1)\n        viol_y_low = np.maximum(0, r - c[:, :, 1])\n        viol_y_high = np.maximum(0, c[:, :, 1] + r - 1)\n\n        grad_r_bound = viol_x_low + viol_x_high + viol_y_low + viol_y_high\n        grad_c_x_bound = -viol_x_low + viol_x_high\n        grad_c_y_bound = -viol_y_low + viol_y_high\n        grad_c_bound = np.stack([grad_c_x_bound, grad_c_y_bound], axis=-1)\n\n        grad_r = -1.0 + w_pen * (grad_r_overlap + grad_r_bound)\n        grad_c = w_pen * (grad_c_overlap + grad_c_bound)\n\n        if progress < 0.8:\n            noise_scale = 1e-3 * (1.0 - progress / 0.8)\n            c += np.random.randn(*c.shape) * noise_scale\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c**2)\n        m_c_hat = m_c / (1 - beta1**step)\n        v_c_hat = v_c / (1 - beta2**step)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r**2)\n        m_r_hat = m_r / (1 - beta1**step)\n        v_r_hat = v_r / (1 - beta2**step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n\n        c = np.clip(c, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    i_idx, j_idx = np.triu_indices(n, k=1)\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1.0\n    A_ub[np.arange(len(i_idx)), j_idx] = 1.0\n    c_obj = -np.ones(n)\n\n    for b in range(B):\n        cb = c[b]\n        \n        diff = cb[:, None, :] - cb[None, :, :]\n        dist_matrix = np.linalg.norm(diff, axis=-1)\n        b_ub = dist_matrix[i_idx, j_idx]\n        \n        bounds = []\n        for i in range(n):\n            cx, cy = cb[i]\n            max_r = min(cx, 1.0 - cx, cy, 1.0 - cy)\n            max_r = max(0.0, float(max_r))\n            bounds.append((0, max_r))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n        \n        if res.success:\n            opt_r = res.x\n            opt_r = np.maximum(opt_r - 1e-9, 0.0)\n            \n            for i in range(n):\n                opt_r[i] = min(opt_r[i], bounds[i][1])\n            \n            dist_fallback = dist_matrix.copy()\n            np.fill_diagonal(dist_fallback, np.inf)\n            \n            for _ in range(2):\n                r_sum_opt = opt_r[:, None] + opt_r[None, :]\n                overlap_mask = r_sum_opt > dist_fallback\n                if not np.any(overlap_mask):\n                    break\n                scales = np.ones_like(dist_fallback)\n                valid_mask = overlap_mask & (r_sum_opt > 1e-12)\n                np.divide(dist_fallback, r_sum_opt, out=scales, where=valid_mask)\n                opt_r *= np.min(scales, axis=1)\n\n            opt_r = np.maximum(opt_r - 1e-11, 0.0)\n            \n            s = np.sum(opt_r)\n            if s > best_sum:\n                best_sum = s\n                best_c = cb.copy()\n                best_r = opt_r.copy()\n\n    if best_c is None:\n        best_c = c[0].copy()\n        best_r = np.zeros(n)\n        best_sum = 0.0\n\n    return best_c, best_r, best_sum\n\nrun_packing = construct_packing"]}}, "artifacts_json": "{\"execution_time\": \"36.12s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.617018/2.635 = 0.9932\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.3% of target value\", \"radius_stats\": \"Min: 0.060623, Max: 0.134561, Avg: 0.100655\"}", "artifact_dir": null, "embedding": null}