{"id": "a1eafec0-b4c7-40e3-bd6d-d4190227fe3b", "code": "# EVOLVE-BLOCK-START\n\"\"\"Constructor-based batched circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    \"\"\"Perform a batched Adam optimization step.\"\"\"\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads_batch(x, y, r, pm):\n    \"\"\"\n    Calculate the physics forces (gradients) simultaneously for a batch of simulated \n    seed environments, maximizing processing speed through strict numpy vectorization.\n    \"\"\"\n    # Calculate all pairwise directional components and distances efficiently \n    dx = x[:, :, None] - x[:, None, :]\n    dy = y[:, :, None] - y[:, None, :]\n    dist = np.hypot(dx, dy)\n    \n    # Exclude identity self-comparisons bounds safely \n    S, n = x.shape\n    idx = np.arange(n)\n    dist[:, idx, idx] = 1000.0\n    \n    # Derive boundary overlaps mapped systems safely\n    overlap = r[:, :, None] + r[:, None, :] - dist\n    overlap = np.maximum(0.0, overlap)\n    \n    # Evaluate physics interactions with zero-div avoidance\n    factor = 2.0 * overlap / (dist + 1e-12)\n    \n    dl_dx = np.sum(factor * (-dx), axis=2)\n    dl_dy = np.sum(factor * (-dy), axis=2)\n    dl_dr = np.sum(2.0 * overlap, axis=2)\n    \n    # Execute wall box repulsive dynamic components \n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += 2.0 * (-wl + wr)\n    dl_dy += 2.0 * (-wb + wt)\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Apply multiplicative limit schedule multipliers smoothly\n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Maximize layout density concurrently by scaling correctly over negative gradient logic\n    dl_dr = pm * dl_dr - 1.0\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef construct_packing():\n    \"\"\"Build densely packed configuration by aggressively evolving geometrically varied setups concurrently.\"\"\"\n    n = 26\n    S = 90  # Increased batch size perfectly ensures maximal heuristic coverage mapping geometries  \n    \n    x = np.zeros((S, n))\n    y = np.zeros((S, n))\n    r = np.zeros((S, n))\n    \n    np.random.seed(31415)\n    \n    idx = 0\n    \n    # Pre-calculated layered arrangements securely resolving local permutations \n    configs = [\n        [5, 5, 6, 5, 5],\n        [6, 5, 4, 5, 6],\n        [5, 6, 4, 6, 5],\n        [4, 6, 6, 6, 4],\n        [6, 7, 7, 6],\n        [7, 6, 6, 7],\n        [5, 4, 8, 4, 5],\n        [4, 5, 8, 5, 4],\n        [5, 4, 4, 4, 4, 5], \n        [5, 4, 5, 4, 4, 4], \n    ]\n    \n    for config in configs:\n        if idx >= S: \n            break\n        pts, rs = [], []\n        num_rows = len(config)\n        for r_idx, count in enumerate(config):\n            y_pos = 0.1 + 0.8 * (r_idx / max(1, num_rows - 1))\n            for c_idx in range(count):\n                x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1)) if count > 1 else 0.5\n                # Break symmetries initially properly mapping cleanly \n                x_pos += np.random.uniform(-0.015, 0.015)\n                y_pos += np.random.uniform(-0.015, 0.015)\n                pts.append([np.clip(x_pos, 0.05, 0.95), np.clip(y_pos, 0.05, 0.95)])\n                rs.append(np.random.uniform(0.045, 0.065))\n                \n        x[idx] = np.array([p[0] for p in pts[:n]])\n        y[idx] = np.array([p[1] for p in pts[:n]])\n        r[idx] = np.array(rs[:n])\n        idx += 1\n\n    # Concentric Array setup mappings evaluations securely maps core elements layouts loops fixes validations logic \n    if idx < S:\n        pts = [[0.5, 0.5]]\n        for i in range(6):\n            a = 2.0 * np.pi * i / 6.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.16 * np.cos(a), 0.5 + 0.16 * np.sin(a)])\n        for i in range(11):\n            a = 2.0 * np.pi * i / 11.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.35 * np.cos(a), 0.5 + 0.35 * np.sin(a)])\n        corners_edges = [(0.12, 0.12), (0.88, 0.12), (0.12, 0.88), (0.88, 0.88),\n                         (0.12, 0.5), (0.88, 0.5), (0.5, 0.12), (0.5, 0.88)]\n        for ce in corners_edges:\n            pts.append([ce[0] + np.random.uniform(-0.02, 0.02), \n                        ce[1] + np.random.uniform(-0.02, 0.02)])\n        x[idx] = np.array([p[0] for p in pts[:n]])\n        y[idx] = np.array([p[1] for p in pts[:n]])\n        r[idx] = np.random.uniform(0.04, 0.07, n)\n        idx += 1\n\n    if idx < S:\n        pts = [[0.5, 0.5]]\n        for i in range(7):\n            a = 2.0 * np.pi * i / 7.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.18 * np.cos(a), 0.5 + 0.18 * np.sin(a)])\n        for i in range(12):\n            a = 2.0 * np.pi * i / 12.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.38 * np.cos(a), 0.5 + 0.38 * np.sin(a)])\n        for _ in range(6):\n            if np.random.random() > 0.5:\n                px = np.random.uniform(0.05, 0.95)\n                py = 0.05 if np.random.random() > 0.5 else 0.95\n            else:\n                py = np.random.uniform(0.05, 0.95)\n                px = 0.05 if np.random.random() > 0.5 else 0.95\n            pts.append([px, py])\n            \n        x[idx] = np.array([p[0] for p in pts[:n]])\n        y[idx] = np.array([p[1] for p in pts[:n]])\n        r[idx] = np.random.uniform(0.04, 0.07, n)\n        idx += 1\n\n    # Completely randomly structured elements maps sets permutations setups \n    while idx < S:\n        tx = np.random.uniform(0.05, 0.95, n)\n        ty = np.random.uniform(0.05, 0.95, n)\n        \n        mode = idx % 4\n        if mode == 0:\n            tr = np.random.uniform(0.02, 0.13, n)\n            dist = np.minimum(np.minimum(np.hypot(tx, ty), np.hypot(tx-1, ty)), \n                              np.minimum(np.hypot(tx, ty-1), np.hypot(tx-1, ty-1)))\n            order = np.argsort(dist)\n            tr = np.sort(tr)[::-1]\n            tro = np.zeros(n)\n            tro[order] = tr\n            r[idx] = tro\n        elif mode == 1:\n            tr = np.random.uniform(0.02, 0.13, n)\n            dist = np.hypot(tx - 0.5, ty - 0.5)\n            order = np.argsort(dist)\n            tr = np.sort(tr)[::-1]\n            tro = np.zeros(n)\n            tro[order] = tr\n            r[idx] = tro\n        elif mode == 2:\n            tr = np.random.uniform(0.03, 0.12, n)\n            dist_edges = np.minimum(np.minimum(tx, 1.0-tx), np.minimum(ty, 1.0-ty))\n            order = np.argsort(dist_edges)\n            tr = np.sort(tr)[::-1]\n            tro = np.zeros(n)\n            tro[order] = tr\n            r[idx] = tro\n        else:\n            r[idx] = np.random.uniform(0.05, 0.09, n)\n            \n        x[idx] = tx\n        y[idx] = ty\n        idx += 1\n\n    # Apply physical state gradient resolution vectors mapped securely mapping layouts shapes properly \n    m_x, v_x = np.zeros((S, n)), np.zeros((S, n))\n    m_y, v_y = np.zeros((S, n)), np.zeros((S, n))\n    m_r, v_r = np.zeros((S, n)), np.zeros((S, n))\n    \n    steps = 15000\n    pms = np.minimum(10.0 * (1.0011 ** np.arange(steps)), 1000000.0)\n    lrs = np.maximum(0.015 * (0.9997 ** np.arange(steps)), 1e-4)\n    noise_steps = 7500\n    \n    t = 0\n    for step in range(steps):\n        pm = pms[step]\n        lr = lrs[step]\n        \n        gx, gy, gr = get_grads_batch(x, y, r, pm)\n        \n        t += 1\n        x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, lr)\n        y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, lr)\n        r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, lr)\n        \n        # Shake configurations strategically avoiding minima loops fully evaluations boundaries fixes checking validations \n        if step < noise_steps:\n            noise_scale = 0.005 * (1.0 - step / noise_steps)\n            x += np.random.normal(0, noise_scale, (S, n))\n            y += np.random.normal(0, noise_scale, (S, n))\n            if step % 5 == 0:\n                r += np.random.normal(0, noise_scale * 0.3, (S, n))\n                \n        x = np.clip(x, 0.001, 0.999)\n        y = np.clip(y, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    for s in range(S):\n        cx, cy, cr = x[s].copy(), y[s].copy(), r[s].copy()\n        \n        # Prevent sizes mapped optimizations evaluation values bounds paths securely rules variables bounds \n        cr = np.maximum(cr, 0.0)\n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        \n        # Aggressive geometry overlap solver strictly passes validation boundaries securely passes checks  \n        for _ in range(160):\n            cr = np.minimum(cr, cx)\n            cr = np.minimum(cr, cy)\n            cr = np.minimum(cr, 1.0 - cx)\n            cr = np.minimum(cr, 1.0 - cy)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = cx[i] - cx[j]\n                    dy_v = cy[i] - cy[j]\n                    dist_v = np.hypot(dx_v, dy_v)\n                    if cr[i] + cr[j] > dist_v:\n                        scale = dist_v / max(cr[i] + cr[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            cr[i] *= scale\n                            cr[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Resolve any residual strictness limitations configurations setups validations cleanly cleanly variations setups limitations boundaries logic layouts\n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        cr *= 0.9999999\n        \n        sum_r = np.sum(cr)\n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((cx, cy))\n            best_radii = cr.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "3aa4a64b-a55e-44f3-b561-1e4bd7d2a5f9", "generation": 3, "timestamp": 1771995340.6402457, "iteration_found": 17, "metrics": {"validity": 1.0, "sum_radii": 2.612141240498306, "target_ratio": 0.9913249489557139, "combined_score": 0.9913249489557139, "radius_variance": 0.0044062440215964635, "spatial_spread": 0.18874250252639915, "eval_time": 29.112488746643066}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.624686263821332, "target_ratio": 0.9960858686228965, "combined_score": 0.9960858686228965, "radius_variance": 0.004514058746871209, "spatial_spread": 0.18847769600192624, "eval_time": 16.82839035987854}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9961\n- Feature coordinates: \n- Focus areas: - Fitness improved: 0.9902 \u2192 0.9961\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n16.83s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.624686/2.635 = 0.9961\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.6% of target value\n```\n\n### radius_stats\n```\nMin: 0.069012, Max: 0.136381, Avg: 0.100949\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6092, target_ratio: 0.9902, combined_score: 0.9902, radius_variance: 0.0057, spatial_spread: 0.1921, eval_time: 2.5088\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6164, target_ratio: 0.9930, combined_score: 0.9930, radius_variance: 0.0053, spatial_spread: 0.1944, eval_time: 6.0728\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6247, target_ratio: 0.9961, combined_score: 0.9961, radius_variance: 0.0045, spatial_spread: 0.1885, eval_time: 16.8284\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9961)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based batched circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    \"\"\"Perform a batched Adam optimization step.\"\"\"\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads_batch(x, y, r, pm):\n    \"\"\"\n    Calculate the physics forces (gradients) simultaneously for a batch of simulated \n    seed environments, maximizing processing speed through strict numpy vectorization.\n    \"\"\"\n    # Calculate all pairwise directional components and distances mapping efficiently \n    dx = x[:, :, None] - x[:, None, :]\n    dy = y[:, :, None] - y[:, None, :]\n    dist = np.hypot(dx, dy)\n    \n    # Exclude identity self-comparisons bounds safely paths \n    S, n = x.shape\n    idx = np.arange(n)\n    dist[:, idx, idx] = 1000.0\n    \n    # Derive boundary overlaps mapped systems checks safely\n    overlap = r[:, :, None] + r[:, None, :] - dist\n    overlap = np.maximum(0.0, overlap)\n    \n    # Evaluate physics interactions with zero-div avoidance directly\n    factor = 2.0 * overlap / (dist + 1e-12)\n    \n    dl_dx = np.sum(factor * (-dx), axis=2)\n    dl_dy = np.sum(factor * (-dy), axis=2)\n    dl_dr = np.sum(2.0 * overlap, axis=2)\n    \n    # Execute wall box repulsive dynamic components \n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += 2.0 * (-wl + wr)\n    dl_dy += 2.0 * (-wb + wt)\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Apply multiplicative mapping limit schedule variables multipliers mapping cleanly \n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Maximize layout density concurrently mappings securely runs fixes variables maps limits passes covers\n    dl_dr = pm * dl_dr - 1.0\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef construct_packing():\n    \"\"\"Build densely packed configuration by aggressively evolving varied starting positions concurrently.\"\"\"\n    n = 26\n    S = 50  # Explores 50 geometrically diverse batch environments in parallel securely\n    \n    x = np.zeros((S, n))\n    y = np.zeros((S, n))\n    r = np.zeros((S, n))\n    \n    np.random.seed(42)\n    \n    # Seed 0: Structured concentric circles core setup logic sizes covers values constraints paths biases \n    pts, rs = [[0.5, 0.5]], [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        rs.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        rs.append(0.06)\n    pts.append([0.15, 0.15])\n    rs.append(0.07)\n    x[0] = np.array([p[0] for p in pts[:n]])\n    y[0] = np.array([p[1] for p in pts[:n]])\n    r[0] = np.array(rs[:n])\n    \n    # Seed 1: Boundary weighted configuration sets setups sets maps correctly runs limits validations\n    pts, rs = [[0.5, 0.5]], [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        rs.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        rs.append(0.04)\n    x[1] = np.array([p[0] for p in pts[:n]])\n    y[1] = np.array([p[1] for p in pts[:n]])\n    r[1] = np.array(rs[:n])\n\n    # Seed 2: 5-5-6-5-5 layered arrangement setups checks safely sets arrays ranges values maps rules securely correctly  \n    pts, rs = [], []\n    for r_idx, count in enumerate([5, 5, 6, 5, 5]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.06 if r_idx == 2 else 0.04)\n    x[2] = np.array([p[0] for p in pts[:n]])\n    y[2] = np.array([p[1] for p in pts[:n]])\n    r[2] = np.array(rs[:n])\n\n    # Seed 3: 6-5-4-5-6 geometric mapping shapes rules checks guarantees paths limits safely covers correctly limits variations constraints   \n    pts, rs = [], []\n    for r_idx, count in enumerate([6, 5, 4, 5, 6]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.08 if count == 4 else 0.05)\n    x[3] = np.array([p[0] for p in pts[:n]])\n    y[3] = np.array([p[1] for p in pts[:n]])\n    r[3] = np.array(rs[:n])\n\n    # Seeds 4 to S-1: Dynamic density biases logic implementations heuristics checking sizes securely variables runs constraints paths  \n    for s in range(4, S):\n        tx = np.random.uniform(0.1, 0.9, n)\n        ty = np.random.uniform(0.1, 0.9, n)\n        tr = np.random.uniform(0.02, 0.08, n)\n        \n        # Center-heavy prioritization logic mapping maps boundaries setups variables cleanly covers maps sizes variations mapping limits layouts updates\n        dist_to_center = np.hypot(tx - 0.5, ty - 0.5)\n        order = np.argsort(dist_to_center)\n        tr = np.sort(tr)[::-1]\n        \n        tr_ordered = np.zeros(n)\n        tr_ordered[order] = tr\n        \n        x[s] = tx\n        y[s] = ty\n        r[s] = tr_ordered\n\n    # Assign state parameters checking paths boundaries memory fully mapping coverage sizes rules cleanly sizes \n    m_x, v_x = np.zeros((S, n)), np.zeros((S, n))\n    m_y, v_y = np.zeros((S, n)), np.zeros((S, n))\n    m_r, v_r = np.zeros((S, n)), np.zeros((S, n))\n    \n    steps = 13000\n    pms = np.minimum(10.0 * (1.0011 ** np.arange(steps)), 800000.0)\n    lrs = np.maximum(0.012 * (0.9996 ** np.arange(steps)), 1e-4)\n    noise_steps = 6500\n    \n    # Process concurrent batches smoothly mapping sets passes evaluations optimizations bounds updates sizes constraints maps checks loops values \n    t = 0\n    for step in range(steps):\n        pm = pms[step]\n        lr = lrs[step]\n        \n        gx, gy, gr = get_grads_batch(x, y, r, pm)\n        \n        t += 1\n        x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, lr)\n        y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, lr)\n        r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, lr)\n        \n        # Perform targeted noise perturbations correctly escaping local minima trapping boundaries ranges constraints checking constraints covers \n        if step < noise_steps:\n            noise_scale = 0.004 * (1.0 - step / noise_steps)\n            x += np.random.normal(0, noise_scale, (S, n))\n            y += np.random.normal(0, noise_scale, (S, n))\n            r += np.random.normal(0, noise_scale * 0.3, (S, n))\n            \n        x = np.clip(x, 0.001, 0.999)\n        y = np.clip(y, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    # Resolution strict rules limits map securely evaluation checking covers boundaries runs variables variations rules sets safely constraints sets validations runs maps bounds paths limits setup \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    for s in range(S):\n        cx, cy, cr = x[s].copy(), y[s].copy(), r[s].copy()\n        \n        cr = np.maximum(cr, 0.0)\n        # Apply intense constraint evaluation resolutions correctly checking safe ranges variables setups validations mapped fixes sizes ranges sets values cleanly covers   \n        for _ in range(120):\n            cr = np.minimum(cr, cx)\n            cr = np.minimum(cr, cy)\n            cr = np.minimum(cr, 1.0 - cx)\n            cr = np.minimum(cr, 1.0 - cy)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = cx[i] - cx[j]\n                    dy_v = cy[i] - cy[j]\n                    dist_v = np.hypot(dx_v, dy_v)\n                    if cr[i] + cr[j] > dist_v:\n                        scale = dist_v / max(cr[i] + cr[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            cr[i] *= scale\n                            cr[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Final rigorous safety validation bounding fixes ranges safely securely paths checks correctly validations bounds correctly configurations securely \n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        cr *= 0.999999\n        \n        sum_r = np.sum(cr)\n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((cx, cy))\n            best_radii = cr.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6247), Performs well on target_ratio (0.9961), Performs well on combined_score (0.9961), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1885), Performs well on eval_time (16.8284)\n\n### Program 2 (Score: 0.9930)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads(x, y, r, pm):\n    dx = x[:, None] - x[None, :]\n    dy = y[:, None] - y[None, :]\n    dist2 = dx**2 + dy**2\n    \n    # Avoid identical-position NaNs gracefully during sqrt derivatives computation\n    dist2 = np.maximum(dist2, 1e-12)\n    np.fill_diagonal(dist2, 1000.0)\n    dist = np.sqrt(dist2)\n    \n    # Force application where bounds overlaps exist aggressively\n    overlap = np.maximum(0.0, r[:, None] + r[None, :] - dist)\n    factor = 2.0 * overlap / dist\n    \n    dl_dx = np.sum(factor * (-dx), axis=1)\n    dl_dy = np.sum(factor * (-dy), axis=1)\n    dl_dr = np.sum(2.0 * overlap, axis=1)\n    \n    # Box bounds repulsing dynamics to contain within 0-to-1 square walls securely\n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += -2.0 * wl + 2.0 * wr\n    dl_dy += -2.0 * wb + 2.0 * wt\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Scale via simulated wall firmness multiplier map\n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Minimize '-sum(radii)', achieving pure direct growth dynamics simultaneously\n    dl_dr = -1.0 + pm * dl_dr\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef get_initial_states(n):\n    states = []\n    \n    def ensure_n(pts, rr):\n        pts, rr = np.array(pts), np.array(rr)\n        num = len(rr)\n        if num > n:\n            return pts[:n, 0], pts[:n, 1], rr[:n]\n        elif num < n:\n            pad = n - num\n            extra_pts = np.random.uniform(0.1, 0.9, (pad, 2))\n            extra_rr = np.random.uniform(0.02, 0.05, pad)\n            new_pts = np.vstack([pts, extra_pts])\n            new_rr = np.concatenate([rr, extra_rr])\n            return new_pts[:, 0], new_pts[:, 1], new_rr\n        return pts[:, 0], pts[:, 1], rr\n\n    # Seed 0: Structured rings initialization heuristical mapping layout core biases\n    pts = [[0.5, 0.5]]\n    r = [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        r.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        r.append(0.06)\n    pts.append([0.15, 0.15])\n    r.append(0.07)\n    states.append(ensure_n(pts, r))\n    \n    # Seed 1: Heavy corners bias plus massive layout core mappings optimization starting position\n    pts = [[0.5, 0.5]]\n    r = [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        r.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        r.append(0.04)\n    states.append(ensure_n(pts, r))\n\n    # Seeds 2 to 7: Variable spread random assignments fully deterministic variations checks guarantees maximum hit spaces checks coverage paths setups runs ranges \n    for s in range(6):\n        np.random.seed(10 + s)\n        x = np.random.uniform(0.1, 0.9, n)\n        y = np.random.uniform(0.1, 0.9, n)\n        r = np.random.uniform(0.02, 0.08, n)\n        states.append((x, y, r))\n        \n    return states\n\n\ndef construct_packing():\n    n = 26\n    states = get_initial_states(n)\n    \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Define optimization loop bounds schedule sizes mapping correctly robust limits\n    steps = 8000\n    pms = np.minimum(10.0 * (1.0015 ** np.arange(steps)), 100000.0)\n    lrs = np.maximum(0.01 * (0.9995 ** np.arange(steps)), 1e-4)\n    \n    for state_idx, (x0, y0, r0) in enumerate(states):\n        np.random.seed(42 + state_idx)\n        \n        x = x0.copy()\n        y = y0.copy()\n        r = r0.copy()\n        \n        m_x, v_x = np.zeros(n), np.zeros(n)\n        m_y, v_y = np.zeros(n), np.zeros(n)\n        m_r, v_r = np.zeros(n), np.zeros(n)\n        \n        t = 0\n        for step in range(steps):\n            pm = pms[step]\n            current_lr = lrs[step]\n            \n            gx, gy, gr = get_grads(x, y, r, pm)\n            \n            t += 1\n            x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, current_lr)\n            y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, current_lr)\n            r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, current_lr)\n            \n            # Simulated annealing component ensures geometry avoids imperfect symmetric trap positions cleanly mappings mapping updates\n            if step < 5000:\n                noise_scale = 0.003 * (1.0 - step / 5000.0)\n                x += np.random.normal(0, noise_scale, n)\n                y += np.random.normal(0, noise_scale, n)\n                r += np.random.normal(0, noise_scale * 0.3, n)\n                \n            x = np.clip(x, 0.001, 0.999)\n            y = np.clip(y, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Extreme rigorous validation limits to correctly adhere evaluator bounds constraints securely \n        r = np.maximum(r, 0.0)\n        for _ in range(100):\n            r = np.minimum(r, x)\n            r = np.minimum(r, y)\n            r = np.minimum(r, 1.0 - x)\n            r = np.minimum(r, 1.0 - y)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = x[i] - x[j]\n                    dy_v = y[i] - y[j]\n                    dist_v = np.sqrt(dx_v * dx_v + dy_v * dy_v)\n                    if r[i] + r[j] > dist_v:\n                        scale = dist_v / max(r[i] + r[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            r[i] *= scale\n                            r[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Guaranteed domain floating points precision coverage pass safety factor blanket map sizes mapping fully safe mapping cleanly checks \n        r = np.minimum(r, x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, 1.0 - y)\n        r *= 0.999999\n        \n        sum_r = np.sum(r)\n        \n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((x, y))\n            best_radii = r.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6164), Performs well on target_ratio (0.9930), Performs well on combined_score (0.9930), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.1944), Performs well on eval_time (6.0728)\n\n### Program 3 (Score: 0.9902)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef get_initializations(n):\n    \"\"\"\n    Generate diverse initial configurations of n circles strategically biased towards boundaries\n    and using structural heuristics like close packing (hex grid), large core arrays, etc.\n    \"\"\"\n    np.random.seed(88) # Fixed seed for reproducibility and robust evaluation bounds\n    inits = []\n    \n    # Init 1: Hexagonal Tight Packing Approximation\n    xh, yh, rh = [], [], []\n    for i in range(6):\n        for j in range(5):\n            if len(xh) < n:\n                shift = (i % 2) * 0.08\n                xh.append(0.1 + j * 0.16 + shift)\n                yh.append(0.1 + i * 0.14)\n                rh.append(0.07)\n    inits.append((np.array(xh), np.array(yh), np.array(rh)))\n\n    # Init 2: Relaxed square grid (5x5) plus 1 interstitial\n    xs, ys, rs = [], [], []\n    xg, yg = np.meshgrid(np.linspace(0.15, 0.85, 5), np.linspace(0.15, 0.85, 5))\n    xs = xg.flatten().tolist()\n    ys = yg.flatten().tolist()\n    xs.append(0.5)\n    ys.append(0.5)\n    # Slight jitter immediately to break perfect symmetry\n    xs = np.array(xs) + np.random.normal(0, 0.01, n)\n    ys = np.array(ys) + np.random.normal(0, 0.01, n)\n    inits.append((np.clip(xs, 0.05, 0.95), np.clip(ys, 0.05, 0.95), np.ones(n) * 0.08))\n\n    # Init 3: Concentric rings (larger center) with randomized edge angles\n    x_c, y_c = [0.5], [0.5]\n    for i in range(9):\n        ang = 2 * np.pi * i / 9\n        x_c.append(0.5 + 0.28 * np.cos(ang))\n        y_c.append(0.5 + 0.28 * np.sin(ang))\n    for i in range(16):\n        ang = 2 * np.pi * i / 16 + np.random.uniform(-0.1, 0.1)\n        x_c.append(0.5 + 0.45 * np.cos(ang))\n        y_c.append(0.5 + 0.45 * np.sin(ang))\n    inits.append((np.array(x_c), np.array(y_c), np.ones(n) * 0.05))\n\n    # Init 4-8: Scattered Random Packings with variable target sizes to heavily drive stochastic topological sorting\n    for _ in range(5):\n        xr = np.random.uniform(0.1, 0.9, n)\n        yr = np.random.uniform(0.1, 0.9, n)\n        rr = np.random.uniform(0.03, 0.1, n)\n        inits.append((xr, yr, rr))\n\n    return inits\n\n\ndef optimize_layout(x_in, y_in, r_in, epochs=3500):\n    \"\"\"\n    Run an annealing physics solver utilizing Adam gradient optimizer, optimizing a Lagrangian\n    whose penalty perfectly reflects collision rules against objective summing their overall radii.\n    \"\"\"\n    n = len(x_in)\n    x, y, r = x_in.copy(), y_in.copy(), r_in.copy()\n    \n    # Adam optim variables\n    m_v = np.zeros((3, n))\n    v_v = np.zeros((3, n))\n    base_lr = 0.012 \n    \n    for epoch in range(epochs):\n        progress = epoch / epochs\n        \n        # Power transition in learning schedules: smoothly move from 'sorting' topology phase\n        # towards strictly constrained final valid non-overlap configurations!\n        current_lambda = 1.0 + 80000.0 * progress**3\n        current_lr = base_lr * (1.0 - progress)\n        \n        g = np.zeros((3, n))\n        \n        # Maximize the sum of radii uniformly over the dataset \n        g[2, :] = -1.0 \n        \n        # Derivatives corresponding to bound crossings violations (wall forces)\n        v_x0 = np.maximum(0, r - x)\n        g[2] += current_lambda * v_x0\n        g[0] -= current_lambda * v_x0\n        \n        v_x1 = np.maximum(0, x + r - 1.0)\n        g[2] += current_lambda * v_x1\n        g[0] += current_lambda * v_x1\n        \n        v_y0 = np.maximum(0, r - y)\n        g[2] += current_lambda * v_y0\n        g[1] -= current_lambda * v_y0\n        \n        v_y1 = np.maximum(0, y + r - 1.0)\n        g[2] += current_lambda * v_y1\n        g[1] += current_lambda * v_y1\n        \n        # Derivatives corresponding to interior collision overlaps \n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.hypot(dx, dy)\n        np.fill_diagonal(dist, np.inf)\n        \n        rad_sum = r[:, None] + r[None, :]\n        v_pair = np.maximum(0, rad_sum - dist)\n        \n        g[2] += current_lambda * np.sum(v_pair, axis=1)\n        \n        dist_safe = np.maximum(dist, 1e-6)\n        force = current_lambda * v_pair / dist_safe\n        \n        g[0] -= np.sum(force * dx, axis=1)\n        g[1] -= np.sum(force * dy, axis=1)\n        \n        # Occasional synthetic annealing heat to shake topology\n        if progress < 0.6 and epoch % 75 == 0:\n            noise_amplitude = 0.005 * (1.0 - progress / 0.6)\n            x += np.random.normal(0, noise_amplitude, n)\n            y += np.random.normal(0, noise_amplitude, n)\n            \n        # Execute stable Adam updates\n        m_v = 0.9 * m_v + 0.1 * g\n        v_v = 0.999 * v_v + 0.001 * (g**2)\n        \n        m_hat = m_v / (1 - 0.9**(epoch+1))\n        v_hat = v_v / (1 - 0.999**(epoch+1))\n        \n        updates = current_lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n        \n        x -= updates[0]\n        y -= updates[1]\n        r -= updates[2]\n        \n        # Constrain to strict safety envelope limiting numerical blowouts\n        x = np.clip(x, 0.005, 0.995)\n        y = np.clip(y, 0.005, 0.995)\n        r = np.clip(r, 0.0001, 0.5)\n\n    return x, y, r\n\n\ndef make_strictly_valid(x_in, y_in, r_in):\n    \"\"\"\n    Project iteratively to completely correct precision overlap issues, guaranteeing 100% boundary \n    and non-intersection mathematically strict validity requirements exactly per fitness instructions.\n    \"\"\"\n    x, y, r = x_in.copy(), y_in.copy(), r_in.copy()\n    n = len(x)\n    \n    # Force coordinates perfectly safe bounds relative to their center positioning first \n    x = np.clip(x, 0.0, 1.0)\n    y = np.clip(y, 0.0, 1.0)\n        \n    for _ in range(35):\n        # Shave sizes exceeding hard edges seamlessly\n        for i in range(n):\n            max_bounds = min(x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n            if r[i] > max_bounds:\n                r[i] = max_bounds\n                \n        # Resolve topological crossings mathematically proportionate onto pairing radii recursively\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                if r[i] + r[j] > dist:\n                    scaling = dist / (r[i] + r[j])\n                    scaling *= 0.999999 \n                    r[i] *= scaling\n                    r[j] *= scaling\n                    \n    # Ultimate sanity boundary re-apply\n    for i in range(n):\n        r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n        \n    # Apply infinitesimal scaling margin buffering completely past FP64 threshold checking\n    r *= 0.99999\n    \n    return x, y, r\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an absolute arrangement of 26 circles using iterative force-equilibrium optimizer,\n    aggregating distinct configurations systematically finding maximum tight-fitting sum!\n    \"\"\"\n    n = 26\n    inits = get_initializations(n)\n    \n    best_centers = None\n    best_radii = None\n    best_sum = -1.0\n    \n    for init_x, init_y, init_r in inits:\n        x_opt, y_opt, r_opt = optimize_layout(init_x, init_y, init_r, epochs=3500)\n        x_val, y_val, r_val = make_strictly_valid(x_opt, y_opt, r_opt)\n        \n        current_sum = np.sum(r_val)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = np.column_stack((x_val, y_val))\n            best_radii = r_val\n            \n    return best_centers, best_radii, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6092), Performs well on target_ratio (0.9902), Performs well on combined_score (0.9902), Performs well on radius_variance (0.0057), Performs well on spatial_spread (0.1921), Performs well on eval_time (2.5088)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9902, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef get_initializations(n):\n    \"\"\"\n    Generate diverse initial configurations of n circles strategically biased towards boundaries\n    and using structural heuristics like close packing (hex grid), large core arrays, etc.\n    \"\"\"\n    np.random.seed(88) # Fixed seed for reproducibility and robust evaluation bounds\n    inits = []\n    \n    # Init 1: Hexagonal Tight Packing Approximation\n    xh, yh, rh = [], [], []\n    for i in range(6):\n        for j in range(5):\n            if len(xh) < n:\n                shift = (i % 2) * 0.08\n                xh.append(0.1 + j * 0.16 + shift)\n                yh.append(0.1 + i * 0.14)\n                rh.append(0.07)\n    inits.append((np.array(xh), np.array(yh), np.array(rh)))\n\n    # Init 2: Relaxed square grid (5x5) plus 1 interstitial\n    xs, ys, rs = [], [], []\n    xg, yg = np.meshgrid(np.linspace(0.15, 0.85, 5), np.linspace(0.15, 0.85, 5))\n    xs = xg.flatten().tolist()\n    ys = yg.flatten().tolist()\n    xs.append(0.5)\n    ys.append(0.5)\n    # Slight jitter immediately to break perfect symmetry\n    xs = np.array(xs) + np.random.normal(0, 0.01, n)\n    ys = np.array(ys) + np.random.normal(0, 0.01, n)\n    inits.append((np.clip(xs, 0.05, 0.95), np.clip(ys, 0.05, 0.95), np.ones(n) * 0.08))\n\n    # Init 3: Concentric rings (larger center) with randomized edge angles\n    x_c, y_c = [0.5], [0.5]\n    for i in range(9):\n        ang = 2 * np.pi * i / 9\n        x_c.append(0.5 + 0.28 * np.cos(ang))\n        y_c.append(0.5 + 0.28 * np.sin(ang))\n    for i in range(16):\n        ang = 2 * np.pi * i / 16 + np.random.uniform(-0.1, 0.1)\n        x_c.append(0.5 + 0.45 * np.cos(ang))\n        y_c.append(0.5 + 0.45 * np.sin(ang))\n    inits.append((np.array(x_c), np.array(y_c), np.ones(n) * 0.05))\n\n    # Init 4-8: Scattered Random Packings with variable target sizes to heavily drive stochastic topological sorting\n    for _ in range(5):\n        xr = np.random.uniform(0.1, 0.9, n)\n        yr = np.random.uniform(0.1, 0.9, n)\n        rr = np.random.uniform(0.03, 0.1, n)\n        inits.append((xr, yr, rr))\n\n    return inits\n\n\ndef optimize_layout(x_in, y_in, r_in, epochs=3500):\n    \"\"\"\n    Run an annealing physics solver utilizing Adam gradient optimizer, optimizing a Lagrangian\n    whose penalty perfectly reflects collision rules against objective summing their overall radii.\n    \"\"\"\n    n = len(x_in)\n    x, y, r = x_in.copy(), y_in.copy(), r_in.copy()\n    \n    # Adam optim variables\n    m_v = np.zeros((3, n))\n    v_v = np.zeros((3, n))\n    base_lr = 0.012 \n    \n    for epoch in range(epochs):\n        progress = epoch / epochs\n        \n        # Power transition in learning schedules: smoothly move from 'sorting' topology phase\n        # towards strictly constrained final valid non-overlap configurations!\n        current_lambda = 1.0 + 80000.0 * progress**3\n        current_lr = base_lr * (1.0 - progress)\n        \n        g = np.zeros((3, n))\n        \n        # Maximize the sum of radii uniformly over the dataset \n        g[2, :] = -1.0 \n        \n        # Derivatives corresponding to bound crossings violations (wall forces)\n        v_x0 = np.maximum(0, r - x)\n        g[2] += current_lambda * v_x0\n        g[0] -= current_lambda * v_x0\n        \n        v_x1 = np.maximum(0, x + r - 1.0)\n        g[2] += current_lambda * v_x1\n        g[0] += current_lambda * v_x1\n        \n        v_y0 = np.maximum(0, r - y)\n        g[2] += current_lambda * v_y0\n        g[1] -= current_lambda * v_y0\n        \n        v_y1 = np.maximum(0, y + r - 1.0)\n        g[2] += current_lambda * v_y1\n        g[1] += current_lambda * v_y1\n        \n        # Derivatives corresponding to interior collision overlaps \n        dx = x[:, None] - x[None, :]\n        dy = y[:, None] - y[None, :]\n        dist = np.hypot(dx, dy)\n        np.fill_diagonal(dist, np.inf)\n        \n        rad_sum = r[:, None] + r[None, :]\n        v_pair = np.maximum(0, rad_sum - dist)\n        \n        g[2] += current_lambda * np.sum(v_pair, axis=1)\n        \n        dist_safe = np.maximum(dist, 1e-6)\n        force = current_lambda * v_pair / dist_safe\n        \n        g[0] -= np.sum(force * dx, axis=1)\n        g[1] -= np.sum(force * dy, axis=1)\n        \n        # Occasional synthetic annealing heat to shake topology\n        if progress < 0.6 and epoch % 75 == 0:\n            noise_amplitude = 0.005 * (1.0 - progress / 0.6)\n            x += np.random.normal(0, noise_amplitude, n)\n            y += np.random.normal(0, noise_amplitude, n)\n            \n        # Execute stable Adam updates\n        m_v = 0.9 * m_v + 0.1 * g\n        v_v = 0.999 * v_v + 0.001 * (g**2)\n        \n        m_hat = m_v / (1 - 0.9**(epoch+1))\n        v_hat = v_v / (1 - 0.999**(epoch+1))\n        \n        updates = current_lr * m_hat / (np.sqrt(v_hat) + 1e-8)\n        \n        x -= updates[0]\n        y -= updates[1]\n        r -= updates[2]\n        \n        # Constrain to strict safety envelope limiting numerical blowouts\n        x = np.clip(x, 0.005, 0.995)\n        y = np.clip(y, 0.005, 0.995)\n        r = np.clip(r, 0.0001, 0.5)\n\n    return x, y, r\n\n\ndef make_strictly_valid(x_in, y_in, r_in):\n    \"\"\"\n    Project iteratively to completely correct precision overlap issues, guaranteeing 100% boundary \n    and non-intersection mathematically strict validity requirements exactly per fitness instructions.\n    \"\"\"\n    x, y, r = x_in.copy(), y_in.copy(), r_in.copy()\n    n = len(x)\n    \n    # Force coordinates perfectly safe bounds relative to their center positioning first \n    x = np.clip(x, 0.0, 1.0)\n    y = np.clip(y, 0.0, 1.0)\n        \n    for _ in range(35):\n        # Shave sizes exceeding hard edges seamlessly\n        for i in range(n):\n            max_bounds = min(x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n            if r[i] > max_bounds:\n                r[i] = max_bounds\n                \n        # Resolve topological crossings mathematically proportionate onto pairing radii recursively\n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.hypot(x[i] - x[j], y[i] - y[j])\n                if r[i] + r[j] > dist:\n                    scaling = dist / (r[i] + r[j])\n                    scaling *= 0.999999 \n                    r[i] *= scaling\n                    r[j] *= scaling\n                    \n    # Ultimate sanity boundary re-apply\n    for i in range(n):\n        r[i] = min(r[i], x[i], 1.0 - x[i], y[i], 1.0 - y[i])\n        \n    # Apply infinitesimal scaling margin buffering completely past FP64 threshold checking\n    r *= 0.99999\n    \n    return x, y, r\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an absolute arrangement of 26 circles using iterative force-equilibrium optimizer,\n    aggregating distinct configurations systematically finding maximum tight-fitting sum!\n    \"\"\"\n    n = 26\n    inits = get_initializations(n)\n    \n    best_centers = None\n    best_radii = None\n    best_sum = -1.0\n    \n    for init_x, init_y, init_r in inits:\n        x_opt, y_opt, r_opt = optimize_layout(init_x, init_y, init_r, epochs=3500)\n        x_val, y_val, r_val = make_strictly_valid(x_opt, y_opt, r_opt)\n        \n        current_sum = np.sum(r_val)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = np.column_stack((x_val, y_val))\n            best_radii = r_val\n            \n    return best_centers, best_radii, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9930, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads(x, y, r, pm):\n    dx = x[:, None] - x[None, :]\n    dy = y[:, None] - y[None, :]\n    dist2 = dx**2 + dy**2\n    \n    # Avoid identical-position NaNs gracefully during sqrt derivatives computation\n    dist2 = np.maximum(dist2, 1e-12)\n    np.fill_diagonal(dist2, 1000.0)\n    dist = np.sqrt(dist2)\n    \n    # Force application where bounds overlaps exist aggressively\n    overlap = np.maximum(0.0, r[:, None] + r[None, :] - dist)\n    factor = 2.0 * overlap / dist\n    \n    dl_dx = np.sum(factor * (-dx), axis=1)\n    dl_dy = np.sum(factor * (-dy), axis=1)\n    dl_dr = np.sum(2.0 * overlap, axis=1)\n    \n    # Box bounds repulsing dynamics to contain within 0-to-1 square walls securely\n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += -2.0 * wl + 2.0 * wr\n    dl_dy += -2.0 * wb + 2.0 * wt\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Scale via simulated wall firmness multiplier map\n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Minimize '-sum(radii)', achieving pure direct growth dynamics simultaneously\n    dl_dr = -1.0 + pm * dl_dr\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef get_initial_states(n):\n    states = []\n    \n    def ensure_n(pts, rr):\n        pts, rr = np.array(pts), np.array(rr)\n        num = len(rr)\n        if num > n:\n            return pts[:n, 0], pts[:n, 1], rr[:n]\n        elif num < n:\n            pad = n - num\n            extra_pts = np.random.uniform(0.1, 0.9, (pad, 2))\n            extra_rr = np.random.uniform(0.02, 0.05, pad)\n            new_pts = np.vstack([pts, extra_pts])\n            new_rr = np.concatenate([rr, extra_rr])\n            return new_pts[:, 0], new_pts[:, 1], new_rr\n        return pts[:, 0], pts[:, 1], rr\n\n    # Seed 0: Structured rings initialization heuristical mapping layout core biases\n    pts = [[0.5, 0.5]]\n    r = [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        r.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        r.append(0.06)\n    pts.append([0.15, 0.15])\n    r.append(0.07)\n    states.append(ensure_n(pts, r))\n    \n    # Seed 1: Heavy corners bias plus massive layout core mappings optimization starting position\n    pts = [[0.5, 0.5]]\n    r = [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        r.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        r.append(0.04)\n    states.append(ensure_n(pts, r))\n\n    # Seeds 2 to 7: Variable spread random assignments fully deterministic variations checks guarantees maximum hit spaces checks coverage paths setups runs ranges \n    for s in range(6):\n        np.random.seed(10 + s)\n        x = np.random.uniform(0.1, 0.9, n)\n        y = np.random.uniform(0.1, 0.9, n)\n        r = np.random.uniform(0.02, 0.08, n)\n        states.append((x, y, r))\n        \n    return states\n\n\ndef construct_packing():\n    n = 26\n    states = get_initial_states(n)\n    \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Define optimization loop bounds schedule sizes mapping correctly robust limits\n    steps = 8000\n    pms = np.minimum(10.0 * (1.0015 ** np.arange(steps)), 100000.0)\n    lrs = np.maximum(0.01 * (0.9995 ** np.arange(steps)), 1e-4)\n    \n    for state_idx, (x0, y0, r0) in enumerate(states):\n        np.random.seed(42 + state_idx)\n        \n        x = x0.copy()\n        y = y0.copy()\n        r = r0.copy()\n        \n        m_x, v_x = np.zeros(n), np.zeros(n)\n        m_y, v_y = np.zeros(n), np.zeros(n)\n        m_r, v_r = np.zeros(n), np.zeros(n)\n        \n        t = 0\n        for step in range(steps):\n            pm = pms[step]\n            current_lr = lrs[step]\n            \n            gx, gy, gr = get_grads(x, y, r, pm)\n            \n            t += 1\n            x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, current_lr)\n            y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, current_lr)\n            r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, current_lr)\n            \n            # Simulated annealing component ensures geometry avoids imperfect symmetric trap positions cleanly mappings mapping updates\n            if step < 5000:\n                noise_scale = 0.003 * (1.0 - step / 5000.0)\n                x += np.random.normal(0, noise_scale, n)\n                y += np.random.normal(0, noise_scale, n)\n                r += np.random.normal(0, noise_scale * 0.3, n)\n                \n            x = np.clip(x, 0.001, 0.999)\n            y = np.clip(y, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Extreme rigorous validation limits to correctly adhere evaluator bounds constraints securely \n        r = np.maximum(r, 0.0)\n        for _ in range(100):\n            r = np.minimum(r, x)\n            r = np.minimum(r, y)\n            r = np.minimum(r, 1.0 - x)\n            r = np.minimum(r, 1.0 - y)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = x[i] - x[j]\n                    dy_v = y[i] - y[j]\n                    dist_v = np.sqrt(dx_v * dx_v + dy_v * dy_v)\n                    if r[i] + r[j] > dist_v:\n                        scale = dist_v / max(r[i] + r[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            r[i] *= scale\n                            r[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Guaranteed domain floating points precision coverage pass safety factor blanket map sizes mapping fully safe mapping cleanly checks \n        r = np.minimum(r, x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, 1.0 - y)\n        r *= 0.999999\n        \n        sum_r = np.sum(r)\n        \n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((x, y))\n            best_radii = r.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based batched circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    \"\"\"Perform a batched Adam optimization step.\"\"\"\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads_batch(x, y, r, pm):\n    \"\"\"\n    Calculate the physics forces (gradients) simultaneously for a batch of simulated \n    seed environments, maximizing processing speed through strict numpy vectorization.\n    \"\"\"\n    # Calculate all pairwise directional components and distances mapping efficiently \n    dx = x[:, :, None] - x[:, None, :]\n    dy = y[:, :, None] - y[:, None, :]\n    dist = np.hypot(dx, dy)\n    \n    # Exclude identity self-comparisons bounds safely paths \n    S, n = x.shape\n    idx = np.arange(n)\n    dist[:, idx, idx] = 1000.0\n    \n    # Derive boundary overlaps mapped systems checks safely\n    overlap = r[:, :, None] + r[:, None, :] - dist\n    overlap = np.maximum(0.0, overlap)\n    \n    # Evaluate physics interactions with zero-div avoidance directly\n    factor = 2.0 * overlap / (dist + 1e-12)\n    \n    dl_dx = np.sum(factor * (-dx), axis=2)\n    dl_dy = np.sum(factor * (-dy), axis=2)\n    dl_dr = np.sum(2.0 * overlap, axis=2)\n    \n    # Execute wall box repulsive dynamic components \n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += 2.0 * (-wl + wr)\n    dl_dy += 2.0 * (-wb + wt)\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Apply multiplicative mapping limit schedule variables multipliers mapping cleanly \n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Maximize layout density concurrently mappings securely runs fixes variables maps limits passes covers\n    dl_dr = pm * dl_dr - 1.0\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef construct_packing():\n    \"\"\"Build densely packed configuration by aggressively evolving varied starting positions concurrently.\"\"\"\n    n = 26\n    S = 50  # Explores 50 geometrically diverse batch environments in parallel securely\n    \n    x = np.zeros((S, n))\n    y = np.zeros((S, n))\n    r = np.zeros((S, n))\n    \n    np.random.seed(42)\n    \n    # Seed 0: Structured concentric circles core setup logic sizes covers values constraints paths biases \n    pts, rs = [[0.5, 0.5]], [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        rs.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        rs.append(0.06)\n    pts.append([0.15, 0.15])\n    rs.append(0.07)\n    x[0] = np.array([p[0] for p in pts[:n]])\n    y[0] = np.array([p[1] for p in pts[:n]])\n    r[0] = np.array(rs[:n])\n    \n    # Seed 1: Boundary weighted configuration sets setups sets maps correctly runs limits validations\n    pts, rs = [[0.5, 0.5]], [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        rs.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        rs.append(0.04)\n    x[1] = np.array([p[0] for p in pts[:n]])\n    y[1] = np.array([p[1] for p in pts[:n]])\n    r[1] = np.array(rs[:n])\n\n    # Seed 2: 5-5-6-5-5 layered arrangement setups checks safely sets arrays ranges values maps rules securely correctly  \n    pts, rs = [], []\n    for r_idx, count in enumerate([5, 5, 6, 5, 5]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.06 if r_idx == 2 else 0.04)\n    x[2] = np.array([p[0] for p in pts[:n]])\n    y[2] = np.array([p[1] for p in pts[:n]])\n    r[2] = np.array(rs[:n])\n\n    # Seed 3: 6-5-4-5-6 geometric mapping shapes rules checks guarantees paths limits safely covers correctly limits variations constraints   \n    pts, rs = [], []\n    for r_idx, count in enumerate([6, 5, 4, 5, 6]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.08 if count == 4 else 0.05)\n    x[3] = np.array([p[0] for p in pts[:n]])\n    y[3] = np.array([p[1] for p in pts[:n]])\n    r[3] = np.array(rs[:n])\n\n    # Seeds 4 to S-1: Dynamic density biases logic implementations heuristics checking sizes securely variables runs constraints paths  \n    for s in range(4, S):\n        tx = np.random.uniform(0.1, 0.9, n)\n        ty = np.random.uniform(0.1, 0.9, n)\n        tr = np.random.uniform(0.02, 0.08, n)\n        \n        # Center-heavy prioritization logic mapping maps boundaries setups variables cleanly covers maps sizes variations mapping limits layouts updates\n        dist_to_center = np.hypot(tx - 0.5, ty - 0.5)\n        order = np.argsort(dist_to_center)\n        tr = np.sort(tr)[::-1]\n        \n        tr_ordered = np.zeros(n)\n        tr_ordered[order] = tr\n        \n        x[s] = tx\n        y[s] = ty\n        r[s] = tr_ordered\n\n    # Assign state parameters checking paths boundaries memory fully mapping coverage sizes rules cleanly sizes \n    m_x, v_x = np.zeros((S, n)), np.zeros((S, n))\n    m_y, v_y = np.zeros((S, n)), np.zeros((S, n))\n    m_r, v_r = np.zeros((S, n)), np.zeros((S, n))\n    \n    steps = 13000\n    pms = np.minimum(10.0 * (1.0011 ** np.arange(steps)), 800000.0)\n    lrs = np.maximum(0.012 * (0.9996 ** np.arange(steps)), 1e-4)\n    noise_steps = 6500\n    \n    # Process concurrent batches smoothly mapping sets passes evaluations optimizations bounds updates sizes constraints maps checks loops values \n    t = 0\n    for step in range(steps):\n        pm = pms[step]\n        lr = lrs[step]\n        \n        gx, gy, gr = get_grads_batch(x, y, r, pm)\n        \n        t += 1\n        x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, lr)\n        y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, lr)\n        r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, lr)\n        \n        # Perform targeted noise perturbations correctly escaping local minima trapping boundaries ranges constraints checking constraints covers \n        if step < noise_steps:\n            noise_scale = 0.004 * (1.0 - step / noise_steps)\n            x += np.random.normal(0, noise_scale, (S, n))\n            y += np.random.normal(0, noise_scale, (S, n))\n            r += np.random.normal(0, noise_scale * 0.3, (S, n))\n            \n        x = np.clip(x, 0.001, 0.999)\n        y = np.clip(y, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    # Resolution strict rules limits map securely evaluation checking covers boundaries runs variables variations rules sets safely constraints sets validations runs maps bounds paths limits setup \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    for s in range(S):\n        cx, cy, cr = x[s].copy(), y[s].copy(), r[s].copy()\n        \n        cr = np.maximum(cr, 0.0)\n        # Apply intense constraint evaluation resolutions correctly checking safe ranges variables setups validations mapped fixes sizes ranges sets values cleanly covers   \n        for _ in range(120):\n            cr = np.minimum(cr, cx)\n            cr = np.minimum(cr, cy)\n            cr = np.minimum(cr, 1.0 - cx)\n            cr = np.minimum(cr, 1.0 - cy)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = cx[i] - cx[j]\n                    dy_v = cy[i] - cy[j]\n                    dist_v = np.hypot(dx_v, dy_v)\n                    if cr[i] + cr[j] > dist_v:\n                        scale = dist_v / max(cr[i] + cr[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            cr[i] *= scale\n                            cr[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Final rigorous safety validation bounding fixes ranges safely securely paths checks correctly validations bounds correctly configurations securely \n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        cr *= 0.999999\n        \n        sum_r = np.sum(cr)\n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((cx, cy))\n            best_radii = cr.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based batched circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    \"\"\"Perform a batched Adam optimization step.\"\"\"\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads_batch(x, y, r, pm):\n    \"\"\"\n    Calculate the physics forces (gradients) simultaneously for a batch of simulated \n    seed environments, maximizing processing speed through strict numpy vectorization.\n    \"\"\"\n    # Calculate all pairwise directional components and distances efficiently \n    dx = x[:, :, None] - x[:, None, :]\n    dy = y[:, :, None] - y[:, None, :]\n    dist = np.hypot(dx, dy)\n    \n    # Exclude identity self-comparisons bounds safely \n    S, n = x.shape\n    idx = np.arange(n)\n    dist[:, idx, idx] = 1000.0\n    \n    # Derive boundary overlaps mapped systems safely\n    overlap = r[:, :, None] + r[:, None, :] - dist\n    overlap = np.maximum(0.0, overlap)\n    \n    # Evaluate physics interactions with zero-div avoidance\n    factor = 2.0 * overlap / (dist + 1e-12)\n    \n    dl_dx = np.sum(factor * (-dx), axis=2)\n    dl_dy = np.sum(factor * (-dy), axis=2)\n    dl_dr = np.sum(2.0 * overlap, axis=2)\n    \n    # Execute wall box repulsive dynamic components \n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += 2.0 * (-wl + wr)\n    dl_dy += 2.0 * (-wb + wt)\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Apply multiplicative limit schedule multipliers smoothly\n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Maximize layout density concurrently by scaling correctly over negative gradient logic\n    dl_dr = pm * dl_dr - 1.0\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef construct_packing():\n    \"\"\"Build densely packed configuration by aggressively evolving geometrically varied setups concurrently.\"\"\"\n    n = 26\n    S = 90  # Increased batch size perfectly ensures maximal heuristic coverage mapping geometries  \n    \n    x = np.zeros((S, n))\n    y = np.zeros((S, n))\n    r = np.zeros((S, n))\n    \n    np.random.seed(31415)\n    \n    idx = 0\n    \n    # Pre-calculated layered arrangements securely resolving local permutations \n    configs = [\n        [5, 5, 6, 5, 5],\n        [6, 5, 4, 5, 6],\n        [5, 6, 4, 6, 5],\n        [4, 6, 6, 6, 4],\n        [6, 7, 7, 6],\n        [7, 6, 6, 7],\n        [5, 4, 8, 4, 5],\n        [4, 5, 8, 5, 4],\n        [5, 4, 4, 4, 4, 5], \n        [5, 4, 5, 4, 4, 4], \n    ]\n    \n    for config in configs:\n        if idx >= S: \n            break\n        pts, rs = [], []\n        num_rows = len(config)\n        for r_idx, count in enumerate(config):\n            y_pos = 0.1 + 0.8 * (r_idx / max(1, num_rows - 1))\n            for c_idx in range(count):\n                x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1)) if count > 1 else 0.5\n                # Break symmetries initially properly mapping cleanly \n                x_pos += np.random.uniform(-0.015, 0.015)\n                y_pos += np.random.uniform(-0.015, 0.015)\n                pts.append([np.clip(x_pos, 0.05, 0.95), np.clip(y_pos, 0.05, 0.95)])\n                rs.append(np.random.uniform(0.045, 0.065))\n                \n        x[idx] = np.array([p[0] for p in pts[:n]])\n        y[idx] = np.array([p[1] for p in pts[:n]])\n        r[idx] = np.array(rs[:n])\n        idx += 1\n\n    # Concentric Array setup mappings evaluations securely maps core elements layouts loops fixes validations logic \n    if idx < S:\n        pts = [[0.5, 0.5]]\n        for i in range(6):\n            a = 2.0 * np.pi * i / 6.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.16 * np.cos(a), 0.5 + 0.16 * np.sin(a)])\n        for i in range(11):\n            a = 2.0 * np.pi * i / 11.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.35 * np.cos(a), 0.5 + 0.35 * np.sin(a)])\n        corners_edges = [(0.12, 0.12), (0.88, 0.12), (0.12, 0.88), (0.88, 0.88),\n                         (0.12, 0.5), (0.88, 0.5), (0.5, 0.12), (0.5, 0.88)]\n        for ce in corners_edges:\n            pts.append([ce[0] + np.random.uniform(-0.02, 0.02), \n                        ce[1] + np.random.uniform(-0.02, 0.02)])\n        x[idx] = np.array([p[0] for p in pts[:n]])\n        y[idx] = np.array([p[1] for p in pts[:n]])\n        r[idx] = np.random.uniform(0.04, 0.07, n)\n        idx += 1\n\n    if idx < S:\n        pts = [[0.5, 0.5]]\n        for i in range(7):\n            a = 2.0 * np.pi * i / 7.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.18 * np.cos(a), 0.5 + 0.18 * np.sin(a)])\n        for i in range(12):\n            a = 2.0 * np.pi * i / 12.0 + np.random.uniform(-0.1, 0.1)\n            pts.append([0.5 + 0.38 * np.cos(a), 0.5 + 0.38 * np.sin(a)])\n        for _ in range(6):\n            if np.random.random() > 0.5:\n                px = np.random.uniform(0.05, 0.95)\n                py = 0.05 if np.random.random() > 0.5 else 0.95\n            else:\n                py = np.random.uniform(0.05, 0.95)\n                px = 0.05 if np.random.random() > 0.5 else 0.95\n            pts.append([px, py])\n            \n        x[idx] = np.array([p[0] for p in pts[:n]])\n        y[idx] = np.array([p[1] for p in pts[:n]])\n        r[idx] = np.random.uniform(0.04, 0.07, n)\n        idx += 1\n\n    # Completely randomly structured elements maps sets permutations setups \n    while idx < S:\n        tx = np.random.uniform(0.05, 0.95, n)\n        ty = np.random.uniform(0.05, 0.95, n)\n        \n        mode = idx % 4\n        if mode == 0:\n            tr = np.random.uniform(0.02, 0.13, n)\n            dist = np.minimum(np.minimum(np.hypot(tx, ty), np.hypot(tx-1, ty)), \n                              np.minimum(np.hypot(tx, ty-1), np.hypot(tx-1, ty-1)))\n            order = np.argsort(dist)\n            tr = np.sort(tr)[::-1]\n            tro = np.zeros(n)\n            tro[order] = tr\n            r[idx] = tro\n        elif mode == 1:\n            tr = np.random.uniform(0.02, 0.13, n)\n            dist = np.hypot(tx - 0.5, ty - 0.5)\n            order = np.argsort(dist)\n            tr = np.sort(tr)[::-1]\n            tro = np.zeros(n)\n            tro[order] = tr\n            r[idx] = tro\n        elif mode == 2:\n            tr = np.random.uniform(0.03, 0.12, n)\n            dist_edges = np.minimum(np.minimum(tx, 1.0-tx), np.minimum(ty, 1.0-ty))\n            order = np.argsort(dist_edges)\n            tr = np.sort(tr)[::-1]\n            tro = np.zeros(n)\n            tro[order] = tr\n            r[idx] = tro\n        else:\n            r[idx] = np.random.uniform(0.05, 0.09, n)\n            \n        x[idx] = tx\n        y[idx] = ty\n        idx += 1\n\n    # Apply physical state gradient resolution vectors mapped securely mapping layouts shapes properly \n    m_x, v_x = np.zeros((S, n)), np.zeros((S, n))\n    m_y, v_y = np.zeros((S, n)), np.zeros((S, n))\n    m_r, v_r = np.zeros((S, n)), np.zeros((S, n))\n    \n    steps = 15000\n    pms = np.minimum(10.0 * (1.0011 ** np.arange(steps)), 1000000.0)\n    lrs = np.maximum(0.015 * (0.9997 ** np.arange(steps)), 1e-4)\n    noise_steps = 7500\n    \n    t = 0\n    for step in range(steps):\n        pm = pms[step]\n        lr = lrs[step]\n        \n        gx, gy, gr = get_grads_batch(x, y, r, pm)\n        \n        t += 1\n        x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, lr)\n        y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, lr)\n        r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, lr)\n        \n        # Shake configurations strategically avoiding minima loops fully evaluations boundaries fixes checking validations \n        if step < noise_steps:\n            noise_scale = 0.005 * (1.0 - step / noise_steps)\n            x += np.random.normal(0, noise_scale, (S, n))\n            y += np.random.normal(0, noise_scale, (S, n))\n            if step % 5 == 0:\n                r += np.random.normal(0, noise_scale * 0.3, (S, n))\n                \n        x = np.clip(x, 0.001, 0.999)\n        y = np.clip(y, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    for s in range(S):\n        cx, cy, cr = x[s].copy(), y[s].copy(), r[s].copy()\n        \n        # Prevent sizes mapped optimizations evaluation values bounds paths securely rules variables bounds \n        cr = np.maximum(cr, 0.0)\n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        \n        # Aggressive geometry overlap solver strictly passes validation boundaries securely passes checks  \n        for _ in range(160):\n            cr = np.minimum(cr, cx)\n            cr = np.minimum(cr, cy)\n            cr = np.minimum(cr, 1.0 - cx)\n            cr = np.minimum(cr, 1.0 - cy)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = cx[i] - cx[j]\n                    dy_v = cy[i] - cy[j]\n                    dist_v = np.hypot(dx_v, dy_v)\n                    if cr[i] + cr[j] > dist_v:\n                        scale = dist_v / max(cr[i] + cr[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            cr[i] *= scale\n                            cr[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Resolve any residual strictness limitations configurations setups validations cleanly cleanly variations setups limitations boundaries logic layouts\n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        cr *= 0.9999999\n        \n        sum_r = np.sum(cr)\n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((cx, cy))\n            best_radii = cr.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```"]}}, "artifacts_json": "{\"execution_time\": \"29.11s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.612141/2.635 = 0.9913\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.1% of target value\", \"radius_stats\": \"Min: 0.069260, Max: 0.136267, Avg: 0.100467\"}", "artifact_dir": null, "embedding": null}