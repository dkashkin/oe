{"id": "3aa4a64b-a55e-44f3-b561-1e4bd7d2a5f9", "code": "# EVOLVE-BLOCK-START\n\"\"\"Constructor-based batched circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    \"\"\"Perform a batched Adam optimization step.\"\"\"\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads_batch(x, y, r, pm):\n    \"\"\"\n    Calculate the physics forces (gradients) simultaneously for a batch of simulated \n    seed environments, maximizing processing speed through strict numpy vectorization.\n    \"\"\"\n    # Calculate all pairwise directional components and distances mapping efficiently \n    dx = x[:, :, None] - x[:, None, :]\n    dy = y[:, :, None] - y[:, None, :]\n    dist = np.hypot(dx, dy)\n    \n    # Exclude identity self-comparisons bounds safely paths \n    S, n = x.shape\n    idx = np.arange(n)\n    dist[:, idx, idx] = 1000.0\n    \n    # Derive boundary overlaps mapped systems checks safely\n    overlap = r[:, :, None] + r[:, None, :] - dist\n    overlap = np.maximum(0.0, overlap)\n    \n    # Evaluate physics interactions with zero-div avoidance directly\n    factor = 2.0 * overlap / (dist + 1e-12)\n    \n    dl_dx = np.sum(factor * (-dx), axis=2)\n    dl_dy = np.sum(factor * (-dy), axis=2)\n    dl_dr = np.sum(2.0 * overlap, axis=2)\n    \n    # Execute wall box repulsive dynamic components \n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += 2.0 * (-wl + wr)\n    dl_dy += 2.0 * (-wb + wt)\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Apply multiplicative mapping limit schedule variables multipliers mapping cleanly \n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Maximize layout density concurrently mappings securely runs fixes variables maps limits passes covers\n    dl_dr = pm * dl_dr - 1.0\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef construct_packing():\n    \"\"\"Build densely packed configuration by aggressively evolving varied starting positions concurrently.\"\"\"\n    n = 26\n    S = 50  # Explores 50 geometrically diverse batch environments in parallel securely\n    \n    x = np.zeros((S, n))\n    y = np.zeros((S, n))\n    r = np.zeros((S, n))\n    \n    np.random.seed(42)\n    \n    # Seed 0: Structured concentric circles core setup logic sizes covers values constraints paths biases \n    pts, rs = [[0.5, 0.5]], [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        rs.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        rs.append(0.06)\n    pts.append([0.15, 0.15])\n    rs.append(0.07)\n    x[0] = np.array([p[0] for p in pts[:n]])\n    y[0] = np.array([p[1] for p in pts[:n]])\n    r[0] = np.array(rs[:n])\n    \n    # Seed 1: Boundary weighted configuration sets setups sets maps correctly runs limits validations\n    pts, rs = [[0.5, 0.5]], [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        rs.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        rs.append(0.04)\n    x[1] = np.array([p[0] for p in pts[:n]])\n    y[1] = np.array([p[1] for p in pts[:n]])\n    r[1] = np.array(rs[:n])\n\n    # Seed 2: 5-5-6-5-5 layered arrangement setups checks safely sets arrays ranges values maps rules securely correctly  \n    pts, rs = [], []\n    for r_idx, count in enumerate([5, 5, 6, 5, 5]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.06 if r_idx == 2 else 0.04)\n    x[2] = np.array([p[0] for p in pts[:n]])\n    y[2] = np.array([p[1] for p in pts[:n]])\n    r[2] = np.array(rs[:n])\n\n    # Seed 3: 6-5-4-5-6 geometric mapping shapes rules checks guarantees paths limits safely covers correctly limits variations constraints   \n    pts, rs = [], []\n    for r_idx, count in enumerate([6, 5, 4, 5, 6]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.08 if count == 4 else 0.05)\n    x[3] = np.array([p[0] for p in pts[:n]])\n    y[3] = np.array([p[1] for p in pts[:n]])\n    r[3] = np.array(rs[:n])\n\n    # Seeds 4 to S-1: Dynamic density biases logic implementations heuristics checking sizes securely variables runs constraints paths  \n    for s in range(4, S):\n        tx = np.random.uniform(0.1, 0.9, n)\n        ty = np.random.uniform(0.1, 0.9, n)\n        tr = np.random.uniform(0.02, 0.08, n)\n        \n        # Center-heavy prioritization logic mapping maps boundaries setups variables cleanly covers maps sizes variations mapping limits layouts updates\n        dist_to_center = np.hypot(tx - 0.5, ty - 0.5)\n        order = np.argsort(dist_to_center)\n        tr = np.sort(tr)[::-1]\n        \n        tr_ordered = np.zeros(n)\n        tr_ordered[order] = tr\n        \n        x[s] = tx\n        y[s] = ty\n        r[s] = tr_ordered\n\n    # Assign state parameters checking paths boundaries memory fully mapping coverage sizes rules cleanly sizes \n    m_x, v_x = np.zeros((S, n)), np.zeros((S, n))\n    m_y, v_y = np.zeros((S, n)), np.zeros((S, n))\n    m_r, v_r = np.zeros((S, n)), np.zeros((S, n))\n    \n    steps = 13000\n    pms = np.minimum(10.0 * (1.0011 ** np.arange(steps)), 800000.0)\n    lrs = np.maximum(0.012 * (0.9996 ** np.arange(steps)), 1e-4)\n    noise_steps = 6500\n    \n    # Process concurrent batches smoothly mapping sets passes evaluations optimizations bounds updates sizes constraints maps checks loops values \n    t = 0\n    for step in range(steps):\n        pm = pms[step]\n        lr = lrs[step]\n        \n        gx, gy, gr = get_grads_batch(x, y, r, pm)\n        \n        t += 1\n        x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, lr)\n        y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, lr)\n        r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, lr)\n        \n        # Perform targeted noise perturbations correctly escaping local minima trapping boundaries ranges constraints checking constraints covers \n        if step < noise_steps:\n            noise_scale = 0.004 * (1.0 - step / noise_steps)\n            x += np.random.normal(0, noise_scale, (S, n))\n            y += np.random.normal(0, noise_scale, (S, n))\n            r += np.random.normal(0, noise_scale * 0.3, (S, n))\n            \n        x = np.clip(x, 0.001, 0.999)\n        y = np.clip(y, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    # Resolution strict rules limits map securely evaluation checking covers boundaries runs variables variations rules sets safely constraints sets validations runs maps bounds paths limits setup \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    for s in range(S):\n        cx, cy, cr = x[s].copy(), y[s].copy(), r[s].copy()\n        \n        cr = np.maximum(cr, 0.0)\n        # Apply intense constraint evaluation resolutions correctly checking safe ranges variables setups validations mapped fixes sizes ranges sets values cleanly covers   \n        for _ in range(120):\n            cr = np.minimum(cr, cx)\n            cr = np.minimum(cr, cy)\n            cr = np.minimum(cr, 1.0 - cx)\n            cr = np.minimum(cr, 1.0 - cy)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = cx[i] - cx[j]\n                    dy_v = cy[i] - cy[j]\n                    dist_v = np.hypot(dx_v, dy_v)\n                    if cr[i] + cr[j] > dist_v:\n                        scale = dist_v / max(cr[i] + cr[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            cr[i] *= scale\n                            cr[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Final rigorous safety validation bounding fixes ranges safely securely paths checks correctly validations bounds correctly configurations securely \n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        cr *= 0.999999\n        \n        sum_r = np.sum(cr)\n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((cx, cy))\n            best_radii = cr.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "0a237815-7e02-47e9-b161-384471ef13f7", "generation": 2, "timestamp": 1771994849.567072, "iteration_found": 9, "metrics": {"validity": 1.0, "sum_radii": 2.624686263821332, "target_ratio": 0.9960858686228965, "combined_score": 0.9960858686228965, "radius_variance": 0.004514058746871209, "spatial_spread": 0.18847769600192624, "eval_time": 16.82839035987854}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.6164441943464687, "target_ratio": 0.992957948518584, "combined_score": 0.992957948518584, "radius_variance": 0.0052666231160881805, "spatial_spread": 0.19439398138298558, "eval_time": 6.07276177406311}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9930\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9930\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n6.07s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.616444/2.635 = 0.9930\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.3% of target value\n```\n\n### radius_stats\n```\nMin: 0.055910, Max: 0.136933, Avg: 0.100632\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6164, target_ratio: 0.9930, combined_score: 0.9930, radius_variance: 0.0053, spatial_spread: 0.1944, eval_time: 6.0728\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9930)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads(x, y, r, pm):\n    dx = x[:, None] - x[None, :]\n    dy = y[:, None] - y[None, :]\n    dist2 = dx**2 + dy**2\n    \n    # Avoid identical-position NaNs gracefully during sqrt derivatives computation\n    dist2 = np.maximum(dist2, 1e-12)\n    np.fill_diagonal(dist2, 1000.0)\n    dist = np.sqrt(dist2)\n    \n    # Force application where bounds overlaps exist aggressively\n    overlap = np.maximum(0.0, r[:, None] + r[None, :] - dist)\n    factor = 2.0 * overlap / dist\n    \n    dl_dx = np.sum(factor * (-dx), axis=1)\n    dl_dy = np.sum(factor * (-dy), axis=1)\n    dl_dr = np.sum(2.0 * overlap, axis=1)\n    \n    # Box bounds repulsing dynamics to contain within 0-to-1 square walls securely\n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += -2.0 * wl + 2.0 * wr\n    dl_dy += -2.0 * wb + 2.0 * wt\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Scale via simulated wall firmness multiplier map\n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Minimize '-sum(radii)', achieving pure direct growth dynamics simultaneously\n    dl_dr = -1.0 + pm * dl_dr\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef get_initial_states(n):\n    states = []\n    \n    def ensure_n(pts, rr):\n        pts, rr = np.array(pts), np.array(rr)\n        num = len(rr)\n        if num > n:\n            return pts[:n, 0], pts[:n, 1], rr[:n]\n        elif num < n:\n            pad = n - num\n            extra_pts = np.random.uniform(0.1, 0.9, (pad, 2))\n            extra_rr = np.random.uniform(0.02, 0.05, pad)\n            new_pts = np.vstack([pts, extra_pts])\n            new_rr = np.concatenate([rr, extra_rr])\n            return new_pts[:, 0], new_pts[:, 1], new_rr\n        return pts[:, 0], pts[:, 1], rr\n\n    # Seed 0: Structured rings initialization heuristical mapping layout core biases\n    pts = [[0.5, 0.5]]\n    r = [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        r.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        r.append(0.06)\n    pts.append([0.15, 0.15])\n    r.append(0.07)\n    states.append(ensure_n(pts, r))\n    \n    # Seed 1: Heavy corners bias plus massive layout core mappings optimization starting position\n    pts = [[0.5, 0.5]]\n    r = [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        r.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        r.append(0.04)\n    states.append(ensure_n(pts, r))\n\n    # Seeds 2 to 7: Variable spread random assignments fully deterministic variations checks guarantees maximum hit spaces checks coverage paths setups runs ranges \n    for s in range(6):\n        np.random.seed(10 + s)\n        x = np.random.uniform(0.1, 0.9, n)\n        y = np.random.uniform(0.1, 0.9, n)\n        r = np.random.uniform(0.02, 0.08, n)\n        states.append((x, y, r))\n        \n    return states\n\n\ndef construct_packing():\n    n = 26\n    states = get_initial_states(n)\n    \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Define optimization loop bounds schedule sizes mapping correctly robust limits\n    steps = 8000\n    pms = np.minimum(10.0 * (1.0015 ** np.arange(steps)), 100000.0)\n    lrs = np.maximum(0.01 * (0.9995 ** np.arange(steps)), 1e-4)\n    \n    for state_idx, (x0, y0, r0) in enumerate(states):\n        np.random.seed(42 + state_idx)\n        \n        x = x0.copy()\n        y = y0.copy()\n        r = r0.copy()\n        \n        m_x, v_x = np.zeros(n), np.zeros(n)\n        m_y, v_y = np.zeros(n), np.zeros(n)\n        m_r, v_r = np.zeros(n), np.zeros(n)\n        \n        t = 0\n        for step in range(steps):\n            pm = pms[step]\n            current_lr = lrs[step]\n            \n            gx, gy, gr = get_grads(x, y, r, pm)\n            \n            t += 1\n            x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, current_lr)\n            y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, current_lr)\n            r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, current_lr)\n            \n            # Simulated annealing component ensures geometry avoids imperfect symmetric trap positions cleanly mappings mapping updates\n            if step < 5000:\n                noise_scale = 0.003 * (1.0 - step / 5000.0)\n                x += np.random.normal(0, noise_scale, n)\n                y += np.random.normal(0, noise_scale, n)\n                r += np.random.normal(0, noise_scale * 0.3, n)\n                \n            x = np.clip(x, 0.001, 0.999)\n            y = np.clip(y, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Extreme rigorous validation limits to correctly adhere evaluator bounds constraints securely \n        r = np.maximum(r, 0.0)\n        for _ in range(100):\n            r = np.minimum(r, x)\n            r = np.minimum(r, y)\n            r = np.minimum(r, 1.0 - x)\n            r = np.minimum(r, 1.0 - y)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = x[i] - x[j]\n                    dy_v = y[i] - y[j]\n                    dist_v = np.sqrt(dx_v * dx_v + dy_v * dy_v)\n                    if r[i] + r[j] > dist_v:\n                        scale = dist_v / max(r[i] + r[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            r[i] *= scale\n                            r[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Guaranteed domain floating points precision coverage pass safety factor blanket map sizes mapping fully safe mapping cleanly checks \n        r = np.minimum(r, x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, 1.0 - y)\n        r *= 0.999999\n        \n        sum_r = np.sum(r)\n        \n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((x, y))\n            best_radii = r.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6164), Performs well on target_ratio (0.9930), Performs well on combined_score (0.9930), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.1944), Performs well on eval_time (6.0728)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads(x, y, r, pm):\n    dx = x[:, None] - x[None, :]\n    dy = y[:, None] - y[None, :]\n    dist2 = dx**2 + dy**2\n    \n    # Avoid identical-position NaNs gracefully during sqrt derivatives computation\n    dist2 = np.maximum(dist2, 1e-12)\n    np.fill_diagonal(dist2, 1000.0)\n    dist = np.sqrt(dist2)\n    \n    # Force application where bounds overlaps exist aggressively\n    overlap = np.maximum(0.0, r[:, None] + r[None, :] - dist)\n    factor = 2.0 * overlap / dist\n    \n    dl_dx = np.sum(factor * (-dx), axis=1)\n    dl_dy = np.sum(factor * (-dy), axis=1)\n    dl_dr = np.sum(2.0 * overlap, axis=1)\n    \n    # Box bounds repulsing dynamics to contain within 0-to-1 square walls securely\n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += -2.0 * wl + 2.0 * wr\n    dl_dy += -2.0 * wb + 2.0 * wt\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Scale via simulated wall firmness multiplier map\n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Minimize '-sum(radii)', achieving pure direct growth dynamics simultaneously\n    dl_dr = -1.0 + pm * dl_dr\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef get_initial_states(n):\n    states = []\n    \n    def ensure_n(pts, rr):\n        pts, rr = np.array(pts), np.array(rr)\n        num = len(rr)\n        if num > n:\n            return pts[:n, 0], pts[:n, 1], rr[:n]\n        elif num < n:\n            pad = n - num\n            extra_pts = np.random.uniform(0.1, 0.9, (pad, 2))\n            extra_rr = np.random.uniform(0.02, 0.05, pad)\n            new_pts = np.vstack([pts, extra_pts])\n            new_rr = np.concatenate([rr, extra_rr])\n            return new_pts[:, 0], new_pts[:, 1], new_rr\n        return pts[:, 0], pts[:, 1], rr\n\n    # Seed 0: Structured rings initialization heuristical mapping layout core biases\n    pts = [[0.5, 0.5]]\n    r = [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        r.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        r.append(0.06)\n    pts.append([0.15, 0.15])\n    r.append(0.07)\n    states.append(ensure_n(pts, r))\n    \n    # Seed 1: Heavy corners bias plus massive layout core mappings optimization starting position\n    pts = [[0.5, 0.5]]\n    r = [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        r.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        r.append(0.04)\n    states.append(ensure_n(pts, r))\n\n    # Seeds 2 to 7: Variable spread random assignments fully deterministic variations checks guarantees maximum hit spaces checks coverage paths setups runs ranges \n    for s in range(6):\n        np.random.seed(10 + s)\n        x = np.random.uniform(0.1, 0.9, n)\n        y = np.random.uniform(0.1, 0.9, n)\n        r = np.random.uniform(0.02, 0.08, n)\n        states.append((x, y, r))\n        \n    return states\n\n\ndef construct_packing():\n    n = 26\n    states = get_initial_states(n)\n    \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Define optimization loop bounds schedule sizes mapping correctly robust limits\n    steps = 8000\n    pms = np.minimum(10.0 * (1.0015 ** np.arange(steps)), 100000.0)\n    lrs = np.maximum(0.01 * (0.9995 ** np.arange(steps)), 1e-4)\n    \n    for state_idx, (x0, y0, r0) in enumerate(states):\n        np.random.seed(42 + state_idx)\n        \n        x = x0.copy()\n        y = y0.copy()\n        r = r0.copy()\n        \n        m_x, v_x = np.zeros(n), np.zeros(n)\n        m_y, v_y = np.zeros(n), np.zeros(n)\n        m_r, v_r = np.zeros(n), np.zeros(n)\n        \n        t = 0\n        for step in range(steps):\n            pm = pms[step]\n            current_lr = lrs[step]\n            \n            gx, gy, gr = get_grads(x, y, r, pm)\n            \n            t += 1\n            x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, current_lr)\n            y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, current_lr)\n            r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, current_lr)\n            \n            # Simulated annealing component ensures geometry avoids imperfect symmetric trap positions cleanly mappings mapping updates\n            if step < 5000:\n                noise_scale = 0.003 * (1.0 - step / 5000.0)\n                x += np.random.normal(0, noise_scale, n)\n                y += np.random.normal(0, noise_scale, n)\n                r += np.random.normal(0, noise_scale * 0.3, n)\n                \n            x = np.clip(x, 0.001, 0.999)\n            y = np.clip(y, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Extreme rigorous validation limits to correctly adhere evaluator bounds constraints securely \n        r = np.maximum(r, 0.0)\n        for _ in range(100):\n            r = np.minimum(r, x)\n            r = np.minimum(r, y)\n            r = np.minimum(r, 1.0 - x)\n            r = np.minimum(r, 1.0 - y)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = x[i] - x[j]\n                    dy_v = y[i] - y[j]\n                    dist_v = np.sqrt(dx_v * dx_v + dy_v * dy_v)\n                    if r[i] + r[j] > dist_v:\n                        scale = dist_v / max(r[i] + r[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            r[i] *= scale\n                            r[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Guaranteed domain floating points precision coverage pass safety factor blanket map sizes mapping fully safe mapping cleanly checks \n        r = np.minimum(r, x)\n        r = np.minimum(r, y)\n        r = np.minimum(r, 1.0 - x)\n        r = np.minimum(r, 1.0 - y)\n        r *= 0.999999\n        \n        sum_r = np.sum(r)\n        \n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((x, y))\n            best_radii = r.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based batched circle packing optimization for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef adam_step(params, grads, m, v, t, lr=0.01, b1=0.9, b2=0.999, eps=1e-8):\n    \"\"\"Perform a batched Adam optimization step.\"\"\"\n    m = b1 * m + (1.0 - b1) * grads\n    v = b2 * v + (1.0 - b2) * (grads**2)\n    m_hat = m / (1.0 - b1**t)\n    v_hat = v / (1.0 - b2**t)\n    params = params - lr * m_hat / (np.sqrt(v_hat) + eps)\n    return params, m, v\n\n\ndef get_grads_batch(x, y, r, pm):\n    \"\"\"\n    Calculate the physics forces (gradients) simultaneously for a batch of simulated \n    seed environments, maximizing processing speed through strict numpy vectorization.\n    \"\"\"\n    # Calculate all pairwise directional components and distances mapping efficiently \n    dx = x[:, :, None] - x[:, None, :]\n    dy = y[:, :, None] - y[:, None, :]\n    dist = np.hypot(dx, dy)\n    \n    # Exclude identity self-comparisons bounds safely paths \n    S, n = x.shape\n    idx = np.arange(n)\n    dist[:, idx, idx] = 1000.0\n    \n    # Derive boundary overlaps mapped systems checks safely\n    overlap = r[:, :, None] + r[:, None, :] - dist\n    overlap = np.maximum(0.0, overlap)\n    \n    # Evaluate physics interactions with zero-div avoidance directly\n    factor = 2.0 * overlap / (dist + 1e-12)\n    \n    dl_dx = np.sum(factor * (-dx), axis=2)\n    dl_dy = np.sum(factor * (-dy), axis=2)\n    dl_dr = np.sum(2.0 * overlap, axis=2)\n    \n    # Execute wall box repulsive dynamic components \n    wl = np.maximum(0.0, r - x)\n    wr = np.maximum(0.0, r + x - 1.0)\n    wb = np.maximum(0.0, r - y)\n    wt = np.maximum(0.0, r + y - 1.0)\n    \n    dl_dx += 2.0 * (-wl + wr)\n    dl_dy += 2.0 * (-wb + wt)\n    dl_dr += 2.0 * (wl + wr + wb + wt)\n    \n    # Apply multiplicative mapping limit schedule variables multipliers mapping cleanly \n    dl_dx *= pm\n    dl_dy *= pm\n    \n    # Maximize layout density concurrently mappings securely runs fixes variables maps limits passes covers\n    dl_dr = pm * dl_dr - 1.0\n    \n    return dl_dx, dl_dy, dl_dr\n\n\ndef construct_packing():\n    \"\"\"Build densely packed configuration by aggressively evolving varied starting positions concurrently.\"\"\"\n    n = 26\n    S = 50  # Explores 50 geometrically diverse batch environments in parallel securely\n    \n    x = np.zeros((S, n))\n    y = np.zeros((S, n))\n    r = np.zeros((S, n))\n    \n    np.random.seed(42)\n    \n    # Seed 0: Structured concentric circles core setup logic sizes covers values constraints paths biases \n    pts, rs = [[0.5, 0.5]], [0.12]\n    for i in range(8):\n        a = 2.0 * np.pi * i / 8.0\n        pts.append([0.5 + 0.3 * np.cos(a), 0.5 + 0.3 * np.sin(a)])\n        rs.append(0.08)\n    for i in range(16):\n        a = 2.0 * np.pi * i / 16.0\n        pts.append([0.5 + 0.7 * np.cos(a), 0.5 + 0.7 * np.sin(a)])\n        rs.append(0.06)\n    pts.append([0.15, 0.15])\n    rs.append(0.07)\n    x[0] = np.array([p[0] for p in pts[:n]])\n    y[0] = np.array([p[1] for p in pts[:n]])\n    r[0] = np.array(rs[:n])\n    \n    # Seed 1: Boundary weighted configuration sets setups sets maps correctly runs limits validations\n    pts, rs = [[0.5, 0.5]], [0.18]\n    for dx, dy in [(0.15, 0.15), (0.15, 0.85), (0.85, 0.15), (0.85, 0.85)]:\n        pts.append([dx, dy])\n        rs.append(0.08)\n    for _ in range(n - 5):\n        pts.append([np.random.uniform(0.2, 0.8), np.random.uniform(0.2, 0.8)])\n        rs.append(0.04)\n    x[1] = np.array([p[0] for p in pts[:n]])\n    y[1] = np.array([p[1] for p in pts[:n]])\n    r[1] = np.array(rs[:n])\n\n    # Seed 2: 5-5-6-5-5 layered arrangement setups checks safely sets arrays ranges values maps rules securely correctly  \n    pts, rs = [], []\n    for r_idx, count in enumerate([5, 5, 6, 5, 5]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.06 if r_idx == 2 else 0.04)\n    x[2] = np.array([p[0] for p in pts[:n]])\n    y[2] = np.array([p[1] for p in pts[:n]])\n    r[2] = np.array(rs[:n])\n\n    # Seed 3: 6-5-4-5-6 geometric mapping shapes rules checks guarantees paths limits safely covers correctly limits variations constraints   \n    pts, rs = [], []\n    for r_idx, count in enumerate([6, 5, 4, 5, 6]):\n        y_pos = 0.1 + 0.8 * (r_idx / 4)\n        for c_idx in range(count):\n            x_pos = 0.1 + 0.8 * (c_idx / max(1, count - 1))\n            pts.append([x_pos, y_pos])\n            rs.append(0.08 if count == 4 else 0.05)\n    x[3] = np.array([p[0] for p in pts[:n]])\n    y[3] = np.array([p[1] for p in pts[:n]])\n    r[3] = np.array(rs[:n])\n\n    # Seeds 4 to S-1: Dynamic density biases logic implementations heuristics checking sizes securely variables runs constraints paths  \n    for s in range(4, S):\n        tx = np.random.uniform(0.1, 0.9, n)\n        ty = np.random.uniform(0.1, 0.9, n)\n        tr = np.random.uniform(0.02, 0.08, n)\n        \n        # Center-heavy prioritization logic mapping maps boundaries setups variables cleanly covers maps sizes variations mapping limits layouts updates\n        dist_to_center = np.hypot(tx - 0.5, ty - 0.5)\n        order = np.argsort(dist_to_center)\n        tr = np.sort(tr)[::-1]\n        \n        tr_ordered = np.zeros(n)\n        tr_ordered[order] = tr\n        \n        x[s] = tx\n        y[s] = ty\n        r[s] = tr_ordered\n\n    # Assign state parameters checking paths boundaries memory fully mapping coverage sizes rules cleanly sizes \n    m_x, v_x = np.zeros((S, n)), np.zeros((S, n))\n    m_y, v_y = np.zeros((S, n)), np.zeros((S, n))\n    m_r, v_r = np.zeros((S, n)), np.zeros((S, n))\n    \n    steps = 13000\n    pms = np.minimum(10.0 * (1.0011 ** np.arange(steps)), 800000.0)\n    lrs = np.maximum(0.012 * (0.9996 ** np.arange(steps)), 1e-4)\n    noise_steps = 6500\n    \n    # Process concurrent batches smoothly mapping sets passes evaluations optimizations bounds updates sizes constraints maps checks loops values \n    t = 0\n    for step in range(steps):\n        pm = pms[step]\n        lr = lrs[step]\n        \n        gx, gy, gr = get_grads_batch(x, y, r, pm)\n        \n        t += 1\n        x, m_x, v_x = adam_step(x, gx, m_x, v_x, t, lr)\n        y, m_y, v_y = adam_step(y, gy, m_y, v_y, t, lr)\n        r, m_r, v_r = adam_step(r, gr, m_r, v_r, t, lr)\n        \n        # Perform targeted noise perturbations correctly escaping local minima trapping boundaries ranges constraints checking constraints covers \n        if step < noise_steps:\n            noise_scale = 0.004 * (1.0 - step / noise_steps)\n            x += np.random.normal(0, noise_scale, (S, n))\n            y += np.random.normal(0, noise_scale, (S, n))\n            r += np.random.normal(0, noise_scale * 0.3, (S, n))\n            \n        x = np.clip(x, 0.001, 0.999)\n        y = np.clip(y, 0.001, 0.999)\n        r = np.maximum(r, 0.001)\n\n    # Resolution strict rules limits map securely evaluation checking covers boundaries runs variables variations rules sets safely constraints sets validations runs maps bounds paths limits setup \n    best_sum_radii = -1.0\n    best_centers = None\n    best_radii = None\n    \n    for s in range(S):\n        cx, cy, cr = x[s].copy(), y[s].copy(), r[s].copy()\n        \n        cr = np.maximum(cr, 0.0)\n        # Apply intense constraint evaluation resolutions correctly checking safe ranges variables setups validations mapped fixes sizes ranges sets values cleanly covers   \n        for _ in range(120):\n            cr = np.minimum(cr, cx)\n            cr = np.minimum(cr, cy)\n            cr = np.minimum(cr, 1.0 - cx)\n            cr = np.minimum(cr, 1.0 - cy)\n            \n            changed = False\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dx_v = cx[i] - cx[j]\n                    dy_v = cy[i] - cy[j]\n                    dist_v = np.hypot(dx_v, dy_v)\n                    if cr[i] + cr[j] > dist_v:\n                        scale = dist_v / max(cr[i] + cr[j], 1e-12)\n                        scale = max(0.0, scale - 1e-9)\n                        if scale < 1.0:\n                            cr[i] *= scale\n                            cr[j] *= scale\n                            changed = True\n                            \n            if not changed:\n                break\n                \n        # Final rigorous safety validation bounding fixes ranges safely securely paths checks correctly validations bounds correctly configurations securely \n        cr = np.minimum(cr, cx)\n        cr = np.minimum(cr, cy)\n        cr = np.minimum(cr, 1.0 - cx)\n        cr = np.minimum(cr, 1.0 - cy)\n        cr *= 0.999999\n        \n        sum_r = np.sum(cr)\n        if sum_r > best_sum_radii:\n            best_sum_radii = sum_r\n            best_centers = np.column_stack((cx, cy))\n            best_radii = cr.copy()\n            \n    return best_centers, best_radii, best_sum_radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```"]}}, "artifacts_json": "{\"execution_time\": \"16.83s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.624686/2.635 = 0.9961\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.6% of target value\", \"radius_stats\": \"Min: 0.069012, Max: 0.136381, Avg: 0.100949\"}", "artifact_dir": null, "embedding": null}