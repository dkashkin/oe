{"id": "12eac90f-9646-401e-9262-f469d87de2ed", "code": "# EVOLVE-BLOCK-START\n\"\"\"Iterative Physics-based optimization and explicit Linear Programming extraction for packing 26 circles.\"\"\"\nimport numpy as np\n\n\ndef init_batch(B, n):\n    \"\"\"\n    Generate mathematically structured initial coordinates alongside strategically \n    focused relative radii weights to thoroughly discover diverse geometrical configurations.\n    \"\"\"\n    np.random.seed(84)\n    centers = np.random.uniform(0.1, 0.9, (B, n, 2))\n    weights = np.ones((B, n))\n\n    for b in range(B):\n        strat = b % 8\n        if strat == 0:\n            weights[b] = np.random.uniform(0.8, 2.8, n)\n        elif strat == 1:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 3.8\n            weights[b, 1:6] = 2.0\n            weights[b, 6:] = np.random.uniform(0.5, 1.4, n - 6)\n        elif strat == 2:\n            centers[b, 0] = [0.3, 0.3]; weights[b, 0] = 3.0\n            centers[b, 1] = [0.7, 0.7]; weights[b, 1] = 3.0\n            centers[b, 2] = [0.3, 0.7]; weights[b, 2] = 3.0\n            centers[b, 3] = [0.7, 0.3]; weights[b, 3] = 3.0\n            weights[b, 4:] = np.random.uniform(0.5, 1.3, n - 4)\n        elif strat == 3:\n            weights[b] = 2.8 * np.exp(-np.arange(n) / 5.0) + 0.5\n        elif strat == 4:\n            weights[b] = np.random.pareto(2, n) + 0.8\n        elif strat == 5:\n            weights[b, :8] = 2.6\n            weights[b, 8:] = 0.6\n        elif strat == 6:\n            for i in range(n):\n                centers[b, i] = [0.12 + (i % 5) * 0.19, 0.1 + (i // 5) * 0.15 + (i % 2) * 0.05]\n            weights[b] = 1.3\n        elif strat == 7:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 4.2\n            weights[b, 1:12] = 1.8\n            weights[b, 12:] = 0.5\n\n    # Introduce generalized spatial diversity shifts natively escaping local minima\n    centers += np.random.normal(0, 0.015, (B, n, 2))\n    centers = np.clip(centers, 0.05, 0.95)\n    weights *= np.random.uniform(0.8, 1.2, (B, n))\n\n    return centers, weights\n\n\ndef optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2400):\n    \"\"\"\n    Highly vectorised physics optimizer. Progressively smoothly adapts dynamic collision parameters \n    enforcing dense boundary mappings globally safely extracting diverse topological sets optimally.\n    \"\"\"\n    B, n, _ = centers_b.shape\n    \n    m_c = np.zeros_like(centers_b)\n    v_c = np.zeros_like(centers_b)\n    m_r = np.zeros_like(radii_b)\n    v_r = np.zeros_like(radii_b)\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    eye = np.eye(n, dtype=bool)\n\n    for step in range(1, num_steps + 1):\n        prog = step / num_steps\n\n        # Transition structural size biasing softly strictly settling evenly near conclusive layouts\n        weight_transition = np.clip((prog - 0.5) / 0.2, 0.0, 1.0)\n        cur_weights = weights_b * (1.0 - weight_transition) + np.ones((B, n)) * weight_transition\n        \n        lr_c = 0.008 * (1.0 - prog ** 1.1)\n        lr_r = 0.008 * (1.0 - prog ** 1.5)\n        \n        k = 15.0 + 3500.0 * (np.maximum(0, prog - 0.35) * 1.538) ** 3\n        kb = 15.0 + 3500.0 * (np.maximum(0, prog - 0.35) * 1.538) ** 3\n\n        diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n        dist = np.linalg.norm(diffs, axis=-1)\n        dist[:, eye] = np.inf\n\n        overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n        overlaps[:, eye] = 0\n\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        # Calculate analytically explicit interactive gradient trajectories efficiently precisely  \n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=2)\n\n        o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n        o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n        o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n        o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n\n        grad_c_bounds = kb * np.stack([-o_xl + o_xr, -o_yl + o_yr], axis=2)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=2) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers_b -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii_b -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        radii_b = np.maximum(radii_b, 0.001)\n        centers_b = np.clip(centers_b, 0.005, 0.995)\n\n    return centers_b, radii_b\n\n\ndef extract_best_packing(centers_b, radii_b):\n    \"\"\"\n    Accurately validates spatial matrices via linear programming identifying safely precisely properly bounded geometries dynamically gracefully perfectly correctly.\n    \"\"\"\n    try:\n        from scipy.optimize import linprog\n        HAS_SCIPY = True\n    except ImportError:\n        HAS_SCIPY = False\n\n    B, n, _ = centers_b.shape\n    best_c, best_r, best_s = None, None, -1.0\n    \n    eye = np.eye(n, dtype=bool)\n    diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n    dist = np.linalg.norm(diffs, axis=-1)\n    dist[:, eye] = np.inf\n    overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n    \n    o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n    o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n    o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n    o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n    \n    max_ov = np.max(overlaps, axis=(1, 2)) + np.max(o_xl + o_xr + o_yl + o_yr, axis=1)\n    sum_r = np.sum(radii_b, axis=1)\n    \n    proxy_scores = sum_r - max_ov * 1.5 - np.sum(overlaps, axis=(1, 2)) * 0.5\n    top_candidates = np.argsort(proxy_scores)[-48:]\n    \n    for b in top_candidates:\n        c = centers_b[b].copy()\n        r_current = None\n        \n        if HAS_SCIPY:\n            c_x = c[:, 0]\n            c_y = c[:, 1]\n            bounds = []\n            for i in range(n):\n                m_b = max(0.0, min(c_x[i], c_y[i], 1.0 - c_x[i], 1.0 - c_y[i]))\n                bounds.append((0, m_b))\n                \n            A_ub = []\n            b_ub = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(c[i] - c[j])\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_ub.append(row)\n                    b_ub.append(d)\n                    \n            try:\n                res = linprog(-np.ones(n), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if res.success:\n                    r_current = res.x\n            except Exception:\n                pass\n                \n        if r_current is None:\n            r_current = radii_b[b].copy()\n            for _ in range(400):\n                max_ov_iter = 0.0\n                for i in range(n):\n                    mb = min(c[i, 0], c[i, 1], 1 - c[i, 0], 1 - c[i, 1])\n                    if r_current[i] > mb: \n                        r_current[i] = max(0.0, mb)\n                    for j in range(i + 1, n):\n                        d = np.linalg.norm(c[i] - c[j])\n                        ov = r_current[i] + r_current[j] - d\n                        if ov > 1e-10:\n                            if ov > max_ov_iter: \n                                max_ov_iter = ov\n                            ratio = r_current[i] / max(1e-9, r_current[i] + r_current[j])\n                            r_current[i] -= ov * ratio * 1.01\n                            r_current[j] -= ov * (1 - ratio) * 1.01\n                if max_ov_iter < 1e-10:\n                    break\n\n        r_current = np.clip(r_current, 0.0, None)\n        \n        # Absolute validation scaling explicitly mapping perfectly correctly natively loops cleanly matrices boundaries! \n        for _ in range(3):\n            for i in range(n):\n                mb = min(c[i, 0], c[i, 1], 1 - c[i, 0], 1 - c[i, 1])\n                if r_current[i] > mb: \n                    r_current[i] = mb\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(c[i] - c[j])\n                    if r_current[i] + r_current[j] > d:\n                        scale = d / (r_current[i] + r_current[j] + 1e-14)\n                        r_current[i] *= scale\n                        r_current[j] *= scale\n                        \n        r_current *= (1.0 - 1e-8)\n        s = np.sum(r_current)\n        \n        if s > best_s:\n            best_s = s\n            best_c = c\n            best_r = r_current\n            \n    return best_c, best_r, best_s\n\n\ndef construct_packing():\n    \"\"\"\n    Main constructor explicitly linking physics layouts smoothly successfully evaluating cleanly smartly precisely seamlessly mathematically arrays! \n    \"\"\"\n    B = 256\n    n = 26\n    centers_b, weights_b = init_batch(B, n)\n    radii_b = np.ones((B, n)) * 0.02\n    \n    c_b, r_b = optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2400)\n    \n    return extract_best_packing(c_b, r_b)\n\n\ndef compute_max_radii(centers):\n    \"\"\"Fallback proxy mapping constraints variables properly seamlessly optimally smoothly\"\"\"\n    pass\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n", "changes_description": null, "language": "python", "parent_id": "29cb9678-794b-4ace-9126-8ad0d0431eb7", "generation": 2, "timestamp": 1771995777.3843558, "iteration_found": 24, "metrics": {"validity": 1.0, "sum_radii": 2.625409545317052, "target_ratio": 0.9963603587540995, "combined_score": 0.9963603587540995, "radius_variance": 0.005366437801092796, "spatial_spread": 0.19405459643834563, "eval_time": 29.699478149414062}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.5863089252680975, "target_ratio": 0.9815214137639839, "combined_score": 0.9815214137639839, "radius_variance": 0.004403489419231537, "spatial_spread": 0.19507192443756233, "eval_time": 7.399550199508667}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9815\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9886 \u2192 0.9815. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n7.40s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.586309/2.635 = 0.9815\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 98.2% of target value\n```\n\n### radius_stats\n```\nMin: 0.070881, Max: 0.132817, Avg: 0.099473\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6049, target_ratio: 0.9886, combined_score: 0.9886, radius_variance: 0.0062, spatial_spread: 0.1868, eval_time: 2.1710\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6207, target_ratio: 0.9946, combined_score: 0.9946, radius_variance: 0.0053, spatial_spread: 0.2038, eval_time: 8.2265\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6304, target_ratio: 0.9982, combined_score: 0.9982, radius_variance: 0.0055, spatial_spread: 0.1974, eval_time: 27.0419\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9982)\n```python\n\"\"\"Iterative Physics-based optimization for packing 26 circles.\"\"\"\nimport numpy as np\n\n\ndef init_batch(B, n):\n    \"\"\"\n    Generate mathematically structured initial coordinates alongside strategically \n    focused relative radii weights to thoroughly discover diverse configurations mapping properly.\n    \"\"\"\n    centers = np.random.uniform(0.1, 0.9, (B, n, 2))\n    weights = np.ones((B, n))\n\n    for b in range(B):\n        strat = b % 8\n        if strat == 0:\n            weights[b] = np.random.uniform(0.5, 2.5, n)\n        elif strat == 1:\n            weights[b, 0] = 3.5\n            weights[b, 1:5] = 1.8\n            weights[b, 5:] = np.random.uniform(0.3, 1.2, n - 5)\n        elif strat == 2:\n            centers[b, 0] = [0.3, 0.3]; weights[b, 0] = 2.5\n            centers[b, 1] = [0.7, 0.7]; weights[b, 1] = 2.5\n            centers[b, 2] = [0.3, 0.7]; weights[b, 2] = 2.5\n            centers[b, 3] = [0.7, 0.3]; weights[b, 3] = 2.5\n            weights[b, 4:] = np.random.uniform(0.4, 1.0, n - 4)\n        elif strat == 3:\n            # Exponentially weighted focus elements natively gracefully executed \n            weights[b] = 2.5 * np.exp(-np.arange(n) / 6.0)\n        elif strat == 4:\n            weights[b] = 1.0\n        elif strat == 5:\n            # High variance explicitly mapped effectively separating bimodal size components explicitly cleanly explicitly\n            weights[b, :6] = 2.2\n            weights[b, 6:] = 0.5\n        elif strat == 6:\n            for i in range(n):\n                centers[b, i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.15 + (i % 2) * 0.05]\n            weights[b] = 1.5\n        elif strat == 7:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 4.0\n            weights[b, 1:10] = 1.5\n            weights[b, 10:] = 0.5\n\n    # Universal structural break introducing essential spatial diversity mappings explicitly robust correctly \n    centers += np.random.normal(0, 0.01, (B, n, 2))\n    centers = np.clip(centers, 0.05, 0.95)\n    weights *= np.random.uniform(0.8, 1.2, (B, n))\n\n    return centers, weights\n\n\ndef optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2200):\n    \"\"\"\n    Highly vectorised explicit pure NumPy optimizer maximizing packings perfectly flawlessly mappings securely explicitly natively elegantly properly reliably safely smoothly executing simultaneously properly intelligently executing across batches!\n    \"\"\"\n    B, n, _ = centers_b.shape\n    \n    m_c = np.zeros_like(centers_b)\n    v_c = np.zeros_like(centers_b)\n    m_r = np.zeros_like(radii_b)\n    v_r = np.zeros_like(radii_b)\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    eye = np.eye(n, dtype=bool)\n\n    for step in range(1, num_steps + 1):\n        prog = step / num_steps\n\n        weight_transition = np.clip((prog - 0.5) / 0.2, 0.0, 1.0)\n        cur_weights = weights_b * (1.0 - weight_transition) + np.ones((B, n)) * weight_transition\n        \n        lr_c = 0.005 * (1.0 - prog)\n        lr_r = 0.005 * (1.0 - prog ** 1.5)\n        \n        k = 10.0 + 3000.0 * (np.maximum(0, prog - 0.4) * 1.666) ** 3\n        kb = 10.0 + 3000.0 * (np.maximum(0, prog - 0.4) * 1.666) ** 3\n\n        diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n        # Strict explicit vectorised distances correctly explicitly mappings perfectly robust\n        dist = np.sqrt(np.sum(diffs ** 2, axis=-1))\n        dist[:, eye] = np.inf\n\n        overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n        overlaps[:, eye] = 0\n\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=2)\n\n        o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n        o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n        o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n        o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n\n        grad_c_bounds = np.zeros_like(centers_b)\n        grad_c_bounds[..., 0] = kb * (-o_xl + o_xr)\n        grad_c_bounds[..., 1] = kb * (-o_yl + o_yr)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=2) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        # Vectorized momentum seamlessly gracefully updates properly\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers_b -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii_b -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        radii_b = np.maximum(radii_b, 0.001)\n        centers_b = np.clip(centers_b, 0.005, 0.995)\n\n    return centers_b, radii_b\n\n\ndef extract_best_packing(centers_b, radii_b):\n    \"\"\"\n    Extensively verifies mappings mathematically elegantly returning natively exactly perfectly robust geometrical configurations rigorously successfully optimally mapping safely optimally\n    \"\"\"\n    B, n, _ = centers_b.shape\n    best_c, best_r, best_s = None, None, -1.0\n    \n    eye = np.eye(n, dtype=bool)\n    diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n    dist = np.sqrt(np.sum(diffs ** 2, axis=-1))\n    dist[:, eye] = np.inf\n    overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n    \n    o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n    o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n    o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n    o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n    \n    max_ov = np.max(overlaps, axis=(1, 2)) + np.max(o_xl + o_xr + o_yl + o_yr, axis=1)\n    sum_r = np.sum(radii_b, axis=1)\n    \n    # Pre-select natively successfully explicitly explicit intelligently filtering efficiently optimizing securely successfully\n    proxy_scores = sum_r - max_ov * 1.5 - np.sum(overlaps, axis=(1, 2)) * 0.5\n    top_candidates = np.argsort(proxy_scores)[-40:]\n    \n    for b in top_candidates:\n        c = centers_b[b].copy()\n        r = radii_b[b].copy()\n        \n        for i in range(n):\n            x, y = c[i]\n            r[i] = min(r[i], x, y, 1 - x, 1 - y)\n            \n        for _ in range(250):\n            max_ov_iter = 0.0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_val = np.linalg.norm(c[i] - c[j])\n                    ov = r[i] + r[j] - dist_val\n                    if ov > 1e-8:\n                        if ov > max_ov_iter: max_ov_iter = ov\n                        r[i] -= ov * 0.501\n                        r[j] -= ov * 0.501\n            if max_ov_iter < 1e-8:\n                break\n                \n        r = np.maximum(r, 0.0)\n        \n        for i in range(n):\n            x, y = c[i]\n            r[i] = min(r[i], x, y, 1 - x, 1 - y)\n            for j in range(i + 1, n):\n                dist_val = np.linalg.norm(c[i] - c[j])\n                if r[i] + r[j] > dist_val:\n                    ov = r[i] + r[j] - dist_val\n                    ratio = r[i] / max(1e-9, r[i] + r[j])\n                    r[i] -= ov * ratio\n                    r[j] -= ov * (1 - ratio)\n                    \n        r = np.maximum(r, 0.0)\n        s = np.sum(r)\n        \n        if s > best_s:\n            best_s = s\n            best_c = c\n            best_r = r\n            \n    return best_c, best_r, best_s\n\n\ndef construct_packing():\n    \"\"\"\n    Central wrapper combining correctly smoothly logically optimally explicitly cleanly mappings directly successfully precisely seamlessly mathematically executing rigorously flawlessly natively cleanly perfectly explicit reliably cleanly!\n    \"\"\"\n    B = 256\n    n = 26\n    centers_b, weights_b = init_batch(B, n)\n    radii_b = np.ones((B, n)) * 0.02\n    \n    c_b, r_b = optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2200)\n    \n    return extract_best_packing(c_b, r_b)\n\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6304), Performs well on target_ratio (0.9982), Performs well on combined_score (0.9982), Performs well on radius_variance (0.0055), Performs well on spatial_spread (0.1974), Performs well on eval_time (27.0419)\n\n### Program 2 (Score: 0.9946)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimization-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef extract_best_packing(centers_batch, opt_r_batch):\n    \"\"\"\n    Evaluates batched optimized center configurations. rigorously extracts the absolute maximum mathematically \n    possible non-overlapping radii corresponding precisely to those structures natively solving proxy limits \n    leveraging the Highs bounded extraction parameters mappings loops spaces bounds sizes restrictions loops formats ranges logic mappings!\n    \"\"\"\n    try:\n        from scipy.optimize import linprog\n        HAS_SCIPY = True\n    except ImportError:\n        HAS_SCIPY = False\n\n    B, N = centers_batch.shape[:2]\n    best_c = None\n    best_r = None\n    best_sum = -1.0\n    \n    for b in range(B):\n        c = centers_batch[b]\n        curr_r = opt_r_batch[b]\n        radii = None\n        \n        if HAS_SCIPY:\n            bounds = []\n            c_x = c[:, 0]\n            c_y = c[:, 1]\n            for i in range(N):\n                # Hard rigid geometry box structures boundaries limits geometries parameters shapes geometries mapping overlaps loops variations ranges dimensions parameters layouts overlaps limitations\n                max_bound = max(0.0, min(c_x[i], c_y[i], 1.0 - c_x[i], 1.0 - c_y[i]))\n                bounds.append((0, max_bound))\n                \n            A_ub = []\n            b_ub = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    row = np.zeros(N)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_ub.append(row)\n                    b_ub.append(dist)\n                    \n            try:\n                res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if res.success:\n                    radii = res.x\n            except Exception:\n                try:\n                    res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n                    if res.success:\n                        radii = res.x\n                except Exception:\n                    pass\n                    \n        if radii is None:\n            # Complete scalar boundary overlaps validation extraction fallback limits ranges sizes layouts calculations \n            r = np.copy(curr_r)\n            for i in range(N):\n                mb = min(c[i, 0], c[i, 1], 1.0 - c[i, 0], 1.0 - c[i, 1])\n                r[i] = min(max(0.0, mb), r[i])\n                \n            for _ in range(300):\n                max_ov = 0.0\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.linalg.norm(c[i] - c[j])\n                        if r[i] + r[j] > dist:\n                            ov = r[i] + r[j] - dist\n                            max_ov = max(max_ov, ov)\n                            scale = dist / (r[i] + r[j] + 1e-12)\n                            r[i] *= scale\n                            r[j] *= scale\n                if max_ov < 1e-10:\n                    break\n            radii = r\n\n        # Assure total scale mathematical gaps floating structures restrictions validation mapping formats boundaries gaps variables logic lengths loops overlaps variables! \n        radii = np.clip(radii, 0.0, None) * (1.0 - 1e-8)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = np.copy(c)\n            best_r = np.copy(radii)\n            \n    return best_c, best_r, best_sum\n\n\ndef optimize_packings():\n    \"\"\"\n    Vectorized heavily mapping distributions configurations variables optimizing arrays constraints bounds sizes loops variables ranges logic distributions layouts checks limitations arrays distributions bounds constraints structures!\n    \"\"\"\n    np.random.seed(42)\n    B, N = 64, 26\n    T = 2500\n    \n    centers = np.random.uniform(0.1, 0.9, (B, N, 2))\n    weights = np.ones((B, N))\n    \n    for b in range(B):\n        strat = b % 8\n        if strat == 0:\n            weights[b] = np.random.uniform(1.0, 3.5, N)\n        elif strat == 1:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 3.5\n            for i in range(1, 9):\n                ang = 2 * np.pi * i / 8\n                r_offset = 0.2 + np.random.normal(0, 0.02)\n                centers[b, i] = [0.5 + r_offset * np.cos(ang), 0.5 + r_offset * np.sin(ang)]\n                weights[b, i] = 2.0\n        elif strat == 2:\n            grid = np.linspace(0.15, 0.85, 5)\n            xv, yv = np.meshgrid(grid, grid)\n            pts = np.vstack([xv.flatten(), yv.flatten()]).T\n            centers[b, :25] = pts + np.random.normal(0, 0.02, (25, 2))\n            centers[b, 25] = [0.5, 0.5]\n        elif strat == 3:\n            weights[b] = np.random.pareto(2, N) + 1.0\n            idx = np.argsort(-weights[b])\n            for k_i, i in enumerate(idx):\n                r = 0.45 * np.sqrt(k_i / N)\n                t = k_i * np.pi * (1 + np.sqrt(5))\n                centers[b, i] = [0.5 + r * np.cos(t), 0.5 + r * np.sin(t)]\n        elif strat == 4:\n            corners = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n            for i in range(4):\n                centers[b, i] = corners[i]\n                weights[b, i] = 3.5\n            for i in range(4, 12):\n                c = i % 4\n                ang = np.random.uniform(0, 2 * np.pi)\n                centers[b, i] = [corners[c][0] + 0.12 * np.cos(ang), corners[c][1] + 0.12 * np.sin(ang)]\n                weights[b, i] = 2.0\n        elif strat == 5:\n            dists = np.linalg.norm(centers[b] - 0.5, axis=1)\n            weights[b] = 1.0 + 3.0 * dists\n        elif strat == 6:\n            for i in range(N):\n                r_c = np.sqrt((i + 0.5) / N) * 0.45\n                t = i * np.pi * (1 + np.sqrt(5))\n                centers[b, i] = [0.5 + r_c * np.cos(t), 0.5 + r_c * np.sin(t)]\n                weights[b, i] = 2.0 if i < 6 else 1.0\n        elif strat == 7:\n            centers[b, 0] = [0.35, 0.5]\n            weights[b, 0] = 3.0\n            centers[b, 1] = [0.65, 0.5]\n            weights[b, 1] = 3.0\n            \n        centers[b] += np.random.normal(0, 0.005, (N, 2))\n        centers[b] = np.clip(centers[b], 0.05, 0.95)\n\n    radii = np.full((B, N), 0.05)\n    \n    m_c, v_c = np.zeros_like(centers), np.zeros_like(centers)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    eye = np.eye(N)[None, :, :]\n    \n    for step in range(1, T + 1):\n        prog = step / T\n        \n        lr_c = 0.008 * (1 - prog * 0.85)\n        lr_r = 0.008 * (1 - prog * 0.95)\n        k = 15.0 + prog * 150.0\n        kb = 15.0 + prog * 150.0\n\n        if prog > 0.85:\n            cur_weights = np.ones_like(weights)\n        else:\n            cur_weights = weights\n\n        diffs = centers[:, :, None, :] - centers[:, None, :, :]  # (B, N, N, 2)\n        dist = np.linalg.norm(diffs, axis=-1)  # (B, N, N)\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        overlaps = radii[:, :, None] + radii[:, None, :] - dist\n        overlaps = np.maximum(0, overlaps) * (1 - eye)\n        \n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=2)\n        \n        o_xl = np.maximum(0, radii - centers[..., 0])\n        o_xr = np.maximum(0, centers[..., 0] + radii - 1)\n        o_yl = np.maximum(0, radii - centers[..., 1])\n        o_yr = np.maximum(0, centers[..., 1] + radii - 1)\n\n        grad_c_bounds = kb * np.stack([-o_xl + o_xr, -o_yl + o_yr], axis=2)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=2) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        radii = np.maximum(radii, 0.001)\n        centers = np.clip(centers, 0.005, 0.995)\n\n    return extract_best_packing(centers, radii)\n\n\ndef construct_packing():\n    best_c, best_r, best_s = optimize_packings()\n    return best_c, best_r, best_s\n\n\ndef compute_max_radii(centers):\n    \"\"\"Fallback bypass\"\"\"\n    pass\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6207), Performs well on target_ratio (0.9946), Performs well on combined_score (0.9946), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.2038), Performs well on eval_time (8.2265)\n\n### Program 3 (Score: 0.9886)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Physics-based optimization for packing 26 circles.\"\"\"\nimport numpy as np\n\n\ndef optimize_adam(centers, radii, weights, num_steps=2000):\n    \"\"\"\n    Perform physics-inspired Adam optimization using overlaps as potentials.\n    Progressively increases collision penalties to smoothly separate objects.\n    \"\"\"\n    n = len(radii)\n    m_c = np.zeros_like(centers)\n    v_c = np.zeros_like(centers)\n    m_r = np.zeros_like(radii)\n    v_r = np.zeros_like(radii)\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n\n    for step in range(1, num_steps + 1):\n        prog = step / num_steps\n        \n        # Simulated annealing layout constraints: lower rates + stiffer overlaps over time\n        lr_c = 0.005 * (1 - prog * 0.8)\n        lr_r = 0.005 * (1 - prog * 0.9)\n        k = 10.0 + prog * 90.0\n        kb = 10.0 + prog * 90.0\n\n        # Uniform weight mapping during final 20% strictly tracks factual fitness bounds\n        cur_weights = np.ones(n) if prog > 0.8 else weights\n\n        diffs = centers[:, None, :] - centers[None, :, :]\n        dist = np.linalg.norm(diffs, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        overlaps = radii[:, None] + radii[None, :] - dist\n        overlaps = np.maximum(0, overlaps)\n        np.fill_diagonal(overlaps, 0)\n\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        # Differentiable gradients mapped for overlapping matrices\n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=1)\n\n        o_xl = np.maximum(0, radii - centers[:, 0])\n        o_xr = np.maximum(0, centers[:, 0] + radii - 1)\n        o_yl = np.maximum(0, radii - centers[:, 1])\n        o_yr = np.maximum(0, centers[:, 1] + radii - 1)\n\n        grad_c_bounds = kb * np.stack([-o_xl + o_xr, -o_yl + o_yr], axis=1)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=1) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        # Apply state momentum steps to centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        # Apply state momentum steps to radii mapping volumes\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        # Retain constraints strictly within logical volume boxes\n        radii = np.maximum(radii, 0.001)\n        centers = np.clip(centers, 0.005, 0.995)\n\n    return centers, radii\n\n\ndef compute_max_radii(centers, start_radii=None):\n    \"\"\"\n    Compute rigid, optimally shrunken radii without strict overlap faults.\n    Returns cleaned configuration passing factual limits.\n    \"\"\"\n    n = centers.shape[0]\n    radii = start_radii.copy() if start_radii is not None else np.ones(n) * 0.5\n    \n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Distributed soft contraction resolves interconnected radii cascades\n    for _ in range(200):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                ov = radii[i] + radii[j] - dist\n                if ov > 1e-8:\n                    max_ov = max(max_ov, ov)\n                    radii[i] -= ov * 0.505\n                    radii[j] -= ov * 0.505\n        if max_ov < 1e-8:\n            break\n\n    radii = np.maximum(radii, 0.0)\n    \n    # Rigorous last sweep absolutely eliminating bounds rounding thresholds\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                ov = radii[i] + radii[j] - dist\n                ratio = radii[i] / max(1e-9, radii[i] + radii[j])\n                radii[i] -= ov * ratio\n                radii[j] -= ov * (1 - ratio)\n\n    return np.maximum(radii, 0.0)\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a rigorously optimized layout combining Adam geometric flows \n    and strict spatial limits evaluating n=26 distinct nodes.\n    \n    Returns: Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    best_c, best_r, best_s = None, None, -1.0\n\n    # Iteration across symmetry breaks discovering multiple basin architectures\n    for restart in range(8):\n        centers = np.random.uniform(0.1, 0.9, (n, 2))\n        weights = np.ones(n)\n\n        # Enforce varying density distributions strategically mapped toward margins vs focus \n        if restart == 0: \n            centers[0], weights[0] = [0.5, 0.5], 2.5\n            for i, p in enumerate([[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]):\n                centers[i + 1], weights[i + 1] = p, 1.5\n        elif restart == 1: \n            centers[0], weights[0] = [0.5, 0.5], 2.5\n            for i in range(8):\n                centers[i + 1] = [0.5 + 0.2 * np.cos(i * np.pi / 4), 0.5 + 0.2 * np.sin(i * np.pi / 4)]\n                weights[i + 1] = 1.3\n            for i in range(16):\n                centers[i + 9] = [0.5 + 0.4 * np.cos(i * np.pi / 8), 0.5 + 0.4 * np.sin(i * np.pi / 8)]\n        elif restart == 2:\n            X, Y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            centers[:25] = np.column_stack((X.flatten(), Y.flatten()))\n            centers[25], weights[12] = [0.5, 0.5], 3.0\n        elif restart == 3: \n            for i in range(n):\n                r_c = np.sqrt((i + 0.5) / n) * 0.45\n                t = i * np.pi * (1 + np.sqrt(5))\n                centers[i] = [0.5 + r_c * np.cos(t), 0.5 + r_c * np.sin(t)]\n                weights[i] = 1.0 if i > 5 else 1.8\n        else:\n            for i in range(n):\n                if i < 4: \n                    weights[i] = 2.0\n            centers += np.random.normal(0, 0.1, (n, 2))\n\n        # Always implement distinct granular spatial randomizations bypassing localized locking architectures\n        centers += np.random.normal(0, 0.005, (n, 2))\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.ones(n) * 0.01\n\n        # Evaluate trajectory settling geometry layouts safely \n        c, r = optimize_adam(centers, radii, weights, num_steps=2000)\n        \n        # Absolute evaluation ensuring bounding conditions precisely enforced\n        valid_r = compute_max_radii(c, r)\n        s = np.sum(valid_r)\n\n        if s > best_s:\n            best_s, best_c, best_r = s, c, valid_r\n\n    return best_c, best_r, best_s\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6049), Performs well on target_ratio (0.9886), Performs well on combined_score (0.9886), Performs well on radius_variance (0.0062), Performs well on spatial_spread (0.1868), Performs well on eval_time (2.1710)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9815)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimization-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef extract_best_packing(centers_batch, opt_r_batch):\n    \"\"\"\n    Given a batch of optimized center arrangements, rigorously extracts exactly\n    optimal valid radii arrays either using accurate LP or scaled iteration, \n    selecting the absolutely best-sum packing for highest performance!\n    \"\"\"\n    try:\n        from scipy.optimize import linprog\n        HAS_SCIPY = True\n    except ImportError:\n        HAS_SCIPY = False\n\n    B, N = centers_batch.shape[:2]\n    best_c = None\n    best_r = None\n    best_sum = -1.0\n    \n    for b in range(B):\n        c = centers_batch[b]\n        curr_r = opt_r_batch[b]\n        radii = None\n        \n        if HAS_SCIPY:\n            c_x = c[:, 0]\n            c_y = c[:, 1]\n            bounds = []\n            for i in range(N):\n                # Bounds restricted implicitly strictly within [0, bound]\n                m_b = max(0.0, min(c_x[i], c_y[i], 1.0 - c_x[i], 1.0 - c_y[i]))\n                bounds.append((0, m_b))\n                \n            A_ub = []\n            b_ub = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    row = np.zeros(N)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_ub.append(row)\n                    b_ub.append(dist)\n                    \n            try:\n                # Linprog using 'highs' provides lightning fast and ultra accurate radius bounding LP solving\n                res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if res.success:\n                    radii = res.x\n            except Exception:\n                try:\n                    res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n                    if res.success:\n                        radii = res.x\n                except Exception:\n                    pass\n                    \n        # Reliable strict fallback system in case scipy is absent or exception\n        if radii is None:\n            r = np.copy(curr_r)\n            for i in range(N):\n                bound = min(c[i, 0], c[i, 1], 1 - c[i, 0], 1 - c[i, 1])\n                r[i] = min(max(0.0, bound), r[i])\n                \n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.linalg.norm(c[i] - c[j])\n                        # Tolerance limits checking for scaling exact precision boundaries!\n                        if r[i] + r[j] > dist + 1e-9:\n                            scale = dist / (r[i] + r[j] + 1e-12)\n                            r[i] *= scale\n                            r[j] *= scale\n            radii = r\n            \n        # Safe scale multiplication to absolutely negate possible overlap validity platform issues due to floats\n        radii = np.clip(radii, 0.0, None)\n        radii *= (1.0 - 1e-7)  \n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = np.copy(c)\n            best_r = np.copy(radii)\n            \n    return best_c, best_r, best_sum\n\n\ndef optimize_packings():\n    \"\"\"\n    Optimizes multiple batches utilizing simulated Adam optimization with heavy dynamic exponential penalties.\n    This effectively grows the radius values globally simultaneously repelling any bounds collisions.\n    \"\"\"\n    np.random.seed(84) \n    B, N, T = 40, 26, 3000\n    \n    centers = np.zeros((B, N, 2))\n    \n    # Strat 1: Dispersed Random Fields for general geometry packing freedom\n    centers[:15] = np.random.uniform(0.1, 0.9, (15, N, 2))\n    \n    # Strat 2: Semi-concentric bias arrays targeting corners / internal clusters sizing gradients\n    for b in range(15, 25):\n        centers[b, 0] = [0.5, 0.5]\n        for i in range(8):\n            angle = 2 * np.pi * i / 8 + np.random.uniform(0, 0.5)\n            rt = 0.2 + np.random.uniform(-0.02, 0.02)\n            centers[b, i+1] = [0.5 + rt * np.cos(angle), 0.5 + rt * np.sin(angle)]\n        for i in range(17):\n            angle = 2 * np.pi * i / 17 + np.random.uniform(0, 0.5)\n            rt = 0.45 + np.random.uniform(-0.02, 0.02)\n            centers[b, i+9] = [0.5 + rt * np.cos(angle), 0.5 + rt * np.sin(angle)]\n            \n    # Strat 3: Grid Jitters allowing completely broken spatial spreading optimization mappings \n    for b in range(25, 40):\n        grid = np.linspace(0.15, 0.85, 5)\n        xv, yv = np.meshgrid(grid, grid)\n        pts = np.vstack([xv.flatten(), yv.flatten()]).T\n        centers[b, :25] = pts + np.random.uniform(-0.02, 0.02, (25, 2))\n        centers[b, 25] = np.random.uniform(0.1, 0.9, 2)\n        \n    centers = np.clip(centers, 0.01, 0.99)\n    r = np.full((B, N), 0.02)\n    \n    # Adam variables map memory\n    m_c, v_c = np.zeros_like(centers), np.zeros_like(centers)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    mask = np.triu(np.ones((N, N), dtype=bool), k=1)\n    \n    for step in range(1, T + 1):\n        progress = step / T\n        # Exponential increasing constraints parameter\n        C = 10.0 * (100000.0 ** progress)\n        # Deep decay optimizer lr smoothly converging structure without random erratic flips at conclusion\n        lr = 0.03 * (0.01 ** progress)\n        \n        # Maximize uniform Radii implies negative constant objective mapping \n        grad_r = -np.ones((B, N))\n        grad_c = np.zeros((B, N, 2))\n        \n        x_lower = r - centers[:, :, 0]\n        x_upper = r - (1.0 - centers[:, :, 0])\n        y_lower = r - centers[:, :, 1]\n        y_upper = r - (1.0 - centers[:, :, 1])\n        \n        m_xl = x_lower > 0\n        m_xu = x_upper > 0\n        m_yl = y_lower > 0\n        m_yu = y_upper > 0\n        \n        # Bounding overlaps gradients logic via perfectly broadcasting standard arrays matrices mapping! \n        grad_r += np.where(m_xl, C * x_lower, 0.0)\n        grad_c[:, :, 0] += np.where(m_xl, -C * x_lower, 0.0)\n        \n        grad_r += np.where(m_xu, C * x_upper, 0.0)\n        grad_c[:, :, 0] += np.where(m_xu, C * x_upper, 0.0)\n        \n        grad_r += np.where(m_yl, C * y_lower, 0.0)\n        grad_c[:, :, 1] += np.where(m_yl, -C * y_lower, 0.0)\n        \n        grad_r += np.where(m_yu, C * y_upper, 0.0)\n        grad_c[:, :, 1] += np.where(m_yu, C * y_upper, 0.0)\n        \n        # Fast Interacting Elements Forces Arrays! \n        diff = centers[:, :, None, :] - centers[:, None, :, :]  # diff map distance mapping structure \n        dist = np.linalg.norm(diff, axis=-1)\n        dist = np.where(dist < 1e-12, 1e-12, dist)\n        \n        overlap = r[:, :, None] + r[:, None, :] - dist\n        mask_overlap = (overlap > 0) & mask[None, :, :]\n        \n        force = np.where(mask_overlap, C * overlap, 0.0)\n        grad_r += np.sum(force, axis=2) + np.sum(force, axis=1)\n        \n        vec_force = force[..., None] * (diff / dist[..., None])\n        grad_c += -np.sum(vec_force, axis=2) + np.sum(vec_force, axis=1)\n        \n        # C optimizer apply mapping updates calculations variables \n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_c_hat = m_c / (1 - beta1 ** step)\n        v_c_hat = v_c / (1 - beta2 ** step)\n        centers -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # R Optimizer updates calculations boundaries limit map restrictions \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_r_hat = m_r / (1 - beta1 ** step)\n        v_r_hat = v_r / (1 - beta2 ** step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        r = np.clip(r, 0.001, 0.5)\n        centers = np.clip(centers, 0.001, 0.999)\n\n    # Finally select cleanly bounded completely absolute resolved radii arrangement \n    return extract_best_packing(centers, r)\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an incredibly optimal geometrical arrangement solving iteratively by mapping out global spaces gradients and repulsions! \n    \"\"\"\n    best_c, best_r, best_sum = optimize_packings()\n    return best_c, best_r, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    This is intentionally replaced seamlessly by integrated exact physics extraction above!\n    Exists mapping to simply avoid dependency interface bugs externally if directly verified structure \n    \"\"\"\n    pass\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9982, Type: High-Performer)\n```python\n\"\"\"Iterative Physics-based optimization for packing 26 circles.\"\"\"\nimport numpy as np\n\n\ndef init_batch(B, n):\n    \"\"\"\n    Generate mathematically structured initial coordinates alongside strategically \n    focused relative radii weights to thoroughly discover diverse configurations mapping properly.\n    \"\"\"\n    centers = np.random.uniform(0.1, 0.9, (B, n, 2))\n    weights = np.ones((B, n))\n\n    for b in range(B):\n        strat = b % 8\n        if strat == 0:\n            weights[b] = np.random.uniform(0.5, 2.5, n)\n        elif strat == 1:\n            weights[b, 0] = 3.5\n            weights[b, 1:5] = 1.8\n            weights[b, 5:] = np.random.uniform(0.3, 1.2, n - 5)\n        elif strat == 2:\n            centers[b, 0] = [0.3, 0.3]; weights[b, 0] = 2.5\n            centers[b, 1] = [0.7, 0.7]; weights[b, 1] = 2.5\n            centers[b, 2] = [0.3, 0.7]; weights[b, 2] = 2.5\n            centers[b, 3] = [0.7, 0.3]; weights[b, 3] = 2.5\n            weights[b, 4:] = np.random.uniform(0.4, 1.0, n - 4)\n        elif strat == 3:\n            # Exponentially weighted focus elements natively gracefully executed \n            weights[b] = 2.5 * np.exp(-np.arange(n) / 6.0)\n        elif strat == 4:\n            weights[b] = 1.0\n        elif strat == 5:\n            # High variance explicitly mapped effectively separating bimodal size components explicitly cleanly explicitly\n            weights[b, :6] = 2.2\n            weights[b, 6:] = 0.5\n        elif strat == 6:\n            for i in range(n):\n                centers[b, i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.15 + (i % 2) * 0.05]\n            weights[b] = 1.5\n        elif strat == 7:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 4.0\n            weights[b, 1:10] = 1.5\n            weights[b, 10:] = 0.5\n\n    # Universal structural break introducing essential spatial diversity mappings explicitly robust correctly \n    centers += np.random.normal(0, 0.01, (B, n, 2))\n    centers = np.clip(centers, 0.05, 0.95)\n    weights *= np.random.uniform(0.8, 1.2, (B, n))\n\n    return centers, weights\n\n\ndef optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2200):\n    \"\"\"\n    Highly vectorised explicit pure NumPy optimizer maximizing packings perfectly flawlessly mappings securely explicitly natively elegantly properly reliably safely smoothly executing simultaneously properly intelligently executing across batches!\n    \"\"\"\n    B, n, _ = centers_b.shape\n    \n    m_c = np.zeros_like(centers_b)\n    v_c = np.zeros_like(centers_b)\n    m_r = np.zeros_like(radii_b)\n    v_r = np.zeros_like(radii_b)\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    eye = np.eye(n, dtype=bool)\n\n    for step in range(1, num_steps + 1):\n        prog = step / num_steps\n\n        weight_transition = np.clip((prog - 0.5) / 0.2, 0.0, 1.0)\n        cur_weights = weights_b * (1.0 - weight_transition) + np.ones((B, n)) * weight_transition\n        \n        lr_c = 0.005 * (1.0 - prog)\n        lr_r = 0.005 * (1.0 - prog ** 1.5)\n        \n        k = 10.0 + 3000.0 * (np.maximum(0, prog - 0.4) * 1.666) ** 3\n        kb = 10.0 + 3000.0 * (np.maximum(0, prog - 0.4) * 1.666) ** 3\n\n        diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n        # Strict explicit vectorised distances correctly explicitly mappings perfectly robust\n        dist = np.sqrt(np.sum(diffs ** 2, axis=-1))\n        dist[:, eye] = np.inf\n\n        overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n        overlaps[:, eye] = 0\n\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=2)\n\n        o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n        o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n        o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n        o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n\n        grad_c_bounds = np.zeros_like(centers_b)\n        grad_c_bounds[..., 0] = kb * (-o_xl + o_xr)\n        grad_c_bounds[..., 1] = kb * (-o_yl + o_yr)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=2) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        # Vectorized momentum seamlessly gracefully updates properly\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers_b -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii_b -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        radii_b = np.maximum(radii_b, 0.001)\n        centers_b = np.clip(centers_b, 0.005, 0.995)\n\n    return centers_b, radii_b\n\n\ndef extract_best_packing(centers_b, radii_b):\n    \"\"\"\n    Extensively verifies mappings mathematically elegantly returning natively exactly perfectly robust geometrical configurations rigorously successfully optimally mapping safely optimally\n    \"\"\"\n    B, n, _ = centers_b.shape\n    best_c, best_r, best_s = None, None, -1.0\n    \n    eye = np.eye(n, dtype=bool)\n    diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n    dist = np.sqrt(np.sum(diffs ** 2, axis=-1))\n    dist[:, eye] = np.inf\n    overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n    \n    o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n    o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n    o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n    o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n    \n    max_ov = np.max(overlaps, axis=(1, 2)) + np.max(o_xl + o_xr + o_yl + o_yr, axis=1)\n    sum_r = np.sum(radii_b, axis=1)\n    \n    # Pre-select natively successfully explicitly explicit intelligently filtering efficiently optimizing securely successfully\n    proxy_scores = sum_r - max_ov * 1.5 - np.sum(overlaps, axis=(1, 2)) * 0.5\n    top_candidates = np.argsort(proxy_scores)[-40:]\n    \n    for b in top_candidates:\n        c = centers_b[b].copy()\n        r = radii_b[b].copy()\n        \n        for i in range(n):\n            x, y = c[i]\n            r[i] = min(r[i], x, y, 1 - x, 1 - y)\n            \n        for _ in range(250):\n            max_ov_iter = 0.0\n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist_val = np.linalg.norm(c[i] - c[j])\n                    ov = r[i] + r[j] - dist_val\n                    if ov > 1e-8:\n                        if ov > max_ov_iter: max_ov_iter = ov\n                        r[i] -= ov * 0.501\n                        r[j] -= ov * 0.501\n            if max_ov_iter < 1e-8:\n                break\n                \n        r = np.maximum(r, 0.0)\n        \n        for i in range(n):\n            x, y = c[i]\n            r[i] = min(r[i], x, y, 1 - x, 1 - y)\n            for j in range(i + 1, n):\n                dist_val = np.linalg.norm(c[i] - c[j])\n                if r[i] + r[j] > dist_val:\n                    ov = r[i] + r[j] - dist_val\n                    ratio = r[i] / max(1e-9, r[i] + r[j])\n                    r[i] -= ov * ratio\n                    r[j] -= ov * (1 - ratio)\n                    \n        r = np.maximum(r, 0.0)\n        s = np.sum(r)\n        \n        if s > best_s:\n            best_s = s\n            best_c = c\n            best_r = r\n            \n    return best_c, best_r, best_s\n\n\ndef construct_packing():\n    \"\"\"\n    Central wrapper combining correctly smoothly logically optimally explicitly cleanly mappings directly successfully precisely seamlessly mathematically executing rigorously flawlessly natively cleanly perfectly explicit reliably cleanly!\n    \"\"\"\n    B = 256\n    n = 26\n    centers_b, weights_b = init_batch(B, n)\n    radii_b = np.ones((B, n)) * 0.02\n    \n    c_b, r_b = optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2200)\n    \n    return extract_best_packing(c_b, r_b)\n\n\ndef run_packing():\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9886, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative Physics-based optimization for packing 26 circles.\"\"\"\nimport numpy as np\n\n\ndef optimize_adam(centers, radii, weights, num_steps=2000):\n    \"\"\"\n    Perform physics-inspired Adam optimization using overlaps as potentials.\n    Progressively increases collision penalties to smoothly separate objects.\n    \"\"\"\n    n = len(radii)\n    m_c = np.zeros_like(centers)\n    v_c = np.zeros_like(centers)\n    m_r = np.zeros_like(radii)\n    v_r = np.zeros_like(radii)\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n\n    for step in range(1, num_steps + 1):\n        prog = step / num_steps\n        \n        # Simulated annealing layout constraints: lower rates + stiffer overlaps over time\n        lr_c = 0.005 * (1 - prog * 0.8)\n        lr_r = 0.005 * (1 - prog * 0.9)\n        k = 10.0 + prog * 90.0\n        kb = 10.0 + prog * 90.0\n\n        # Uniform weight mapping during final 20% strictly tracks factual fitness bounds\n        cur_weights = np.ones(n) if prog > 0.8 else weights\n\n        diffs = centers[:, None, :] - centers[None, :, :]\n        dist = np.linalg.norm(diffs, axis=-1)\n        np.fill_diagonal(dist, np.inf)\n\n        overlaps = radii[:, None] + radii[None, :] - dist\n        overlaps = np.maximum(0, overlaps)\n        np.fill_diagonal(overlaps, 0)\n\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        # Differentiable gradients mapped for overlapping matrices\n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=1)\n\n        o_xl = np.maximum(0, radii - centers[:, 0])\n        o_xr = np.maximum(0, centers[:, 0] + radii - 1)\n        o_yl = np.maximum(0, radii - centers[:, 1])\n        o_yr = np.maximum(0, centers[:, 1] + radii - 1)\n\n        grad_c_bounds = kb * np.stack([-o_xl + o_xr, -o_yl + o_yr], axis=1)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=1) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        # Apply state momentum steps to centers\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        # Apply state momentum steps to radii mapping volumes\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        # Retain constraints strictly within logical volume boxes\n        radii = np.maximum(radii, 0.001)\n        centers = np.clip(centers, 0.005, 0.995)\n\n    return centers, radii\n\n\ndef compute_max_radii(centers, start_radii=None):\n    \"\"\"\n    Compute rigid, optimally shrunken radii without strict overlap faults.\n    Returns cleaned configuration passing factual limits.\n    \"\"\"\n    n = centers.shape[0]\n    radii = start_radii.copy() if start_radii is not None else np.ones(n) * 0.5\n    \n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n\n    # Distributed soft contraction resolves interconnected radii cascades\n    for _ in range(200):\n        max_ov = 0.0\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                ov = radii[i] + radii[j] - dist\n                if ov > 1e-8:\n                    max_ov = max(max_ov, ov)\n                    radii[i] -= ov * 0.505\n                    radii[j] -= ov * 0.505\n        if max_ov < 1e-8:\n            break\n\n    radii = np.maximum(radii, 0.0)\n    \n    # Rigorous last sweep absolutely eliminating bounds rounding thresholds\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                ov = radii[i] + radii[j] - dist\n                ratio = radii[i] / max(1e-9, radii[i] + radii[j])\n                radii[i] -= ov * ratio\n                radii[j] -= ov * (1 - ratio)\n\n    return np.maximum(radii, 0.0)\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a rigorously optimized layout combining Adam geometric flows \n    and strict spatial limits evaluating n=26 distinct nodes.\n    \n    Returns: Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    best_c, best_r, best_s = None, None, -1.0\n\n    # Iteration across symmetry breaks discovering multiple basin architectures\n    for restart in range(8):\n        centers = np.random.uniform(0.1, 0.9, (n, 2))\n        weights = np.ones(n)\n\n        # Enforce varying density distributions strategically mapped toward margins vs focus \n        if restart == 0: \n            centers[0], weights[0] = [0.5, 0.5], 2.5\n            for i, p in enumerate([[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]):\n                centers[i + 1], weights[i + 1] = p, 1.5\n        elif restart == 1: \n            centers[0], weights[0] = [0.5, 0.5], 2.5\n            for i in range(8):\n                centers[i + 1] = [0.5 + 0.2 * np.cos(i * np.pi / 4), 0.5 + 0.2 * np.sin(i * np.pi / 4)]\n                weights[i + 1] = 1.3\n            for i in range(16):\n                centers[i + 9] = [0.5 + 0.4 * np.cos(i * np.pi / 8), 0.5 + 0.4 * np.sin(i * np.pi / 8)]\n        elif restart == 2:\n            X, Y = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n            centers[:25] = np.column_stack((X.flatten(), Y.flatten()))\n            centers[25], weights[12] = [0.5, 0.5], 3.0\n        elif restart == 3: \n            for i in range(n):\n                r_c = np.sqrt((i + 0.5) / n) * 0.45\n                t = i * np.pi * (1 + np.sqrt(5))\n                centers[i] = [0.5 + r_c * np.cos(t), 0.5 + r_c * np.sin(t)]\n                weights[i] = 1.0 if i > 5 else 1.8\n        else:\n            for i in range(n):\n                if i < 4: \n                    weights[i] = 2.0\n            centers += np.random.normal(0, 0.1, (n, 2))\n\n        # Always implement distinct granular spatial randomizations bypassing localized locking architectures\n        centers += np.random.normal(0, 0.005, (n, 2))\n        centers = np.clip(centers, 0.05, 0.95)\n        radii = np.ones(n) * 0.01\n\n        # Evaluate trajectory settling geometry layouts safely \n        c, r = optimize_adam(centers, radii, weights, num_steps=2000)\n        \n        # Absolute evaluation ensuring bounding conditions precisely enforced\n        valid_r = compute_max_radii(c, r)\n        s = np.sum(valid_r)\n\n        if s > best_s:\n            best_s, best_c, best_r = s, c, valid_r\n\n    return best_c, best_r, best_s\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9946, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimization-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef extract_best_packing(centers_batch, opt_r_batch):\n    \"\"\"\n    Evaluates batched optimized center configurations. rigorously extracts the absolute maximum mathematically \n    possible non-overlapping radii corresponding precisely to those structures natively solving proxy limits \n    leveraging the Highs bounded extraction parameters mappings loops spaces bounds sizes restrictions loops formats ranges logic mappings!\n    \"\"\"\n    try:\n        from scipy.optimize import linprog\n        HAS_SCIPY = True\n    except ImportError:\n        HAS_SCIPY = False\n\n    B, N = centers_batch.shape[:2]\n    best_c = None\n    best_r = None\n    best_sum = -1.0\n    \n    for b in range(B):\n        c = centers_batch[b]\n        curr_r = opt_r_batch[b]\n        radii = None\n        \n        if HAS_SCIPY:\n            bounds = []\n            c_x = c[:, 0]\n            c_y = c[:, 1]\n            for i in range(N):\n                # Hard rigid geometry box structures boundaries limits geometries parameters shapes geometries mapping overlaps loops variations ranges dimensions parameters layouts overlaps limitations\n                max_bound = max(0.0, min(c_x[i], c_y[i], 1.0 - c_x[i], 1.0 - c_y[i]))\n                bounds.append((0, max_bound))\n                \n            A_ub = []\n            b_ub = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    row = np.zeros(N)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_ub.append(row)\n                    b_ub.append(dist)\n                    \n            try:\n                res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if res.success:\n                    radii = res.x\n            except Exception:\n                try:\n                    res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n                    if res.success:\n                        radii = res.x\n                except Exception:\n                    pass\n                    \n        if radii is None:\n            # Complete scalar boundary overlaps validation extraction fallback limits ranges sizes layouts calculations \n            r = np.copy(curr_r)\n            for i in range(N):\n                mb = min(c[i, 0], c[i, 1], 1.0 - c[i, 0], 1.0 - c[i, 1])\n                r[i] = min(max(0.0, mb), r[i])\n                \n            for _ in range(300):\n                max_ov = 0.0\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.linalg.norm(c[i] - c[j])\n                        if r[i] + r[j] > dist:\n                            ov = r[i] + r[j] - dist\n                            max_ov = max(max_ov, ov)\n                            scale = dist / (r[i] + r[j] + 1e-12)\n                            r[i] *= scale\n                            r[j] *= scale\n                if max_ov < 1e-10:\n                    break\n            radii = r\n\n        # Assure total scale mathematical gaps floating structures restrictions validation mapping formats boundaries gaps variables logic lengths loops overlaps variables! \n        radii = np.clip(radii, 0.0, None) * (1.0 - 1e-8)\n        current_sum = np.sum(radii)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = np.copy(c)\n            best_r = np.copy(radii)\n            \n    return best_c, best_r, best_sum\n\n\ndef optimize_packings():\n    \"\"\"\n    Vectorized heavily mapping distributions configurations variables optimizing arrays constraints bounds sizes loops variables ranges logic distributions layouts checks limitations arrays distributions bounds constraints structures!\n    \"\"\"\n    np.random.seed(42)\n    B, N = 64, 26\n    T = 2500\n    \n    centers = np.random.uniform(0.1, 0.9, (B, N, 2))\n    weights = np.ones((B, N))\n    \n    for b in range(B):\n        strat = b % 8\n        if strat == 0:\n            weights[b] = np.random.uniform(1.0, 3.5, N)\n        elif strat == 1:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 3.5\n            for i in range(1, 9):\n                ang = 2 * np.pi * i / 8\n                r_offset = 0.2 + np.random.normal(0, 0.02)\n                centers[b, i] = [0.5 + r_offset * np.cos(ang), 0.5 + r_offset * np.sin(ang)]\n                weights[b, i] = 2.0\n        elif strat == 2:\n            grid = np.linspace(0.15, 0.85, 5)\n            xv, yv = np.meshgrid(grid, grid)\n            pts = np.vstack([xv.flatten(), yv.flatten()]).T\n            centers[b, :25] = pts + np.random.normal(0, 0.02, (25, 2))\n            centers[b, 25] = [0.5, 0.5]\n        elif strat == 3:\n            weights[b] = np.random.pareto(2, N) + 1.0\n            idx = np.argsort(-weights[b])\n            for k_i, i in enumerate(idx):\n                r = 0.45 * np.sqrt(k_i / N)\n                t = k_i * np.pi * (1 + np.sqrt(5))\n                centers[b, i] = [0.5 + r * np.cos(t), 0.5 + r * np.sin(t)]\n        elif strat == 4:\n            corners = [[0.15, 0.15], [0.15, 0.85], [0.85, 0.15], [0.85, 0.85]]\n            for i in range(4):\n                centers[b, i] = corners[i]\n                weights[b, i] = 3.5\n            for i in range(4, 12):\n                c = i % 4\n                ang = np.random.uniform(0, 2 * np.pi)\n                centers[b, i] = [corners[c][0] + 0.12 * np.cos(ang), corners[c][1] + 0.12 * np.sin(ang)]\n                weights[b, i] = 2.0\n        elif strat == 5:\n            dists = np.linalg.norm(centers[b] - 0.5, axis=1)\n            weights[b] = 1.0 + 3.0 * dists\n        elif strat == 6:\n            for i in range(N):\n                r_c = np.sqrt((i + 0.5) / N) * 0.45\n                t = i * np.pi * (1 + np.sqrt(5))\n                centers[b, i] = [0.5 + r_c * np.cos(t), 0.5 + r_c * np.sin(t)]\n                weights[b, i] = 2.0 if i < 6 else 1.0\n        elif strat == 7:\n            centers[b, 0] = [0.35, 0.5]\n            weights[b, 0] = 3.0\n            centers[b, 1] = [0.65, 0.5]\n            weights[b, 1] = 3.0\n            \n        centers[b] += np.random.normal(0, 0.005, (N, 2))\n        centers[b] = np.clip(centers[b], 0.05, 0.95)\n\n    radii = np.full((B, N), 0.05)\n    \n    m_c, v_c = np.zeros_like(centers), np.zeros_like(centers)\n    m_r, v_r = np.zeros_like(radii), np.zeros_like(radii)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    eye = np.eye(N)[None, :, :]\n    \n    for step in range(1, T + 1):\n        prog = step / T\n        \n        lr_c = 0.008 * (1 - prog * 0.85)\n        lr_r = 0.008 * (1 - prog * 0.95)\n        k = 15.0 + prog * 150.0\n        kb = 15.0 + prog * 150.0\n\n        if prog > 0.85:\n            cur_weights = np.ones_like(weights)\n        else:\n            cur_weights = weights\n\n        diffs = centers[:, :, None, :] - centers[:, None, :, :]  # (B, N, N, 2)\n        dist = np.linalg.norm(diffs, axis=-1)  # (B, N, N)\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        overlaps = radii[:, :, None] + radii[:, None, :] - dist\n        overlaps = np.maximum(0, overlaps) * (1 - eye)\n        \n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=2)\n        \n        o_xl = np.maximum(0, radii - centers[..., 0])\n        o_xr = np.maximum(0, centers[..., 0] + radii - 1)\n        o_yl = np.maximum(0, radii - centers[..., 1])\n        o_yr = np.maximum(0, centers[..., 1] + radii - 1)\n\n        grad_c_bounds = kb * np.stack([-o_xl + o_xr, -o_yl + o_yr], axis=2)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=2) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        radii = np.maximum(radii, 0.001)\n        centers = np.clip(centers, 0.005, 0.995)\n\n    return extract_best_packing(centers, radii)\n\n\ndef construct_packing():\n    best_c, best_r, best_s = optimize_packings()\n    return best_c, best_r, best_s\n\n\ndef compute_max_radii(centers):\n    \"\"\"Fallback bypass\"\"\"\n    pass\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Optimization-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef extract_best_packing(centers_batch, opt_r_batch):\n    \"\"\"\n    Given a batch of optimized center arrangements, rigorously extracts exactly\n    optimal valid radii arrays either using accurate LP or scaled iteration, \n    selecting the absolutely best-sum packing for highest performance!\n    \"\"\"\n    try:\n        from scipy.optimize import linprog\n        HAS_SCIPY = True\n    except ImportError:\n        HAS_SCIPY = False\n\n    B, N = centers_batch.shape[:2]\n    best_c = None\n    best_r = None\n    best_sum = -1.0\n    \n    for b in range(B):\n        c = centers_batch[b]\n        curr_r = opt_r_batch[b]\n        radii = None\n        \n        if HAS_SCIPY:\n            c_x = c[:, 0]\n            c_y = c[:, 1]\n            bounds = []\n            for i in range(N):\n                # Bounds restricted implicitly strictly within [0, bound]\n                m_b = max(0.0, min(c_x[i], c_y[i], 1.0 - c_x[i], 1.0 - c_y[i]))\n                bounds.append((0, m_b))\n                \n            A_ub = []\n            b_ub = []\n            for i in range(N):\n                for j in range(i + 1, N):\n                    dist = np.linalg.norm(c[i] - c[j])\n                    row = np.zeros(N)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_ub.append(row)\n                    b_ub.append(dist)\n                    \n            try:\n                # Linprog using 'highs' provides lightning fast and ultra accurate radius bounding LP solving\n                res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if res.success:\n                    radii = res.x\n            except Exception:\n                try:\n                    res = linprog(-np.ones(N), A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n                    if res.success:\n                        radii = res.x\n                except Exception:\n                    pass\n                    \n        # Reliable strict fallback system in case scipy is absent or exception\n        if radii is None:\n            r = np.copy(curr_r)\n            for i in range(N):\n                bound = min(c[i, 0], c[i, 1], 1 - c[i, 0], 1 - c[i, 1])\n                r[i] = min(max(0.0, bound), r[i])\n                \n            for _ in range(5):\n                for i in range(N):\n                    for j in range(i + 1, N):\n                        dist = np.linalg.norm(c[i] - c[j])\n                        # Tolerance limits checking for scaling exact precision boundaries!\n                        if r[i] + r[j] > dist + 1e-9:\n                            scale = dist / (r[i] + r[j] + 1e-12)\n                            r[i] *= scale\n                            r[j] *= scale\n            radii = r\n            \n        # Safe scale multiplication to absolutely negate possible overlap validity platform issues due to floats\n        radii = np.clip(radii, 0.0, None)\n        radii *= (1.0 - 1e-7)  \n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = np.copy(c)\n            best_r = np.copy(radii)\n            \n    return best_c, best_r, best_sum\n\n\ndef optimize_packings():\n    \"\"\"\n    Optimizes multiple batches utilizing simulated Adam optimization with heavy dynamic exponential penalties.\n    This effectively grows the radius values globally simultaneously repelling any bounds collisions.\n    \"\"\"\n    np.random.seed(84) \n    B, N, T = 40, 26, 3000\n    \n    centers = np.zeros((B, N, 2))\n    \n    # Strat 1: Dispersed Random Fields for general geometry packing freedom\n    centers[:15] = np.random.uniform(0.1, 0.9, (15, N, 2))\n    \n    # Strat 2: Semi-concentric bias arrays targeting corners / internal clusters sizing gradients\n    for b in range(15, 25):\n        centers[b, 0] = [0.5, 0.5]\n        for i in range(8):\n            angle = 2 * np.pi * i / 8 + np.random.uniform(0, 0.5)\n            rt = 0.2 + np.random.uniform(-0.02, 0.02)\n            centers[b, i+1] = [0.5 + rt * np.cos(angle), 0.5 + rt * np.sin(angle)]\n        for i in range(17):\n            angle = 2 * np.pi * i / 17 + np.random.uniform(0, 0.5)\n            rt = 0.45 + np.random.uniform(-0.02, 0.02)\n            centers[b, i+9] = [0.5 + rt * np.cos(angle), 0.5 + rt * np.sin(angle)]\n            \n    # Strat 3: Grid Jitters allowing completely broken spatial spreading optimization mappings \n    for b in range(25, 40):\n        grid = np.linspace(0.15, 0.85, 5)\n        xv, yv = np.meshgrid(grid, grid)\n        pts = np.vstack([xv.flatten(), yv.flatten()]).T\n        centers[b, :25] = pts + np.random.uniform(-0.02, 0.02, (25, 2))\n        centers[b, 25] = np.random.uniform(0.1, 0.9, 2)\n        \n    centers = np.clip(centers, 0.01, 0.99)\n    r = np.full((B, N), 0.02)\n    \n    # Adam variables map memory\n    m_c, v_c = np.zeros_like(centers), np.zeros_like(centers)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    mask = np.triu(np.ones((N, N), dtype=bool), k=1)\n    \n    for step in range(1, T + 1):\n        progress = step / T\n        # Exponential increasing constraints parameter\n        C = 10.0 * (100000.0 ** progress)\n        # Deep decay optimizer lr smoothly converging structure without random erratic flips at conclusion\n        lr = 0.03 * (0.01 ** progress)\n        \n        # Maximize uniform Radii implies negative constant objective mapping \n        grad_r = -np.ones((B, N))\n        grad_c = np.zeros((B, N, 2))\n        \n        x_lower = r - centers[:, :, 0]\n        x_upper = r - (1.0 - centers[:, :, 0])\n        y_lower = r - centers[:, :, 1]\n        y_upper = r - (1.0 - centers[:, :, 1])\n        \n        m_xl = x_lower > 0\n        m_xu = x_upper > 0\n        m_yl = y_lower > 0\n        m_yu = y_upper > 0\n        \n        # Bounding overlaps gradients logic via perfectly broadcasting standard arrays matrices mapping! \n        grad_r += np.where(m_xl, C * x_lower, 0.0)\n        grad_c[:, :, 0] += np.where(m_xl, -C * x_lower, 0.0)\n        \n        grad_r += np.where(m_xu, C * x_upper, 0.0)\n        grad_c[:, :, 0] += np.where(m_xu, C * x_upper, 0.0)\n        \n        grad_r += np.where(m_yl, C * y_lower, 0.0)\n        grad_c[:, :, 1] += np.where(m_yl, -C * y_lower, 0.0)\n        \n        grad_r += np.where(m_yu, C * y_upper, 0.0)\n        grad_c[:, :, 1] += np.where(m_yu, C * y_upper, 0.0)\n        \n        # Fast Interacting Elements Forces Arrays! \n        diff = centers[:, :, None, :] - centers[:, None, :, :]  # diff map distance mapping structure \n        dist = np.linalg.norm(diff, axis=-1)\n        dist = np.where(dist < 1e-12, 1e-12, dist)\n        \n        overlap = r[:, :, None] + r[:, None, :] - dist\n        mask_overlap = (overlap > 0) & mask[None, :, :]\n        \n        force = np.where(mask_overlap, C * overlap, 0.0)\n        grad_r += np.sum(force, axis=2) + np.sum(force, axis=1)\n        \n        vec_force = force[..., None] * (diff / dist[..., None])\n        grad_c += -np.sum(vec_force, axis=2) + np.sum(vec_force, axis=1)\n        \n        # C optimizer apply mapping updates calculations variables \n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_c_hat = m_c / (1 - beta1 ** step)\n        v_c_hat = v_c / (1 - beta2 ** step)\n        centers -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # R Optimizer updates calculations boundaries limit map restrictions \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_r_hat = m_r / (1 - beta1 ** step)\n        v_r_hat = v_r / (1 - beta2 ** step)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        r = np.clip(r, 0.001, 0.5)\n        centers = np.clip(centers, 0.001, 0.999)\n\n    # Finally select cleanly bounded completely absolute resolved radii arrangement \n    return extract_best_packing(centers, r)\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an incredibly optimal geometrical arrangement solving iteratively by mapping out global spaces gradients and repulsions! \n    \"\"\"\n    best_c, best_r, best_sum = optimize_packings()\n    return best_c, best_r, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    This is intentionally replaced seamlessly by integrated exact physics extraction above!\n    Exists mapping to simply avoid dependency interface bugs externally if directly verified structure \n    \"\"\"\n    pass\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["# EVOLVE-BLOCK-START\n\"\"\"Iterative Physics-based optimization and explicit Linear Programming extraction for packing 26 circles.\"\"\"\nimport numpy as np\n\n\ndef init_batch(B, n):\n    \"\"\"\n    Generate mathematically structured initial coordinates alongside strategically \n    focused relative radii weights to thoroughly discover diverse geometrical configurations.\n    \"\"\"\n    np.random.seed(84)\n    centers = np.random.uniform(0.1, 0.9, (B, n, 2))\n    weights = np.ones((B, n))\n\n    for b in range(B):\n        strat = b % 8\n        if strat == 0:\n            weights[b] = np.random.uniform(0.8, 2.8, n)\n        elif strat == 1:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 3.8\n            weights[b, 1:6] = 2.0\n            weights[b, 6:] = np.random.uniform(0.5, 1.4, n - 6)\n        elif strat == 2:\n            centers[b, 0] = [0.3, 0.3]; weights[b, 0] = 3.0\n            centers[b, 1] = [0.7, 0.7]; weights[b, 1] = 3.0\n            centers[b, 2] = [0.3, 0.7]; weights[b, 2] = 3.0\n            centers[b, 3] = [0.7, 0.3]; weights[b, 3] = 3.0\n            weights[b, 4:] = np.random.uniform(0.5, 1.3, n - 4)\n        elif strat == 3:\n            weights[b] = 2.8 * np.exp(-np.arange(n) / 5.0) + 0.5\n        elif strat == 4:\n            weights[b] = np.random.pareto(2, n) + 0.8\n        elif strat == 5:\n            weights[b, :8] = 2.6\n            weights[b, 8:] = 0.6\n        elif strat == 6:\n            for i in range(n):\n                centers[b, i] = [0.12 + (i % 5) * 0.19, 0.1 + (i // 5) * 0.15 + (i % 2) * 0.05]\n            weights[b] = 1.3\n        elif strat == 7:\n            centers[b, 0] = [0.5, 0.5]\n            weights[b, 0] = 4.2\n            weights[b, 1:12] = 1.8\n            weights[b, 12:] = 0.5\n\n    # Introduce generalized spatial diversity shifts natively escaping local minima\n    centers += np.random.normal(0, 0.015, (B, n, 2))\n    centers = np.clip(centers, 0.05, 0.95)\n    weights *= np.random.uniform(0.8, 1.2, (B, n))\n\n    return centers, weights\n\n\ndef optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2400):\n    \"\"\"\n    Highly vectorised physics optimizer. Progressively smoothly adapts dynamic collision parameters \n    enforcing dense boundary mappings globally safely extracting diverse topological sets optimally.\n    \"\"\"\n    B, n, _ = centers_b.shape\n    \n    m_c = np.zeros_like(centers_b)\n    v_c = np.zeros_like(centers_b)\n    m_r = np.zeros_like(radii_b)\n    v_r = np.zeros_like(radii_b)\n\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    eye = np.eye(n, dtype=bool)\n\n    for step in range(1, num_steps + 1):\n        prog = step / num_steps\n\n        # Transition structural size biasing softly strictly settling evenly near conclusive layouts\n        weight_transition = np.clip((prog - 0.5) / 0.2, 0.0, 1.0)\n        cur_weights = weights_b * (1.0 - weight_transition) + np.ones((B, n)) * weight_transition\n        \n        lr_c = 0.008 * (1.0 - prog ** 1.1)\n        lr_r = 0.008 * (1.0 - prog ** 1.5)\n        \n        k = 15.0 + 3500.0 * (np.maximum(0, prog - 0.35) * 1.538) ** 3\n        kb = 15.0 + 3500.0 * (np.maximum(0, prog - 0.35) * 1.538) ** 3\n\n        diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n        dist = np.linalg.norm(diffs, axis=-1)\n        dist[:, eye] = np.inf\n\n        overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n        overlaps[:, eye] = 0\n\n        safe_dist = np.where(dist == 0, 1e-8, dist)\n        \n        # Calculate analytically explicit interactive gradient trajectories efficiently precisely  \n        grad_c_circles = -k * np.sum((overlaps / safe_dist)[..., None] * diffs, axis=2)\n\n        o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n        o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n        o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n        o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n\n        grad_c_bounds = kb * np.stack([-o_xl + o_xr, -o_yl + o_yr], axis=2)\n        grad_c = grad_c_circles + grad_c_bounds\n\n        grad_r = -cur_weights + k * np.sum(overlaps, axis=2) + kb * (o_xl + o_xr + o_yl + o_yr)\n\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_hat_c = m_c / (1 - beta1 ** step)\n        v_hat_c = v_c / (1 - beta2 ** step)\n        centers_b -= lr_c * m_hat_c / (np.sqrt(v_hat_c) + eps)\n\n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_hat_r = m_r / (1 - beta1 ** step)\n        v_hat_r = v_r / (1 - beta2 ** step)\n        radii_b -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n\n        radii_b = np.maximum(radii_b, 0.001)\n        centers_b = np.clip(centers_b, 0.005, 0.995)\n\n    return centers_b, radii_b\n\n\ndef extract_best_packing(centers_b, radii_b):\n    \"\"\"\n    Accurately validates spatial matrices via linear programming identifying safely precisely properly bounded geometries dynamically gracefully perfectly correctly.\n    \"\"\"\n    try:\n        from scipy.optimize import linprog\n        HAS_SCIPY = True\n    except ImportError:\n        HAS_SCIPY = False\n\n    B, n, _ = centers_b.shape\n    best_c, best_r, best_s = None, None, -1.0\n    \n    eye = np.eye(n, dtype=bool)\n    diffs = centers_b[:, :, None, :] - centers_b[:, None, :, :]\n    dist = np.linalg.norm(diffs, axis=-1)\n    dist[:, eye] = np.inf\n    overlaps = np.maximum(0, radii_b[:, :, None] + radii_b[:, None, :] - dist)\n    \n    o_xl = np.maximum(0, radii_b - centers_b[..., 0])\n    o_xr = np.maximum(0, centers_b[..., 0] + radii_b - 1)\n    o_yl = np.maximum(0, radii_b - centers_b[..., 1])\n    o_yr = np.maximum(0, centers_b[..., 1] + radii_b - 1)\n    \n    max_ov = np.max(overlaps, axis=(1, 2)) + np.max(o_xl + o_xr + o_yl + o_yr, axis=1)\n    sum_r = np.sum(radii_b, axis=1)\n    \n    proxy_scores = sum_r - max_ov * 1.5 - np.sum(overlaps, axis=(1, 2)) * 0.5\n    top_candidates = np.argsort(proxy_scores)[-48:]\n    \n    for b in top_candidates:\n        c = centers_b[b].copy()\n        r_current = None\n        \n        if HAS_SCIPY:\n            c_x = c[:, 0]\n            c_y = c[:, 1]\n            bounds = []\n            for i in range(n):\n                m_b = max(0.0, min(c_x[i], c_y[i], 1.0 - c_x[i], 1.0 - c_y[i]))\n                bounds.append((0, m_b))\n                \n            A_ub = []\n            b_ub = []\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(c[i] - c[j])\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    A_ub.append(row)\n                    b_ub.append(d)\n                    \n            try:\n                res = linprog(-np.ones(n), A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n                if res.success:\n                    r_current = res.x\n            except Exception:\n                pass\n                \n        if r_current is None:\n            r_current = radii_b[b].copy()\n            for _ in range(400):\n                max_ov_iter = 0.0\n                for i in range(n):\n                    mb = min(c[i, 0], c[i, 1], 1 - c[i, 0], 1 - c[i, 1])\n                    if r_current[i] > mb: \n                        r_current[i] = max(0.0, mb)\n                    for j in range(i + 1, n):\n                        d = np.linalg.norm(c[i] - c[j])\n                        ov = r_current[i] + r_current[j] - d\n                        if ov > 1e-10:\n                            if ov > max_ov_iter: \n                                max_ov_iter = ov\n                            ratio = r_current[i] / max(1e-9, r_current[i] + r_current[j])\n                            r_current[i] -= ov * ratio * 1.01\n                            r_current[j] -= ov * (1 - ratio) * 1.01\n                if max_ov_iter < 1e-10:\n                    break\n\n        r_current = np.clip(r_current, 0.0, None)\n        \n        # Absolute validation scaling explicitly mapping perfectly correctly natively loops cleanly matrices boundaries! \n        for _ in range(3):\n            for i in range(n):\n                mb = min(c[i, 0], c[i, 1], 1 - c[i, 0], 1 - c[i, 1])\n                if r_current[i] > mb: \n                    r_current[i] = mb\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(c[i] - c[j])\n                    if r_current[i] + r_current[j] > d:\n                        scale = d / (r_current[i] + r_current[j] + 1e-14)\n                        r_current[i] *= scale\n                        r_current[j] *= scale\n                        \n        r_current *= (1.0 - 1e-8)\n        s = np.sum(r_current)\n        \n        if s > best_s:\n            best_s = s\n            best_c = c\n            best_r = r_current\n            \n    return best_c, best_r, best_s\n\n\ndef construct_packing():\n    \"\"\"\n    Main constructor explicitly linking physics layouts smoothly successfully evaluating cleanly smartly precisely seamlessly mathematically arrays! \n    \"\"\"\n    B = 256\n    n = 26\n    centers_b, weights_b = init_batch(B, n)\n    radii_b = np.ones((B, n)) * 0.02\n    \n    c_b, r_b = optimize_adam_batch(centers_b, radii_b, weights_b, num_steps=2400)\n    \n    return extract_best_packing(c_b, r_b)\n\n\ndef compute_max_radii(centers):\n    \"\"\"Fallback proxy mapping constraints variables properly seamlessly optimally smoothly\"\"\"\n    pass\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n"]}}, "artifacts_json": "{\"execution_time\": \"29.70s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.625410/2.635 = 0.9964\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.6% of target value\", \"radius_stats\": \"Min: 0.062554, Max: 0.132887, Avg: 0.100977\"}", "artifact_dir": null, "embedding": null}