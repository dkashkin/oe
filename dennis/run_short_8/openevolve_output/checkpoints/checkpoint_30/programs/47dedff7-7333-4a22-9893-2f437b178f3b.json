{"id": "47dedff7-7333-4a22-9893-2f437b178f3b", "code": "# EVOLVE-BLOCK-START\n\"\"\"Iterative physics-based simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    # We loop exhaustively, eliminating the maximum overlap proportionally until none remain.\n    # Max n*n passes provides overwhelming headroom to ensure geometric convergence.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Perform multiple gradient descent optimizations with randomized symmetries\n    and heuristically spaced architectures to discover tightly bound packings\n    combining varied sizes maximizing their combined cumulative radii.\n    \"\"\"\n    n = 26\n    restarts = 24\n    iters = 2000\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n\n    # Pre-allocate indices pair combinations to heavily optimize array iteration\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    for rst in range(restarts):\n        rng = np.random.RandomState(42 + rst)\n\n        # Distribute varying sized centers matching multiple heuristic constraints\n        p = rng.uniform(0.1, 0.9, (n, 2))\n        r = rng.uniform(0.02, 0.12, n)\n\n        strat = rst % 4\n        if strat == 0:\n            # Concentric shell rings\n            for k in range(8):\n                angle = 2 * np.pi * k / 8\n                p[k] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for k in range(17):\n                angle = 2 * np.pi * k / 17\n                p[k + 8] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            p[25] = [0.5, 0.5]\n            r[:] = 0.08\n            r[25] = 0.15\n        elif strat == 1:\n            # Loose homogeneous 5x5 grids layout plus wandering floater\n            for k in range(25):\n                p[k] = [0.1 + 0.2 * (k % 5), 0.1 + 0.2 * (k // 5)]\n            r[:] = 0.08\n            p[25] = [0.5, 0.5]\n        elif strat == 2:\n            # Massive corner boulders framing small interstitially dense inner dust\n            p[0:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[0:4] = 0.25\n            r[4:] = 0.05\n        elif strat == 3:\n            # Monolithic mega center ringed symmetrically\n            p[0] = [0.5, 0.5]\n            r[0] = 0.35\n            r[1:] = 0.05\n\n        # Small jiggling permanently breaks mathematical symmetrical traps\n        p += rng.normal(0, 0.01, (n, 2))\n        p = np.clip(p, 0.02, 0.98)\n\n        # Momentum memories\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n\n        lr_p = 0.01\n        lr_r = 0.01\n\n        # Smooth optimization settling transitioning penalty stringency seamlessly (simulated annealing like)\n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n\n            # Distances mapped across upper triangle permutations\n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1))\n            dist = np.maximum(dist, 1e-8)\n\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n\n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n\n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n\n            # Spheroid collisions repulsion feedback\n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, np.newaxis] * (diff / dist[:, np.newaxis])\n\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                \n                # Push vectors inversely applying repulsing gradients ensuring centers repel apart\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n\n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n\n            # Adam stepping variables recalculating\n            beta1, beta2 = 0.9, 0.999\n            \n            m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n            v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n            p = p - lr_p * (m_p / (1.0 - beta1 ** t)) / (np.sqrt(v_p / (1.0 - beta2 ** t)) + 1e-8)\n\n            m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n            v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n            r = r - lr_r * (m_r / (1.0 - beta1 ** t)) / (np.sqrt(v_r / (1.0 - beta2 ** t)) + 1e-8)\n\n            # Coordinate confinement strictly\n            p = np.clip(p, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Mathematical strict exact validation wrapper ensuring precise operational geometric boundary bounds are zero.\n        r_valid = compute_max_radii(p, r)\n\n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n\n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "201d40dc-bb69-49d5-845b-63f8cc19f717", "generation": 1, "timestamp": 1772008140.6138132, "iteration_found": 8, "metrics": {"validity": 1.0, "sum_radii": 1.0753833163396522, "target_ratio": 0.40811511056533295, "combined_score": 0.40811511056533295, "radius_variance": 0.01725556155116175, "spatial_spread": 0.22408629214457715}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 0.9597642169962064, "target_ratio": 0.36423689449571406, "combined_score": 0.36423689449571406, "radius_variance": 0.026599407523434117, "spatial_spread": 0.23809223949931868}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.3642\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.3642\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Unknown changes\n- Metrics: validity: 1.0000, sum_radii: 0.9598, target_ratio: 0.3642, combined_score: 0.3642, radius_variance: 0.0266, spatial_spread: 0.2381\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.3642)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (0.9598), Performs well on target_ratio (0.3642), Performs well on combined_score (0.3642), Performs well on radius_variance (0.0266), Performs well on spatial_spread (0.2381)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative physics-based simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    # We loop exhaustively, eliminating the maximum overlap proportionally until none remain.\n    # Max n*n passes provides overwhelming headroom to ensure geometric convergence.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Perform multiple gradient descent optimizations with randomized symmetries\n    and heuristically spaced architectures to discover tightly bound packings\n    combining varied sizes maximizing their combined cumulative radii.\n    \"\"\"\n    n = 26\n    restarts = 24\n    iters = 2000\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n\n    # Pre-allocate indices pair combinations to heavily optimize array iteration\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    for rst in range(restarts):\n        rng = np.random.RandomState(42 + rst)\n\n        # Distribute varying sized centers matching multiple heuristic constraints\n        p = rng.uniform(0.1, 0.9, (n, 2))\n        r = rng.uniform(0.02, 0.12, n)\n\n        strat = rst % 4\n        if strat == 0:\n            # Concentric shell rings\n            for k in range(8):\n                angle = 2 * np.pi * k / 8\n                p[k] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for k in range(17):\n                angle = 2 * np.pi * k / 17\n                p[k + 8] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            p[25] = [0.5, 0.5]\n            r[:] = 0.08\n            r[25] = 0.15\n        elif strat == 1:\n            # Loose homogeneous 5x5 grids layout plus wandering floater\n            for k in range(25):\n                p[k] = [0.1 + 0.2 * (k % 5), 0.1 + 0.2 * (k // 5)]\n            r[:] = 0.08\n            p[25] = [0.5, 0.5]\n        elif strat == 2:\n            # Massive corner boulders framing small interstitially dense inner dust\n            p[0:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[0:4] = 0.25\n            r[4:] = 0.05\n        elif strat == 3:\n            # Monolithic mega center ringed symmetrically\n            p[0] = [0.5, 0.5]\n            r[0] = 0.35\n            r[1:] = 0.05\n\n        # Small jiggling permanently breaks mathematical symmetrical traps\n        p += rng.normal(0, 0.01, (n, 2))\n        p = np.clip(p, 0.02, 0.98)\n\n        # Momentum memories\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n\n        lr_p = 0.01\n        lr_r = 0.01\n\n        # Smooth optimization settling transitioning penalty stringency seamlessly (simulated annealing like)\n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n\n            # Distances mapped across upper triangle permutations\n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1))\n            dist = np.maximum(dist, 1e-8)\n\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n\n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n\n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n\n            # Spheroid collisions repulsion feedback\n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, np.newaxis] * (diff / dist[:, np.newaxis])\n\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                \n                # Push vectors inversely applying repulsing gradients ensuring centers repel apart\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n\n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n\n            # Adam stepping variables recalculating\n            beta1, beta2 = 0.9, 0.999\n            \n            m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n            v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n            p = p - lr_p * (m_p / (1.0 - beta1 ** t)) / (np.sqrt(v_p / (1.0 - beta2 ** t)) + 1e-8)\n\n            m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n            v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n            r = r - lr_r * (m_r / (1.0 - beta1 ** t)) / (np.sqrt(v_r / (1.0 - beta2 ** t)) + 1e-8)\n\n            # Coordinate confinement strictly\n            p = np.clip(p, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Mathematical strict exact validation wrapper ensuring precise operational geometric boundary bounds are zero.\n        r_valid = compute_max_radii(p, r)\n\n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n\n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```"]}}, "artifacts_json": "{\"execution_time\": \"5.72s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum: 1.075383, Ratio: 0.4081\"}", "artifact_dir": null, "embedding": null}