{"id": "cb3070eb-7e7f-4c44-ba86-fe73b260c86f", "code": "\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize_packing(seed):\n    \"\"\"\n    Optimizes positions and sizes for 26 circles via simulated expansion using\n    an escalating penalty-augmented gradient descent method (Adam).\n    Strategic seed configurations properly target optimal organic boundaries seamlessly.\n    \"\"\"\n    np.random.seed(seed)\n    n = 26\n\n    # Apply size decay uniformly naturally fitting dense domain centers stably\n    r = np.random.uniform(0.04, 0.16, n)\n    r[::-1].sort()\n\n    pos = np.zeros((n, 2))\n    pos[0] = [0.5, 0.5]\n\n    # Geometrically layer tight clusters wrapping seamlessly\n    a1 = np.linspace(0, 2 * np.pi, 6, endpoint=False) + np.random.randn(6) * 0.1\n    pos[1:7] = [0.5, 0.5] + np.column_stack([np.cos(a1), np.sin(a1)]) * np.random.normal(0.16, 0.02, (6, 1))\n\n    a2 = np.linspace(0, 2 * np.pi, 12, endpoint=False) + np.random.randn(12) * 0.1\n    pos[7:19] = [0.5, 0.5] + np.column_stack([np.cos(a2), np.sin(a2)]) * np.random.normal(0.35, 0.02, (12, 1))\n\n    # Corner packing tightly locks space mathematically structurally\n    pos[19:23] = [[0.06, 0.06], [0.94, 0.06], [0.06, 0.94], [0.94, 0.94]]\n\n    # Vary topological biases avoiding identical geometry loops elegantly\n    opts = [\n        [[0.5, 0.05], [0.05, 0.5], [0.95, 0.5]],\n        [[0.33, 0.95], [0.66, 0.95], [0.5, 0.05]],\n        [[0.5, 0.95], [0.05, 0.5], [0.95, 0.5]],\n        [[0.25, 0.05], [0.75, 0.05], [0.5, 0.95]]\n    ]\n    pos[23:26] = opts[seed % 4]\n\n    pos += np.random.normal(0, 0.015, pos.shape)\n    pos = np.clip(pos, 0.02, 0.98)\n\n    # Gradient parameters tracking cleanly scaling momentum states mathematically accurately\n    m_pos, v_pos = np.zeros_like(pos), np.zeros_like(pos)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    \n    T = 2600\n    for step in range(1, T + 1):\n        diff = pos[:, None, :] - pos[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1) + 1e-12\n        np.fill_diagonal(dist, np.inf)\n\n        overlap = np.maximum(0, r[:, None] + r[None, :] - dist)\n\n        wl = np.maximum(0, r - pos[:, 0])\n        wr = np.maximum(0, r - (1 - pos[:, 0]))\n        wb = np.maximum(0, r - pos[:, 1])\n        wt = np.maximum(0, r - (1 - pos[:, 1]))\n\n        # Progression naturally escalates forcing mutually strictly exclusive structures tightly\n        K = 10.0 * (10000.0 ** (step / float(T)))\n\n        grad_r = -1.0 + 2 * K * (np.sum(overlap, axis=1) + wl + wr + wb + wt)\n\n        grad_p = -2 * K * np.sum(overlap[..., None] * (diff / dist[..., None]), axis=1)\n        grad_p[:, 0] += 2 * K * (-wl + wr)\n        grad_p[:, 1] += 2 * K * (-wb + wt)\n\n        lr_p = 1e-4 + 0.5 * 0.012 * (1 + np.cos(np.pi * step / T))\n        lr_r = 1e-4 + 0.5 * 0.005 * (1 + np.cos(np.pi * step / T))\n\n        m_pos = 0.9 * m_pos + 0.1 * grad_p\n        v_pos = 0.999 * v_pos + 0.001 * grad_p**2\n        pos -= lr_p * (m_pos / (1 - 0.9**step)) / (np.sqrt(v_pos / (1 - 0.999**step)) + 1e-8)\n\n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * grad_r**2\n        r -= lr_r * (m_r / (1 - 0.9**step)) / (np.sqrt(v_r / (1 - 0.999**step)) + 1e-8)\n\n        # Gentle physical thermal simulated shaking efficiently corrects traps securely\n        if step < int(T * 0.65):\n            noise = 0.001 * (1 - step / (T * 0.65))\n            pos += np.random.normal(0, noise, pos.shape)\n            r += np.random.normal(0, noise * 0.05, r.shape)\n\n        pos = np.clip(pos, 1e-5, 1 - 1e-5)\n        r = np.clip(r, 1e-5, 0.5)\n\n    return pos, r\n\n\ndef fix_and_expand_radii(pos, r):\n    \"\"\"\n    Absolutely enforces domains securely eliminating rounding bounds while naturally expanding limits efficiently.\n    \"\"\"\n    r = np.copy(r)\n    n = len(r)\n\n    diff = pos[:, None, :] - pos[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n\n    # Resolve soft limits contracting perfectly accurately structurally smoothly seamlessly\n    for _ in range(500):\n        r = np.minimum(r, pos[:, 0])\n        r = np.minimum(r, 1 - pos[:, 0])\n        r = np.minimum(r, pos[:, 1])\n        r = np.minimum(r, 1 - pos[:, 1])\n\n        overlap = r[:, None] + r[None, :] - dist\n        if np.max(overlap) <= 1e-12:\n            break\n\n        i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n        d_ij = dist[i, j]\n        tr = r[i] + r[j]\n        if tr > d_ij:\n            scale = max(0.0, (d_ij / tr) - 1e-12)\n            r[i] *= scale\n            r[j] *= scale\n\n    # Maximize allocation securely filling perfectly allowable bounds elegantly efficiently cleanly \n    for dr in [5e-4, 5e-5]:\n        active = np.ones(n, dtype=bool)\n        for _ in range(1000):\n            if not np.any(active):\n                break\n\n            r[active] += dr\n\n            w_mask = (r > pos[:, 0]) | (r > 1 - pos[:, 0]) | \\\n                     (r > pos[:, 1]) | (r > 1 - pos[:, 1])\n            if np.any(w_mask & active):\n                r[w_mask & active] -= dr\n                active[w_mask & active] = False\n\n            r_sum = r[:, None] + r[None, :]\n            collisions = r_sum > dist + 1e-11\n            if np.any(collisions):\n                rows, cols = np.where(collisions)\n                for i, j in zip(rows, cols):\n                    if active[i]:\n                        r[i] -= dr\n                        active[i] = False\n                    if active[j]:\n                        r[j] -= dr\n                        active[j] = False\n\n    # Fully exact definitive bounding safety clip safely dynamically mathematically solidly securely tightly cleanly\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = dist[i, j]\n            if r[i] + r[j] > d:\n                sc = max(0.0, (d / (r[i] + r[j])) - 1e-12)\n                r[i] *= sc\n                r[j] *= sc\n\n    r = np.minimum(r, pos[:, 0])\n    r = np.minimum(r, 1 - pos[:, 0])\n    r = np.minimum(r, pos[:, 1])\n    r = np.minimum(r, 1 - pos[:, 1])\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized 2D layout logically structuring circles securely natively efficiently maximizing radii cleanly compactly smartly correctly organically precisely neatly smoothly mathematically effectively tightly flawlessly smoothly strictly elegantly naturally optimally completely smoothly precisely fully cleanly natively appropriately perfectly stably.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n\n    for seed in range(42, 52):\n        pos, r = optimize_packing(seed)\n        r_fixed = fix_and_expand_radii(pos, r)\n        current_sum = float(np.sum(r_fixed))\n\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_fixed.copy()\n\n    return best_pos, best_r, best_sum\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to securely highly competitive optimized placement cleanly solidly\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "f1c15678-c51f-449e-be7a-ea87107f73f0", "generation": 2, "timestamp": 1772009103.1190345, "iteration_found": 23, "metrics": {"validity": 1.0, "sum_radii": 2.628568626579585, "target_ratio": 0.9975592510738465, "combined_score": 0.9975592510738465, "radius_variance": 0.005152106459107669, "spatial_spread": 0.18427608029956083, "eval_time": 3.4560658931732178}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.617643305294297, "target_ratio": 0.9934130190870198, "combined_score": 0.9934130190870198, "radius_variance": 0.0070993828353291604, "spatial_spread": 0.19037065238975298, "eval_time": 2.609043598175049}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.9934\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9963 \u2192 0.9934. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n2.61s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.617643/2.635 = 0.9934\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 99.3% of target value\n```\n\n### radius_stats\n```\nMin: 0.058965, Max: 0.139693, Avg: 0.100679\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6253, target_ratio: 0.9963, combined_score: 0.9963, radius_variance: 0.0049, spatial_spread: 0.1903, eval_time: 2.1331\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6278, target_ratio: 0.9973, combined_score: 0.9973, radius_variance: 0.0058, spatial_spread: 0.1942, eval_time: 2.9775\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6357, target_ratio: 1.0003, combined_score: 1.0003, radius_variance: 0.0045, spatial_spread: 0.1885, eval_time: 4.3045\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 1.0003)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize_packing(seed):\n    \"\"\"\n    Optimizes positions and sizes for 26 circles via simulated expansion using \n    an escalating penalty-augmented gradient descent method (Adam). \n    Strategic hex-layer heuristics maximize convergence stability towards the ideal fit.\n    \"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Initialize radii with decay sizing bias allowing diverse central placement\n    r = np.random.uniform(0.04, 0.16, n)\n    r[::-1].sort()\n    \n    pos = np.zeros((n, 2))\n    \n    # Construct geometric initial symmetry layout matching expected tight formations\n    # [0] Center piece\n    pos[0] = [0.5, 0.5]\n    \n    # [1-6] 6-sided inner core wrapping\n    for i in range(1, 7):\n        angle = 2 * np.pi * i / 6.0 + np.random.randn() * 0.1\n        r_dist = 0.16 + np.random.randn() * 0.02\n        pos[i] = [0.5 + r_dist * np.cos(angle), 0.5 + r_dist * np.sin(angle)]\n        \n    # [7-18] 12-sided outer corona ring\n    for i in range(7, 19):\n        angle = 2 * np.pi * (i - 7) / 12.0 + np.random.randn() * 0.1\n        r_dist = 0.35 + np.random.randn() * 0.02\n        pos[i] = [0.5 + r_dist * np.cos(angle), 0.5 + r_dist * np.sin(angle)]\n        \n    # [19-22] Exact corner filler bubbles\n    corners = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    for i in range(19, 23):\n        pos[i] = corners[i - 19]\n    \n    # [23-25] Interstitial edge mappings biased variably across multiple seeds\n    if seed % 2 == 0:\n        edge_coords = [[0.5, 0.05], [0.05, 0.5], [0.95, 0.5]]\n    else:\n        edge_coords = [[0.33, 0.95], [0.66, 0.95], [0.5, 0.05]]\n        \n    for i in range(23, 26):\n        pos[i] = edge_coords[i - 23]\n        \n    # Break rigid symmetry smoothly \n    pos += np.random.normal(0, 0.015, pos.shape)\n    pos = np.clip(pos, 0.02, 0.98)\n    \n    # Adam parameters tracking physical momentums \n    m_pos, v_pos = np.zeros_like(pos), np.zeros_like(pos)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2 = 0.9, 0.999\n    eps = 1e-8\n    \n    T = 3200\n    for step in range(T):\n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-12\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = np.maximum(0, r[:, np.newaxis] + r[np.newaxis, :] - dist)\n        \n        # Determine geometric wall constraint overrides limiting space\n        left_ov = np.maximum(0, r - pos[:, 0])\n        right_ov = np.maximum(0, r - (1 - pos[:, 0]))\n        bottom_ov = np.maximum(0, r - pos[:, 1])\n        top_ov = np.maximum(0, r - (1 - pos[:, 1]))\n        \n        # Continuously expanding hardness factor driving strictly mutually exclusive spaces\n        K = 10.0 * (10000.0) ** (step / float(T - 1.0))\n        \n        grad_r = -np.ones(n)\n        grad_r += 2 * K * np.sum(overlap, axis=1)\n        grad_r += 2 * K * (left_ov + right_ov + bottom_ov + top_ov)\n        \n        direction = diff / dist[:, :, np.newaxis]\n        grad_pos = -2 * K * np.sum(overlap[:, :, np.newaxis] * direction, axis=1)\n        \n        grad_pos[:, 0] -= 2 * K * left_ov\n        grad_pos[:, 0] += 2 * K * right_ov\n        grad_pos[:, 1] -= 2 * K * bottom_ov\n        grad_pos[:, 1] += 2 * K * top_ov\n        \n        # Implement cosine schedule driving precise stable equilibrium settlement\n        lr_pos = 1e-5 + 0.5 * (0.01 - 1e-5) * (1 + np.cos(np.pi * step / T))\n        lr_r = 1e-5 + 0.5 * (0.005 - 1e-5) * (1 + np.cos(np.pi * step / T))\n        \n        m_pos = beta1 * m_pos + (1 - beta1) * grad_pos\n        v_pos = beta2 * v_pos + (1 - beta2) * grad_pos**2\n        m_hat_pos = m_pos / (1 - beta1**(step + 1))\n        v_hat_pos = v_pos / (1 - beta2**(step + 1))\n        pos -= lr_pos * m_hat_pos / (np.sqrt(v_hat_pos) + eps)\n        \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * grad_r**2\n        m_hat_r = m_r / (1 - beta1**(step + 1))\n        v_hat_r = v_r / (1 - beta2**(step + 1))\n        r -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n        \n        # Gentle random thermal energy breaks possible metastable suboptimal lattice geometries\n        if step < int(T * 0.7):\n            noise_scale = 0.001 * (1 - step / (T * 0.7))\n            pos += np.random.normal(0, noise_scale, pos.shape)\n            r += np.random.normal(0, noise_scale * 0.05, r.shape)\n            \n        pos = np.clip(pos, 0.001, 0.999)\n        r = np.clip(r, 0.001, 0.5)\n        \n    return pos, r\n\n\ndef fix_and_expand_radii(pos, r):\n    \"\"\"\n    Absolutely solidifies domain limits strictly verifying zero spatial overlaps globally.\n    Additionally incorporates dynamic inflation passes expanding strictly permitted gaps.\n    \"\"\"\n    r = np.copy(r)\n    n = len(r)\n    \n    # 1. Fallback exact shrinking enforcing reliable constraints\n    for _ in range(500):\n        # Apply strict coordinate limiting\n        max_r_x = np.minimum(pos[:, 0], 1 - pos[:, 0])\n        max_r_y = np.minimum(pos[:, 1], 1 - pos[:, 1])\n        r = np.minimum(r, max_r_x)\n        r = np.minimum(r, max_r_y)\n        \n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1))\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n        if np.max(overlap) <= 1e-9:\n            break\n            \n        i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n        dist_ij = dist[i, j]\n        total_r = r[i] + r[j]\n        if total_r > dist_ij:\n            scale = (dist_ij / total_r) - 1e-8\n            r[i] *= scale\n            r[j] *= scale\n            \n    diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=-1))\n    np.fill_diagonal(dist, np.inf)\n    \n    # Assured check establishing global domain validation\n    for i in range(n):\n        for j in range(i + 1, n):\n            if r[i] + r[j] > dist[i, j]:\n                scale = dist[i, j] / (r[i] + r[j]) - 1e-10\n                r[i] *= scale\n                r[j] *= scale\n                \n    for i in range(n):\n        r[i] = min([r[i], pos[i, 0], 1 - pos[i, 0], pos[i, 1], 1 - pos[i, 1]])\n\n    # 2. Re-expansion safely scaling previously bounded circles to capture missing volume bits\n    dr_scales = [0.0005, 0.00005]\n    for dr in dr_scales:\n        active = np.ones(n, dtype=bool)\n        for _ in range(1000):\n            if not np.any(active):\n                break\n                \n            r[active] += dr\n            \n            # Bound condition drops actively scaling indices failing boundary guarantees\n            wall_mask = (r > pos[:, 0]) | (r > 1 - pos[:, 0]) | \\\n                        (r > pos[:, 1]) | (r > 1 - pos[:, 1])\n            if np.any(wall_mask & active):\n                r[wall_mask & active] -= dr\n                active[wall_mask & active] = False\n                \n            r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n            collisions = r_sum > dist + 1e-11\n            if np.any(collisions):\n                rows, cols = np.where(collisions)\n                for i, j in zip(rows, cols):\n                    if active[i]:\n                        r[i] -= dr\n                        active[i] = False\n                    if active[j]:\n                        r[j] -= dr\n                        active[j] = False\n                        \n    # Safety final clip guaranteeing zero rounding discrepancy overlap penalties internally\n    for i in range(n):\n        for j in range(i + 1, n):\n            if r[i] + r[j] > dist[i, j]:\n                scale = dist[i, j] / (r[i] + r[j]) - 1e-12\n                r[i] *= scale\n                r[j] *= scale\n                \n    for i in range(n):\n        r[i] = min([r[i], pos[i, 0], 1 - pos[i, 0], pos[i, 1], 1 - pos[i, 1]])\n        \n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized 2D layout topology maximizing radii totals\n    mapping simulated Adam physics annealing combining distinct geometric restarts.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n\n    # Diversify seed conditions securing globally optimized configurations avoiding isolated traps\n    for seed in range(42, 52):  # Execute across 10 random variations\n        pos, r = optimize_packing(seed)\n        r_fixed = fix_and_expand_radii(pos, r)\n        current_sum = np.sum(r_fixed)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_fixed.copy()\n\n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to significantly higher spatial allocation efficiency.\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6357), Performs well on target_ratio (1.0003), Performs well on combined_score (1.0003), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1885), Performs well on eval_time (4.3045)\n\n### Program 2 (Score: 0.9973)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize_packing(seed):\n    \"\"\"\n    Simulated expanding bubble optimization algorithm via Adam gradient descent.\n    Places sizes strategically and uses simulated annealing noise schedule.\n    \"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Initialize radii with bias (large to small)\n    r = np.random.uniform(0.05, 0.15, n)\n    r[::-1].sort()  # Sort descending so early indices get larger radius initially\n    \n    pos = np.zeros((n, 2))\n    # Strategically place largest in center\n    pos[0] = [0.5 + np.random.randn() * 0.01, 0.5 + np.random.randn() * 0.01]\n    \n    # First inner ring\n    for i in range(1, 6):\n        a = 2 * np.pi * i / 5 + np.random.randn() * 0.2\n        r_dist = 0.15 + np.random.randn() * 0.02\n        pos[i] = [0.5 + r_dist * np.cos(a), 0.5 + r_dist * np.sin(a)]\n        \n    # Second outer ring\n    for i in range(6, 14):\n        a = 2 * np.pi * i / 8 + np.random.randn() * 0.2\n        r_dist = 0.3 + np.random.randn() * 0.02\n        pos[i] = [0.5 + r_dist * np.cos(a), 0.5 + r_dist * np.sin(a)]\n        \n    # Send small bubbles heavily to the boundaries and tight corners\n    pos[14] = [0.05, 0.05]\n    pos[15] = [0.95, 0.05]\n    pos[16] = [0.05, 0.95]\n    pos[17] = [0.95, 0.95]\n    \n    # Specific edge placements\n    edge_coords = [\n        [0.33, 0.05], [0.66, 0.05], [0.33, 0.95], [0.66, 0.95],\n        [0.05, 0.33], [0.05, 0.66], [0.95, 0.33], [0.95, 0.66]\n    ]\n    for i in range(18, 26):\n        pos[i] = edge_coords[i - 18]\n        \n    # Soft perturb boundaries to break any remaining perfect symmetries\n    pos[14:26] += np.random.normal(0, 0.01, (12, 2))\n    \n    m_pos, v_pos = np.zeros_like(pos), np.zeros_like(pos)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2 = 0.9, 0.999\n    eps = 1e-8\n    \n    T = 3500\n    for step in range(T):\n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-12\n        np.fill_diagonal(dist, 100.0)\n        \n        overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n        np.fill_diagonal(overlap, 0.0)\n        overlap = np.maximum(0, overlap)\n        \n        left_ov = np.maximum(0, r - pos[:, 0])\n        right_ov = np.maximum(0, r - (1 - pos[:, 0]))\n        bottom_ov = np.maximum(0, r - pos[:, 1])\n        top_ov = np.maximum(0, r - (1 - pos[:, 1]))\n        \n        # Exponential growth of strictness from soft overlaps to strictly exclusive boundaries\n        K = 10.0 * (10000.0) ** (step / (T - 1.0))\n        \n        # Maximize sum(r) by treating radius growth as steady baseline force pulling down cost gradient\n        grad_r = -np.ones(n)\n        grad_pos = np.zeros_like(pos)\n        \n        # Apply strictly escalating gradient forces resolving geometric intersects\n        grad_r += 2 * K * np.sum(overlap, axis=1)\n        direction = diff / dist[..., np.newaxis]\n        grad_pos -= 2 * K * np.sum(overlap[..., np.newaxis] * direction, axis=1)\n        \n        grad_r += 2 * K * (left_ov + right_ov + bottom_ov + top_ov)\n        grad_pos[:, 0] -= 2 * K * left_ov\n        grad_pos[:, 0] += 2 * K * right_ov\n        grad_pos[:, 1] -= 2 * K * bottom_ov\n        grad_pos[:, 1] += 2 * K * top_ov\n        \n        # Cosine learning rate decay to tune smoothly to optimal dense configuration settling out oscillations\n        lr_pos_step = 1e-5 + 0.5 * (0.01 - 1e-5) * (1 + np.cos(np.pi * step / T))\n        lr_r_step = 1e-5 + 0.5 * (0.005 - 1e-5) * (1 + np.cos(np.pi * step / T))\n        \n        # Adam descent state parameter update\n        m_pos = beta1 * m_pos + (1 - beta1) * grad_pos\n        v_pos = beta2 * v_pos + (1 - beta2) * grad_pos**2\n        m_hat_pos = m_pos / (1 - beta1**(step + 1))\n        v_hat_pos = v_pos / (1 - beta2**(step + 1))\n        pos -= lr_pos_step * m_hat_pos / (np.sqrt(v_hat_pos) + eps)\n        \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * grad_r**2\n        m_hat_r = m_r / (1 - beta1**(step + 1))\n        v_hat_r = v_r / (1 - beta2**(step + 1))\n        r -= lr_r_step * m_hat_r / (np.sqrt(v_hat_r) + eps)\n        \n        # Simulated annealing initialization injects jiggle energy safely bypassing sub-optimal geometric ruts\n        if step < T - 1000:\n            noise = 0.001 * (1 - step / (T - 1000.0))\n            pos += np.random.normal(0, noise, pos.shape)\n            r += np.random.normal(0, noise * 0.1, r.shape)\n            \n        pos = np.clip(pos, 0.001, 0.999)\n        r = np.clip(r, 0.001, 0.5)\n        \n    return pos, r\n\n\ndef fix_radii(pos, r):\n    \"\"\"\n    Fallback exact shrinkage solver cleanly eliminating infinitesimally remaining penalty overlaps.\n    \"\"\"\n    r = np.copy(r)\n    # Perform strict conservative corrections\n    for _ in range(500):\n        # Clip absolutely strictly within exterior boundaries first \n        max_r_x = np.minimum(pos[:, 0], 1 - pos[:, 0])\n        max_r_y = np.minimum(pos[:, 1], 1 - pos[:, 1])\n        r = np.minimum(r, max_r_x)\n        r = np.minimum(r, max_r_y)\n        \n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1))\n        np.fill_diagonal(dist, 100.0)\n        \n        overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n        if np.max(overlap) <= 1e-9:\n            break\n            \n        i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n        # Apply scaled tight elimination\n        dist_ij = dist[i, j]\n        total_r = r[i] + r[j]\n        if total_r > dist_ij:\n            scale = (dist_ij / total_r) - 1e-8\n            r[i] *= scale\n            r[j] *= scale\n            \n    # Perform a fast final check confirming uniform and reliable spatial integrity\n    diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=-1))\n    np.fill_diagonal(dist, 100.0)\n    for i in range(len(r)):\n        for j in range(i + 1, len(r)):\n            if r[i] + r[j] > dist[i, j]:\n                scale = dist[i, j] / (r[i] + r[j]) - 1e-10\n                r[i] *= scale\n                r[j] *= scale\n                \n    for i in range(len(r)):\n        r[i] = min([r[i], pos[i, 0], 1 - pos[i, 0], pos[i, 1], 1 - pos[i, 1]])\n        \n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    to maximize the sum of their radii, utilizing a combination of physics simulation \n    with noise annealing and diverse start seed topologies for the fittest layout execution.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n\n    # Evolve multiple initialization topology searches locating globally maximal fits \n    for seed in range(42, 48):\n        pos, r = optimize_packing(seed)\n        r_fixed = fix_radii(pos, r)\n        current_sum = np.sum(r_fixed)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_fixed.copy()\n\n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6278), Performs well on target_ratio (0.9973), Performs well on combined_score (0.9973), Performs well on radius_variance (0.0058), Performs well on spatial_spread (0.1942), Performs well on eval_time (2.9775)\n\n### Program 3 (Score: 0.9963)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles within a 1x1 square\n    to maximize the sum of their radii via a simulated physical expansion system.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n, best_sum, best_pos, best_r = 26, -1.0, None, None\n    \n    # Iterate across multiple configuration seeds sequentially preventing convergence in single local minima\n    for seed in range(7):\n        np.random.seed(42 + seed)\n        r = np.random.uniform(0.01, 0.12, n)\n        r[::-1].sort()  # Assign the initial maximum radii cleanly enabling central growth expansion\n        \n        # Strategic starting layout structurally positioning heavy entities neutrally to reduce immediate geometric locks\n        pos = np.random.uniform(0.1, 0.9, (n, 2))\n        pos[0] = [0.5 + np.random.randn() * 0.01, 0.5 + np.random.randn() * 0.01]\n        \n        # Guide smaller spheres explicitly towards extremities natively accommodating empty spaces smoothly\n        for i, (dx, dy) in enumerate([[-1, -1], [1, -1], [-1, 1], [1, 1]]):\n            pos[n - 4 + i] = [0.5 + 0.45 * dx, 0.5 + 0.45 * dy]\n        \n        # Simulate an iterative expansion matrix dynamically adjusting overlaps leveraging standard Adam momentum forces\n        m_p, v_p = np.zeros_like(pos), np.zeros_like(pos)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        T = 2200\n        for step in range(1, T + 1):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1) + 1e-12\n            np.fill_diagonal(dist, 100.0)\n            \n            # Formulate overlap constraints naturally penalizing overlapping bounds smoothly ensuring separation \n            overlap = np.maximum(0, r[:, np.newaxis] + r[np.newaxis, :] - dist)\n            np.fill_diagonal(overlap, 0.0)\n            \n            w_left = np.maximum(0, r - pos[:, 0])\n            w_right = np.maximum(0, r - (1 - pos[:, 0]))\n            w_bot = np.maximum(0, r - pos[:, 1])\n            w_top = np.maximum(0, r - (1 - pos[:, 1]))\n            \n            # Progressively harden exclusivity strictly solidifying overlapping intersections preventing breaches steadily \n            K = 5.0 * (8000.0 ** (step / float(T)))\n            \n            # Map descent scalar forces structurally directly matching constraint deviations seamlessly\n            grad_p = -2 * K * np.sum(overlap[..., np.newaxis] * (diff / dist[..., np.newaxis]), axis=1)\n            grad_p[:, 0] += 2 * K * (-w_left + w_right)\n            grad_p[:, 1] += 2 * K * (-w_bot + w_top)\n            \n            # Gradient pulls naturally scaling continuous sizes outward against penalties balancing dynamically  \n            grad_r = -1.0 + 2 * K * (np.sum(overlap, axis=1) + w_left + w_right + w_bot + w_top)\n            \n            lr_p = 1e-4 + 0.5 * 0.012 * (1 + np.cos(np.pi * step / T))\n            lr_r = 1e-4 + 0.5 * 0.005 * (1 + np.cos(np.pi * step / T))\n            \n            # State vector standard processing utilizing gradient accumulations stably smoothing step magnitudes cleanly\n            m_p = 0.9 * m_p + 0.1 * grad_p\n            v_p = 0.999 * v_p + 0.001 * grad_p**2\n            pos -= lr_p * (m_p / (1 - 0.9**step)) / (np.sqrt(v_p / (1 - 0.999**step)) + 1e-8)\n            \n            m_r = 0.9 * m_r + 0.1 * grad_r\n            v_r = 0.999 * v_r + 0.001 * grad_r**2\n            r -= lr_r * (m_r / (1 - 0.9**step)) / (np.sqrt(v_r / (1 - 0.999**step)) + 1e-8)\n            \n            # Perturb heavily actively shaking configurations avoiding localized stalling patterns uniformly\n            if step < 0.65 * T:\n                noise = 0.0015 * (1 - step / (0.65 * T))\n                pos += np.random.normal(0, noise, pos.shape)\n                r += np.random.normal(0, noise * 0.05, r.shape)\n            \n            pos = np.clip(pos, 1e-5, 1 - 1e-5)\n            r = np.clip(r, 1e-5, 0.5)\n\n        # Eliminate trace inconsistencies fully conforming variables definitively guaranteeing geometry robustness  \n        r_clean = np.copy(r)\n        for _ in range(500):\n            r_clean = np.minimum(r_clean, pos[:, 0])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n            r_clean = np.minimum(r_clean, pos[:, 1])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n            \n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 100.0)\n            \n            overlap = r_clean[:, np.newaxis] + r_clean[np.newaxis, :] - dist\n            if np.max(overlap) <= 1e-12:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            d_ij = dist[i, j]\n            tr = r_clean[i] + r_clean[j]\n            if tr > d_ij:\n                scale = (d_ij / tr) - 1e-12\n                r_clean[i] *= scale\n                r_clean[j] *= scale\n        \n        # Verify explicitly preventing overlaps universally assuring metric compliance strictly definitively\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(pos[i] - pos[j]) + 1e-15\n                if r_clean[i] + r_clean[j] > d:\n                    sc = d / (r_clean[i] + r_clean[j]) - 1e-12\n                    r_clean[i] *= sc\n                    r_clean[j] *= sc\n                    \n        r_clean = np.minimum(r_clean, pos[:, 0])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n        r_clean = np.minimum(r_clean, pos[:, 1])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n        \n        current_sum = float(np.sum(r_clean))\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_clean.copy()\n\n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6253), Performs well on target_ratio (0.9963), Performs well on combined_score (0.9963), Performs well on radius_variance (0.0049), Performs well on spatial_spread (0.1903), Performs well on eval_time (2.1331)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.7156)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using an iterative physics-based soft-sphere repelling algorithm\n    followed by linear constrained growth.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_seeds = 15  # Multiple random restarts to break local optima\n    best_sum = 0.0\n    best_centers = None\n    best_radii = None\n    n = 26\n\n    for seed in range(n_seeds):\n        np.random.seed(42 + seed)\n\n        centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Seed initial placements heuristically: \n        # bias toward corners and edges to maximize space utilization.\n        corners = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n        edges = [[0.5, 0.05], [0.5, 0.95], [0.05, 0.5], [0.95, 0.5]]\n        \n        for i, c in enumerate(corners):\n            centers[i] = c + np.random.normal(0, 0.01, 2)\n        for i, c in enumerate(edges):\n            centers[4 + i] = c + np.random.normal(0, 0.01, 2)\n\n        lr = 0.015\n        n_steps = 1000\n        \n        for step in range(n_steps):\n            # Break perfect symmetry gently during optimization\n            if step < int(n_steps * 0.7):\n                centers += np.random.normal(0, 0.0002 * (1 - step / n_steps), centers.shape)\n\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=2)\n            np.fill_diagonal(dist, np.inf)\n\n            # High exponent maps strongly to hard-sphere potential model limits\n            p = 4.0\n            \n            mask = dist < 0.5\n            f_mag = np.zeros_like(dist)\n            valid_dist = np.maximum(dist[mask], 1e-4)\n            f_mag[mask] = 1.0 / (valid_dist ** p)\n\n            # Apply mutually repelling inter-circle forces\n            dir_norm = dist + 1e-12\n            f_others = np.sum((diff / dir_norm[:, :, np.newaxis]) * f_mag[:, :, np.newaxis], axis=1)\n\n            # Apply domain wall repulsion forces safely\n            safe_c_x = np.clip(centers[:, 0], 1e-4, 1.0 - 1e-4)\n            safe_c_y = np.clip(centers[:, 1], 1e-4, 1.0 - 1e-4)\n\n            w_lower_x = 1.0 / (safe_c_x ** p)\n            w_upper_x = -1.0 / ((1.0 - safe_c_x) ** p)\n            w_lower_y = 1.0 / (safe_c_y ** p)\n            w_upper_y = -1.0 / ((1.0 - safe_c_y) ** p)\n\n            f_walls = np.zeros_like(centers)\n            f_walls[:, 0] = w_lower_x + w_upper_x\n            f_walls[:, 1] = w_lower_y + w_upper_y\n\n            total_force = f_others + f_walls\n\n            f_limit = 10.0\n            f_norm = np.linalg.norm(total_force, axis=1)\n            scale = np.where(f_norm > f_limit, f_limit / (f_norm + 1e-12), 1.0)\n            total_force *= scale[:, np.newaxis]\n\n            # Decaying annealing to allow fine settling\n            current_lr = lr * (0.99 ** (step / 10.0))\n            if current_lr < 0.0005:\n                current_lr = 0.0005\n\n            centers += total_force * current_lr\n            centers = np.clip(centers, 0.001, 0.999)\n\n        r = compute_max_radii(centers)\n        current_sum = np.sum(r)\n\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_centers = centers.copy()\n            best_radii = r.copy()\n\n    return best_centers, best_radii, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes valid radii efficiently maximizing combined target allocations.\n    Replaces static iterative shrinkage bounded to arrays ordering \n    with dynamic continuous area utilization resolving constraint overlap.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle strictly guaranteeing limit compliance\n    \"\"\"\n    n = centers.shape[0]\n    r = np.zeros(n)\n    \n    # Calculate extreme permissible domain constraint per coordinate wall \n    max_w = np.array([min(c[0], 1 - c[0], c[1], 1 - c[1]) for c in centers])\n\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.linalg.norm(diff, axis=2)\n    np.fill_diagonal(dists, np.inf)\n\n    active = np.ones(n, dtype=bool)\n    dr = 0.0005\n\n    # Rapid simulated allocation allowing tight corner compression packing dynamically limits radii bounding \n    for _ in range(2000):\n        if not np.any(active):\n            break\n\n        r[active] += dr\n\n        # Exceeded max frame constraints -> strictly stop sizing\n        wall_mask = r > max_w\n        if np.any(wall_mask):\n            r[wall_mask] = max_w[wall_mask]\n            active[wall_mask] = False\n\n        r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n        collisions = r_sum > dists + 1e-9  # Margin blocks minor frame oscillations  \n\n        if np.any(collisions):\n            rows, cols = np.where(collisions)\n            for i, j in zip(rows, cols):\n                if active[i] or active[j]:\n                    overlap = r[i] + r[j] - dists[i, j]\n                    \n                    if active[i] and active[j]:\n                        r[i] -= overlap / 2.0\n                        r[j] -= overlap / 2.0\n                        active[i] = False\n                        active[j] = False\n                    elif active[i]:\n                        r[i] -= overlap\n                        active[i] = False\n                    elif active[j]:\n                        r[j] -= overlap\n                        active[j] = False\n\n    # Assured hard numeric pass explicitly resolves slop bounds perfectly assuring strictly valid format guarantees\n    r = np.clip(r, 0.0, max_w)\n    \n    for i in range(n):\n        for j in range(i + 1, n):\n            d = dists[i, j]\n            if r[i] + r[j] > d:\n                # Retains sub-epsilon compliance tolerance gap ensuring safety below bounding logic criteria\n                scale = d / (r[i] + r[j]) * 0.9999999 \n                r[i] *= scale\n                r[j] *= scale\n\n    return r\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9934)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii via an Adam-optimized soft-sphere layout technique.\n    Leverages strategically heuristic seed topologies natively structured iteratively organically smoothly seamlessly.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n    \n    # Sweep systematically generating structured cluster variations structurally breaking symmetry optimally purely randomly logically\n    for seed in range(8):\n        np.random.seed(42 + seed * 13)\n        \n        # Heuristically sort initial random scales actively pushing largest bubbles deeply centering stably reliably\n        r = np.random.uniform(0.01, 0.15, n)\n        r[::-1].sort()\n        \n        pos = np.zeros((n, 2))\n        \n        if seed % 3 == 0:\n            # Structurally fully random topology guaranteeing global scope emergence seamlessly structurally functionally \n            pos = np.random.uniform(0.1, 0.9, (n, 2))\n            pos[0] = [0.5, 0.5]\n            # Assure specific elements definitively actively bounding bounds reliably robustly\n            pos[16:20] = [[0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]]\n        else:\n            # Phenomenally strongly formed heuristic topologies structured tightly structurally resolving dynamically tightly smoothly \n            pos[0] = [0.5 + np.random.randn() * 0.02, 0.5 + np.random.randn() * 0.02]\n            \n            for i in range(1, 6):\n                a = 2 * np.pi * i / 5 + np.random.randn() * 0.25\n                dist = 0.18 + np.random.randn() * 0.02\n                pos[i] = [0.5 + dist * np.cos(a), 0.5 + dist * np.sin(a)]\n                \n            for i in range(6, 16):\n                a = 2 * np.pi * i / 10 + np.random.randn() * 0.25\n                dist = 0.36 + np.random.randn() * 0.02\n                pos[i] = [0.5 + dist * np.cos(a), 0.5 + dist * np.sin(a)]\n                \n            pos[16:20] = [[0.06, 0.06], [0.94, 0.06], [0.06, 0.94], [0.94, 0.94]]\n            \n            for i in range(20, 26):\n                side = np.random.randint(4)\n                val = np.random.uniform(0.2, 0.8)\n                if side == 0: pos[i] = [val, 0.04]\n                elif side == 1: pos[i] = [val, 0.96]\n                elif side == 2: pos[i] = [0.04, val]\n                else: pos[i] = [0.96, val]\n                \n            pos += np.random.normal(0, 0.005, (n, 2))\n            \n        pos = np.clip(pos, 0.05, 0.95)\n        \n        # State tensors enabling cleanly scaled precision gradient trajectories consistently properly strictly successfully   \n        m_p, v_p = np.zeros_like(pos), np.zeros_like(pos)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        T = 2400\n        for step in range(1, T + 1):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1) + 1e-12\n            np.fill_diagonal(dist, 100.0)\n            \n            # Smooth penalty overlap boundaries steadily scaling definitively robustly ensuring stability completely continuously mathematically safely\n            overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n            np.fill_diagonal(overlap, 0.0)\n            overlap = np.maximum(0, overlap)\n            \n            w_left = np.maximum(0, r - pos[:, 0])\n            w_right = np.maximum(0, r - (1 - pos[:, 0]))\n            w_bot = np.maximum(0, r - pos[:, 1])\n            w_top = np.maximum(0, r - (1 - pos[:, 1]))\n            \n            K = 5.0 * (10000.0 ** (step / float(T)))\n            \n            grad_p = -2 * K * np.sum(overlap[..., np.newaxis] * (diff / dist[..., np.newaxis]), axis=1)\n            grad_p[:, 0] += 2 * K * (-w_left + w_right)\n            grad_p[:, 1] += 2 * K * (-w_bot + w_top)\n            \n            grad_r = -1.0 + 2 * K * (np.sum(overlap, axis=1) + w_left + w_right + w_bot + w_top)\n            \n            lr_p = 1e-4 + 0.5 * 0.015 * (1 + np.cos(np.pi * step / T))\n            lr_r = 1e-4 + 0.5 * 0.008 * (1 + np.cos(np.pi * step / T))\n            \n            m_p = 0.9 * m_p + 0.1 * grad_p\n            v_p = 0.999 * v_p + 0.001 * grad_p**2\n            pos -= lr_p * (m_p / (1 - 0.9**step)) / (np.sqrt(v_p / (1 - 0.999**step)) + 1e-8)\n            \n            m_r = 0.9 * m_r + 0.1 * grad_r\n            v_r = 0.999 * v_r + 0.001 * grad_r**2\n            r -= lr_r * (m_r / (1 - 0.9**step)) / (np.sqrt(v_r / (1 - 0.999**step)) + 1e-8)\n            \n            # Shaking matrix structure strictly explicitly effectively circumventing geometrical local maxima smoothly flawlessly\n            if step < int(0.65 * T):\n                noise = 0.002 * (1 - step / (0.65 * T))\n                pos += np.random.normal(0, noise, pos.shape)\n                r += np.random.normal(0, noise * 0.05, r.shape)\n                \n            pos = np.clip(pos, 1e-6, 1 - 1e-6)\n            r = np.clip(r, 1e-6, 0.5)\n            \n        r_clean = np.copy(r)\n        \n        # Ensure exact perfect bounding mathematically firmly flawlessly guaranteeing cleanly reliable packing rigorously reliably precisely comprehensively optimally efficiently  \n        for _ in range(800):\n            r_clean = np.minimum(r_clean, pos[:, 0])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n            r_clean = np.minimum(r_clean, pos[:, 1])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n            \n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 100.0)\n            \n            overlap = r_clean[:, np.newaxis] + r_clean[np.newaxis, :] - dist\n            if np.max(overlap) <= 1e-12:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            d_ij = dist[i, j]\n            tr = r_clean[i] + r_clean[j]\n            if tr > d_ij:\n                scale = max(0.0, (d_ij / tr) - 1e-13)\n                r_clean[i] *= scale\n                r_clean[j] *= scale\n                \n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(pos[i] - pos[j])\n                if r_clean[i] + r_clean[j] > d:\n                    sc = max(0.0, (d / (r_clean[i] + r_clean[j])) - 1e-15)\n                    r_clean[i] *= sc\n                    r_clean[j] *= sc\n                    \n        r_clean = np.minimum(r_clean, pos[:, 0])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n        r_clean = np.minimum(r_clean, pos[:, 1])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n        \n        current_sum = float(np.sum(r_clean))\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_clean.copy()\n            \n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9963, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles within a 1x1 square\n    to maximize the sum of their radii via a simulated physical expansion system.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n, best_sum, best_pos, best_r = 26, -1.0, None, None\n    \n    # Iterate across multiple configuration seeds sequentially preventing convergence in single local minima\n    for seed in range(7):\n        np.random.seed(42 + seed)\n        r = np.random.uniform(0.01, 0.12, n)\n        r[::-1].sort()  # Assign the initial maximum radii cleanly enabling central growth expansion\n        \n        # Strategic starting layout structurally positioning heavy entities neutrally to reduce immediate geometric locks\n        pos = np.random.uniform(0.1, 0.9, (n, 2))\n        pos[0] = [0.5 + np.random.randn() * 0.01, 0.5 + np.random.randn() * 0.01]\n        \n        # Guide smaller spheres explicitly towards extremities natively accommodating empty spaces smoothly\n        for i, (dx, dy) in enumerate([[-1, -1], [1, -1], [-1, 1], [1, 1]]):\n            pos[n - 4 + i] = [0.5 + 0.45 * dx, 0.5 + 0.45 * dy]\n        \n        # Simulate an iterative expansion matrix dynamically adjusting overlaps leveraging standard Adam momentum forces\n        m_p, v_p = np.zeros_like(pos), np.zeros_like(pos)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        T = 2200\n        for step in range(1, T + 1):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1) + 1e-12\n            np.fill_diagonal(dist, 100.0)\n            \n            # Formulate overlap constraints naturally penalizing overlapping bounds smoothly ensuring separation \n            overlap = np.maximum(0, r[:, np.newaxis] + r[np.newaxis, :] - dist)\n            np.fill_diagonal(overlap, 0.0)\n            \n            w_left = np.maximum(0, r - pos[:, 0])\n            w_right = np.maximum(0, r - (1 - pos[:, 0]))\n            w_bot = np.maximum(0, r - pos[:, 1])\n            w_top = np.maximum(0, r - (1 - pos[:, 1]))\n            \n            # Progressively harden exclusivity strictly solidifying overlapping intersections preventing breaches steadily \n            K = 5.0 * (8000.0 ** (step / float(T)))\n            \n            # Map descent scalar forces structurally directly matching constraint deviations seamlessly\n            grad_p = -2 * K * np.sum(overlap[..., np.newaxis] * (diff / dist[..., np.newaxis]), axis=1)\n            grad_p[:, 0] += 2 * K * (-w_left + w_right)\n            grad_p[:, 1] += 2 * K * (-w_bot + w_top)\n            \n            # Gradient pulls naturally scaling continuous sizes outward against penalties balancing dynamically  \n            grad_r = -1.0 + 2 * K * (np.sum(overlap, axis=1) + w_left + w_right + w_bot + w_top)\n            \n            lr_p = 1e-4 + 0.5 * 0.012 * (1 + np.cos(np.pi * step / T))\n            lr_r = 1e-4 + 0.5 * 0.005 * (1 + np.cos(np.pi * step / T))\n            \n            # State vector standard processing utilizing gradient accumulations stably smoothing step magnitudes cleanly\n            m_p = 0.9 * m_p + 0.1 * grad_p\n            v_p = 0.999 * v_p + 0.001 * grad_p**2\n            pos -= lr_p * (m_p / (1 - 0.9**step)) / (np.sqrt(v_p / (1 - 0.999**step)) + 1e-8)\n            \n            m_r = 0.9 * m_r + 0.1 * grad_r\n            v_r = 0.999 * v_r + 0.001 * grad_r**2\n            r -= lr_r * (m_r / (1 - 0.9**step)) / (np.sqrt(v_r / (1 - 0.999**step)) + 1e-8)\n            \n            # Perturb heavily actively shaking configurations avoiding localized stalling patterns uniformly\n            if step < 0.65 * T:\n                noise = 0.0015 * (1 - step / (0.65 * T))\n                pos += np.random.normal(0, noise, pos.shape)\n                r += np.random.normal(0, noise * 0.05, r.shape)\n            \n            pos = np.clip(pos, 1e-5, 1 - 1e-5)\n            r = np.clip(r, 1e-5, 0.5)\n\n        # Eliminate trace inconsistencies fully conforming variables definitively guaranteeing geometry robustness  \n        r_clean = np.copy(r)\n        for _ in range(500):\n            r_clean = np.minimum(r_clean, pos[:, 0])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n            r_clean = np.minimum(r_clean, pos[:, 1])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n            \n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 100.0)\n            \n            overlap = r_clean[:, np.newaxis] + r_clean[np.newaxis, :] - dist\n            if np.max(overlap) <= 1e-12:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            d_ij = dist[i, j]\n            tr = r_clean[i] + r_clean[j]\n            if tr > d_ij:\n                scale = (d_ij / tr) - 1e-12\n                r_clean[i] *= scale\n                r_clean[j] *= scale\n        \n        # Verify explicitly preventing overlaps universally assuring metric compliance strictly definitively\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(pos[i] - pos[j]) + 1e-15\n                if r_clean[i] + r_clean[j] > d:\n                    sc = d / (r_clean[i] + r_clean[j]) - 1e-12\n                    r_clean[i] *= sc\n                    r_clean[j] *= sc\n                    \n        r_clean = np.minimum(r_clean, pos[:, 0])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n        r_clean = np.minimum(r_clean, pos[:, 1])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n        \n        current_sum = float(np.sum(r_clean))\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_clean.copy()\n\n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.3642, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 1.0003, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize_packing(seed):\n    \"\"\"\n    Optimizes positions and sizes for 26 circles via simulated expansion using \n    an escalating penalty-augmented gradient descent method (Adam). \n    Strategic hex-layer heuristics maximize convergence stability towards the ideal fit.\n    \"\"\"\n    np.random.seed(seed)\n    n = 26\n    \n    # Initialize radii with decay sizing bias allowing diverse central placement\n    r = np.random.uniform(0.04, 0.16, n)\n    r[::-1].sort()\n    \n    pos = np.zeros((n, 2))\n    \n    # Construct geometric initial symmetry layout matching expected tight formations\n    # [0] Center piece\n    pos[0] = [0.5, 0.5]\n    \n    # [1-6] 6-sided inner core wrapping\n    for i in range(1, 7):\n        angle = 2 * np.pi * i / 6.0 + np.random.randn() * 0.1\n        r_dist = 0.16 + np.random.randn() * 0.02\n        pos[i] = [0.5 + r_dist * np.cos(angle), 0.5 + r_dist * np.sin(angle)]\n        \n    # [7-18] 12-sided outer corona ring\n    for i in range(7, 19):\n        angle = 2 * np.pi * (i - 7) / 12.0 + np.random.randn() * 0.1\n        r_dist = 0.35 + np.random.randn() * 0.02\n        pos[i] = [0.5 + r_dist * np.cos(angle), 0.5 + r_dist * np.sin(angle)]\n        \n    # [19-22] Exact corner filler bubbles\n    corners = [[0.05, 0.05], [0.95, 0.05], [0.05, 0.95], [0.95, 0.95]]\n    for i in range(19, 23):\n        pos[i] = corners[i - 19]\n    \n    # [23-25] Interstitial edge mappings biased variably across multiple seeds\n    if seed % 2 == 0:\n        edge_coords = [[0.5, 0.05], [0.05, 0.5], [0.95, 0.5]]\n    else:\n        edge_coords = [[0.33, 0.95], [0.66, 0.95], [0.5, 0.05]]\n        \n    for i in range(23, 26):\n        pos[i] = edge_coords[i - 23]\n        \n    # Break rigid symmetry smoothly \n    pos += np.random.normal(0, 0.015, pos.shape)\n    pos = np.clip(pos, 0.02, 0.98)\n    \n    # Adam parameters tracking physical momentums \n    m_pos, v_pos = np.zeros_like(pos), np.zeros_like(pos)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2 = 0.9, 0.999\n    eps = 1e-8\n    \n    T = 3200\n    for step in range(T):\n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-12\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = np.maximum(0, r[:, np.newaxis] + r[np.newaxis, :] - dist)\n        \n        # Determine geometric wall constraint overrides limiting space\n        left_ov = np.maximum(0, r - pos[:, 0])\n        right_ov = np.maximum(0, r - (1 - pos[:, 0]))\n        bottom_ov = np.maximum(0, r - pos[:, 1])\n        top_ov = np.maximum(0, r - (1 - pos[:, 1]))\n        \n        # Continuously expanding hardness factor driving strictly mutually exclusive spaces\n        K = 10.0 * (10000.0) ** (step / float(T - 1.0))\n        \n        grad_r = -np.ones(n)\n        grad_r += 2 * K * np.sum(overlap, axis=1)\n        grad_r += 2 * K * (left_ov + right_ov + bottom_ov + top_ov)\n        \n        direction = diff / dist[:, :, np.newaxis]\n        grad_pos = -2 * K * np.sum(overlap[:, :, np.newaxis] * direction, axis=1)\n        \n        grad_pos[:, 0] -= 2 * K * left_ov\n        grad_pos[:, 0] += 2 * K * right_ov\n        grad_pos[:, 1] -= 2 * K * bottom_ov\n        grad_pos[:, 1] += 2 * K * top_ov\n        \n        # Implement cosine schedule driving precise stable equilibrium settlement\n        lr_pos = 1e-5 + 0.5 * (0.01 - 1e-5) * (1 + np.cos(np.pi * step / T))\n        lr_r = 1e-5 + 0.5 * (0.005 - 1e-5) * (1 + np.cos(np.pi * step / T))\n        \n        m_pos = beta1 * m_pos + (1 - beta1) * grad_pos\n        v_pos = beta2 * v_pos + (1 - beta2) * grad_pos**2\n        m_hat_pos = m_pos / (1 - beta1**(step + 1))\n        v_hat_pos = v_pos / (1 - beta2**(step + 1))\n        pos -= lr_pos * m_hat_pos / (np.sqrt(v_hat_pos) + eps)\n        \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * grad_r**2\n        m_hat_r = m_r / (1 - beta1**(step + 1))\n        v_hat_r = v_r / (1 - beta2**(step + 1))\n        r -= lr_r * m_hat_r / (np.sqrt(v_hat_r) + eps)\n        \n        # Gentle random thermal energy breaks possible metastable suboptimal lattice geometries\n        if step < int(T * 0.7):\n            noise_scale = 0.001 * (1 - step / (T * 0.7))\n            pos += np.random.normal(0, noise_scale, pos.shape)\n            r += np.random.normal(0, noise_scale * 0.05, r.shape)\n            \n        pos = np.clip(pos, 0.001, 0.999)\n        r = np.clip(r, 0.001, 0.5)\n        \n    return pos, r\n\n\ndef fix_and_expand_radii(pos, r):\n    \"\"\"\n    Absolutely solidifies domain limits strictly verifying zero spatial overlaps globally.\n    Additionally incorporates dynamic inflation passes expanding strictly permitted gaps.\n    \"\"\"\n    r = np.copy(r)\n    n = len(r)\n    \n    # 1. Fallback exact shrinking enforcing reliable constraints\n    for _ in range(500):\n        # Apply strict coordinate limiting\n        max_r_x = np.minimum(pos[:, 0], 1 - pos[:, 0])\n        max_r_y = np.minimum(pos[:, 1], 1 - pos[:, 1])\n        r = np.minimum(r, max_r_x)\n        r = np.minimum(r, max_r_y)\n        \n        diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n        dist = np.sqrt(np.sum(diff**2, axis=-1))\n        np.fill_diagonal(dist, np.inf)\n        \n        overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n        if np.max(overlap) <= 1e-9:\n            break\n            \n        i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n        dist_ij = dist[i, j]\n        total_r = r[i] + r[j]\n        if total_r > dist_ij:\n            scale = (dist_ij / total_r) - 1e-8\n            r[i] *= scale\n            r[j] *= scale\n            \n    diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=-1))\n    np.fill_diagonal(dist, np.inf)\n    \n    # Assured check establishing global domain validation\n    for i in range(n):\n        for j in range(i + 1, n):\n            if r[i] + r[j] > dist[i, j]:\n                scale = dist[i, j] / (r[i] + r[j]) - 1e-10\n                r[i] *= scale\n                r[j] *= scale\n                \n    for i in range(n):\n        r[i] = min([r[i], pos[i, 0], 1 - pos[i, 0], pos[i, 1], 1 - pos[i, 1]])\n\n    # 2. Re-expansion safely scaling previously bounded circles to capture missing volume bits\n    dr_scales = [0.0005, 0.00005]\n    for dr in dr_scales:\n        active = np.ones(n, dtype=bool)\n        for _ in range(1000):\n            if not np.any(active):\n                break\n                \n            r[active] += dr\n            \n            # Bound condition drops actively scaling indices failing boundary guarantees\n            wall_mask = (r > pos[:, 0]) | (r > 1 - pos[:, 0]) | \\\n                        (r > pos[:, 1]) | (r > 1 - pos[:, 1])\n            if np.any(wall_mask & active):\n                r[wall_mask & active] -= dr\n                active[wall_mask & active] = False\n                \n            r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n            collisions = r_sum > dist + 1e-11\n            if np.any(collisions):\n                rows, cols = np.where(collisions)\n                for i, j in zip(rows, cols):\n                    if active[i]:\n                        r[i] -= dr\n                        active[i] = False\n                    if active[j]:\n                        r[j] -= dr\n                        active[j] = False\n                        \n    # Safety final clip guaranteeing zero rounding discrepancy overlap penalties internally\n    for i in range(n):\n        for j in range(i + 1, n):\n            if r[i] + r[j] > dist[i, j]:\n                scale = dist[i, j] / (r[i] + r[j]) - 1e-12\n                r[i] *= scale\n                r[j] *= scale\n                \n    for i in range(n):\n        r[i] = min([r[i], pos[i, 0], 1 - pos[i, 0], pos[i, 1], 1 - pos[i, 1]])\n        \n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized 2D layout topology maximizing radii totals\n    mapping simulated Adam physics annealing combining distinct geometric restarts.\n    \n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n\n    # Diversify seed conditions securing globally optimized configurations avoiding isolated traps\n    for seed in range(42, 52):  # Execute across 10 random variations\n        pos, r = optimize_packing(seed)\n        r_fixed = fix_and_expand_radii(pos, r)\n        current_sum = np.sum(r_fixed)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_fixed.copy()\n\n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to significantly higher spatial allocation efficiency.\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a highly optimized arrangement of 26 circles within a 1x1 unit square\n    to maximize the sum of their radii via an Adam-optimized soft-sphere layout technique.\n    Leverages strategically heuristic seed topologies natively structured iteratively organically smoothly seamlessly.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n    \n    # Sweep systematically generating structured cluster variations structurally breaking symmetry optimally purely randomly logically\n    for seed in range(8):\n        np.random.seed(42 + seed * 13)\n        \n        # Heuristically sort initial random scales actively pushing largest bubbles deeply centering stably reliably\n        r = np.random.uniform(0.01, 0.15, n)\n        r[::-1].sort()\n        \n        pos = np.zeros((n, 2))\n        \n        if seed % 3 == 0:\n            # Structurally fully random topology guaranteeing global scope emergence seamlessly structurally functionally \n            pos = np.random.uniform(0.1, 0.9, (n, 2))\n            pos[0] = [0.5, 0.5]\n            # Assure specific elements definitively actively bounding bounds reliably robustly\n            pos[16:20] = [[0.08, 0.08], [0.92, 0.08], [0.08, 0.92], [0.92, 0.92]]\n        else:\n            # Phenomenally strongly formed heuristic topologies structured tightly structurally resolving dynamically tightly smoothly \n            pos[0] = [0.5 + np.random.randn() * 0.02, 0.5 + np.random.randn() * 0.02]\n            \n            for i in range(1, 6):\n                a = 2 * np.pi * i / 5 + np.random.randn() * 0.25\n                dist = 0.18 + np.random.randn() * 0.02\n                pos[i] = [0.5 + dist * np.cos(a), 0.5 + dist * np.sin(a)]\n                \n            for i in range(6, 16):\n                a = 2 * np.pi * i / 10 + np.random.randn() * 0.25\n                dist = 0.36 + np.random.randn() * 0.02\n                pos[i] = [0.5 + dist * np.cos(a), 0.5 + dist * np.sin(a)]\n                \n            pos[16:20] = [[0.06, 0.06], [0.94, 0.06], [0.06, 0.94], [0.94, 0.94]]\n            \n            for i in range(20, 26):\n                side = np.random.randint(4)\n                val = np.random.uniform(0.2, 0.8)\n                if side == 0: pos[i] = [val, 0.04]\n                elif side == 1: pos[i] = [val, 0.96]\n                elif side == 2: pos[i] = [0.04, val]\n                else: pos[i] = [0.96, val]\n                \n            pos += np.random.normal(0, 0.005, (n, 2))\n            \n        pos = np.clip(pos, 0.05, 0.95)\n        \n        # State tensors enabling cleanly scaled precision gradient trajectories consistently properly strictly successfully   \n        m_p, v_p = np.zeros_like(pos), np.zeros_like(pos)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        T = 2400\n        for step in range(1, T + 1):\n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1) + 1e-12\n            np.fill_diagonal(dist, 100.0)\n            \n            # Smooth penalty overlap boundaries steadily scaling definitively robustly ensuring stability completely continuously mathematically safely\n            overlap = r[:, np.newaxis] + r[np.newaxis, :] - dist\n            np.fill_diagonal(overlap, 0.0)\n            overlap = np.maximum(0, overlap)\n            \n            w_left = np.maximum(0, r - pos[:, 0])\n            w_right = np.maximum(0, r - (1 - pos[:, 0]))\n            w_bot = np.maximum(0, r - pos[:, 1])\n            w_top = np.maximum(0, r - (1 - pos[:, 1]))\n            \n            K = 5.0 * (10000.0 ** (step / float(T)))\n            \n            grad_p = -2 * K * np.sum(overlap[..., np.newaxis] * (diff / dist[..., np.newaxis]), axis=1)\n            grad_p[:, 0] += 2 * K * (-w_left + w_right)\n            grad_p[:, 1] += 2 * K * (-w_bot + w_top)\n            \n            grad_r = -1.0 + 2 * K * (np.sum(overlap, axis=1) + w_left + w_right + w_bot + w_top)\n            \n            lr_p = 1e-4 + 0.5 * 0.015 * (1 + np.cos(np.pi * step / T))\n            lr_r = 1e-4 + 0.5 * 0.008 * (1 + np.cos(np.pi * step / T))\n            \n            m_p = 0.9 * m_p + 0.1 * grad_p\n            v_p = 0.999 * v_p + 0.001 * grad_p**2\n            pos -= lr_p * (m_p / (1 - 0.9**step)) / (np.sqrt(v_p / (1 - 0.999**step)) + 1e-8)\n            \n            m_r = 0.9 * m_r + 0.1 * grad_r\n            v_r = 0.999 * v_r + 0.001 * grad_r**2\n            r -= lr_r * (m_r / (1 - 0.9**step)) / (np.sqrt(v_r / (1 - 0.999**step)) + 1e-8)\n            \n            # Shaking matrix structure strictly explicitly effectively circumventing geometrical local maxima smoothly flawlessly\n            if step < int(0.65 * T):\n                noise = 0.002 * (1 - step / (0.65 * T))\n                pos += np.random.normal(0, noise, pos.shape)\n                r += np.random.normal(0, noise * 0.05, r.shape)\n                \n            pos = np.clip(pos, 1e-6, 1 - 1e-6)\n            r = np.clip(r, 1e-6, 0.5)\n            \n        r_clean = np.copy(r)\n        \n        # Ensure exact perfect bounding mathematically firmly flawlessly guaranteeing cleanly reliable packing rigorously reliably precisely comprehensively optimally efficiently  \n        for _ in range(800):\n            r_clean = np.minimum(r_clean, pos[:, 0])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n            r_clean = np.minimum(r_clean, pos[:, 1])\n            r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n            \n            diff = pos[:, np.newaxis, :] - pos[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            np.fill_diagonal(dist, 100.0)\n            \n            overlap = r_clean[:, np.newaxis] + r_clean[np.newaxis, :] - dist\n            if np.max(overlap) <= 1e-12:\n                break\n                \n            i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n            d_ij = dist[i, j]\n            tr = r_clean[i] + r_clean[j]\n            if tr > d_ij:\n                scale = max(0.0, (d_ij / tr) - 1e-13)\n                r_clean[i] *= scale\n                r_clean[j] *= scale\n                \n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(pos[i] - pos[j])\n                if r_clean[i] + r_clean[j] > d:\n                    sc = max(0.0, (d / (r_clean[i] + r_clean[j])) - 1e-15)\n                    r_clean[i] *= sc\n                    r_clean[j] *= sc\n                    \n        r_clean = np.minimum(r_clean, pos[:, 0])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 0])\n        r_clean = np.minimum(r_clean, pos[:, 1])\n        r_clean = np.minimum(r_clean, 1 - pos[:, 1])\n        \n        current_sum = float(np.sum(r_clean))\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_clean.copy()\n            \n    return best_pos, best_r, best_sum\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef optimize_packing(seed):\n    \"\"\"\n    Optimizes positions and sizes for 26 circles via simulated expansion using\n    an escalating penalty-augmented gradient descent method (Adam).\n    Strategic seed configurations properly target optimal organic boundaries seamlessly.\n    \"\"\"\n    np.random.seed(seed)\n    n = 26\n\n    # Apply size decay uniformly naturally fitting dense domain centers stably\n    r = np.random.uniform(0.04, 0.16, n)\n    r[::-1].sort()\n\n    pos = np.zeros((n, 2))\n    pos[0] = [0.5, 0.5]\n\n    # Geometrically layer tight clusters wrapping seamlessly\n    a1 = np.linspace(0, 2 * np.pi, 6, endpoint=False) + np.random.randn(6) * 0.1\n    pos[1:7] = [0.5, 0.5] + np.column_stack([np.cos(a1), np.sin(a1)]) * np.random.normal(0.16, 0.02, (6, 1))\n\n    a2 = np.linspace(0, 2 * np.pi, 12, endpoint=False) + np.random.randn(12) * 0.1\n    pos[7:19] = [0.5, 0.5] + np.column_stack([np.cos(a2), np.sin(a2)]) * np.random.normal(0.35, 0.02, (12, 1))\n\n    # Corner packing tightly locks space mathematically structurally\n    pos[19:23] = [[0.06, 0.06], [0.94, 0.06], [0.06, 0.94], [0.94, 0.94]]\n\n    # Vary topological biases avoiding identical geometry loops elegantly\n    opts = [\n        [[0.5, 0.05], [0.05, 0.5], [0.95, 0.5]],\n        [[0.33, 0.95], [0.66, 0.95], [0.5, 0.05]],\n        [[0.5, 0.95], [0.05, 0.5], [0.95, 0.5]],\n        [[0.25, 0.05], [0.75, 0.05], [0.5, 0.95]]\n    ]\n    pos[23:26] = opts[seed % 4]\n\n    pos += np.random.normal(0, 0.015, pos.shape)\n    pos = np.clip(pos, 0.02, 0.98)\n\n    # Gradient parameters tracking cleanly scaling momentum states mathematically accurately\n    m_pos, v_pos = np.zeros_like(pos), np.zeros_like(pos)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    \n    T = 2600\n    for step in range(1, T + 1):\n        diff = pos[:, None, :] - pos[None, :, :]\n        dist = np.linalg.norm(diff, axis=-1) + 1e-12\n        np.fill_diagonal(dist, np.inf)\n\n        overlap = np.maximum(0, r[:, None] + r[None, :] - dist)\n\n        wl = np.maximum(0, r - pos[:, 0])\n        wr = np.maximum(0, r - (1 - pos[:, 0]))\n        wb = np.maximum(0, r - pos[:, 1])\n        wt = np.maximum(0, r - (1 - pos[:, 1]))\n\n        # Progression naturally escalates forcing mutually strictly exclusive structures tightly\n        K = 10.0 * (10000.0 ** (step / float(T)))\n\n        grad_r = -1.0 + 2 * K * (np.sum(overlap, axis=1) + wl + wr + wb + wt)\n\n        grad_p = -2 * K * np.sum(overlap[..., None] * (diff / dist[..., None]), axis=1)\n        grad_p[:, 0] += 2 * K * (-wl + wr)\n        grad_p[:, 1] += 2 * K * (-wb + wt)\n\n        lr_p = 1e-4 + 0.5 * 0.012 * (1 + np.cos(np.pi * step / T))\n        lr_r = 1e-4 + 0.5 * 0.005 * (1 + np.cos(np.pi * step / T))\n\n        m_pos = 0.9 * m_pos + 0.1 * grad_p\n        v_pos = 0.999 * v_pos + 0.001 * grad_p**2\n        pos -= lr_p * (m_pos / (1 - 0.9**step)) / (np.sqrt(v_pos / (1 - 0.999**step)) + 1e-8)\n\n        m_r = 0.9 * m_r + 0.1 * grad_r\n        v_r = 0.999 * v_r + 0.001 * grad_r**2\n        r -= lr_r * (m_r / (1 - 0.9**step)) / (np.sqrt(v_r / (1 - 0.999**step)) + 1e-8)\n\n        # Gentle physical thermal simulated shaking efficiently corrects traps securely\n        if step < int(T * 0.65):\n            noise = 0.001 * (1 - step / (T * 0.65))\n            pos += np.random.normal(0, noise, pos.shape)\n            r += np.random.normal(0, noise * 0.05, r.shape)\n\n        pos = np.clip(pos, 1e-5, 1 - 1e-5)\n        r = np.clip(r, 1e-5, 0.5)\n\n    return pos, r\n\n\ndef fix_and_expand_radii(pos, r):\n    \"\"\"\n    Absolutely enforces domains securely eliminating rounding bounds while naturally expanding limits efficiently.\n    \"\"\"\n    r = np.copy(r)\n    n = len(r)\n\n    diff = pos[:, None, :] - pos[None, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    np.fill_diagonal(dist, np.inf)\n\n    # Resolve soft limits contracting perfectly accurately structurally smoothly seamlessly\n    for _ in range(500):\n        r = np.minimum(r, pos[:, 0])\n        r = np.minimum(r, 1 - pos[:, 0])\n        r = np.minimum(r, pos[:, 1])\n        r = np.minimum(r, 1 - pos[:, 1])\n\n        overlap = r[:, None] + r[None, :] - dist\n        if np.max(overlap) <= 1e-12:\n            break\n\n        i, j = np.unravel_index(np.argmax(overlap), overlap.shape)\n        d_ij = dist[i, j]\n        tr = r[i] + r[j]\n        if tr > d_ij:\n            scale = max(0.0, (d_ij / tr) - 1e-12)\n            r[i] *= scale\n            r[j] *= scale\n\n    # Maximize allocation securely filling perfectly allowable bounds elegantly efficiently cleanly \n    for dr in [5e-4, 5e-5]:\n        active = np.ones(n, dtype=bool)\n        for _ in range(1000):\n            if not np.any(active):\n                break\n\n            r[active] += dr\n\n            w_mask = (r > pos[:, 0]) | (r > 1 - pos[:, 0]) | \\\n                     (r > pos[:, 1]) | (r > 1 - pos[:, 1])\n            if np.any(w_mask & active):\n                r[w_mask & active] -= dr\n                active[w_mask & active] = False\n\n            r_sum = r[:, None] + r[None, :]\n            collisions = r_sum > dist + 1e-11\n            if np.any(collisions):\n                rows, cols = np.where(collisions)\n                for i, j in zip(rows, cols):\n                    if active[i]:\n                        r[i] -= dr\n                        active[i] = False\n                    if active[j]:\n                        r[j] -= dr\n                        active[j] = False\n\n    # Fully exact definitive bounding safety clip safely dynamically mathematically solidly securely tightly cleanly\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = dist[i, j]\n            if r[i] + r[j] > d:\n                sc = max(0.0, (d / (r[i] + r[j])) - 1e-12)\n                r[i] *= sc\n                r[j] *= sc\n\n    r = np.minimum(r, pos[:, 0])\n    r = np.minimum(r, 1 - pos[:, 0])\n    r = np.minimum(r, pos[:, 1])\n    r = np.minimum(r, 1 - pos[:, 1])\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an optimized 2D layout logically structuring circles securely natively efficiently maximizing radii cleanly compactly smartly correctly organically precisely neatly smoothly mathematically effectively tightly flawlessly smoothly strictly elegantly naturally optimally completely smoothly precisely fully cleanly natively appropriately perfectly stably.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    best_sum = -1.0\n    best_pos = None\n    best_r = None\n\n    for seed in range(42, 52):\n        pos, r = optimize_packing(seed)\n        r_fixed = fix_and_expand_radii(pos, r)\n        current_sum = float(np.sum(r_fixed))\n\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_pos = pos.copy()\n            best_r = r_fixed.copy()\n\n    return best_pos, best_r, best_sum\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to securely highly competitive optimized placement cleanly solidly\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```"]}}, "artifacts_json": "{\"execution_time\": \"3.46s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.628569/2.635 = 0.9976\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.8% of target value\", \"radius_stats\": \"Min: 0.068451, Max: 0.134149, Avg: 0.101099\"}", "artifact_dir": null, "embedding": null}