{"id": "c781e363-7e3a-4e88-b349-edbe68603d56", "code": "# EVOLVE-BLOCK-START\n\"\"\"Physics-based iterative optimization engine for N=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers,\n    preserving the initially requested ratios sizes bounding correctly safely.\n    It guarantees absolute geometric validity bounding entirely securely properly.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n, dtype=np.float64) * 0.1\n    else:\n        r = input_radii.astype(np.float64, copy=True)\n\n    r = np.clip(r, 0.0, np.inf)\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n\n    # Extract single continuous pairwise map ensuring purely correct boundary bounds efficiently\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=-1))\n    np.fill_diagonal(dist, np.inf)\n\n    # Resolve exhaustively to handle tight interlocking matrices structurally efficiently limits identically identically flawlessly\n    max_passes = n * n * 5\n    for _ in range(max_passes):\n        sum_r = r[:, np.newaxis] + r[np.newaxis, :]\n        overlaps = sum_r - dist\n        max_idx = np.argmax(overlaps)\n        \n        # Perfect exact sub-threshold mapping bounds perfectly structurally identically\n        if overlaps.flat[max_idx] <= 1e-10:\n            break\n            \n        i, j = divmod(max_idx, n)\n        s_r = r[i] + r[j]\n        d = dist[i, j]\n        if s_r > 1e-12:\n            scale = (d - 1e-11) / s_r\n            if scale < 1.0:\n                r[i] *= scale\n                r[j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Main numerical layout configuration structure executing massively vectorized parallel simulated simulated bounds perfectly dynamically boundaries structures efficiently optimally dynamically boundaries tightly correctly natively bounds seamlessly identically identically completely globally flawlessly gracefully securely scaling properly identically perfectly exactly boundaries mathematically efficiently stringently rigorously mathematically resolving boundaries safely efficiently perfectly seamlessly gracefully.\n    \"\"\"\n    n_circles = 26\n    n_batch = 60\n    n_iters = 14000\n    \n    rng = np.random.RandomState(42)\n    rng_thermal = np.random.RandomState(100)\n    \n    params = np.zeros((n_batch, n_circles, 3), dtype=np.float32)\n    \n    for b in range(n_batch):\n        mode = b % 10\n        if mode == 0:\n            params[b, :, :2] = rng.uniform(0.1, 0.9, (n_circles, 2))\n            params[b, :, 2] = 0.05\n        elif mode == 1:\n            params[b, :, :2] = rng.uniform(0.1, 0.9, (n_circles, 2))\n            params[b, :, 2] = rng.uniform(0.02, 0.09, n_circles)\n        elif mode == 2:\n            for i in range(5):\n                for j in range(5):\n                    params[b, i*5+j, :2] = [(i + 0.5) / 5.0, (j + 0.5) / 5.0]\n            params[b, 25, :2] = [0.5, 0.5]\n            params[b, :, :2] += rng.uniform(-0.03, 0.03, (n_circles, 2))\n            params[b, :, 2] = 0.08\n        elif mode == 3:\n            for i in range(6):\n                for j in range(4):\n                    params[b, i*4+j, :2] = [(i + 0.5) / 6.0, (j + 0.5) / 4.0]\n            params[b, 24, :2] = [0.5, 0.5]\n            params[b, 25, :2] = [0.4, 0.6]\n            params[b, :, :2] += rng.uniform(-0.02, 0.02, (n_circles, 2))\n            params[b, :, 2] = 0.07\n        elif mode == 4:\n            k = 0\n            for i in range(4):\n                params[b, k, :2] = [0.1 + i*0.8/4, 0.1]\n                k += 1\n                params[b, k, :2] = [0.9, 0.1 + i*0.8/4]\n                k += 1\n                params[b, k, :2] = [0.9 - i*0.8/4, 0.9]\n                k += 1\n                params[b, k, :2] = [0.1, 0.9 - i*0.8/4]\n                k += 1\n            params[b, k:, :2] = rng.uniform(0.2, 0.8, (n_circles - k, 2))\n            params[b, :, 2] = 0.05\n        elif mode == 5:\n            params[b, 0, :2] = [0.5, 0.5]\n            params[b, 0, 2] = 0.35\n            params[b, 1:, :2] = rng.uniform(0.1, 0.9, (n_circles - 1, 2))\n            params[b, 1:, 2] = rng.uniform(0.01, 0.06, n_circles - 1)\n        elif mode == 6:\n            params[b, 0, :2] = [0.5, 0.5]\n            for i_p in range(7):\n                params[b, i_p+1, :2] = [0.5 + 0.25*np.cos(i_p*2*np.pi/7), 0.5 + 0.25*np.sin(i_p*2*np.pi/7)]\n            for i_p in range(18):\n                params[b, i_p+8, :2] = [0.5 + 0.45*np.cos(i_p*2*np.pi/18), 0.5 + 0.45*np.sin(i_p*2*np.pi/18)]\n            params[b, :, :2] += rng.uniform(-0.01, 0.01, (n_circles, 2))\n            params[b, :, 2] = 0.06\n        elif mode == 7:\n            for k in range(4): \n                params[b, k, :2] = [0.5+0.15*np.cos(k*np.pi/2), 0.5+0.15*np.sin(k*np.pi/2)]\n            for k in range(10): \n                params[b, 4+k, :2] = [0.5+0.3*np.cos(k*2*np.pi/10), 0.5+0.3*np.sin(k*2*np.pi/10)]\n            for k in range(12): \n                params[b, 14+k, :2] = [0.5+0.45*np.cos(k*2*np.pi/12), 0.5+0.45*np.sin(k*2*np.pi/12)]\n            params[b, :, 2] = 0.06\n            params[b, :, :2] += rng.normal(0, 0.015, (n_circles, 2))\n        elif mode == 8:\n            params[b, 0:4, :2] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            params[b, 0:4, 2] = 0.18\n            for k in range(22):\n                theta = k * 2 * np.pi / 22\n                params[b, 4+k, :2] = [0.5 + 0.3*np.cos(theta), 0.5 + 0.3*np.sin(theta)]\n            params[b, 4:, 2] = 0.05\n        elif mode == 9:\n            params[b, 0:2, :2] = [[0.3, 0.5], [0.7, 0.5]]\n            params[b, 0:2, 2] = 0.25\n            params[b, 2:, :2] = rng.uniform(0.05, 0.95, (24, 2))\n            params[b, 2:, 2] = 0.04\n\n    params[:, :, :2] = np.clip(params[:, :, :2], 0.05, 0.95)\n\n    eye26 = np.eye(n_circles, dtype=np.float32)\n    not_eye26 = (1.0 - eye26).astype(np.float32)\n\n    alpha = 0.04\n    alpha_end = 0.0001\n    alpha_mult = (alpha_end / alpha) ** (1.0 / n_iters)\n    \n    lambda_val = 5.0\n    lambda_end = 5e7\n    lambda_mult = (lambda_end / lambda_val) ** (1.0 / n_iters)\n\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    grad = np.zeros_like(params)\n    beta1 = 0.85\n    beta2 = 0.98\n    m_scale = 1.0\n    v_scale = 1.0\n    epsilon = 1e-8\n\n    for step in range(1, n_iters + 1):\n        pos_curr = params[:, :, :2]\n        rad_curr = params[:, :, 2]\n        \n        diff = pos_curr[:, :, np.newaxis, :] - pos_curr[:, np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        \n        dist += eye26[np.newaxis, :, :]\n        \n        rad_sum = rad_curr[:, :, np.newaxis] + rad_curr[:, np.newaxis, :]\n        violations = np.maximum(rad_sum - dist, 0.0) * not_eye26[np.newaxis, :, :]\n        \n        v_left = np.maximum(rad_curr - pos_curr[:, :, 0], 0.0)\n        v_right = np.maximum(rad_curr + pos_curr[:, :, 0] - 1.0, 0.0)\n        v_bottom = np.maximum(rad_curr - pos_curr[:, :, 1], 0.0)\n        v_top = np.maximum(rad_curr + pos_curr[:, :, 1] - 1.0, 0.0)\n        \n        grad_r = 2.0 * lambda_val * (np.sum(violations, axis=2) + v_left + v_right + v_bottom + v_top) - 1.0\n        \n        factor = 2.0 * lambda_val * violations / np.maximum(dist, 1e-9)\n        grad_p_overlap = -np.sum(factor[:, :, :, np.newaxis] * diff, axis=2)\n        \n        grad_p = grad[:, :, :2]\n        grad_p[:, :, 0] = 2.0 * lambda_val * (-v_left + v_right)\n        grad_p[:, :, 1] = 2.0 * lambda_val * (-v_bottom + v_top)\n        grad_p += grad_p_overlap\n        \n        grad[:, :, 2] = grad_r\n        \n        m = beta1 * m + (1.0 - beta1) * grad\n        v = beta2 * v + (1.0 - beta2) * (grad ** 2)\n        \n        m_scale *= beta1\n        v_scale *= beta2\n        \n        m_hat = m / (1.0 - m_scale)\n        v_hat = v / (1.0 - v_scale)\n        \n        params -= alpha * m_hat / (np.sqrt(v_hat) + epsilon)\n        \n        if step < 9000:\n            vibrate_scale = 0.0005 * (1.0 - step / 9000.0) ** 2\n            params[:, :, :2] += rng_thermal.normal(0, vibrate_scale, pos_curr.shape).astype(np.float32)\n\n        params[:, :, :2] = np.clip(params[:, :, :2], 0.0001, 0.9999)\n        params[:, :, 2] = np.clip(params[:, :, 2], 0.0001, 0.5)\n\n        alpha *= alpha_mult\n        lambda_val *= lambda_mult\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    for b in range(n_batch):\n        p_res = params[b, :, :2].astype(np.float64)\n        r_res = params[b, :, 2].astype(np.float64)\n        \n        r_valid = compute_max_radii(p_res, r_res)\n        s = np.sum(r_valid)\n        \n        if s > best_sum:\n            best_sum = s\n            best_p = p_res.copy()\n            best_r = r_valid.copy()\n            \n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")", "changes_description": null, "language": "python", "parent_id": "47dedff7-7333-4a22-9893-2f437b178f3b", "generation": 2, "timestamp": 1772009309.230834, "iteration_found": 24, "metrics": {"validity": 1.0, "sum_radii": 2.61201573908329, "target_ratio": 0.9912773203352145, "combined_score": 0.9912773203352145, "radius_variance": 0.0045449974849733395, "spatial_spread": 0.1886400958204808, "eval_time": 39.65143847465515}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 1.0753833163396522, "target_ratio": 0.40811511056533295, "combined_score": 0.40811511056533295, "radius_variance": 0.01725556155116175, "spatial_spread": 0.22408629214457715}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.4081\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.4081\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n5.72s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum: 1.075383, Ratio: 0.4081\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 1.0754, target_ratio: 0.4081, combined_score: 0.4081, radius_variance: 0.0173, spatial_spread: 0.2241\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6070, target_ratio: 0.9894, combined_score: 0.9894, radius_variance: 0.0086, spatial_spread: 0.1955, eval_time: 3.1157\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6165, target_ratio: 0.9930, combined_score: 0.9930, radius_variance: 0.0053, spatial_spread: 0.2004, eval_time: 3.6265\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9930)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based optimization circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using an iterative Adam-based physics and penalty optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_batch = 8\n    n_iters = 8000\n    \n    # Initialize batch parameters to explore different starting layouts\n    np.random.seed(42)  # Controlled stochasticity for symmetry breaking\n    params = np.zeros((n_batch, n_circles, 3))\n    \n    for b in range(n_batch):\n        # Center circle (large)\n        params[b, 0, :2] = [0.5, 0.5] + (np.random.rand(2) - 0.5) * 0.05\n        params[b, 0, 2] = 0.25 + np.random.rand() * 0.05\n        \n        # 4 corners\n        angles = np.pi / 4 + np.pi / 2 * np.arange(4) + (np.random.rand(4) - 0.5) * 0.2\n        params[b, 1:5, 0] = 0.5 + 0.35 * np.cos(angles)\n        params[b, 1:5, 1] = 0.5 + 0.35 * np.sin(angles)\n        params[b, 1:5, 2] = 0.1\n        \n        # 4 mid-edge circles\n        angles = np.pi / 2 * np.arange(4) + (np.random.rand(4) - 0.5) * 0.2\n        params[b, 5:9, 0] = 0.5 + 0.45 * np.cos(angles)\n        params[b, 5:9, 1] = 0.5 + 0.45 * np.sin(angles)\n        params[b, 5:9, 2] = 0.08\n        \n        # Remaining scattered interstitial small circles\n        params[b, 9:, :2] = np.random.rand(17, 2)\n        params[b, 9:, 2] = 0.02 + np.random.rand(17) * 0.02\n        \n        # Clip initial positions inside square limits safely\n        params[b, :, :2] = np.clip(params[b, :, :2], 0.05, 0.95)\n    \n    # Adam Optimization parameters setup\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    beta1 = 0.8\n    beta2 = 0.95\n    epsilon = 1e-8\n    \n    # Annealing schedule for learning rate and geometric penalty weight\n    alpha = 0.025\n    alpha_end = 0.0001\n    alpha_mult = (alpha_end / alpha) ** (1.0 / n_iters)\n    \n    lambda_val = 10.0\n    lambda_end = 1e6\n    lambda_mult = (lambda_end / lambda_val) ** (1.0 / n_iters)\n    \n    eye26 = np.eye(n_circles)\n    not_eye26 = 1.0 - eye26\n    \n    # Physics and simulated annealing iterative engine loops over variables\n    for step in range(1, n_iters + 1):\n        pos_curr = params[:, :, :2]\n        rad_curr = params[:, :, 2]\n        \n        # Determine distances pairwise between all circular coordinates\n        diff = pos_curr[:, :, np.newaxis, :] - pos_curr[:, np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        \n        # Robust division handling: add minor trick mapping to diagonal\n        dist += eye26[np.newaxis, :, :]\n        dist = np.maximum(dist, 1e-6)\n        \n        rad_sum = rad_curr[:, :, np.newaxis] + rad_curr[:, np.newaxis, :]\n        \n        # Penalty magnitude violations calculation off diagonal\n        violations = np.maximum(rad_sum - dist, 0.0) * not_eye26[np.newaxis, :, :]\n        \n        # Confined mapping for strict edge penalty validation\n        v_left = np.maximum(rad_curr - pos_curr[:, :, 0], 0.0)\n        v_right = np.maximum(rad_curr + pos_curr[:, :, 0] - 1.0, 0.0)\n        v_bottom = np.maximum(rad_curr - pos_curr[:, :, 1], 0.0)\n        v_top = np.maximum(rad_curr + pos_curr[:, :, 1] - 1.0, 0.0)\n        \n        # Assemble composite gradient updates per property\n        # Radius expansion target mapped alongside structural penalties\n        grad_r = 2 * lambda_val * (np.sum(violations, axis=2) + v_left + v_right + v_bottom + v_top) - 1.0\n        \n        # Gradient directional constraints resolving exact boundary\n        factor = 2 * lambda_val * violations / dist\n        grad_p_overlap = -np.sum(factor[:, :, :, np.newaxis] * diff, axis=2)\n        \n        grad_p = np.zeros_like(pos_curr)\n        grad_p[:, :, 0] = 2 * lambda_val * (-v_left + v_right)\n        grad_p[:, :, 1] = 2 * lambda_val * (-v_bottom + v_top)\n        grad_p += grad_p_overlap\n        \n        grad = np.concatenate([grad_p, grad_r[:, :, np.newaxis]], axis=-1)\n        \n        # Adam descent algorithmic movement mapped into spatial matrices\n        m = beta1 * m + (1 - beta1) * grad\n        v = beta2 * v + (1 - beta2) * (grad ** 2)\n        \n        m_hat = m / (1 - beta1 ** step)\n        v_hat = v / (1 - beta2 ** step)\n        \n        params -= alpha * m_hat / (np.sqrt(v_hat) + epsilon)\n        params[:, :, 2] = np.maximum(params[:, :, 2], 1e-4)\n        \n        alpha *= alpha_mult\n        lambda_val *= lambda_mult\n        \n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Refinement iteration validating clean geometric overlap resolution\n    for b in range(n_batch):\n        b_centers = params[b, :, :2].copy()\n        b_radii = params[b, :, 2].copy()\n        \n        # Safety subpixel constraints forcing rigid mathematical box bounds\n        for j in range(n_circles):\n            cx, cy = b_centers[j]\n            b_radii[j] = min(b_radii[j], cx, 1 - cx, cy, 1 - cy)\n            b_radii[j] = max(0.0, b_radii[j])\n            \n        for _ in range(200):\n            max_v = 0\n            worst_pair = None\n            for i1 in range(n_circles):\n                for i2 in range(i1 + 1, n_circles):\n                    d = np.linalg.norm(b_centers[i1] - b_centers[i2])\n                    ov = b_radii[i1] + b_radii[i2] - d\n                    if ov > max_v:\n                        max_v = ov\n                        worst_pair = (i1, i2)\n            \n            # Exact metric convergence ensures stability prior breaking loops\n            if max_v <= 1e-10:\n                break\n                \n            i1, i2 = worst_pair\n            d = np.linalg.norm(b_centers[i1] - b_centers[i2])\n            if b_radii[i1] + b_radii[i2] > 1e-12:\n                # Retract gracefully away from boundary geometry error\n                scale = (d - 1e-11) / (b_radii[i1] + b_radii[i2])\n                b_radii[i1] *= scale\n                b_radii[i2] *= scale\n        \n        s_radii = np.sum(b_radii)\n        if s_radii > best_sum:\n            best_sum = s_radii\n            best_centers = b_centers\n            best_radii = b_radii\n            \n    return best_centers, best_radii, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Left intact to provide strictly standard API calls compatibilities.\n    If evaluated via sandbox hook this mathematically deflates sizes.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = (dist - 1e-11) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6165), Performs well on target_ratio (0.9930), Performs well on combined_score (0.9930), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.2004), Performs well on eval_time (3.6265)\n\n### Program 2 (Score: 0.9894)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative and SLSQP-based physics simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\ntry:\n    from scipy.optimize import minimize, Bounds, NonlinearConstraint\n    SCIPY_AVAILABLE = True\nexcept ImportError:\n    SCIPY_AVAILABLE = False\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef generate_diverse_seeds(n, num_seeds):\n    \"\"\"Generates highly spread, pseudo-relaxed layouts suitable for continuous optimizers.\"\"\"\n    seeds = []\n    \n    # 1. Start with structured and randomly jittered grids\n    grid_count = min(num_seeds // 2 + 1, num_seeds)\n    for rst in range(grid_count):\n        rng = np.random.RandomState(100 + rst)\n        p = []\n        for i in range(5):\n            for j in range(5):\n                p.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n        p.append([0.5, 0.5])  # Additional core entity to break total equality space mapping\n        \n        p = np.array(p)\n        p += rng.normal(0, 0.015, p.shape)\n        \n        # Settle the random initialization via simple geometric repulsion pushes\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 0.5)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.2\n            p = np.clip(p, 0.03, 0.97)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    # 2. Entirely random layouts leveraging uniform initial probability across borders\n    for rst in range(num_seeds - grid_count):\n        rng = np.random.RandomState(200 + rst)\n        p = rng.uniform(0.05, 0.95, (n, 2))\n        \n        # Emphasized separation\n        for _ in range(80):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 1.0)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.15\n            p = np.clip(p, 0.02, 0.98)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    return seeds\n\n\ndef build_optimization_scipy(n, restarts=32):\n    \"\"\"\n    Robust geometric optimization using mathematically absolute objective structures bounded cleanly inside SciPy's Nonlinear capabilities.\n    Enforces equality conditions through exact, directly injected Jacobians dramatically enhancing speed without diverging numerically.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p_init, r_init in seeds:\n        # X mapping: px(0 -> n), py(n -> 2n), rad(2n -> 3n)\n        def objective(X):\n            return -np.sum(X[2*n: 3*n])\n            \n        def objective_jac(X):\n            g = np.zeros(3*n)\n            g[2*n: 3*n] = -1.0\n            return g\n            \n        def cons_f(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            c1 = px - rad\n            c2 = 1.0 - px - rad\n            c3 = py - rad\n            c4 = 1.0 - py - rad\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            \n            c5 = dx**2 + dy**2 - r_sum**2\n            return np.concatenate([c1, c2, c3, c4, c5])\n\n        def cons_j(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            M = 4*n + len(i_idx)\n            J = np.zeros((M, 3*n))\n            idx = np.arange(n)\n            \n            # Constraint derivations explicitly placed against matching structural index references ensuring instant, safe derivatives bounds locking\n            J[idx, idx] = 1.0\n            J[idx, 2*n + idx] = -1.0\n            \n            J[n + idx, idx] = -1.0\n            J[n + idx, 2*n + idx] = -1.0\n            \n            J[2*n + idx, n + idx] = 1.0\n            J[2*n + idx, 2*n + idx] = -1.0\n            \n            J[3*n + idx, n + idx] = -1.0\n            J[3*n + idx, 2*n + idx] = -1.0\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            c5_idx = np.arange(4*n, M)\n            \n            J[c5_idx, i_idx] = 2 * dx\n            J[c5_idx, j_idx] = -2 * dx\n            J[c5_idx, n + i_idx] = 2 * dy\n            J[c5_idx, n + j_idx] = -2 * dy\n            J[c5_idx, 2*n + i_idx] = -2 * r_sum\n            J[c5_idx, 2*n + j_idx] = -2 * r_sum\n            \n            return J\n\n        lower_bound = np.zeros(3*n)\n        upper_bound = np.concatenate([np.ones(2*n), np.ones(n)*0.5])\n        \n        nlc = NonlinearConstraint(cons_f, 0.0, np.inf, jac=cons_j)\n        bounds = Bounds(lower_bound, upper_bound)\n        \n        x0 = np.concatenate([p_init[:, 0], p_init[:, 1], r_init])\n        x0 = np.clip(x0, lower_bound + 1e-5, upper_bound - 1e-5)\n        \n        try:\n            res = minimize(\n                objective, x0,\n                jac=objective_jac,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[nlc],\n                options={'maxiter': 800, 'ftol': 1e-5, 'disp': False}\n            )\n            \n            p_res = np.column_stack((res.x[0: n], res.x[n: 2*n]))\n            r_res = res.x[2*n: 3*n]\n            \n            r_valid = compute_max_radii(p_res, r_res)\n            curr_sum = np.sum(r_valid)\n            \n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_p = p_res.copy()\n                best_r = r_valid.copy()\n        except Exception:\n            continue\n            \n    return best_p, best_r, best_sum\n\n\ndef build_optimization_numpy(n, restarts=32):\n    \"\"\"\n    Fall-back mathematically refined exact Adam implementation mimicking simulated annealing dynamics, gracefully maximizing packing sum without explicit analytical constraints bounds relying uniquely internally across continuous spaces distributions.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p, r in seeds:\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        lr_p, lr_r = 0.005, 0.005\n        iters = 1500\n        \n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n            \n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1)) + 1e-12\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n            \n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n            \n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n            \n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, None] * (diff / dist[:, None])\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n                \n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n            \n            b1, b2 = 0.9, 0.999\n            m_p = b1 * m_p + (1.0 - b1) * grad_p\n            v_p = b2 * v_p + (1.0 - b2) * (grad_p ** 2)\n            p -= lr_p * (m_p / (1.0 - b1**t)) / (np.sqrt(v_p / (1.0 - b2**t)) + 1e-8)\n            \n            m_r = b1 * m_r + (1.0 - b1) * grad_r\n            v_r = b2 * v_r + (1.0 - b2) * (grad_r ** 2)\n            r -= lr_r * (m_r / (1.0 - b1**t)) / (np.sqrt(v_r / (1.0 - b2**t)) + 1e-8)\n            \n            p = np.clip(p, 0.001, 0.999)\n            r = np.clip(r, 0.001, 0.5)\n            \n        r_valid = compute_max_radii(p, r)\n        curr_sum = np.sum(r_valid)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n            \n    return best_p, best_r, best_sum\n\n\ndef construct_packing():\n    \"\"\"Run mathematically exact optimization algorithms smoothly switching implementations dynamically maximizing global packing bounds space utilization structures securely universally cross platforms capabilities limits.\"\"\"\n    n = 26\n    restarts = 32\n    if SCIPY_AVAILABLE:\n        p, r, s = build_optimization_scipy(n, restarts)\n        # Verify valid configuration was gracefully produced, otherwise bypass to guaranteed pure numerical optimizer algorithm sequences identically\n        if s > 0:\n            return p, r, s\n    \n    return build_optimization_numpy(n, restarts)\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6070), Performs well on target_ratio (0.9894), Performs well on combined_score (0.9894), Performs well on radius_variance (0.0086), Performs well on spatial_spread (0.1955), Performs well on eval_time (3.1157)\n\n### Program 3 (Score: 0.4081)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative physics-based simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    # We loop exhaustively, eliminating the maximum overlap proportionally until none remain.\n    # Max n*n passes provides overwhelming headroom to ensure geometric convergence.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Perform multiple gradient descent optimizations with randomized symmetries\n    and heuristically spaced architectures to discover tightly bound packings\n    combining varied sizes maximizing their combined cumulative radii.\n    \"\"\"\n    n = 26\n    restarts = 24\n    iters = 2000\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n\n    # Pre-allocate indices pair combinations to heavily optimize array iteration\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    for rst in range(restarts):\n        rng = np.random.RandomState(42 + rst)\n\n        # Distribute varying sized centers matching multiple heuristic constraints\n        p = rng.uniform(0.1, 0.9, (n, 2))\n        r = rng.uniform(0.02, 0.12, n)\n\n        strat = rst % 4\n        if strat == 0:\n            # Concentric shell rings\n            for k in range(8):\n                angle = 2 * np.pi * k / 8\n                p[k] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for k in range(17):\n                angle = 2 * np.pi * k / 17\n                p[k + 8] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            p[25] = [0.5, 0.5]\n            r[:] = 0.08\n            r[25] = 0.15\n        elif strat == 1:\n            # Loose homogeneous 5x5 grids layout plus wandering floater\n            for k in range(25):\n                p[k] = [0.1 + 0.2 * (k % 5), 0.1 + 0.2 * (k // 5)]\n            r[:] = 0.08\n            p[25] = [0.5, 0.5]\n        elif strat == 2:\n            # Massive corner boulders framing small interstitially dense inner dust\n            p[0:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[0:4] = 0.25\n            r[4:] = 0.05\n        elif strat == 3:\n            # Monolithic mega center ringed symmetrically\n            p[0] = [0.5, 0.5]\n            r[0] = 0.35\n            r[1:] = 0.05\n\n        # Small jiggling permanently breaks mathematical symmetrical traps\n        p += rng.normal(0, 0.01, (n, 2))\n        p = np.clip(p, 0.02, 0.98)\n\n        # Momentum memories\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n\n        lr_p = 0.01\n        lr_r = 0.01\n\n        # Smooth optimization settling transitioning penalty stringency seamlessly (simulated annealing like)\n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n\n            # Distances mapped across upper triangle permutations\n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1))\n            dist = np.maximum(dist, 1e-8)\n\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n\n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n\n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n\n            # Spheroid collisions repulsion feedback\n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, np.newaxis] * (diff / dist[:, np.newaxis])\n\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                \n                # Push vectors inversely applying repulsing gradients ensuring centers repel apart\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n\n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n\n            # Adam stepping variables recalculating\n            beta1, beta2 = 0.9, 0.999\n            \n            m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n            v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n            p = p - lr_p * (m_p / (1.0 - beta1 ** t)) / (np.sqrt(v_p / (1.0 - beta2 ** t)) + 1e-8)\n\n            m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n            v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n            r = r - lr_r * (m_r / (1.0 - beta1 ** t)) / (np.sqrt(v_r / (1.0 - beta2 ** t)) + 1e-8)\n\n            # Coordinate confinement strictly\n            p = np.clip(p, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Mathematical strict exact validation wrapper ensuring precise operational geometric boundary bounds are zero.\n        r_valid = compute_max_radii(p, r)\n\n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n\n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.0754), Performs well on target_ratio (0.4081), Performs well on combined_score (0.4081), Performs well on radius_variance (0.0173), Performs well on spatial_spread (0.2241)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9894, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative and SLSQP-based physics simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\ntry:\n    from scipy.optimize import minimize, Bounds, NonlinearConstraint\n    SCIPY_AVAILABLE = True\nexcept ImportError:\n    SCIPY_AVAILABLE = False\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef generate_diverse_seeds(n, num_seeds):\n    \"\"\"Generates highly spread, pseudo-relaxed layouts suitable for continuous optimizers.\"\"\"\n    seeds = []\n    \n    # 1. Start with structured and randomly jittered grids\n    grid_count = min(num_seeds // 2 + 1, num_seeds)\n    for rst in range(grid_count):\n        rng = np.random.RandomState(100 + rst)\n        p = []\n        for i in range(5):\n            for j in range(5):\n                p.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n        p.append([0.5, 0.5])  # Additional core entity to break total equality space mapping\n        \n        p = np.array(p)\n        p += rng.normal(0, 0.015, p.shape)\n        \n        # Settle the random initialization via simple geometric repulsion pushes\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 0.5)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.2\n            p = np.clip(p, 0.03, 0.97)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    # 2. Entirely random layouts leveraging uniform initial probability across borders\n    for rst in range(num_seeds - grid_count):\n        rng = np.random.RandomState(200 + rst)\n        p = rng.uniform(0.05, 0.95, (n, 2))\n        \n        # Emphasized separation\n        for _ in range(80):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 1.0)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.15\n            p = np.clip(p, 0.02, 0.98)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    return seeds\n\n\ndef build_optimization_scipy(n, restarts=32):\n    \"\"\"\n    Robust geometric optimization using mathematically absolute objective structures bounded cleanly inside SciPy's Nonlinear capabilities.\n    Enforces equality conditions through exact, directly injected Jacobians dramatically enhancing speed without diverging numerically.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p_init, r_init in seeds:\n        # X mapping: px(0 -> n), py(n -> 2n), rad(2n -> 3n)\n        def objective(X):\n            return -np.sum(X[2*n: 3*n])\n            \n        def objective_jac(X):\n            g = np.zeros(3*n)\n            g[2*n: 3*n] = -1.0\n            return g\n            \n        def cons_f(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            c1 = px - rad\n            c2 = 1.0 - px - rad\n            c3 = py - rad\n            c4 = 1.0 - py - rad\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            \n            c5 = dx**2 + dy**2 - r_sum**2\n            return np.concatenate([c1, c2, c3, c4, c5])\n\n        def cons_j(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            M = 4*n + len(i_idx)\n            J = np.zeros((M, 3*n))\n            idx = np.arange(n)\n            \n            # Constraint derivations explicitly placed against matching structural index references ensuring instant, safe derivatives bounds locking\n            J[idx, idx] = 1.0\n            J[idx, 2*n + idx] = -1.0\n            \n            J[n + idx, idx] = -1.0\n            J[n + idx, 2*n + idx] = -1.0\n            \n            J[2*n + idx, n + idx] = 1.0\n            J[2*n + idx, 2*n + idx] = -1.0\n            \n            J[3*n + idx, n + idx] = -1.0\n            J[3*n + idx, 2*n + idx] = -1.0\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            c5_idx = np.arange(4*n, M)\n            \n            J[c5_idx, i_idx] = 2 * dx\n            J[c5_idx, j_idx] = -2 * dx\n            J[c5_idx, n + i_idx] = 2 * dy\n            J[c5_idx, n + j_idx] = -2 * dy\n            J[c5_idx, 2*n + i_idx] = -2 * r_sum\n            J[c5_idx, 2*n + j_idx] = -2 * r_sum\n            \n            return J\n\n        lower_bound = np.zeros(3*n)\n        upper_bound = np.concatenate([np.ones(2*n), np.ones(n)*0.5])\n        \n        nlc = NonlinearConstraint(cons_f, 0.0, np.inf, jac=cons_j)\n        bounds = Bounds(lower_bound, upper_bound)\n        \n        x0 = np.concatenate([p_init[:, 0], p_init[:, 1], r_init])\n        x0 = np.clip(x0, lower_bound + 1e-5, upper_bound - 1e-5)\n        \n        try:\n            res = minimize(\n                objective, x0,\n                jac=objective_jac,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[nlc],\n                options={'maxiter': 800, 'ftol': 1e-5, 'disp': False}\n            )\n            \n            p_res = np.column_stack((res.x[0: n], res.x[n: 2*n]))\n            r_res = res.x[2*n: 3*n]\n            \n            r_valid = compute_max_radii(p_res, r_res)\n            curr_sum = np.sum(r_valid)\n            \n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_p = p_res.copy()\n                best_r = r_valid.copy()\n        except Exception:\n            continue\n            \n    return best_p, best_r, best_sum\n\n\ndef build_optimization_numpy(n, restarts=32):\n    \"\"\"\n    Fall-back mathematically refined exact Adam implementation mimicking simulated annealing dynamics, gracefully maximizing packing sum without explicit analytical constraints bounds relying uniquely internally across continuous spaces distributions.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p, r in seeds:\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        lr_p, lr_r = 0.005, 0.005\n        iters = 1500\n        \n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n            \n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1)) + 1e-12\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n            \n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n            \n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n            \n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, None] * (diff / dist[:, None])\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n                \n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n            \n            b1, b2 = 0.9, 0.999\n            m_p = b1 * m_p + (1.0 - b1) * grad_p\n            v_p = b2 * v_p + (1.0 - b2) * (grad_p ** 2)\n            p -= lr_p * (m_p / (1.0 - b1**t)) / (np.sqrt(v_p / (1.0 - b2**t)) + 1e-8)\n            \n            m_r = b1 * m_r + (1.0 - b1) * grad_r\n            v_r = b2 * v_r + (1.0 - b2) * (grad_r ** 2)\n            r -= lr_r * (m_r / (1.0 - b1**t)) / (np.sqrt(v_r / (1.0 - b2**t)) + 1e-8)\n            \n            p = np.clip(p, 0.001, 0.999)\n            r = np.clip(r, 0.001, 0.5)\n            \n        r_valid = compute_max_radii(p, r)\n        curr_sum = np.sum(r_valid)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n            \n    return best_p, best_r, best_sum\n\n\ndef construct_packing():\n    \"\"\"Run mathematically exact optimization algorithms smoothly switching implementations dynamically maximizing global packing bounds space utilization structures securely universally cross platforms capabilities limits.\"\"\"\n    n = 26\n    restarts = 32\n    if SCIPY_AVAILABLE:\n        p, r, s = build_optimization_scipy(n, restarts)\n        # Verify valid configuration was gracefully produced, otherwise bypass to guaranteed pure numerical optimizer algorithm sequences identically\n        if s > 0:\n            return p, r, s\n    \n    return build_optimization_numpy(n, restarts)\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9930, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based optimization circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square\n    using an iterative Adam-based physics and penalty optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_circles = 26\n    n_batch = 8\n    n_iters = 8000\n    \n    # Initialize batch parameters to explore different starting layouts\n    np.random.seed(42)  # Controlled stochasticity for symmetry breaking\n    params = np.zeros((n_batch, n_circles, 3))\n    \n    for b in range(n_batch):\n        # Center circle (large)\n        params[b, 0, :2] = [0.5, 0.5] + (np.random.rand(2) - 0.5) * 0.05\n        params[b, 0, 2] = 0.25 + np.random.rand() * 0.05\n        \n        # 4 corners\n        angles = np.pi / 4 + np.pi / 2 * np.arange(4) + (np.random.rand(4) - 0.5) * 0.2\n        params[b, 1:5, 0] = 0.5 + 0.35 * np.cos(angles)\n        params[b, 1:5, 1] = 0.5 + 0.35 * np.sin(angles)\n        params[b, 1:5, 2] = 0.1\n        \n        # 4 mid-edge circles\n        angles = np.pi / 2 * np.arange(4) + (np.random.rand(4) - 0.5) * 0.2\n        params[b, 5:9, 0] = 0.5 + 0.45 * np.cos(angles)\n        params[b, 5:9, 1] = 0.5 + 0.45 * np.sin(angles)\n        params[b, 5:9, 2] = 0.08\n        \n        # Remaining scattered interstitial small circles\n        params[b, 9:, :2] = np.random.rand(17, 2)\n        params[b, 9:, 2] = 0.02 + np.random.rand(17) * 0.02\n        \n        # Clip initial positions inside square limits safely\n        params[b, :, :2] = np.clip(params[b, :, :2], 0.05, 0.95)\n    \n    # Adam Optimization parameters setup\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    beta1 = 0.8\n    beta2 = 0.95\n    epsilon = 1e-8\n    \n    # Annealing schedule for learning rate and geometric penalty weight\n    alpha = 0.025\n    alpha_end = 0.0001\n    alpha_mult = (alpha_end / alpha) ** (1.0 / n_iters)\n    \n    lambda_val = 10.0\n    lambda_end = 1e6\n    lambda_mult = (lambda_end / lambda_val) ** (1.0 / n_iters)\n    \n    eye26 = np.eye(n_circles)\n    not_eye26 = 1.0 - eye26\n    \n    # Physics and simulated annealing iterative engine loops over variables\n    for step in range(1, n_iters + 1):\n        pos_curr = params[:, :, :2]\n        rad_curr = params[:, :, 2]\n        \n        # Determine distances pairwise between all circular coordinates\n        diff = pos_curr[:, :, np.newaxis, :] - pos_curr[:, np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        \n        # Robust division handling: add minor trick mapping to diagonal\n        dist += eye26[np.newaxis, :, :]\n        dist = np.maximum(dist, 1e-6)\n        \n        rad_sum = rad_curr[:, :, np.newaxis] + rad_curr[:, np.newaxis, :]\n        \n        # Penalty magnitude violations calculation off diagonal\n        violations = np.maximum(rad_sum - dist, 0.0) * not_eye26[np.newaxis, :, :]\n        \n        # Confined mapping for strict edge penalty validation\n        v_left = np.maximum(rad_curr - pos_curr[:, :, 0], 0.0)\n        v_right = np.maximum(rad_curr + pos_curr[:, :, 0] - 1.0, 0.0)\n        v_bottom = np.maximum(rad_curr - pos_curr[:, :, 1], 0.0)\n        v_top = np.maximum(rad_curr + pos_curr[:, :, 1] - 1.0, 0.0)\n        \n        # Assemble composite gradient updates per property\n        # Radius expansion target mapped alongside structural penalties\n        grad_r = 2 * lambda_val * (np.sum(violations, axis=2) + v_left + v_right + v_bottom + v_top) - 1.0\n        \n        # Gradient directional constraints resolving exact boundary\n        factor = 2 * lambda_val * violations / dist\n        grad_p_overlap = -np.sum(factor[:, :, :, np.newaxis] * diff, axis=2)\n        \n        grad_p = np.zeros_like(pos_curr)\n        grad_p[:, :, 0] = 2 * lambda_val * (-v_left + v_right)\n        grad_p[:, :, 1] = 2 * lambda_val * (-v_bottom + v_top)\n        grad_p += grad_p_overlap\n        \n        grad = np.concatenate([grad_p, grad_r[:, :, np.newaxis]], axis=-1)\n        \n        # Adam descent algorithmic movement mapped into spatial matrices\n        m = beta1 * m + (1 - beta1) * grad\n        v = beta2 * v + (1 - beta2) * (grad ** 2)\n        \n        m_hat = m / (1 - beta1 ** step)\n        v_hat = v / (1 - beta2 ** step)\n        \n        params -= alpha * m_hat / (np.sqrt(v_hat) + epsilon)\n        params[:, :, 2] = np.maximum(params[:, :, 2], 1e-4)\n        \n        alpha *= alpha_mult\n        lambda_val *= lambda_mult\n        \n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Refinement iteration validating clean geometric overlap resolution\n    for b in range(n_batch):\n        b_centers = params[b, :, :2].copy()\n        b_radii = params[b, :, 2].copy()\n        \n        # Safety subpixel constraints forcing rigid mathematical box bounds\n        for j in range(n_circles):\n            cx, cy = b_centers[j]\n            b_radii[j] = min(b_radii[j], cx, 1 - cx, cy, 1 - cy)\n            b_radii[j] = max(0.0, b_radii[j])\n            \n        for _ in range(200):\n            max_v = 0\n            worst_pair = None\n            for i1 in range(n_circles):\n                for i2 in range(i1 + 1, n_circles):\n                    d = np.linalg.norm(b_centers[i1] - b_centers[i2])\n                    ov = b_radii[i1] + b_radii[i2] - d\n                    if ov > max_v:\n                        max_v = ov\n                        worst_pair = (i1, i2)\n            \n            # Exact metric convergence ensures stability prior breaking loops\n            if max_v <= 1e-10:\n                break\n                \n            i1, i2 = worst_pair\n            d = np.linalg.norm(b_centers[i1] - b_centers[i2])\n            if b_radii[i1] + b_radii[i2] > 1e-12:\n                # Retract gracefully away from boundary geometry error\n                scale = (d - 1e-11) / (b_radii[i1] + b_radii[i2])\n                b_radii[i1] *= scale\n                b_radii[i2] *= scale\n        \n        s_radii = np.sum(b_radii)\n        if s_radii > best_sum:\n            best_sum = s_radii\n            best_centers = b_centers\n            best_radii = b_radii\n            \n    return best_centers, best_radii, best_sum\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Left intact to provide strictly standard API calls compatibilities.\n    If evaluated via sandbox hook this mathematically deflates sizes.\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n            if radii[i] + radii[j] > dist:\n                scale = (dist - 1e-11) / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative physics-based simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    # We loop exhaustively, eliminating the maximum overlap proportionally until none remain.\n    # Max n*n passes provides overwhelming headroom to ensure geometric convergence.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Perform multiple gradient descent optimizations with randomized symmetries\n    and heuristically spaced architectures to discover tightly bound packings\n    combining varied sizes maximizing their combined cumulative radii.\n    \"\"\"\n    n = 26\n    restarts = 24\n    iters = 2000\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n\n    # Pre-allocate indices pair combinations to heavily optimize array iteration\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    for rst in range(restarts):\n        rng = np.random.RandomState(42 + rst)\n\n        # Distribute varying sized centers matching multiple heuristic constraints\n        p = rng.uniform(0.1, 0.9, (n, 2))\n        r = rng.uniform(0.02, 0.12, n)\n\n        strat = rst % 4\n        if strat == 0:\n            # Concentric shell rings\n            for k in range(8):\n                angle = 2 * np.pi * k / 8\n                p[k] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for k in range(17):\n                angle = 2 * np.pi * k / 17\n                p[k + 8] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            p[25] = [0.5, 0.5]\n            r[:] = 0.08\n            r[25] = 0.15\n        elif strat == 1:\n            # Loose homogeneous 5x5 grids layout plus wandering floater\n            for k in range(25):\n                p[k] = [0.1 + 0.2 * (k % 5), 0.1 + 0.2 * (k // 5)]\n            r[:] = 0.08\n            p[25] = [0.5, 0.5]\n        elif strat == 2:\n            # Massive corner boulders framing small interstitially dense inner dust\n            p[0:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[0:4] = 0.25\n            r[4:] = 0.05\n        elif strat == 3:\n            # Monolithic mega center ringed symmetrically\n            p[0] = [0.5, 0.5]\n            r[0] = 0.35\n            r[1:] = 0.05\n\n        # Small jiggling permanently breaks mathematical symmetrical traps\n        p += rng.normal(0, 0.01, (n, 2))\n        p = np.clip(p, 0.02, 0.98)\n\n        # Momentum memories\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n\n        lr_p = 0.01\n        lr_r = 0.01\n\n        # Smooth optimization settling transitioning penalty stringency seamlessly (simulated annealing like)\n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n\n            # Distances mapped across upper triangle permutations\n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1))\n            dist = np.maximum(dist, 1e-8)\n\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n\n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n\n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n\n            # Spheroid collisions repulsion feedback\n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, np.newaxis] * (diff / dist[:, np.newaxis])\n\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                \n                # Push vectors inversely applying repulsing gradients ensuring centers repel apart\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n\n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n\n            # Adam stepping variables recalculating\n            beta1, beta2 = 0.9, 0.999\n            \n            m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n            v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n            p = p - lr_p * (m_p / (1.0 - beta1 ** t)) / (np.sqrt(v_p / (1.0 - beta2 ** t)) + 1e-8)\n\n            m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n            v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n            r = r - lr_r * (m_r / (1.0 - beta1 ** t)) / (np.sqrt(v_r / (1.0 - beta2 ** t)) + 1e-8)\n\n            # Coordinate confinement strictly\n            p = np.clip(p, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Mathematical strict exact validation wrapper ensuring precise operational geometric boundary bounds are zero.\n        r_valid = compute_max_radii(p, r)\n\n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n\n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"Physics-based iterative optimization engine for N=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers,\n    preserving the initially requested ratios sizes bounding correctly safely.\n    It guarantees absolute geometric validity bounding entirely securely properly.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n, dtype=np.float64) * 0.1\n    else:\n        r = input_radii.astype(np.float64, copy=True)\n\n    r = np.clip(r, 0.0, np.inf)\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n\n    # Extract single continuous pairwise map ensuring purely correct boundary bounds efficiently\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist = np.sqrt(np.sum(diff**2, axis=-1))\n    np.fill_diagonal(dist, np.inf)\n\n    # Resolve exhaustively to handle tight interlocking matrices structurally efficiently limits identically identically flawlessly\n    max_passes = n * n * 5\n    for _ in range(max_passes):\n        sum_r = r[:, np.newaxis] + r[np.newaxis, :]\n        overlaps = sum_r - dist\n        max_idx = np.argmax(overlaps)\n        \n        # Perfect exact sub-threshold mapping bounds perfectly structurally identically\n        if overlaps.flat[max_idx] <= 1e-10:\n            break\n            \n        i, j = divmod(max_idx, n)\n        s_r = r[i] + r[j]\n        d = dist[i, j]\n        if s_r > 1e-12:\n            scale = (d - 1e-11) / s_r\n            if scale < 1.0:\n                r[i] *= scale\n                r[j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Main numerical layout configuration structure executing massively vectorized parallel simulated simulated bounds perfectly dynamically boundaries structures efficiently optimally dynamically boundaries tightly correctly natively bounds seamlessly identically identically completely globally flawlessly gracefully securely scaling properly identically perfectly exactly boundaries mathematically efficiently stringently rigorously mathematically resolving boundaries safely efficiently perfectly seamlessly gracefully.\n    \"\"\"\n    n_circles = 26\n    n_batch = 60\n    n_iters = 14000\n    \n    rng = np.random.RandomState(42)\n    rng_thermal = np.random.RandomState(100)\n    \n    params = np.zeros((n_batch, n_circles, 3), dtype=np.float32)\n    \n    for b in range(n_batch):\n        mode = b % 10\n        if mode == 0:\n            params[b, :, :2] = rng.uniform(0.1, 0.9, (n_circles, 2))\n            params[b, :, 2] = 0.05\n        elif mode == 1:\n            params[b, :, :2] = rng.uniform(0.1, 0.9, (n_circles, 2))\n            params[b, :, 2] = rng.uniform(0.02, 0.09, n_circles)\n        elif mode == 2:\n            for i in range(5):\n                for j in range(5):\n                    params[b, i*5+j, :2] = [(i + 0.5) / 5.0, (j + 0.5) / 5.0]\n            params[b, 25, :2] = [0.5, 0.5]\n            params[b, :, :2] += rng.uniform(-0.03, 0.03, (n_circles, 2))\n            params[b, :, 2] = 0.08\n        elif mode == 3:\n            for i in range(6):\n                for j in range(4):\n                    params[b, i*4+j, :2] = [(i + 0.5) / 6.0, (j + 0.5) / 4.0]\n            params[b, 24, :2] = [0.5, 0.5]\n            params[b, 25, :2] = [0.4, 0.6]\n            params[b, :, :2] += rng.uniform(-0.02, 0.02, (n_circles, 2))\n            params[b, :, 2] = 0.07\n        elif mode == 4:\n            k = 0\n            for i in range(4):\n                params[b, k, :2] = [0.1 + i*0.8/4, 0.1]\n                k += 1\n                params[b, k, :2] = [0.9, 0.1 + i*0.8/4]\n                k += 1\n                params[b, k, :2] = [0.9 - i*0.8/4, 0.9]\n                k += 1\n                params[b, k, :2] = [0.1, 0.9 - i*0.8/4]\n                k += 1\n            params[b, k:, :2] = rng.uniform(0.2, 0.8, (n_circles - k, 2))\n            params[b, :, 2] = 0.05\n        elif mode == 5:\n            params[b, 0, :2] = [0.5, 0.5]\n            params[b, 0, 2] = 0.35\n            params[b, 1:, :2] = rng.uniform(0.1, 0.9, (n_circles - 1, 2))\n            params[b, 1:, 2] = rng.uniform(0.01, 0.06, n_circles - 1)\n        elif mode == 6:\n            params[b, 0, :2] = [0.5, 0.5]\n            for i_p in range(7):\n                params[b, i_p+1, :2] = [0.5 + 0.25*np.cos(i_p*2*np.pi/7), 0.5 + 0.25*np.sin(i_p*2*np.pi/7)]\n            for i_p in range(18):\n                params[b, i_p+8, :2] = [0.5 + 0.45*np.cos(i_p*2*np.pi/18), 0.5 + 0.45*np.sin(i_p*2*np.pi/18)]\n            params[b, :, :2] += rng.uniform(-0.01, 0.01, (n_circles, 2))\n            params[b, :, 2] = 0.06\n        elif mode == 7:\n            for k in range(4): \n                params[b, k, :2] = [0.5+0.15*np.cos(k*np.pi/2), 0.5+0.15*np.sin(k*np.pi/2)]\n            for k in range(10): \n                params[b, 4+k, :2] = [0.5+0.3*np.cos(k*2*np.pi/10), 0.5+0.3*np.sin(k*2*np.pi/10)]\n            for k in range(12): \n                params[b, 14+k, :2] = [0.5+0.45*np.cos(k*2*np.pi/12), 0.5+0.45*np.sin(k*2*np.pi/12)]\n            params[b, :, 2] = 0.06\n            params[b, :, :2] += rng.normal(0, 0.015, (n_circles, 2))\n        elif mode == 8:\n            params[b, 0:4, :2] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            params[b, 0:4, 2] = 0.18\n            for k in range(22):\n                theta = k * 2 * np.pi / 22\n                params[b, 4+k, :2] = [0.5 + 0.3*np.cos(theta), 0.5 + 0.3*np.sin(theta)]\n            params[b, 4:, 2] = 0.05\n        elif mode == 9:\n            params[b, 0:2, :2] = [[0.3, 0.5], [0.7, 0.5]]\n            params[b, 0:2, 2] = 0.25\n            params[b, 2:, :2] = rng.uniform(0.05, 0.95, (24, 2))\n            params[b, 2:, 2] = 0.04\n\n    params[:, :, :2] = np.clip(params[:, :, :2], 0.05, 0.95)\n\n    eye26 = np.eye(n_circles, dtype=np.float32)\n    not_eye26 = (1.0 - eye26).astype(np.float32)\n\n    alpha = 0.04\n    alpha_end = 0.0001\n    alpha_mult = (alpha_end / alpha) ** (1.0 / n_iters)\n    \n    lambda_val = 5.0\n    lambda_end = 5e7\n    lambda_mult = (lambda_end / lambda_val) ** (1.0 / n_iters)\n\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    grad = np.zeros_like(params)\n    beta1 = 0.85\n    beta2 = 0.98\n    m_scale = 1.0\n    v_scale = 1.0\n    epsilon = 1e-8\n\n    for step in range(1, n_iters + 1):\n        pos_curr = params[:, :, :2]\n        rad_curr = params[:, :, 2]\n        \n        diff = pos_curr[:, :, np.newaxis, :] - pos_curr[:, np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        \n        dist += eye26[np.newaxis, :, :]\n        \n        rad_sum = rad_curr[:, :, np.newaxis] + rad_curr[:, np.newaxis, :]\n        violations = np.maximum(rad_sum - dist, 0.0) * not_eye26[np.newaxis, :, :]\n        \n        v_left = np.maximum(rad_curr - pos_curr[:, :, 0], 0.0)\n        v_right = np.maximum(rad_curr + pos_curr[:, :, 0] - 1.0, 0.0)\n        v_bottom = np.maximum(rad_curr - pos_curr[:, :, 1], 0.0)\n        v_top = np.maximum(rad_curr + pos_curr[:, :, 1] - 1.0, 0.0)\n        \n        grad_r = 2.0 * lambda_val * (np.sum(violations, axis=2) + v_left + v_right + v_bottom + v_top) - 1.0\n        \n        factor = 2.0 * lambda_val * violations / np.maximum(dist, 1e-9)\n        grad_p_overlap = -np.sum(factor[:, :, :, np.newaxis] * diff, axis=2)\n        \n        grad_p = grad[:, :, :2]\n        grad_p[:, :, 0] = 2.0 * lambda_val * (-v_left + v_right)\n        grad_p[:, :, 1] = 2.0 * lambda_val * (-v_bottom + v_top)\n        grad_p += grad_p_overlap\n        \n        grad[:, :, 2] = grad_r\n        \n        m = beta1 * m + (1.0 - beta1) * grad\n        v = beta2 * v + (1.0 - beta2) * (grad ** 2)\n        \n        m_scale *= beta1\n        v_scale *= beta2\n        \n        m_hat = m / (1.0 - m_scale)\n        v_hat = v / (1.0 - v_scale)\n        \n        params -= alpha * m_hat / (np.sqrt(v_hat) + epsilon)\n        \n        if step < 9000:\n            vibrate_scale = 0.0005 * (1.0 - step / 9000.0) ** 2\n            params[:, :, :2] += rng_thermal.normal(0, vibrate_scale, pos_curr.shape).astype(np.float32)\n\n        params[:, :, :2] = np.clip(params[:, :, :2], 0.0001, 0.9999)\n        params[:, :, 2] = np.clip(params[:, :, 2], 0.0001, 0.5)\n\n        alpha *= alpha_mult\n        lambda_val *= lambda_mult\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    for b in range(n_batch):\n        p_res = params[b, :, :2].astype(np.float64)\n        r_res = params[b, :, 2].astype(np.float64)\n        \n        r_valid = compute_max_radii(p_res, r_res)\n        s = np.sum(r_valid)\n        \n        if s > best_sum:\n            best_sum = s\n            best_p = p_res.copy()\n            best_r = r_valid.copy()\n            \n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"39.65s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.612016/2.635 = 0.9913\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 99.1% of target value\", \"radius_stats\": \"Min: 0.068791, Max: 0.135454, Avg: 0.100462\"}", "artifact_dir": null, "embedding": null}