{"id": "811cf83a-84aa-4c3b-93f5-eae18850718e", "code": "# EVOLVE-BLOCK-START\n\"\"\"Iterative and SLSQP-based physics simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\ntry:\n    from scipy.optimize import minimize, Bounds, NonlinearConstraint\n    SCIPY_AVAILABLE = True\nexcept ImportError:\n    SCIPY_AVAILABLE = False\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef generate_diverse_seeds(n, num_seeds):\n    \"\"\"Generates highly spread, pseudo-relaxed layouts suitable for continuous optimizers.\"\"\"\n    seeds = []\n    \n    # 1. Start with structured and randomly jittered grids\n    grid_count = min(num_seeds // 2 + 1, num_seeds)\n    for rst in range(grid_count):\n        rng = np.random.RandomState(100 + rst)\n        p = []\n        for i in range(5):\n            for j in range(5):\n                p.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n        p.append([0.5, 0.5])  # Additional core entity to break total equality space mapping\n        \n        p = np.array(p)\n        p += rng.normal(0, 0.015, p.shape)\n        \n        # Settle the random initialization via simple geometric repulsion pushes\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 0.5)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.2\n            p = np.clip(p, 0.03, 0.97)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    # 2. Entirely random layouts leveraging uniform initial probability across borders\n    for rst in range(num_seeds - grid_count):\n        rng = np.random.RandomState(200 + rst)\n        p = rng.uniform(0.05, 0.95, (n, 2))\n        \n        # Emphasized separation\n        for _ in range(80):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 1.0)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.15\n            p = np.clip(p, 0.02, 0.98)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    return seeds\n\n\ndef build_optimization_scipy(n, restarts=32):\n    \"\"\"\n    Robust geometric optimization using mathematically absolute objective structures bounded cleanly inside SciPy's Nonlinear capabilities.\n    Enforces equality conditions through exact, directly injected Jacobians dramatically enhancing speed without diverging numerically.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p_init, r_init in seeds:\n        # X mapping: px(0 -> n), py(n -> 2n), rad(2n -> 3n)\n        def objective(X):\n            return -np.sum(X[2*n: 3*n])\n            \n        def objective_jac(X):\n            g = np.zeros(3*n)\n            g[2*n: 3*n] = -1.0\n            return g\n            \n        def cons_f(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            c1 = px - rad\n            c2 = 1.0 - px - rad\n            c3 = py - rad\n            c4 = 1.0 - py - rad\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            \n            c5 = dx**2 + dy**2 - r_sum**2\n            return np.concatenate([c1, c2, c3, c4, c5])\n\n        def cons_j(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            M = 4*n + len(i_idx)\n            J = np.zeros((M, 3*n))\n            idx = np.arange(n)\n            \n            # Constraint derivations explicitly placed against matching structural index references ensuring instant, safe derivatives bounds locking\n            J[idx, idx] = 1.0\n            J[idx, 2*n + idx] = -1.0\n            \n            J[n + idx, idx] = -1.0\n            J[n + idx, 2*n + idx] = -1.0\n            \n            J[2*n + idx, n + idx] = 1.0\n            J[2*n + idx, 2*n + idx] = -1.0\n            \n            J[3*n + idx, n + idx] = -1.0\n            J[3*n + idx, 2*n + idx] = -1.0\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            c5_idx = np.arange(4*n, M)\n            \n            J[c5_idx, i_idx] = 2 * dx\n            J[c5_idx, j_idx] = -2 * dx\n            J[c5_idx, n + i_idx] = 2 * dy\n            J[c5_idx, n + j_idx] = -2 * dy\n            J[c5_idx, 2*n + i_idx] = -2 * r_sum\n            J[c5_idx, 2*n + j_idx] = -2 * r_sum\n            \n            return J\n\n        lower_bound = np.zeros(3*n)\n        upper_bound = np.concatenate([np.ones(2*n), np.ones(n)*0.5])\n        \n        nlc = NonlinearConstraint(cons_f, 0.0, np.inf, jac=cons_j)\n        bounds = Bounds(lower_bound, upper_bound)\n        \n        x0 = np.concatenate([p_init[:, 0], p_init[:, 1], r_init])\n        x0 = np.clip(x0, lower_bound + 1e-5, upper_bound - 1e-5)\n        \n        try:\n            res = minimize(\n                objective, x0,\n                jac=objective_jac,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[nlc],\n                options={'maxiter': 800, 'ftol': 1e-5, 'disp': False}\n            )\n            \n            p_res = np.column_stack((res.x[0: n], res.x[n: 2*n]))\n            r_res = res.x[2*n: 3*n]\n            \n            r_valid = compute_max_radii(p_res, r_res)\n            curr_sum = np.sum(r_valid)\n            \n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_p = p_res.copy()\n                best_r = r_valid.copy()\n        except Exception:\n            continue\n            \n    return best_p, best_r, best_sum\n\n\ndef build_optimization_numpy(n, restarts=32):\n    \"\"\"\n    Fall-back mathematically refined exact Adam implementation mimicking simulated annealing dynamics, gracefully maximizing packing sum without explicit analytical constraints bounds relying uniquely internally across continuous spaces distributions.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p, r in seeds:\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        lr_p, lr_r = 0.005, 0.005\n        iters = 1500\n        \n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n            \n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1)) + 1e-12\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n            \n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n            \n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n            \n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, None] * (diff / dist[:, None])\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n                \n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n            \n            b1, b2 = 0.9, 0.999\n            m_p = b1 * m_p + (1.0 - b1) * grad_p\n            v_p = b2 * v_p + (1.0 - b2) * (grad_p ** 2)\n            p -= lr_p * (m_p / (1.0 - b1**t)) / (np.sqrt(v_p / (1.0 - b2**t)) + 1e-8)\n            \n            m_r = b1 * m_r + (1.0 - b1) * grad_r\n            v_r = b2 * v_r + (1.0 - b2) * (grad_r ** 2)\n            r -= lr_r * (m_r / (1.0 - b1**t)) / (np.sqrt(v_r / (1.0 - b2**t)) + 1e-8)\n            \n            p = np.clip(p, 0.001, 0.999)\n            r = np.clip(r, 0.001, 0.5)\n            \n        r_valid = compute_max_radii(p, r)\n        curr_sum = np.sum(r_valid)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n            \n    return best_p, best_r, best_sum\n\n\ndef construct_packing():\n    \"\"\"Run mathematically exact optimization algorithms smoothly switching implementations dynamically maximizing global packing bounds space utilization structures securely universally cross platforms capabilities limits.\"\"\"\n    n = 26\n    restarts = 32\n    if SCIPY_AVAILABLE:\n        p, r, s = build_optimization_scipy(n, restarts)\n        # Verify valid configuration was gracefully produced, otherwise bypass to guaranteed pure numerical optimizer algorithm sequences identically\n        if s > 0:\n            return p, r, s\n    \n    return build_optimization_numpy(n, restarts)\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "47dedff7-7333-4a22-9893-2f437b178f3b", "generation": 2, "timestamp": 1772008702.535187, "iteration_found": 15, "metrics": {"validity": 1.0, "sum_radii": 2.6070294060126593, "target_ratio": 0.9893849738188462, "combined_score": 0.9893849738188462, "radius_variance": 0.008565605635787994, "spatial_spread": 0.19551916734273384, "eval_time": 3.11567759513855}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 1.0753833163396522, "target_ratio": 0.40811511056533295, "combined_score": 0.40811511056533295, "radius_variance": 0.01725556155116175, "spatial_spread": 0.22408629214457715}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.4081\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.4081\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n5.72s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum: 1.075383, Ratio: 0.4081\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 1.0754, target_ratio: 0.4081, combined_score: 0.4081, radius_variance: 0.0173, spatial_spread: 0.2241\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.4081)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative physics-based simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    # We loop exhaustively, eliminating the maximum overlap proportionally until none remain.\n    # Max n*n passes provides overwhelming headroom to ensure geometric convergence.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Perform multiple gradient descent optimizations with randomized symmetries\n    and heuristically spaced architectures to discover tightly bound packings\n    combining varied sizes maximizing their combined cumulative radii.\n    \"\"\"\n    n = 26\n    restarts = 24\n    iters = 2000\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n\n    # Pre-allocate indices pair combinations to heavily optimize array iteration\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    for rst in range(restarts):\n        rng = np.random.RandomState(42 + rst)\n\n        # Distribute varying sized centers matching multiple heuristic constraints\n        p = rng.uniform(0.1, 0.9, (n, 2))\n        r = rng.uniform(0.02, 0.12, n)\n\n        strat = rst % 4\n        if strat == 0:\n            # Concentric shell rings\n            for k in range(8):\n                angle = 2 * np.pi * k / 8\n                p[k] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for k in range(17):\n                angle = 2 * np.pi * k / 17\n                p[k + 8] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            p[25] = [0.5, 0.5]\n            r[:] = 0.08\n            r[25] = 0.15\n        elif strat == 1:\n            # Loose homogeneous 5x5 grids layout plus wandering floater\n            for k in range(25):\n                p[k] = [0.1 + 0.2 * (k % 5), 0.1 + 0.2 * (k // 5)]\n            r[:] = 0.08\n            p[25] = [0.5, 0.5]\n        elif strat == 2:\n            # Massive corner boulders framing small interstitially dense inner dust\n            p[0:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[0:4] = 0.25\n            r[4:] = 0.05\n        elif strat == 3:\n            # Monolithic mega center ringed symmetrically\n            p[0] = [0.5, 0.5]\n            r[0] = 0.35\n            r[1:] = 0.05\n\n        # Small jiggling permanently breaks mathematical symmetrical traps\n        p += rng.normal(0, 0.01, (n, 2))\n        p = np.clip(p, 0.02, 0.98)\n\n        # Momentum memories\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n\n        lr_p = 0.01\n        lr_r = 0.01\n\n        # Smooth optimization settling transitioning penalty stringency seamlessly (simulated annealing like)\n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n\n            # Distances mapped across upper triangle permutations\n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1))\n            dist = np.maximum(dist, 1e-8)\n\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n\n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n\n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n\n            # Spheroid collisions repulsion feedback\n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, np.newaxis] * (diff / dist[:, np.newaxis])\n\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                \n                # Push vectors inversely applying repulsing gradients ensuring centers repel apart\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n\n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n\n            # Adam stepping variables recalculating\n            beta1, beta2 = 0.9, 0.999\n            \n            m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n            v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n            p = p - lr_p * (m_p / (1.0 - beta1 ** t)) / (np.sqrt(v_p / (1.0 - beta2 ** t)) + 1e-8)\n\n            m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n            v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n            r = r - lr_r * (m_r / (1.0 - beta1 ** t)) / (np.sqrt(v_r / (1.0 - beta2 ** t)) + 1e-8)\n\n            # Coordinate confinement strictly\n            p = np.clip(p, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Mathematical strict exact validation wrapper ensuring precise operational geometric boundary bounds are zero.\n        r_valid = compute_max_radii(p, r)\n\n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n\n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (1.0754), Performs well on target_ratio (0.4081), Performs well on combined_score (0.4081), Performs well on radius_variance (0.0173), Performs well on spatial_spread (0.2241)\n\n\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Iterative physics-based simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    # We loop exhaustively, eliminating the maximum overlap proportionally until none remain.\n    # Max n*n passes provides overwhelming headroom to ensure geometric convergence.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef construct_packing():\n    \"\"\"\n    Perform multiple gradient descent optimizations with randomized symmetries\n    and heuristically spaced architectures to discover tightly bound packings\n    combining varied sizes maximizing their combined cumulative radii.\n    \"\"\"\n    n = 26\n    restarts = 24\n    iters = 2000\n\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n\n    # Pre-allocate indices pair combinations to heavily optimize array iteration\n    i_idx, j_idx = np.triu_indices(n, 1)\n\n    for rst in range(restarts):\n        rng = np.random.RandomState(42 + rst)\n\n        # Distribute varying sized centers matching multiple heuristic constraints\n        p = rng.uniform(0.1, 0.9, (n, 2))\n        r = rng.uniform(0.02, 0.12, n)\n\n        strat = rst % 4\n        if strat == 0:\n            # Concentric shell rings\n            for k in range(8):\n                angle = 2 * np.pi * k / 8\n                p[k] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n            for k in range(17):\n                angle = 2 * np.pi * k / 17\n                p[k + 8] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n            p[25] = [0.5, 0.5]\n            r[:] = 0.08\n            r[25] = 0.15\n        elif strat == 1:\n            # Loose homogeneous 5x5 grids layout plus wandering floater\n            for k in range(25):\n                p[k] = [0.1 + 0.2 * (k % 5), 0.1 + 0.2 * (k // 5)]\n            r[:] = 0.08\n            p[25] = [0.5, 0.5]\n        elif strat == 2:\n            # Massive corner boulders framing small interstitially dense inner dust\n            p[0:4] = [[0.1, 0.1], [0.1, 0.9], [0.9, 0.1], [0.9, 0.9]]\n            r[0:4] = 0.25\n            r[4:] = 0.05\n        elif strat == 3:\n            # Monolithic mega center ringed symmetrically\n            p[0] = [0.5, 0.5]\n            r[0] = 0.35\n            r[1:] = 0.05\n\n        # Small jiggling permanently breaks mathematical symmetrical traps\n        p += rng.normal(0, 0.01, (n, 2))\n        p = np.clip(p, 0.02, 0.98)\n\n        # Momentum memories\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n\n        lr_p = 0.01\n        lr_r = 0.01\n\n        # Smooth optimization settling transitioning penalty stringency seamlessly (simulated annealing like)\n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n\n            # Distances mapped across upper triangle permutations\n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1))\n            dist = np.maximum(dist, 1e-8)\n\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n\n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n\n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n\n            # Spheroid collisions repulsion feedback\n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, np.newaxis] * (diff / dist[:, np.newaxis])\n\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                \n                # Push vectors inversely applying repulsing gradients ensuring centers repel apart\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n\n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n\n            # Adam stepping variables recalculating\n            beta1, beta2 = 0.9, 0.999\n            \n            m_p = beta1 * m_p + (1.0 - beta1) * grad_p\n            v_p = beta2 * v_p + (1.0 - beta2) * (grad_p ** 2)\n            p = p - lr_p * (m_p / (1.0 - beta1 ** t)) / (np.sqrt(v_p / (1.0 - beta2 ** t)) + 1e-8)\n\n            m_r = beta1 * m_r + (1.0 - beta1) * grad_r\n            v_r = beta2 * v_r + (1.0 - beta2) * (grad_r ** 2)\n            r = r - lr_r * (m_r / (1.0 - beta1 ** t)) / (np.sqrt(v_r / (1.0 - beta2 ** t)) + 1e-8)\n\n            # Coordinate confinement strictly\n            p = np.clip(p, 0.001, 0.999)\n            r = np.maximum(r, 0.001)\n\n        # Mathematical strict exact validation wrapper ensuring precise operational geometric boundary bounds are zero.\n        r_valid = compute_max_radii(p, r)\n\n        current_sum = np.sum(r_valid)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n\n    return best_p, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["# EVOLVE-BLOCK-START\n\"\"\"Iterative and SLSQP-based physics simulation for maximizing n=26 circle packing.\"\"\"\nimport numpy as np\n\ntry:\n    from scipy.optimize import minimize, Bounds, NonlinearConstraint\n    SCIPY_AVAILABLE = True\nexcept ImportError:\n    SCIPY_AVAILABLE = False\n\n\ndef compute_max_radii(centers, input_radii=None):\n    \"\"\"\n    Compute exactly valid maximum possible radii for a fixed set of centers, \n    preserving the initial requested sizes without overextending overlaps.\n    \"\"\"\n    n = centers.shape[0]\n    if input_radii is None:\n        r = np.ones(n) * 0.1\n    else:\n        r = input_radii.copy()\n\n    # Step 1: Clamp radii cleanly inside unit square limits\n    r = np.minimum(r, centers[:, 0])\n    r = np.minimum(r, 1.0 - centers[:, 0])\n    r = np.minimum(r, centers[:, 1])\n    r = np.minimum(r, 1.0 - centers[:, 1])\n    r = np.maximum(r, 0.0)\n\n    # Step 2: Rigorously enforce separation constraints between colliding pairs.\n    max_passes = n * n * 2\n    for _ in range(max_passes):\n        max_over = 0.0\n        best_i, best_j = -1, -1\n        best_d = 0.0\n\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                d = np.sqrt(dx * dx + dy * dy)\n                over = r[i] + r[j] - d\n                if over > max_over:\n                    max_over = over\n                    best_i, best_j = i, j\n                    best_d = d\n\n        if max_over <= 1e-9:\n            break\n\n        sum_r = r[best_i] + r[best_j]\n        if sum_r > 0:\n            scale = best_d / sum_r\n            r[best_i] *= scale\n            r[best_j] *= scale\n\n    return r\n\n\ndef generate_diverse_seeds(n, num_seeds):\n    \"\"\"Generates highly spread, pseudo-relaxed layouts suitable for continuous optimizers.\"\"\"\n    seeds = []\n    \n    # 1. Start with structured and randomly jittered grids\n    grid_count = min(num_seeds // 2 + 1, num_seeds)\n    for rst in range(grid_count):\n        rng = np.random.RandomState(100 + rst)\n        p = []\n        for i in range(5):\n            for j in range(5):\n                p.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n        p.append([0.5, 0.5])  # Additional core entity to break total equality space mapping\n        \n        p = np.array(p)\n        p += rng.normal(0, 0.015, p.shape)\n        \n        # Settle the random initialization via simple geometric repulsion pushes\n        for _ in range(40):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 0.5)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.2\n            p = np.clip(p, 0.03, 0.97)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    # 2. Entirely random layouts leveraging uniform initial probability across borders\n    for rst in range(num_seeds - grid_count):\n        rng = np.random.RandomState(200 + rst)\n        p = rng.uniform(0.05, 0.95, (n, 2))\n        \n        # Emphasized separation\n        for _ in range(80):\n            diff = p[:, None, :] - p[None, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1))\n            np.fill_diagonal(dist, np.inf)\n            fm = np.clip(0.005 / (dist**2 + 1e-8), 0, 1.0)\n            p += np.sum((diff / (dist[..., None] + 1e-8)) * fm[..., None], axis=1) * 0.15\n            p = np.clip(p, 0.02, 0.98)\n            \n        r = np.ones(n) * 0.02\n        seeds.append((p, r))\n        \n    return seeds\n\n\ndef build_optimization_scipy(n, restarts=32):\n    \"\"\"\n    Robust geometric optimization using mathematically absolute objective structures bounded cleanly inside SciPy's Nonlinear capabilities.\n    Enforces equality conditions through exact, directly injected Jacobians dramatically enhancing speed without diverging numerically.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p_init, r_init in seeds:\n        # X mapping: px(0 -> n), py(n -> 2n), rad(2n -> 3n)\n        def objective(X):\n            return -np.sum(X[2*n: 3*n])\n            \n        def objective_jac(X):\n            g = np.zeros(3*n)\n            g[2*n: 3*n] = -1.0\n            return g\n            \n        def cons_f(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            c1 = px - rad\n            c2 = 1.0 - px - rad\n            c3 = py - rad\n            c4 = 1.0 - py - rad\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            \n            c5 = dx**2 + dy**2 - r_sum**2\n            return np.concatenate([c1, c2, c3, c4, c5])\n\n        def cons_j(X):\n            px = X[0: n]\n            py = X[n: 2*n]\n            rad = X[2*n: 3*n]\n            \n            M = 4*n + len(i_idx)\n            J = np.zeros((M, 3*n))\n            idx = np.arange(n)\n            \n            # Constraint derivations explicitly placed against matching structural index references ensuring instant, safe derivatives bounds locking\n            J[idx, idx] = 1.0\n            J[idx, 2*n + idx] = -1.0\n            \n            J[n + idx, idx] = -1.0\n            J[n + idx, 2*n + idx] = -1.0\n            \n            J[2*n + idx, n + idx] = 1.0\n            J[2*n + idx, 2*n + idx] = -1.0\n            \n            J[3*n + idx, n + idx] = -1.0\n            J[3*n + idx, 2*n + idx] = -1.0\n            \n            dx = px[i_idx] - px[j_idx]\n            dy = py[i_idx] - py[j_idx]\n            r_sum = rad[i_idx] + rad[j_idx]\n            c5_idx = np.arange(4*n, M)\n            \n            J[c5_idx, i_idx] = 2 * dx\n            J[c5_idx, j_idx] = -2 * dx\n            J[c5_idx, n + i_idx] = 2 * dy\n            J[c5_idx, n + j_idx] = -2 * dy\n            J[c5_idx, 2*n + i_idx] = -2 * r_sum\n            J[c5_idx, 2*n + j_idx] = -2 * r_sum\n            \n            return J\n\n        lower_bound = np.zeros(3*n)\n        upper_bound = np.concatenate([np.ones(2*n), np.ones(n)*0.5])\n        \n        nlc = NonlinearConstraint(cons_f, 0.0, np.inf, jac=cons_j)\n        bounds = Bounds(lower_bound, upper_bound)\n        \n        x0 = np.concatenate([p_init[:, 0], p_init[:, 1], r_init])\n        x0 = np.clip(x0, lower_bound + 1e-5, upper_bound - 1e-5)\n        \n        try:\n            res = minimize(\n                objective, x0,\n                jac=objective_jac,\n                method='SLSQP',\n                bounds=bounds,\n                constraints=[nlc],\n                options={'maxiter': 800, 'ftol': 1e-5, 'disp': False}\n            )\n            \n            p_res = np.column_stack((res.x[0: n], res.x[n: 2*n]))\n            r_res = res.x[2*n: 3*n]\n            \n            r_valid = compute_max_radii(p_res, r_res)\n            curr_sum = np.sum(r_valid)\n            \n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_p = p_res.copy()\n                best_r = r_valid.copy()\n        except Exception:\n            continue\n            \n    return best_p, best_r, best_sum\n\n\ndef build_optimization_numpy(n, restarts=32):\n    \"\"\"\n    Fall-back mathematically refined exact Adam implementation mimicking simulated annealing dynamics, gracefully maximizing packing sum without explicit analytical constraints bounds relying uniquely internally across continuous spaces distributions.\n    \"\"\"\n    best_sum = -1.0\n    best_p = None\n    best_r = None\n    \n    seeds = generate_diverse_seeds(n, restarts)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    \n    for p, r in seeds:\n        m_p, v_p = np.zeros_like(p), np.zeros_like(p)\n        m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n        \n        lr_p, lr_r = 0.005, 0.005\n        iters = 1500\n        \n        for t in range(1, iters + 1):\n            lam = 1.0 * (10000 ** (t / iters))\n            \n            diff = p[i_idx] - p[j_idx]\n            dist = np.sqrt(np.sum(diff ** 2, axis=1)) + 1e-12\n            overlap = np.maximum(0, (r[i_idx] + r[j_idx]) - dist)\n            \n            pen_x0 = np.maximum(0, r - p[:, 0])\n            pen_x1 = np.maximum(0, r - (1.0 - p[:, 0]))\n            pen_y0 = np.maximum(0, r - p[:, 1])\n            pen_y1 = np.maximum(0, r - (1.0 - p[:, 1]))\n            \n            grad_r = -1.0 * np.ones_like(r)\n            grad_p = np.zeros_like(p)\n            \n            if np.any(overlap > 0):\n                force_r = lam * overlap\n                force_p = lam * overlap[:, None] * (diff / dist[:, None])\n                np.add.at(grad_r, i_idx, force_r)\n                np.add.at(grad_r, j_idx, force_r)\n                np.add.at(grad_p, i_idx, -force_p)\n                np.add.at(grad_p, j_idx, force_p)\n                \n            grad_r += lam * (pen_x0 + pen_x1 + pen_y0 + pen_y1)\n            grad_p[:, 0] += lam * (-pen_x0 + pen_x1)\n            grad_p[:, 1] += lam * (-pen_y0 + pen_y1)\n            \n            b1, b2 = 0.9, 0.999\n            m_p = b1 * m_p + (1.0 - b1) * grad_p\n            v_p = b2 * v_p + (1.0 - b2) * (grad_p ** 2)\n            p -= lr_p * (m_p / (1.0 - b1**t)) / (np.sqrt(v_p / (1.0 - b2**t)) + 1e-8)\n            \n            m_r = b1 * m_r + (1.0 - b1) * grad_r\n            v_r = b2 * v_r + (1.0 - b2) * (grad_r ** 2)\n            r -= lr_r * (m_r / (1.0 - b1**t)) / (np.sqrt(v_r / (1.0 - b2**t)) + 1e-8)\n            \n            p = np.clip(p, 0.001, 0.999)\n            r = np.clip(r, 0.001, 0.5)\n            \n        r_valid = compute_max_radii(p, r)\n        curr_sum = np.sum(r_valid)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_p = p.copy()\n            best_r = r_valid.copy()\n            \n    return best_p, best_r, best_sum\n\n\ndef construct_packing():\n    \"\"\"Run mathematically exact optimization algorithms smoothly switching implementations dynamically maximizing global packing bounds space utilization structures securely universally cross platforms capabilities limits.\"\"\"\n    n = 26\n    restarts = 32\n    if SCIPY_AVAILABLE:\n        p, r, s = build_optimization_scipy(n, restarts)\n        # Verify valid configuration was gracefully produced, otherwise bypass to guaranteed pure numerical optimizer algorithm sequences identically\n        if s > 0:\n            return p, r, s\n    \n    return build_optimization_numpy(n, restarts)\n\n# EVOLVE-BLOCK-END\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)"]}}, "artifacts_json": "{\"execution_time\": \"3.12s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.607029/2.635 = 0.9894\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 98.9% of target value\", \"radius_stats\": \"Min: 0.059528, Max: 0.160311, Avg: 0.100270\"}", "artifact_dir": null, "embedding": null}