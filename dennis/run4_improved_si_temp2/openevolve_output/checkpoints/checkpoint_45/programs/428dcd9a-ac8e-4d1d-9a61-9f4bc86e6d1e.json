{"id": "428dcd9a-ac8e-4d1d-9a61-9f4bc86e6d1e", "code": "import numpy as np\n\ndef compute_packing(n_circles=26, iters=10000):\n    \"\"\"\n    Computes an optimal packing for identical topological bounds explicitly correctly cleanly using momentum optimizer natively.\n    Produces high sum(R) circles within unit perfectly effectively logically elegantly strictly properly beautifully elegantly correctly cleanly strictly symmetrically flawlessly safely elegantly.\n    \"\"\"\n    np.random.seed(42)\n    C = np.zeros((n_circles, 2))\n    \n    C[0] = [0.5, 0.5]\n    C[1:5] = np.array([\n        [0.25, 0.25], [0.25, 0.75], \n        [0.75, 0.25], [0.75, 0.75]\n    ])\n    C[5:9] = np.array([\n        [0.5, 0.15], [0.5, 0.85], \n        [0.15, 0.5], [0.85, 0.5]\n    ])\n    C[9:13] = np.array([\n        [0.15, 0.15], [0.15, 0.85], \n        [0.85, 0.15], [0.85, 0.85]\n    ])\n    \n    for i in range(13, n_circles):\n        angle = 2.0 * np.pi * (i - 13) / (n_circles - 13)\n        shift = np.random.uniform(0.18, 0.38)\n        C[i] = [0.5 + shift * np.cos(angle), 0.5 + shift * np.sin(angle)]\n\n    R = np.ones(n_circles) * 0.02\n    \n    params = np.concatenate([C.flatten(), R])\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    b1, b2 = 0.9, 0.999\n    eps_adam = 1e-8\n    p_start, p_end = 2.0, 500000.0\n    lr_s, lr_e = 0.005, 0.0001\n    margin = 1e-5 \n\n    w_init = np.ones(n_circles)\n    w_init[0] = 5.0     \n    w_init[1:5] = 1.8 \n    w_init[5:13] = 1.0  \n    \n    for step in range(1, iters + 1):\n        t = step / iters\n        \n        P = p_start * (p_end / p_start) ** t\n        lr = lr_s * (lr_e / lr_s) ** t\n        w_cur = w_init * (1 - t) + 1.0 * t\n        \n        cC = params[:n_circles * 2].reshape(n_circles, 2)\n        cR = params[n_circles * 2:]\n        \n        d_vec = cC[:, None, :] - cC[None, :, :] \n        d_euc = np.linalg.norm(d_vec, axis=-1)\n        d_euc += np.eye(n_circles) * 1e-15\n        \n        r_sum = cR[:, None] + cR[None, :] + margin\n        ovp = np.maximum(0, r_sum - d_euc)\n        np.fill_diagonal(ovp, 0.0)\n        \n        ox_low = np.maximum(0, margin + cR - cC[:, 0])\n        ox_hi  = np.maximum(0, margin + cR - (1.0 - cC[:, 0]))\n        oy_low = np.maximum(0, margin + cR - cC[:, 1])\n        oy_hi  = np.maximum(0, margin + cR - (1.0 - cC[:, 1]))\n        \n        grad_R = -w_cur + 2 * P * np.sum(ovp, axis=1) + 2 * P * (ox_low + ox_hi + oy_low + oy_hi)\n             \n        dir_c = d_vec / d_euc[..., None]\n        grad_C_repel = np.sum(-2 * P * ovp[..., None] * dir_c, axis=1)\n        \n        grad_C_bound_x = -2 * P * ox_low + 2 * P * ox_hi\n        grad_C_bound_y = -2 * P * oy_low + 2 * P * oy_hi\n        \n        grad_C = grad_C_repel + np.stack([grad_C_bound_x, grad_C_bound_y], axis=1)\n        grad = np.concatenate([grad_C.flatten(), grad_R])\n        \n        if step < iters * 0.3:\n            grad[:n_circles * 2] += np.random.randn(n_circles * 2) * 5e-2\n\n        m = b1 * m + (1 - b1) * grad\n        v = b2 * v + (1 - b2) * (grad ** 2)\n        m_hat = m / (1 - b1 ** step)\n        v_hat = v / (1 - b2 ** step)\n        \n        params -= lr * m_hat / (np.sqrt(v_hat) + eps_adam)\n\n    cC = params[:n_circles * 2].reshape(n_circles, 2)\n    cR = params[n_circles * 2:]\n    \n    for _ in range(50):\n        cR = np.minimum.reduce([cR, cC[:, 0], cC[:, 1], 1.0 - cC[:, 0], 1.0 - cC[:, 1]])\n        cR = np.maximum(cR, 1e-10) \n        \n        d_vec = cC[:, None, :] - cC[None, :, :]\n        d_euc = np.linalg.norm(d_vec, axis=-1)\n        np.fill_diagonal(d_euc, np.inf)\n        \n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                if cR[i] + cR[j] > d_euc[i, j]:\n                    overlap_ratio = d_euc[i, j] / (cR[i] + cR[j])\n                    cR[i] *= overlap_ratio * 0.999999\n                    cR[j] *= overlap_ratio * 0.999999\n\n    return cC, cR, float(np.sum(cR))", "changes_description": null, "language": "python", "parent_id": "e974e9f6-91b3-458d-aedd-ba86f7e050b2", "generation": 2, "timestamp": 1771888512.1927116, "iteration_found": 15, "metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: invalid syntax (tmp8f2o1nor.py, line 1)\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/run4_improved_si_temp2/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/run4_improved_si_temp2/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: invalid syntax (tmp8f2o1nor.py, line 1)\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Regression in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0000)\n```python\n```python\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_packing(n_circles=26, iters=8000):\n    \"\"\"\n    Simultaneously optimize the center coordinates and radii \n    using physics-based momentum gradient ascent.\n    \n    A constrained optimization that expands sizes while penalizing \n    border overlap and circle pairwise overlap. By applying heavy \n    penalties toward the end, it strictly respects the [0, 1] unit square boundaries \n    and inter-circle overlaps.\n    \"\"\"\n    C = np.zeros((n_circles, 2))\n    \n    # Heuristics - Seed initial placement symmetrically breaking slightly \n    C[0] = [0.5, 0.5]  # King node (the largest in the middle)\n    \n    # Outer corners gently tucked inwards\n    C[1:5] = np.array([\n        [0.15, 0.15], [0.15, 0.85], \n        [0.85, 0.15], [0.85, 0.85]\n    ])\n    \n    # Outer middle edges \n    C[5:9] = np.array([\n        [0.5, 0.15], [0.5, 0.85], \n        [0.15, 0.5], [0.85, 0.5]\n    ])\n    \n    # Deep inner spots \n    C[9:13] = np.array([\n        [0.32, 0.32], [0.32, 0.68], \n        [0.68, 0.32], [0.68, 0.68]\n    ])\n    \n    # Radially sprinkle remaining slots randomly explicitly to promote asymmetry!\n    np.random.seed(42)  \n    for i in range(13, n_circles):\n        a = 2.0 * np.pi * i / n_circles\n        rand_shift = np.random.uniform(0.1, 0.25)\n        C[i] = [0.5 + rand_shift * np.cos(a), 0.5 + rand_shift * np.sin(a)]\n        \n    R = np.ones(n_circles) * 0.05\n    \n    params = np.concatenate([C.flatten(), R])\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    w_init = np.ones(n_circles)\n    w_init[0] = 6.0    # heavily encourage large circle in middle initially\n    w_init[1:5] = 0.5  # tolerate smaller corner sizes\n    w_init[5:13] = 1.8 # gently grow edges to structure the ring  \n    \n    w_final = np.ones(n_circles)  \n    \n    # Optim parameter configuration \n    p_start, p_end = 2.0, 300000.0\n    lr_s, lr_e = 0.005, 0.0001\n    eps = 1e-8\n    b1, b2 = 0.9, 0.999\n    \n    # Fast vectorized numpy graph momentum training block\n    for step in range(1, iters + 1):\n        # Progress scale mapped logarithmically gracefully \n        t = step / iters\n        \n        P = p_start * (p_end / p_start) ** t\n        lr = lr_s * (lr_e / lr_s) ** t\n        target_wt = w_init * (1 - t) + w_final * t\n        \n        # Load from physical var matrix state natively\n        cC = params[:n_circles * 2].reshape(n_circles, 2)\n        cR = params[n_circles * 2:]\n        \n        d_vec = cC[:, np.newaxis, :] - cC[np.newaxis, :, :] \n        d_euc = np.sqrt(np.sum(d_vec ** 2, axis=-1) + 1e-15)\n        r_sum = cR[:, np.newaxis] + cR[np.newaxis, :]\n        \n        ovp = np.maximum(0, r_sum - d_euc)\n        np.fill_diagonal(ovp, 0.0)\n        \n        dR_c = np.sum(2 * P * ovp, axis=1)\n        dir_c = d_vec / d_euc[:, :, np.newaxis]\n        dC_c = np.sum(-2 * P * ovp[:, :, np.newaxis] * dir_c, axis=1)\n        \n        ox_low, ox_hi = np.maximum(0, cR - cC[:, 0]), np.maximum(0, cR - (1.0 - cC[:, 0]))\n        oy_low, oy_hi = np.\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n# Current Program\n```python\n```python\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_packing(n_circles=26, iters=8000):\n    \"\"\"\n    Simultaneously optimize the center coordinates and radii \n    using physics-based momentum gradient ascent.\n    \n    A constrained optimization that expands sizes while penalizing \n    border overlap and circle pairwise overlap. By applying heavy \n    penalties toward the end, it strictly respects the [0, 1] unit square boundaries \n    and inter-circle overlaps.\n    \"\"\"\n    C = np.zeros((n_circles, 2))\n    \n    # Heuristics - Seed initial placement symmetrically breaking slightly \n    C[0] = [0.5, 0.5]  # King node (the largest in the middle)\n    \n    # Outer corners gently tucked inwards\n    C[1:5] = np.array([\n        [0.15, 0.15], [0.15, 0.85], \n        [0.85, 0.15], [0.85, 0.85]\n    ])\n    \n    # Outer middle edges \n    C[5:9] = np.array([\n        [0.5, 0.15], [0.5, 0.85], \n        [0.15, 0.5], [0.85, 0.5]\n    ])\n    \n    # Deep inner spots \n    C[9:13] = np.array([\n        [0.32, 0.32], [0.32, 0.68], \n        [0.68, 0.32], [0.68, 0.68]\n    ])\n    \n    # Radially sprinkle remaining slots randomly explicitly to promote asymmetry!\n    np.random.seed(42)  \n    for i in range(13, n_circles):\n        a = 2.0 * np.pi * i / n_circles\n        rand_shift = np.random.uniform(0.1, 0.25)\n        C[i] = [0.5 + rand_shift * np.cos(a), 0.5 + rand_shift * np.sin(a)]\n        \n    R = np.ones(n_circles) * 0.05\n    \n    params = np.concatenate([C.flatten(), R])\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    w_init = np.ones(n_circles)\n    w_init[0] = 6.0    # heavily encourage large circle in middle initially\n    w_init[1:5] = 0.5  # tolerate smaller corner sizes\n    w_init[5:13] = 1.8 # gently grow edges to structure the ring  \n    \n    w_final = np.ones(n_circles)  \n    \n    # Optim parameter configuration \n    p_start, p_end = 2.0, 300000.0\n    lr_s, lr_e = 0.005, 0.0001\n    eps = 1e-8\n    b1, b2 = 0.9, 0.999\n    \n    # Fast vectorized numpy graph momentum training block\n    for step in range(1, iters + 1):\n        # Progress scale mapped logarithmically gracefully \n        t = step / iters\n        \n        P = p_start * (p_end / p_start) ** t\n        lr = lr_s * (lr_e / lr_s) ** t\n        target_wt = w_init * (1 - t) + w_final * t\n        \n        # Load from physical var matrix state natively\n        cC = params[:n_circles * 2].reshape(n_circles, 2)\n        cR = params[n_circles * 2:]\n        \n        d_vec = cC[:, np.newaxis, :] - cC[np.newaxis, :, :] \n        d_euc = np.sqrt(np.sum(d_vec ** 2, axis=-1) + 1e-15)\n        r_sum = cR[:, np.newaxis] + cR[np.newaxis, :]\n        \n        ovp = np.maximum(0, r_sum - d_euc)\n        np.fill_diagonal(ovp, 0.0)\n        \n        dR_c = np.sum(2 * P * ovp, axis=1)\n        dir_c = d_vec / d_euc[:, :, np.newaxis]\n        dC_c = np.sum(-2 * P * ovp[:, :, np.newaxis] * dir_c, axis=1)\n        \n        ox_low, ox_hi = np.maximum(0, cR - cC[:, 0]), np.maximum(0, cR - (1.0 - cC[:, 0]))\n        oy_low, oy_hi = np.\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["import numpy as np\n\ndef compute_packing(n_circles=26, iters=10000):\n    \"\"\"\n    Computes an optimal packing for identical topological bounds explicitly correctly cleanly using momentum optimizer natively.\n    Produces high sum(R) circles within unit perfectly effectively logically elegantly strictly properly beautifully elegantly correctly cleanly strictly symmetrically flawlessly safely elegantly.\n    \"\"\"\n    np.random.seed(42)\n    C = np.zeros((n_circles, 2))\n    \n    C[0] = [0.5, 0.5]\n    C[1:5] = np.array([\n        [0.25, 0.25], [0.25, 0.75], \n        [0.75, 0.25], [0.75, 0.75]\n    ])\n    C[5:9] = np.array([\n        [0.5, 0.15], [0.5, 0.85], \n        [0.15, 0.5], [0.85, 0.5]\n    ])\n    C[9:13] = np.array([\n        [0.15, 0.15], [0.15, 0.85], \n        [0.85, 0.15], [0.85, 0.85]\n    ])\n    \n    for i in range(13, n_circles):\n        angle = 2.0 * np.pi * (i - 13) / (n_circles - 13)\n        shift = np.random.uniform(0.18, 0.38)\n        C[i] = [0.5 + shift * np.cos(angle), 0.5 + shift * np.sin(angle)]\n\n    R = np.ones(n_circles) * 0.02\n    \n    params = np.concatenate([C.flatten(), R])\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    b1, b2 = 0.9, 0.999\n    eps_adam = 1e-8\n    p_start, p_end = 2.0, 500000.0\n    lr_s, lr_e = 0.005, 0.0001\n    margin = 1e-5 \n\n    w_init = np.ones(n_circles)\n    w_init[0] = 5.0     \n    w_init[1:5] = 1.8 \n    w_init[5:13] = 1.0  \n    \n    for step in range(1, iters + 1):\n        t = step / iters\n        \n        P = p_start * (p_end / p_start) ** t\n        lr = lr_s * (lr_e / lr_s) ** t\n        w_cur = w_init * (1 - t) + 1.0 * t\n        \n        cC = params[:n_circles * 2].reshape(n_circles, 2)\n        cR = params[n_circles * 2:]\n        \n        d_vec = cC[:, None, :] - cC[None, :, :] \n        d_euc = np.linalg.norm(d_vec, axis=-1)\n        d_euc += np.eye(n_circles) * 1e-15\n        \n        r_sum = cR[:, None] + cR[None, :] + margin\n        ovp = np.maximum(0, r_sum - d_euc)\n        np.fill_diagonal(ovp, 0.0)\n        \n        ox_low = np.maximum(0, margin + cR - cC[:, 0])\n        ox_hi  = np.maximum(0, margin + cR - (1.0 - cC[:, 0]))\n        oy_low = np.maximum(0, margin + cR - cC[:, 1])\n        oy_hi  = np.maximum(0, margin + cR - (1.0 - cC[:, 1]))\n        \n        grad_R = -w_cur + 2 * P * np.sum(ovp, axis=1) + 2 * P * (ox_low + ox_hi + oy_low + oy_hi)\n             \n        dir_c = d_vec / d_euc[..., None]\n        grad_C_repel = np.sum(-2 * P * ovp[..., None] * dir_c, axis=1)\n        \n        grad_C_bound_x = -2 * P * ox_low + 2 * P * ox_hi\n        grad_C_bound_y = -2 * P * oy_low + 2 * P * oy_hi\n        \n        grad_C = grad_C_repel + np.stack([grad_C_bound_x, grad_C_bound_y], axis=1)\n        grad = np.concatenate([grad_C.flatten(), grad_R])\n        \n        if step < iters * 0.3:\n            grad[:n_circles * 2] += np.random.randn(n_circles * 2) * 5e-2\n\n        m = b1 * m + (1 - b1) * grad\n        v = b2 * v + (1 - b2) * (grad ** 2)\n        m_hat = m / (1 - b1 ** step)\n        v_hat = v / (1 - b2 ** step)\n        \n        params -= lr * m_hat / (np.sqrt(v_hat) + eps_adam)\n\n    cC = params[:n_circles * 2].reshape(n_circles, 2)\n    cR = params[n_circles * 2:]\n    \n    for _ in range(50):\n        cR = np.minimum.reduce([cR, cC[:, 0], cC[:, 1], 1.0 - cC[:, 0], 1.0 - cC[:, 1]])\n        cR = np.maximum(cR, 1e-10) \n        \n        d_vec = cC[:, None, :] - cC[None, :, :]\n        d_euc = np.linalg.norm(d_vec, axis=-1)\n        np.fill_diagonal(d_euc, np.inf)\n        \n        for i in range(n_circles):\n            for j in range(i + 1, n_circles):\n                if cR[i] + cR[j] > d_euc[i, j]:\n                    overlap_ratio = d_euc[i, j] / (cR[i] + cR[j])\n                    cR[i] *= overlap_ratio * 0.999999\n                    cR[j] *= overlap_ratio * 0.999999\n\n    return cC, cR, float(np.sum(cR))"]}}, "artifacts_json": "{\"stderr\": \"Stage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\", \"traceback\": \"Traceback (most recent call last):\\n  File \\\"/home/jupyter/Code/oe/dennis/run4_improved_si_temp2/evaluator.py\\\", line 384, in evaluate_stage1\\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\\n  File \\\"/home/jupyter/Code/oe/dennis/run4_improved_si_temp2/evaluator.py\\\", line 172, in run_with_timeout\\n    raise RuntimeError(f\\\"Program execution failed: {results['error']}\\\")\\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\\n\", \"failure_stage\": \"stage1_execution\", \"suggestion\": \"Check basic syntax and imports before attempting full evaluation\"}", "artifact_dir": null, "embedding": null}