{"id": "1e23e9a8-f655-4b6d-9db7-10f4356512d2", "code": "import numpy as np\n\n\ndef compute_max_radii(centers, trials=150):\n    \"\"\"\n    Maximizes the total sum of radii for fixed center positions within a unit square.\n    The problem of maximizing sum(r_i) subject to r_i + r_j <= d_ij and \n    r_i <= boundary_limit_i is a Linear Program. This function approximates the \n    optimal solution using coordinate descent with multiple expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary constraints: x, y, 1-x, 1-y\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Pairwise distances\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Mask to ignore self-interactions\n    mask = np.eye(n) * 1e10\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic and randomized orders for coordinate descent\n    # Strategic ordering allows some circles to grow large at the expense of others\n    heuristic_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(centers[:, 0] - centers[:, 1])\n    ]\n\n    for trial in range(trials):\n        if trial < len(heuristic_orders):\n            order = heuristic_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Multiple passes of expansion to converge towards a local optimum\n        for _ in range(12):\n            for i in order:\n                # Maximize r_i subject to all current neighbor constraints\n                # r_i <= d_ij - r_j  for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Finds a packing of 26 circles in a unit square that maximizes the sum of radii.\n    Uses multi-start force-directed relaxation with various target separation distances\n    and initial configurations to explore different packing topologies.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target distances (diameters) likely to yield good packing\n    target_dists = np.linspace(0.192, 0.228, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible diversity across restarts\n        np.random.seed(3000 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversified initial center layouts\n        if restart == 0:\n            # Shifted 5x5 grid + 1 circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered pattern (5-6-5-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Staggered pattern (4-6-6-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([4, 6, 6, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        else:\n            # Jittered grid or random initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n            \n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2500\n        dt_base = 0.075\n\n        for k in range(iters):\n            # Compute pairwise displacement and distance matrices\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            \n            # Repulsion force if circles overlap the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Boundary repulsion: keep centers at least r_target from edges\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Apply update with a power-based cooling schedule\n            cooling = (1.0 - k / iters) ** 1.3\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Annealing: Add decreasing stochastic noise early on\n            if k < iters * 0.6:\n                noise_scale = 0.0035 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to find maximized radii\n        radii, current_sum = compute_max_radii(centers)\n        \n        # Track the global best configuration\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")", "changes_description": null, "language": "python", "parent_id": "6e79cb57-230d-49f2-9932-96b92c5312f0", "generation": 4, "timestamp": 1771870680.8642302, "iteration_found": 80, "metrics": {"validity": 1.0, "sum_radii": 2.4805132040738065, "target_ratio": 0.9413712349426211, "combined_score": 0.9413712349426211, "radius_variance": 0.00020689308221863076, "spatial_spread": 0.18508980441497136, "eval_time": 6.479959964752197}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.4804373885217825, "target_ratio": 0.9413424624371092, "combined_score": 0.9413424624371092, "radius_variance": 0.0003007767285942396, "spatial_spread": 0.19210806795277305, "eval_time": 5.592351675033569}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.9413\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9413\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n5.59s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.480437/2.635 = 0.9413\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4804, target_ratio: 0.9413, combined_score: 0.9413, radius_variance: 0.0003, spatial_spread: 0.1921, eval_time: 5.5924\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4864, target_ratio: 0.9436, combined_score: 0.9436, radius_variance: 0.0002, spatial_spread: 0.1903, eval_time: 7.9801\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4892, target_ratio: 0.9447, combined_score: 0.9447, radius_variance: 0.0008, spatial_spread: 0.1841, eval_time: 3.1322\n- Outcome: Improvement in all metrics\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9447)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=180):\n    \"\"\"\n    Given a fixed set of center positions, this function determines the \n    radii that maximize the total sum of radii subject to no overlaps \n    and boundary constraints. It uses a coordinate descent approach \n    with multiple randomized greedy expansion orders.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        np.ndarray: (n,) array of optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders: boundary proximity, coordinate-based, and center-based\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Two passes of greedy expansion to ensure stability\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a force-directed physics \n    simulation with cooling and restarts. Each configuration is then \n    optimized for the maximum sum of radii.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    # This helps find different packing topologies (e.g., staggered rows)\n    target_dists = np.linspace(0.198, 0.218, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Set seed per restart for reproducible diversity\n        np.random.seed(42 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based or random\n        if restart == 0:\n            # 5x5 grid plus one circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Row-based staggered initialization\n            centers = []\n            rows = [5, 6, 5, 6, 4]\n            for r_idx, num_circles in enumerate(rows):\n                for c_idx in range(num_circles):\n                    centers.append([(c_idx + 0.5) / num_circles, (r_idx + 0.5) / 5])\n            centers = np.array(centers[:n])\n        else:\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        # Physics simulation: particles repel each other and square boundaries\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion force\n            overlap = np.maximum(0, t_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Boundary repulsion forces\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add decreasing noise early in the simulation\n            if k < iters * 0.6:\n                noise_scale = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process centers to solve for optimal radii\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Keep the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4892), Performs well on target_ratio (0.9447), Performs well on combined_score (0.9447), Performs well on radius_variance (0.0008), Performs well on spatial_spread (0.1841), Performs well on eval_time (3.1322)\n\n### Program 2 (Score: 0.9436)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center coordinates within \n    a unit square. Uses coordinate descent with various greedy expansion \n    orders and multiple trials to find an optimal set of radii that satisfy \n    all non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Vectorized precomputation of pairwise distances and boundary limits\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Boundary limits for each center: distance to nearest square edge\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Mask to ignore self-distance in calculations\n    mask = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: heuristic sorting and random permutations\n    orders = [\n        np.argsort(boundary_limits),\n        np.argsort(-boundary_limits),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Multiple passes ensure the radii converge to a stable local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(boundary_limits[i], np.min(dist_matrix[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a \n    force-directed physics simulation with cooling and jitter across \n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.222, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(800 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Shifted 5x5 grid with one extra circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-6-5-6-4 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Randomly jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.025, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters: iterations and initial step size\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion magnitude proportional to overlap\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Square boundary repulsion forces\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with linear cooling schedule\n            cooling = 1.0 - 0.9 * k / iters\n            dt = dt_base * cooling\n            centers += forces * dt\n\n            # Add decreasing stochastic noise to skip local minima\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Final greedy radius maximization for the current configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4864), Performs well on target_ratio (0.9436), Performs well on combined_score (0.9436), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1903), Performs well on eval_time (7.9801)\n\n### Program 3 (Score: 0.9413)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=250):\n    \"\"\"\n    Maximizes the sum of radii for fixed center positions within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    and coordinate descent passes to find a high-performing radii distribution.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a mask to ignore self-distances in minimization\n    mask = np.eye(n) * 1e10\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 15:\n            # Sort by distance from the center of the square\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        # Multiple passes of expansion to allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Radius r_i limited by walls and currently set radii of others\n                # dist(i,j) >= r_i + r_j  =>  r_i <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed\n    physics simulation with cooling and jitter to find an optimal configuration\n    for maximizing the total sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to diversify configurations\n    target_dists = np.linspace(0.190, 0.220, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Specific seeds for reproducible diversity\n        np.random.seed(2024 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered hexagonal-style rows\n            centers = []\n            row_pattern = [5, 6, 5, 6, 4]\n            for r_idx, num_c in enumerate(row_pattern):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers[:n])\n        elif restart < 8:\n            # Randomly jittered grid\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Physics simulation loop\n        iters = 2200\n        dt_base = 0.06\n\n        for k in range(iters):\n            # Pairwise repulsion calculation\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n\n            # Repulsion force if circles are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Step update with cooling schedule\n            cooling = (1.0 - k / iters)**1.2\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Annealing: Add decreasing noise early in the simulation\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4804), Performs well on target_ratio (0.9413), Performs well on combined_score (0.9413), Performs well on radius_variance (0.0003), Performs well on spatial_spread (0.1921), Performs well on eval_time (5.5924)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9398)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=160):\n    \"\"\"\n    Maximizes the sum of radii for a given set of centers within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    to find a high-performing radii distribution for fixed center positions.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e10)\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 12:\n            # Sort by distance from the center of the square to prioritize middle or edge circles\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        for i in order:\n            # The radius r_i is limited by its distance to walls and already set radii of neighbors\n            r_i = min(b_limits[i], np.min(dists[i] - radii))\n            radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the \n    total sum of radii using a force-directed physics simulation with \n    multiple restarts, diverse initial layouts, and annealing noise.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to find different packing topologies\n    target_dists = np.linspace(0.192, 0.218, 14)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions across restarts to explore the solution space\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Hexagonal-style staggered row pattern (5-6-5-6-4)\n            centers = []\n            for row_idx, num_cols in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + row_idx * 0.2\n                for col_idx in range(num_cols):\n                    centers.append([(col_idx + 0.5) / num_cols, y])\n            centers = np.array(centers)\n        elif restart < 9:\n            # Jittered grid initialization to break symmetry early\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.045, (n, 2))\n        else:\n            # Purely random initialization to find unconventional configurations\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2000\n        dt_base = 0.055\n\n        for k in range(iters):\n            # Calculate pairwise displacement vectors and distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            # Avoid self-interaction division errors\n            np.fill_diagonal(dists, 1.0)\n\n            # Inter-circle repulsion forces proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces to keep centers within viable packing regions\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update positions with power-based cooling schedule\n            cooling = (1.0 - k / iters)**1.15\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Stochastic jitter (simulated annealing) to escape local minima\n            if k < iters * 0.6:\n                noise_mag = 0.0028 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the current resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Update global best result if the current configuration is superior\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9371)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square, ensuring no overlaps and respect for boundaries.\n    Uses coordinate descent with multiple greedy expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several expansion orders to maximize the sum of radii\n    for trial in range(13):\n        radii = np.zeros(n)\n        if trial == 0:\n            order = np.arange(n)\n        elif trial == 1:\n            order = np.argsort(boundary_limits)\n        else:\n            order = np.random.permutation(n)\n\n        # Coordinate descent to solve for optimal radii for fixed centers\n        for _ in range(25):\n            for i in order:\n                # Maximum radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dist_matrix[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter, followed\n    by a greedy radii optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    iters = 1600\n    dt_base = 0.05\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple restarts\n    target_dists = np.linspace(0.198, 0.208, 10)\n    \n    for restart in range(10):\n        # Set seed for reproducibility per restart\n        np.random.seed(200 + restart)\n        target_dist = target_dists[restart]\n        \n        # Initial layout: 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n        \n        # Placement of the 26th circle varies to diversify the search\n        if restart % 3 == 0:\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            centers[25] = [0.05, 0.05]\n        else:\n            centers[25] = [0.95, 0.95]\n            \n        # Add jitter to break initial symmetry and encourage exploration\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            # Magnitude proportional to overlap distance\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with a cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n            \n            # Add small noise early in the simulation to help skip local minima\n            if k < iters * 0.6:\n                noise_mag = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Compute maximized radii for these center positions\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to run the packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9362, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=40):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the total sum of radii subject to no overlaps and\n    boundary constraints. It uses coordinate descent with multiple\n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Distance to the nearest wall for each center [x, y, 1-x, 1-y]\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    for trial in range(trials):\n        # Specific heuristic orderings followed by random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Iterative coordinate descent to grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Calculate maximum possible radius r_i given current r_j\n                mask = np.ones(n, dtype=bool)\n                mask[i] = False\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i, mask] - radii[mask]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a force-directed physics simulation \n    with varying target distances and jitter across multiple restarts.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target diameters to explore across multiple restarts\n    target_dists = [0.198, 0.201, 0.204, 0.207, 0.210, 0.213, 0.216, 0.219]\n    \n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible search per restart\n        np.random.seed(600 + restart)\n        r_target = t_dist / 2.0\n        \n        # Initial layout: 5x5 grid plus one circle in the center\n        centers = np.zeros((n, 2))\n        for i in range(25):\n            centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter helps break grid symmetry and escape local minima\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Simulation parameters\n        iters = 1600\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Vectorized pairwise repulsion forces\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            np.fill_diagonal(dists, 1.0) # Avoid self-interaction\n            \n            # Repulsion proportional to overlap distance\n            f_mag = np.maximum(0, t_dist - dists) / (dists + 1e-10)\n            np.fill_diagonal(f_mag, 0)\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Repulsion from square boundaries\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Cooling schedule for simulation convergence\n            cooling = (1.0 - k / iters)**1.5\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.5:\n                noise_scale = 0.001 * (1.0 - k / (iters * 0.5))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Optimize radii for these center positions\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.8312, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes the maximum possible radii for each circle position such that\n    no circles overlap and all stay within the unit square. Uses a greedy\n    iterative approach to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Maximum radius for each circle restricted only by the square boundaries\n    boundary_limits = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n    \n    best_radii = np.zeros(n)\n    best_sum = 0\n    \n    # Run multiple trials with different random greedy expansion orders\n    for trial in range(15):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Iteratively maximize each radius given the others\n        for _ in range(25):\n            for i in order:\n                # Radius must satisfy r_i <= boundary_limit and r_i + r_j <= dist_ij\n                limit = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        # Candidate radius given fixed neighbor j\n                        limit = min(limit, dist - radii[j])\n                radii[i] = max(0.0, limit)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize \n    the sum of radii using a force-directed physics simulation.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a structured pattern: 4 rows of 5 and 1 middle row of 6\n    centers_list = []\n    # Top and bottom rows (y=0.1, 0.3, 0.7, 0.9)\n    for y in [0.1, 0.3, 0.7, 0.9]:\n        for x in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            centers_list.append([x, y])\n    # Middle row (y=0.5) with 6 circles\n    for x in np.linspace(0.08, 0.92, 6):\n        centers_list.append([x, 0.5])\n        \n    centers = np.array(centers_list)\n    \n    # Add small jitter to break symmetry\n    centers += np.random.normal(0, 0.005, (n, 2))\n    \n    # Physics parameters: target separation distance and time step\n    dt = 0.1\n    target_dist = 0.203\n    \n    # Simulation loop to optimize center positions\n    for _ in range(3000):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            # Inter-circle repulsion\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d = np.linalg.norm(d_vec)\n                if d < target_dist:\n                    # Prevent division by zero\n                    if d < 1e-9:\n                        d_vec = np.array([0.001, 0.0])\n                        d = 0.001\n                    # Magnitude of repulsion proportional to overlap\n                    f_mag = (target_dist - d) / d\n                    forces[i] += d_vec * f_mag\n                    forces[j] -= d_vec * f_mag\n            \n            # Boundary repulsion: pushes centers away from square edges\n            r_est = target_dist / 2.0\n            if centers[i, 0] < r_est:\n                forces[i, 0] += (r_est - centers[i, 0])\n            elif centers[i, 0] > 1.0 - r_est:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - r_est))\n                \n            if centers[i, 1] < r_est:\n                forces[i, 1] += (r_est - centers[i, 1])\n            elif centers[i, 1] > 1.0 - r_est:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - r_est))\n        \n        # Apply force updates and constrain centers to the unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Annealing the step size\n        dt *= 0.999\n        \n    # Calculate optimal radii for final center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point for evaluating the packing of n=26 circles.\n    Returns (centers, radii, sum_radii).\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.8113, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using a \n    force-directed simulation and greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Initial layout: 5x5 grid plus one circle in the middle\n    centers = np.zeros((n, 2))\n    for i in range(25):\n        centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n    centers[25] = [0.5, 0.5]\n\n    # Add small jitter to break symmetry for better packing exploration\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.01, (n, 2))\n\n    # Parameters for the physics-based repulsion simulation\n    # Target distance corresponds to an average radius of ~0.1015\n    iters = 500\n    dt = 0.08\n    target_dist = 0.203\n\n    # Simulation loop: push overlapping circles apart\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = centers[i] - centers[j]\n                dist = np.sqrt(d[0]**2 + d[1]**2)\n                if dist < target_dist:\n                    # Prevent division by zero with small epsilon\n                    if dist < 1e-8:\n                        d = np.array([0.01, 0.0])\n                        dist = 0.01\n                    # Repulsion force proportional to overlap\n                    f = (target_dist - dist) / dist\n                    forces[i] += d * f\n                    forces[j] -= d * f\n        \n        centers += forces * dt\n        # Constrain centers to the unit square\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final optimized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    using proportional scaling followed by iterative greedy refinement.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii based on distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # 2. Proportionally scale radii to remove any circle-circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = np.sqrt(dx*dx + dy*dy)\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Greedy refinement to maximize the sum of radii\n    # In each step, maximize r_i given all other fixed radii\n    for _ in range(20):\n        for i in range(n):\n            # Distance to boundaries\n            m = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            # Distance to all other circles\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = np.sqrt(dx*dx + dy*dy)\n                    if dist - radii[j] < m:\n                        m = dist - radii[j]\n            radii[i] = max(0.0, m)\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=250):\n    \"\"\"\n    Maximizes the sum of radii for fixed center positions within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    and coordinate descent passes to find a high-performing radii distribution.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Use a mask to ignore self-distances in minimization\n    mask = np.eye(n) * 1e10\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 15:\n            # Sort by distance from the center of the square\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        # Multiple passes of expansion to allow radii to redistribute space\n        for _ in range(3):\n            for i in order:\n                # Radius r_i limited by walls and currently set radii of others\n                # dist(i,j) >= r_i + r_j  =>  r_i <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a multi-start force-directed\n    physics simulation with cooling and jitter to find an optimal configuration\n    for maximizing the total sum of radii.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to diversify configurations\n    target_dists = np.linspace(0.190, 0.220, 16)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Specific seeds for reproducible diversity\n        np.random.seed(2024 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered hexagonal-style rows\n            centers = []\n            row_pattern = [5, 6, 5, 6, 4]\n            for r_idx, num_c in enumerate(row_pattern):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers[:n])\n        elif restart < 8:\n            # Randomly jittered grid\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Physics simulation loop\n        iters = 2200\n        dt_base = 0.06\n\n        for k in range(iters):\n            # Pairwise repulsion calculation\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            np.fill_diagonal(dists, 1.0)\n\n            # Repulsion force if circles are closer than the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Step update with cooling schedule\n            cooling = (1.0 - k / iters)**1.2\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Annealing: Add decreasing noise early in the simulation\n            if k < iters * 0.65:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.65))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Track the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=150):\n    \"\"\"\n    Maximizes the total sum of radii for fixed center positions within a unit square.\n    The problem of maximizing sum(r_i) subject to r_i + r_j <= d_ij and \n    r_i <= boundary_limit_i is a Linear Program. This function approximates the \n    optimal solution using coordinate descent with multiple expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Boundary constraints: x, y, 1-x, 1-y\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Pairwise distances\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Mask to ignore self-interactions\n    mask = np.eye(n) * 1e10\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic and randomized orders for coordinate descent\n    # Strategic ordering allows some circles to grow large at the expense of others\n    heuristic_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(centers[:, 0] - centers[:, 1])\n    ]\n\n    for trial in range(trials):\n        if trial < len(heuristic_orders):\n            order = heuristic_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Multiple passes of expansion to converge towards a local optimum\n        for _ in range(12):\n            for i in order:\n                # Maximize r_i subject to all current neighbor constraints\n                # r_i <= d_ij - r_j  for all j\n                r_i = min(b_limits[i], np.min(dists[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Finds a packing of 26 circles in a unit square that maximizes the sum of radii.\n    Uses multi-start force-directed relaxation with various target separation distances\n    and initial configurations to explore different packing topologies.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target distances (diameters) likely to yield good packing\n    target_dists = np.linspace(0.192, 0.228, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible diversity across restarts\n        np.random.seed(3000 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversified initial center layouts\n        if restart == 0:\n            # Shifted 5x5 grid + 1 circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Staggered pattern (5-6-5-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([5, 6, 5, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        elif restart == 2:\n            # Staggered pattern (4-6-6-6-4 = 26)\n            centers = []\n            for r_idx, num_c in enumerate([4, 6, 6, 6, 4]):\n                y = (r_idx + 0.5) / 5.0\n                for c_idx in range(num_c):\n                    centers.append([(c_idx + 0.5) / num_c, y])\n            centers = np.array(centers)\n        else:\n            # Jittered grid or random initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.05, (n, 2))\n            \n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2500\n        dt_base = 0.075\n\n        for k in range(iters):\n            # Compute pairwise displacement and distance matrices\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            \n            # Repulsion force if circles overlap the target distance\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Boundary repulsion: keep centers at least r_target from edges\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            b_forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            b_forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Apply update with a power-based cooling schedule\n            cooling = (1.0 - k / iters) ** 1.3\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Annealing: Add decreasing stochastic noise early on\n            if k < iters * 0.6:\n                noise_scale = 0.0035 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process resulting centers to find maximized radii\n        radii, current_sum = compute_max_radii(centers)\n        \n        # Track the global best configuration\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"6.48s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.480513/2.635 = 0.9414\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}