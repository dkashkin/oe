{"id": "70fbb17f-ba38-4a57-991d-bfd129ccfec7", "code": "import numpy as np\n\n\"\"\"\nExpert-level circle packing for n=26 in a unit square.\nMaximizes the sum of radii using a combination of physics-based center relaxation\nand iterative coordinate descent for radius allocation.\n\"\"\"\n\n\ndef compute_max_radii(centers, trials=100):\n    \"\"\"\n    Optimizes radii for fixed center positions to maximize the sum of radii.\n    Employs randomized greedy initialization followed by coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the boundaries of the unit square\n    walls = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with large value to exclude self-comparison in vectorized operations\n    np.fill_diagonal(dists, 1e11)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Randomized Greedy Allocation\n        for i in order:\n            mask = (r > 0)\n            r_limit = walls[i]\n            if np.any(mask):\n                # Circle i must be at most dist(i,j) - r_j from any placed circle j\n                r_limit = min(r_limit, np.min(dists[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Coordinate Descent Refinement\n        # This increases individual radii while maintaining non-overlap constraints\n        for _ in range(30):\n            # Shuffling order helps escape plateau regions in sum-radii optimization\n            np.random.shuffle(order)\n            for i in order:\n                # Maximize r[i] given current radii of all other circles\n                r_limit = min(walls[i], np.min(dists[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=2200, target_r=0.100):\n    \"\"\"\n    Simulates a force-directed system to find center arrangements that maximize available space.\n    Uses non-linear repulsion and boundary constraint forces.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.016\n    damping = 0.93\n\n    for step in range(n_steps):\n        # Vectorized pairwise center differences and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=2)\n        dists = np.sqrt(dist_sq)\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: activates when circles are closer than the target diameter\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        # 1.5 exponent provides a sharper repulsion at close distances\n        force_mag = (overlap**1.5) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Container boundary forces\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Physical update with damping and simulated annealing (cooling dt)\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        if (step + 1) % 600 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Main constructor for 26-circle packing. \n    Tests multiple geometric starting layouts and relaxation parameters.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # 1. Staggered Grid (5-5-6-5-5)\n    l1 = []\n    for counts in [5, 5, 6, 5, 5]:\n        y = (len(l1) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * counts), 1.0 - 1.0 / (2 * counts), counts):\n            l1.append([x, y])\n    layouts.append(np.array(l1[:n]))\n\n    # 2. Staggered Grid (6-5-6-5-4)\n    l2 = []\n    for counts in [6, 5, 6, 5, 4]:\n        y = (len(l2) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * counts), 1.0 - 1.0 / (2 * counts), counts):\n            l2.append([x, y])\n    layouts.append(np.array(l2[:n]))\n\n    # 3. Sunflower / Phyllotaxis Arrangement\n    phi = (1.0 + 5.0**0.5) / 2.0\n    l3 = []\n    for i in range(n):\n        radius_val = 0.485 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l3.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l3))\n\n    # 4. 5x5 Grid plus one corner point\n    l4 = [[(i + 0.5) / 5.0, (j + 0.5) / 5.0] for i in range(5) for j in range(5)]\n    l4.append([0.985, 0.985])\n    layouts.append(np.array(l4))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Search through the strategy space\n    for base in layouts:\n        for t_rad in [0.098, 0.100, 0.102]:\n            # Apply slight jitter to help physics explore non-symmetric configurations\n            start_pos = np.clip(base + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start_pos, n_steps=2000, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_c, trials=80)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final intensive radius optimization pass on the best discovered centers\n    final_radii, final_sum = compute_max_radii(best_overall_centers, trials=250)\n    \n    # Tiny safety margin to ensure no overlap/boundary violations due to float precision\n    final_radii = np.maximum(final_radii - 1e-12, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Returns the final circle packing configuration.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")", "changes_description": null, "language": "python", "parent_id": "1a3b9d3e-f443-4829-9631-853c2447a2f3", "generation": 5, "timestamp": 1771871091.015461, "iteration_found": 94, "metrics": {"validity": 1.0, "sum_radii": 2.4901071766558736, "target_ratio": 0.945012211254601, "combined_score": 0.945012211254601, "radius_variance": 0.00016981589389990345, "spatial_spread": 0.18756490793430847, "eval_time": 6.681220054626465}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.4867883226573113, "target_ratio": 0.9437526841204218, "combined_score": 0.9437526841204218, "radius_variance": 7.043085843647818e-05, "spatial_spread": 0.19497736877859279, "eval_time": 9.162462949752808}, "island": 1}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.9438\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9442 \u2192 0.9438. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n9.16s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.486788/2.635 = 0.9438\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4880, target_ratio: 0.9442, combined_score: 0.9442, radius_variance: 0.0001, spatial_spread: 0.1938, eval_time: 5.4028\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4938, target_ratio: 0.9464, combined_score: 0.9464, radius_variance: 0.0000, spatial_spread: 0.1951, eval_time: 7.9484\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5015, target_ratio: 0.9493, combined_score: 0.9493, radius_variance: 0.0001, spatial_spread: 0.1861, eval_time: 7.9564\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9493)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, num_trials=100):\n    \"\"\"\n    Optimizes radii for fixed center positions to maximize the sum.\n    Uses randomized greedy allocation followed by coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dists, 1e11)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(num_trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Randomized Greedy Initial Allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                r_limit = min(r_limit, np.min(dists[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Coordinate Descent Refinement\n        for _ in range(20):\n            for i in order:\n                # Calculate max possible radius for i given all other current radii\n                r_limit = min(wall_dist[i], np.min(dists[i, :] - r))\n                # Note: np.min over dists[i,i]-r[i] is ignored by large diagonal\n                r[i] = max(0.0, r_limit)\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=3200, target_r=0.100):\n    \"\"\"\n    Physics-based force-directed simulation to optimize center placement.\n    Uses repulsion forces and wall constraints to distribute circles.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.016\n    damping = 0.93\n    target_d = 2.0 * target_r\n\n    for step in range(n_steps):\n        # Calculate pairwise differences and distances efficiently\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=2)\n        dists = np.sqrt(dist_sq)\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: push apart if centers are closer than target diameter\n        overlap = np.maximum(0, target_d - dists)\n        force_mag = (overlap**1.2) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints: push centers toward interior of the unit square\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Velocity update with damping and cooling\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Adaptive cooling schedule\n        if (step + 1) % 400 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Orchestrates the optimization of 26 circles in a unit square.\n    Tests several starting configurations and relaxation parameters.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # Layout 1: Staggered grid (5-5-6-5-5)\n    l1 = []\n    for count in [5, 5, 6, 5, 5]:\n        y = (len(l1) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l1.append([x, y])\n    layouts.append(np.array(l1[:n]))\n\n    # Layout 2: Staggered grid (6-5-6-5-4)\n    l2 = []\n    for count in [6, 5, 6, 5, 4]:\n        y = (len(l2) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l2.append([x, y])\n    layouts.append(np.array(l2[:n]))\n\n    # Layout 3: Staggered grid (5-6-5-6-4)\n    l3 = []\n    for count in [5, 6, 5, 6, 4]:\n        y = (len(l3) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l3.append([x, y])\n    layouts.append(np.array(l3[:n]))\n\n    # Layout 4: Sunflower / Phyllotaxis Pattern\n    phi = (1.0 + 5.0**0.5) / 2.0\n    l4 = []\n    for i in range(n):\n        radius_val = 0.485 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l4.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l4))\n\n    # Layout 5: 5x5 Grid plus random corner\n    l5 = []\n    for i in range(5):\n        for j in range(5):\n            l5.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    l5.append([0.98, 0.98])\n    layouts.append(np.array(l5))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Search space defined by layout and target radius parameters\n    for base in layouts:\n        for t_rad in [0.098, 0.101, 0.103]:\n            # Inject jitter to break symmetries and explore neighborhood\n            start_pos = np.clip(base + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start_pos, n_steps=3000, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_c, num_trials=100)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Ensure precision safety margin to avoid floating point overlap violations\n    final_radii = best_overall_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5015), Performs well on target_ratio (0.9493), Performs well on combined_score (0.9493), Performs well on radius_variance (0.0001), Performs well on spatial_spread (0.1861), Performs well on eval_time (7.9564)\n\n### Program 2 (Score: 0.9464)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis program uses a physics-inspired relaxation simulation with multiple\nlayout initializations and an iterative coordinate descent algorithm to\nmaximize the total sum of radii while ensuring no overlaps and boundary validity.\n\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=50):\n    \"\"\"\n    Given fixed circle center positions, find a set of radii that maximize\n    the sum of radii subject to the unit square boundary and non-overlap constraints.\n    Uses randomized greedy allocation followed by coordinate descent refinement.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances from each center to the boundaries of the unit square\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with a large value to ignore self-distance in optimization\n    np.fill_diagonal(dist_matrix, 1e12)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Randomized Greedy Initial Allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            if np.any(r > 0):\n                # Ensure the new circle doesn't overlap with already placed circles\n                r_limit = min(r_limit, np.min(dist_matrix[i, r > 0] - r[r > 0]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Coordinate Descent Refinement to maximize available slack\n        for _ in range(25):\n            for i in np.random.permutation(n):\n                # Adjust current radius i by taking the minimum gap to all other circles and walls\n                r_limit = min(wall_dist[i], np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, steps=3500, target_r=0.100):\n    \"\"\"\n    Apply a physics-inspired force-directed simulation to optimize the placement\n    of circle centers. Uses repulsion forces and wall constraints.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.012\n    damping = 0.94\n    target_d = 2.0 * target_r\n\n    for step in range(steps):\n        # Calculate pairwise differences and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: push centers apart if they are closer than target diameter\n        overlap = target_d - dists\n        force_mag = np.where(overlap > 0, overlap**1.1, 0) / (dists + 1e-9)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints: push centers toward the inner bounds of the unit square\n        # to ensure there is space for a circle of radius target_r\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Update velocity with damping and momentum\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule to settle the centers into stable configurations\n        if (step + 1) % 500 == 0:\n            dt *= 0.85\n            damping = min(0.99, damping + 0.01)\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Iterates over multiple starting layouts and target parameters to find \n    the best possible 26-circle arrangement in a unit square.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # 1. Staggered Grid (5-5-6-5-5)\n    l1 = []\n    for count in [5, 5, 6, 5, 5]:\n        y = (len(l1) // 5 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l1.append([x, y])\n    layouts.append(np.array(l1[:n]))\n\n    # 2. Staggered Grid (6-4-6-4-6)\n    l2 = []\n    for count in [6, 4, 6, 4, 6]:\n        y = (len(l2) // 5 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l2.append([x, y])\n    layouts.append(np.array(l2[:n]))\n\n    # 3. Staggered Grid (5-6-5-6-4)\n    l3 = []\n    for count in [5, 6, 5, 6, 4]:\n        y = (len(l3) // 5 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l3.append([x, y])\n    layouts.append(np.array(l3[:n]))\n\n    # 4. Sunflower / Phyllotaxis Pattern\n    phi = (1.0 + 5.0**0.5) / 2.0\n    l4 = []\n    for i in range(n):\n        radius_val = 0.49 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l4.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l4))\n\n    # 5. 5x5 Grid plus Corner\n    l5 = []\n    for i in range(5):\n        for j in range(5):\n            l5.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    l5.append([0.98, 0.98])\n    layouts.append(np.array(l5))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Search across different starting layouts and target radii\n    for base in layouts:\n        for t_rad in [0.098, 0.102, 0.105]:\n            # Inject jitter to break layout symmetries\n            start_pos = np.clip(base + np.random.normal(0, 0.005, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start_pos, steps=3500, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_c, trials=50)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Safety margin subtraction to ensure strict validity against float precision\n    final_radii = best_overall_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4938), Performs well on target_ratio (0.9464), Performs well on combined_score (0.9464), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.1951), Performs well on eval_time (7.9484)\n\n### Program 3 (Score: 0.9442)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis program maximizes the sum of radii using a multi-strategy approach:\n1.  Physics-based force-directed relaxation starting from diverse geometric layouts.\n2.  Non-linear repulsion forces and boundary constraints with an annealing schedule.\n3.  A robust randomized greedy and iterative coordinate descent radius maximization solver.\n\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=100):\n    \"\"\"\n    Given fixed circle center positions, find a set of radii that maximize\n    the sum of radii subject to the unit square boundary and non-overlap constraints.\n    Uses randomized greedy allocation followed by coordinate descent refinement.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances from each center to the boundaries of the unit square\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with a large value to ignore self-distance in optimization\n    np.fill_diagonal(dist_matrix, 1e12)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several random greedy orders to maximize the sum of radii\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(wall_dist)\n        elif t == 1:\n            order = np.argsort(-wall_dist)\n        else:\n            order = np.random.permutation(n)\n        \n        r = np.zeros(n)\n        # Phase 1: Randomized Greedy Initial Allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                # Ensure the new circle doesn't overlap with already placed circles\n                r_limit = min(r_limit, np.min(dist_matrix[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Coordinate Descent Refinement to maximize the sum\n        # The constraint is r[i] + r[j] <= dist_matrix[i, j]\n        for _ in range(25):\n            for i in order:\n                # Adjust current radius i by taking the minimum gap to all other circles and walls\n                r_limit = min(wall_dist[i], np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, steps=3200, target_r=0.101):\n    \"\"\"\n    Apply a physics-inspired force-directed simulation to optimize the placement\n    of circle centers. Uses non-linear repulsion forces and cooling.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.93\n    target_d = 2.0 * target_r\n\n    for step in range(steps):\n        # Calculate pairwise differences and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-9)\n\n        # Non-linear repulsion force: push centers apart if they are closer than target diameter\n        overlap = np.maximum(0, target_d - dists)\n        # Using overlap^1.5 to provide a stronger push as they get closer\n        force_mag = (overlap**1.5) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints: push centers toward the inner bounds of the unit square\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Update velocity with damping and momentum\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule to settle the centers into stable configurations\n        if (step + 1) % 600 == 0:\n            dt *= 0.85\n            damping = min(0.99, damping + 0.01)\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Iterates over multiple starting layouts and target parameters to find \n    the best possible 26-circle arrangement in a unit square.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # 1. Staggered Grid (5-5-6-5-5)\n    p1 = [5, 5, 6, 5, 5]\n    l1 = []\n    for i, count in enumerate(p1):\n        y = (i + 0.5) / len(p1)\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l1.append([x, y])\n    layouts.append(np.array(l1))\n\n    # 2. Staggered Grid (6-5-4-5-6)\n    p2 = [6, 5, 4, 5, 6]\n    l2 = []\n    for i, count in enumerate(p2):\n        y = (i + 0.5) / len(p2)\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l2.append([x, y])\n    layouts.append(np.array(l2))\n\n    # 3. Sunflower / Phyllotaxis Pattern\n    phi = (1.0 + 5.0**0.5) / 2.0\n    l3 = []\n    for i in range(n):\n        radius_val = 0.495 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l3.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l3))\n\n    # 4. Staggered Grid (5-6-5-6-4)\n    p4 = [5, 6, 5, 6, 4]\n    l4 = []\n    for i, count in enumerate(p4):\n        y = (i + 0.5) / len(p4)\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l4.append([x, y])\n    layouts.append(np.array(l4))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore different starting layouts and target radii for force simulation\n    for base in layouts:\n        for t_rad in [0.099, 0.102]:\n            # Inject jitter to break layout symmetries\n            start_pos = np.clip(base + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start_pos, steps=3000, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_c, trials=80)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final higher-intensity radius refinement for the best arrangement found\n    final_radii, final_sum = compute_max_radii(best_overall_centers, trials=250)\n    \n    # Subtract a tiny safety margin to ensure strict validity against float precision\n    final_radii = final_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4880), Performs well on target_ratio (0.9442), Performs well on combined_score (0.9442), Performs well on radius_variance (0.0001), Performs well on spatial_spread (0.1938), Performs well on eval_time (5.4028)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9440)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles.\nUses a physics-based relaxation routine and a randomized coordinate descent solver \nto maximize the sum of radii within a unit square.\n\"\"\"\nimport numpy as np\n\n\ndef get_max_radii(centers, num_trials=80):\n    \"\"\"\n    Finds a set of radii that maximize the sum for fixed center positions.\n    Uses randomized greedy allocation followed by iterative coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the boundaries\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dist_matrix, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(num_trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Greedy initial allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                r_limit = min(r_limit, np.min(dist_matrix[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Refine using coordinate descent\n        for _ in range(20):\n            for i in order:\n                r_limit = wall_dist[i]\n                r_limit = min(r_limit, np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=3200, target_r=0.100):\n    \"\"\"\n    Physics-based force-directed simulation to optimize center placement.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.93\n\n    for step in range(n_steps):\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-8)\n\n        # Repulsion force\n        overlap = (2.0 * target_r) - dists\n        force_mag = np.maximum(0, overlap) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Velocity update\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling\n        if (step + 1) % 400 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles in a unit square using multiple starting layouts.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # Layout 1: Staggered grid (5-5-6-5-5)\n    l1 = []\n    for i, count in enumerate([5, 5, 6, 5, 5]):\n        y = (i + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l1.append([x, y])\n    layouts.append(np.array(l1))\n\n    # Layout 2: Sunflower / Phyllotaxis pattern\n    l2 = []\n    phi = (1.0 + 5.0**0.5) / 2.0\n    for i in range(n):\n        radius_val = 0.48 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l2.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l2))\n\n    # Layout 3: 5x5 Grid + 1 center\n    l3 = []\n    for i in range(5):\n        for j in range(5):\n            l3.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    l3.append([0.5, 0.5])\n    layouts.append(np.array(l3))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    for base_layout in layouts:\n        for t_rad in [0.098, 0.101, 0.104]:\n            # Jitter to allow asymmetrical evolution\n            start = np.clip(base_layout + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start, target_r=t_rad)\n            radii, current_sum = get_max_radii(refined_c, num_trials=60)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final safety margin for strict validity\n    final_radii = best_overall_radii - 1e-13\n    final_radii = np.maximum(final_radii, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9438)\n```python\nimport numpy as np\n\n\"\"\"\nConstructor-based circle packing for n=26 circles.\nUses a physics-based relaxation routine and a randomized coordinate descent solver \nto maximize the sum of radii within a unit square.\n\"\"\"\n\n\ndef get_max_radii(centers, trials=100):\n    \"\"\"\n    Finds a set of radii that maximize the sum for fixed center positions.\n    Uses randomized greedy allocation followed by iterative coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the boundaries\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dist_matrix, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Greedy initial allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                r_limit = min(r_limit, np.min(dist_matrix[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Refine using coordinate descent\n        for _ in range(25):\n            for i in order:\n                # Optimized update: r[i] is limited by walls and other circles\n                r_limit = min(wall_dist[i], np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=3500, target_r=0.100):\n    \"\"\"\n    Physics-based force-directed simulation to optimize center placement.\n    Uses repulsion forces, boundary constraints, and momentum damping.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.93\n\n    for step in range(n_steps):\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-8)\n\n        # Repulsion force push centers apart based on target diameter\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        force_mag = overlap / (dists + 1e-9)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints: keep centers away from the square edges\n        for d in range(2):\n            forces[:, d] += np.where(centers[:, d] < target_r, target_r - centers[:, d], 0)\n            forces[:, d] -= np.where(centers[:, d] > 1.0 - target_r, centers[:, d] - (1.0 - target_r), 0)\n\n        # Velocity update and coordinate adjustment\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule for the time step to allow convergence\n        if (step + 1) % 500 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles in a unit square using multiple strategic starting layouts.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # Strategy 1: Staggered grids with various row configurations\n    for p in [[5, 5, 6, 5, 5], [6, 4, 6, 4, 6], [4, 6, 6, 6, 4]]:\n        coords = []\n        for i, count in enumerate(p):\n            y = (i + 0.5) / len(p)\n            for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n                coords.append([x, y])\n        layouts.append(np.array(coords))\n\n    # Strategy 2: Sunflower (Phyllotaxis) pattern for uniform radial spread\n    phi = (1.0 + 5.0**0.5) / 2.0\n    sun_layout = []\n    for i in range(n):\n        radius_val = 0.48 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        sun_layout.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(sun_layout))\n\n    # Strategy 3: 5x5 Grid with an extra circle at a strategic point\n    grid5x5 = []\n    for i in range(5):\n        for j in range(5):\n            grid5x5.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    grid5x5.append([0.98, 0.98])\n    layouts.append(np.array(grid5x5))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore variations of each base layout\n    for base_layout in layouts:\n        for t_rad in [0.098, 0.101, 0.104]:\n            # Jitter starting positions to allow asymmetric evolution during relaxation\n            start = np.clip(base_layout + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start, target_r=t_rad)\n            radii, current_sum = get_max_radii(refined_c, trials=80)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final polish with more trials for the best configuration found\n    final_radii, final_sum = get_max_radii(best_overall_centers, trials=250)\n    \n    # Subtract a tiny safety margin to ensure no boundary or overlap violations\n    final_radii = np.maximum(final_radii - 1e-12, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9440, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles.\nUses a physics-based relaxation routine and a randomized coordinate descent solver \nto maximize the sum of radii within a unit square.\n\"\"\"\nimport numpy as np\n\n\ndef get_max_radii(centers, num_trials=80):\n    \"\"\"\n    Finds a set of radii that maximize the sum for fixed center positions.\n    Uses randomized greedy allocation followed by iterative coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the boundaries\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dist_matrix, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(num_trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Greedy initial allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                r_limit = min(r_limit, np.min(dist_matrix[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Refine using coordinate descent\n        for _ in range(20):\n            for i in order:\n                r_limit = wall_dist[i]\n                r_limit = min(r_limit, np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=3200, target_r=0.100):\n    \"\"\"\n    Physics-based force-directed simulation to optimize center placement.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.93\n\n    for step in range(n_steps):\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-8)\n\n        # Repulsion force\n        overlap = (2.0 * target_r) - dists\n        force_mag = np.maximum(0, overlap) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Velocity update\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling\n        if (step + 1) % 400 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles in a unit square using multiple starting layouts.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # Layout 1: Staggered grid (5-5-6-5-5)\n    l1 = []\n    for i, count in enumerate([5, 5, 6, 5, 5]):\n        y = (i + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l1.append([x, y])\n    layouts.append(np.array(l1))\n\n    # Layout 2: Sunflower / Phyllotaxis pattern\n    l2 = []\n    phi = (1.0 + 5.0**0.5) / 2.0\n    for i in range(n):\n        radius_val = 0.48 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l2.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l2))\n\n    # Layout 3: 5x5 Grid + 1 center\n    l3 = []\n    for i in range(5):\n        for j in range(5):\n            l3.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    l3.append([0.5, 0.5])\n    layouts.append(np.array(l3))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    for base_layout in layouts:\n        for t_rad in [0.098, 0.101, 0.104]:\n            # Jitter to allow asymmetrical evolution\n            start = np.clip(base_layout + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start, target_r=t_rad)\n            radii, current_sum = get_max_radii(refined_c, num_trials=60)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final safety margin for strict validity\n    final_radii = best_overall_radii - 1e-13\n    final_radii = np.maximum(final_radii, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9442, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis program maximizes the sum of radii using a multi-strategy approach:\n1.  Physics-based force-directed relaxation starting from diverse geometric layouts.\n2.  Non-linear repulsion forces and boundary constraints with an annealing schedule.\n3.  A robust randomized greedy and iterative coordinate descent radius maximization solver.\n\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=100):\n    \"\"\"\n    Given fixed circle center positions, find a set of radii that maximize\n    the sum of radii subject to the unit square boundary and non-overlap constraints.\n    Uses randomized greedy allocation followed by coordinate descent refinement.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances from each center to the boundaries of the unit square\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with a large value to ignore self-distance in optimization\n    np.fill_diagonal(dist_matrix, 1e12)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several random greedy orders to maximize the sum of radii\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(wall_dist)\n        elif t == 1:\n            order = np.argsort(-wall_dist)\n        else:\n            order = np.random.permutation(n)\n        \n        r = np.zeros(n)\n        # Phase 1: Randomized Greedy Initial Allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                # Ensure the new circle doesn't overlap with already placed circles\n                r_limit = min(r_limit, np.min(dist_matrix[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Coordinate Descent Refinement to maximize the sum\n        # The constraint is r[i] + r[j] <= dist_matrix[i, j]\n        for _ in range(25):\n            for i in order:\n                # Adjust current radius i by taking the minimum gap to all other circles and walls\n                r_limit = min(wall_dist[i], np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, steps=3200, target_r=0.101):\n    \"\"\"\n    Apply a physics-inspired force-directed simulation to optimize the placement\n    of circle centers. Uses non-linear repulsion forces and cooling.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.93\n    target_d = 2.0 * target_r\n\n    for step in range(steps):\n        # Calculate pairwise differences and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-9)\n\n        # Non-linear repulsion force: push centers apart if they are closer than target diameter\n        overlap = np.maximum(0, target_d - dists)\n        # Using overlap^1.5 to provide a stronger push as they get closer\n        force_mag = (overlap**1.5) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints: push centers toward the inner bounds of the unit square\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Update velocity with damping and momentum\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule to settle the centers into stable configurations\n        if (step + 1) % 600 == 0:\n            dt *= 0.85\n            damping = min(0.99, damping + 0.01)\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Iterates over multiple starting layouts and target parameters to find \n    the best possible 26-circle arrangement in a unit square.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # 1. Staggered Grid (5-5-6-5-5)\n    p1 = [5, 5, 6, 5, 5]\n    l1 = []\n    for i, count in enumerate(p1):\n        y = (i + 0.5) / len(p1)\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l1.append([x, y])\n    layouts.append(np.array(l1))\n\n    # 2. Staggered Grid (6-5-4-5-6)\n    p2 = [6, 5, 4, 5, 6]\n    l2 = []\n    for i, count in enumerate(p2):\n        y = (i + 0.5) / len(p2)\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l2.append([x, y])\n    layouts.append(np.array(l2))\n\n    # 3. Sunflower / Phyllotaxis Pattern\n    phi = (1.0 + 5.0**0.5) / 2.0\n    l3 = []\n    for i in range(n):\n        radius_val = 0.495 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l3.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l3))\n\n    # 4. Staggered Grid (5-6-5-6-4)\n    p4 = [5, 6, 5, 6, 4]\n    l4 = []\n    for i, count in enumerate(p4):\n        y = (i + 0.5) / len(p4)\n        for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n            l4.append([x, y])\n    layouts.append(np.array(l4))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore different starting layouts and target radii for force simulation\n    for base in layouts:\n        for t_rad in [0.099, 0.102]:\n            # Inject jitter to break layout symmetries\n            start_pos = np.clip(base + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start_pos, steps=3000, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_c, trials=80)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final higher-intensity radius refinement for the best arrangement found\n    final_radii, final_sum = compute_max_radii(best_overall_centers, trials=250)\n    \n    # Subtract a tiny safety margin to ensure strict validity against float precision\n    final_radii = final_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9422, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=100):\n    \"\"\"\n    Given fixed center positions, find a set of radii that maximize\n    the sum while satisfying the non-overlap and boundary constraints.\n    Uses randomized greedy allocation followed by coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the four walls of the unit square\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dists, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several random greedy orders to maximize the sum of radii\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Phase 1: Greedy allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            # Use vectorization to find the minimum possible radius for i\n            # given already assigned radii in r\n            mask = r > 0\n            if np.any(mask):\n                r_limit = min(r_limit, np.min(dists[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n            \n        # Phase 2: Iterative coordinate descent refinement to optimize slack\n        for _ in range(25):\n            for i in order:\n                r_limit = wall_dist[i]\n                # Find best r[i] given all other r[j]\n                r_limit = min(r_limit, np.min(dists[i, :] - r[:]))\n                # Note: np.min(dists[i] - r) includes i, but dists[i,i] is 1e10\n                r[i] = max(0.0, r_limit)\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=3500, target_r=0.1015):\n    \"\"\"\n    Apply a physics-inspired force-directed simulation to optimize\n    the placement of circle centers for maximizing available radius space.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.94\n\n    for step in range(n_steps):\n        # Pairwise repulsion calculation\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: push apart if centers are closer than 2*target_r\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        # Force inversely proportional to distance to prevent explosion\n        force_mag = overlap / (dists + 1e-6)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Square boundary constraints: push centers towards the inner bounds [target_r, 1-target_r]\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Update velocity and apply damping\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule for convergence and precision\n        if (step + 1) % 500 == 0:\n            dt *= 0.85\n            damping += 0.01\n            damping = min(damping, 0.99)\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement of 26 circles in a unit square.\n    Iterates over multiple diverse layout initializations and performs\n    physics-based relaxation to maximize the total sum of radii.\n    \"\"\"\n    n = 26\n    np.random.seed(55)\n\n    layouts = []\n    \n    # Pattern 1: Staggered grid (5, 5, 6, 5, 5)\n    p1 = [5, 5, 6, 5, 5]\n    coords1 = []\n    for i, count in enumerate(p1):\n        y = (i + 0.5) / len(p1)\n        x_range = np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count)\n        for x in x_range:\n            coords1.append([x, y])\n    layouts.append(np.array(coords1))\n\n    # Pattern 2: Staggered grid (6, 4, 6, 4, 6)\n    p2 = [6, 4, 6, 4, 6]\n    coords2 = []\n    for i, count in enumerate(p2):\n        y = (i + 0.5) / len(p2)\n        x_range = np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count)\n        for x in x_range:\n            coords2.append([x, y])\n    layouts.append(np.array(coords2))\n\n    # Pattern 3: Modified sunflower layout\n    phi = (1.0 + 5.0**0.5) / 2.0\n    theta_step = 2.0 * np.pi / (phi**2)\n    sunflower = []\n    for i in range(n):\n        r_val = 0.49 * np.sqrt((i + 0.5) / n)\n        theta = i * theta_step\n        sunflower.append([0.5 + r_val * np.cos(theta), 0.5 + r_val * np.sin(theta)])\n    layouts.append(np.array(sunflower))\n\n    # Pattern 4: 5x5 grid plus one corner circle\n    grid5x5 = []\n    for i in range(5):\n        for j in range(5):\n            grid5x5.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    grid5x5.append([0.98, 0.98])\n    layouts.append(np.array(grid5x5))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore each layout with slightly varied target radii parameters\n    for base_layout in layouts:\n        for t_rad in [0.0985, 0.1005, 0.1025]:\n            # Apply slight jitter to break layout symmetries\n            start_pos = np.clip(base_layout + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_centers = relax_centers(start_pos, n_steps=3500, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_centers, trials=120)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_centers\n                best_overall_radii = radii\n\n    # Final precision safety margin\n    final_radii = best_overall_radii - 1e-12\n    final_radii = np.maximum(final_radii, 0.0)\n\n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point for the packing algorithm.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\n# EVOLVE-BLOCK-END\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\n\n\"\"\"\nConstructor-based circle packing for n=26 circles.\nUses a physics-based relaxation routine and a randomized coordinate descent solver \nto maximize the sum of radii within a unit square.\n\"\"\"\n\n\ndef get_max_radii(centers, trials=100):\n    \"\"\"\n    Finds a set of radii that maximize the sum for fixed center positions.\n    Uses randomized greedy allocation followed by iterative coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the boundaries\n    wall_dist = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=2))\n    np.fill_diagonal(dist_matrix, 1e10)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Greedy initial allocation\n        for i in order:\n            r_limit = wall_dist[i]\n            mask = (r > 0)\n            if np.any(mask):\n                r_limit = min(r_limit, np.min(dist_matrix[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Refine using coordinate descent\n        for _ in range(25):\n            for i in order:\n                # Optimized update: r[i] is limited by walls and other circles\n                r_limit = min(wall_dist[i], np.min(dist_matrix[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        curr_sum = np.sum(r)\n        if curr_sum > best_sum:\n            best_sum = curr_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=3500, target_r=0.100):\n    \"\"\"\n    Physics-based force-directed simulation to optimize center placement.\n    Uses repulsion forces, boundary constraints, and momentum damping.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.015\n    damping = 0.93\n\n    for step in range(n_steps):\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dists = np.sqrt(np.sum(diffs**2, axis=2))\n        np.fill_diagonal(dists, 1e-8)\n\n        # Repulsion force push centers apart based on target diameter\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        force_mag = overlap / (dists + 1e-9)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Boundary constraints: keep centers away from the square edges\n        for d in range(2):\n            forces[:, d] += np.where(centers[:, d] < target_r, target_r - centers[:, d], 0)\n            forces[:, d] -= np.where(centers[:, d] > 1.0 - target_r, centers[:, d] - (1.0 - target_r), 0)\n\n        # Velocity update and coordinate adjustment\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Cooling schedule for the time step to allow convergence\n        if (step + 1) % 500 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles in a unit square using multiple strategic starting layouts.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # Strategy 1: Staggered grids with various row configurations\n    for p in [[5, 5, 6, 5, 5], [6, 4, 6, 4, 6], [4, 6, 6, 6, 4]]:\n        coords = []\n        for i, count in enumerate(p):\n            y = (i + 0.5) / len(p)\n            for x in np.linspace(1.0 / (2 * count), 1.0 - 1.0 / (2 * count), count):\n                coords.append([x, y])\n        layouts.append(np.array(coords))\n\n    # Strategy 2: Sunflower (Phyllotaxis) pattern for uniform radial spread\n    phi = (1.0 + 5.0**0.5) / 2.0\n    sun_layout = []\n    for i in range(n):\n        radius_val = 0.48 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        sun_layout.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(sun_layout))\n\n    # Strategy 3: 5x5 Grid with an extra circle at a strategic point\n    grid5x5 = []\n    for i in range(5):\n        for j in range(5):\n            grid5x5.append([(i + 0.5) / 5.0, (j + 0.5) / 5.0])\n    grid5x5.append([0.98, 0.98])\n    layouts.append(np.array(grid5x5))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore variations of each base layout\n    for base_layout in layouts:\n        for t_rad in [0.098, 0.101, 0.104]:\n            # Jitter starting positions to allow asymmetric evolution during relaxation\n            start = np.clip(base_layout + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start, target_r=t_rad)\n            radii, current_sum = get_max_radii(refined_c, trials=80)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final polish with more trials for the best configuration found\n    final_radii, final_sum = get_max_radii(best_overall_centers, trials=250)\n    \n    # Subtract a tiny safety margin to ensure no boundary or overlap violations\n    final_radii = np.maximum(final_radii - 1e-12, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Execution entry point.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\"\"\"\nExpert-level circle packing for n=26 in a unit square.\nMaximizes the sum of radii using a combination of physics-based center relaxation\nand iterative coordinate descent for radius allocation.\n\"\"\"\n\n\ndef compute_max_radii(centers, trials=100):\n    \"\"\"\n    Optimizes radii for fixed center positions to maximize the sum of radii.\n    Employs randomized greedy initialization followed by coordinate descent.\n    \"\"\"\n    n = centers.shape[0]\n    # Distances to the boundaries of the unit square\n    walls = np.min(np.hstack([centers, 1.0 - centers]), axis=1)\n    # Pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal with large value to exclude self-comparison in vectorized operations\n    np.fill_diagonal(dists, 1e11)\n\n    best_r = np.zeros(n)\n    best_sum = -1.0\n\n    for _ in range(trials):\n        r = np.zeros(n)\n        order = np.random.permutation(n)\n        # Phase 1: Randomized Greedy Allocation\n        for i in order:\n            mask = (r > 0)\n            r_limit = walls[i]\n            if np.any(mask):\n                # Circle i must be at most dist(i,j) - r_j from any placed circle j\n                r_limit = min(r_limit, np.min(dists[i, mask] - r[mask]))\n            r[i] = max(0.0, r_limit)\n        \n        # Phase 2: Coordinate Descent Refinement\n        # This increases individual radii while maintaining non-overlap constraints\n        for _ in range(30):\n            # Shuffling order helps escape plateau regions in sum-radii optimization\n            np.random.shuffle(order)\n            for i in order:\n                # Maximize r[i] given current radii of all other circles\n                r_limit = min(walls[i], np.min(dists[i, :] - r))\n                r[i] = max(0.0, r_limit)\n\n        current_sum = np.sum(r)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_r = r.copy()\n\n    return best_r, best_sum\n\n\ndef relax_centers(initial_centers, n_steps=2200, target_r=0.100):\n    \"\"\"\n    Simulates a force-directed system to find center arrangements that maximize available space.\n    Uses non-linear repulsion and boundary constraint forces.\n    \"\"\"\n    centers = initial_centers.copy()\n    velocity = np.zeros_like(centers)\n    dt = 0.016\n    damping = 0.93\n\n    for step in range(n_steps):\n        # Vectorized pairwise center differences and distances\n        diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n        dist_sq = np.sum(diffs**2, axis=2)\n        dists = np.sqrt(dist_sq)\n        np.fill_diagonal(dists, 1e-9)\n\n        # Repulsion force: activates when circles are closer than the target diameter\n        overlap = np.maximum(0, (2.0 * target_r) - dists)\n        # 1.5 exponent provides a sharper repulsion at close distances\n        force_mag = (overlap**1.5) / (dists + 1e-8)\n        forces = np.sum(diffs * force_mag[:, :, np.newaxis], axis=1)\n\n        # Container boundary forces\n        forces[:, 0] += np.where(centers[:, 0] < target_r, target_r - centers[:, 0], 0)\n        forces[:, 0] -= np.where(centers[:, 0] > 1.0 - target_r, centers[:, 0] - (1.0 - target_r), 0)\n        forces[:, 1] += np.where(centers[:, 1] < target_r, target_r - centers[:, 1], 0)\n        forces[:, 1] -= np.where(centers[:, 1] > 1.0 - target_r, centers[:, 1] - (1.0 - target_r), 0)\n\n        # Physical update with damping and simulated annealing (cooling dt)\n        velocity = velocity * damping + forces * dt\n        centers += velocity\n        centers = np.clip(centers, 0.0, 1.0)\n\n        if (step + 1) % 600 == 0:\n            dt *= 0.85\n\n    return centers\n\n\ndef construct_packing():\n    \"\"\"\n    Main constructor for 26-circle packing. \n    Tests multiple geometric starting layouts and relaxation parameters.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    layouts = []\n\n    # 1. Staggered Grid (5-5-6-5-5)\n    l1 = []\n    for counts in [5, 5, 6, 5, 5]:\n        y = (len(l1) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * counts), 1.0 - 1.0 / (2 * counts), counts):\n            l1.append([x, y])\n    layouts.append(np.array(l1[:n]))\n\n    # 2. Staggered Grid (6-5-6-5-4)\n    l2 = []\n    for counts in [6, 5, 6, 5, 4]:\n        y = (len(l2) // 5.2 + 0.5) / 5.0\n        for x in np.linspace(1.0 / (2 * counts), 1.0 - 1.0 / (2 * counts), counts):\n            l2.append([x, y])\n    layouts.append(np.array(l2[:n]))\n\n    # 3. Sunflower / Phyllotaxis Arrangement\n    phi = (1.0 + 5.0**0.5) / 2.0\n    l3 = []\n    for i in range(n):\n        radius_val = 0.485 * np.sqrt((i + 0.5) / n)\n        theta = 2.0 * np.pi * i / (phi**2)\n        l3.append([0.5 + radius_val * np.cos(theta), 0.5 + radius_val * np.sin(theta)])\n    layouts.append(np.array(l3))\n\n    # 4. 5x5 Grid plus one corner point\n    l4 = [[(i + 0.5) / 5.0, (j + 0.5) / 5.0] for i in range(5) for j in range(5)]\n    l4.append([0.985, 0.985])\n    layouts.append(np.array(l4))\n\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Search through the strategy space\n    for base in layouts:\n        for t_rad in [0.098, 0.100, 0.102]:\n            # Apply slight jitter to help physics explore non-symmetric configurations\n            start_pos = np.clip(base + np.random.normal(0, 0.003, (n, 2)), 0.0, 1.0)\n            refined_c = relax_centers(start_pos, n_steps=2000, target_r=t_rad)\n            radii, current_sum = compute_max_radii(refined_c, trials=80)\n\n            if current_sum > best_overall_sum:\n                best_overall_sum = current_sum\n                best_overall_centers = refined_c\n                best_overall_radii = radii\n\n    # Final intensive radius optimization pass on the best discovered centers\n    final_radii, final_sum = compute_max_radii(best_overall_centers, trials=250)\n    \n    # Tiny safety margin to ensure no overlap/boundary violations due to float precision\n    final_radii = np.maximum(final_radii - 1e-12, 0.0)\n    \n    return best_overall_centers, final_radii, np.sum(final_radii)\n\n\ndef run_packing():\n    \"\"\"Returns the final circle packing configuration.\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii for n=26: {sum_radii:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"6.68s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.490107/2.635 = 0.9450\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}