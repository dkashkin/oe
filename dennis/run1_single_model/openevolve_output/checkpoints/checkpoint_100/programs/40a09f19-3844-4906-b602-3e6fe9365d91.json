{"id": "40a09f19-3844-4906-b602-3e6fe9365d91", "code": "import numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts, buffer=1e-11):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    \"\"\"\n    n = pts.shape[0]\n    # Minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.sqrt(np.sum(diffs**2, axis=1))\n    num_pairs = len(i_idx)\n    \n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n (boundary constraints per circle)\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    b_ub[:num_pairs] = np.maximum(0, dists - buffer)\n        \n    # Boundary constraints: interleaved per circle (x, 1-x, y, 1-y)\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n    \n    x, y = pts[:, 0], pts[:, 1]\n    b_ub[num_pairs::4] = np.maximum(0, x - buffer)\n    b_ub[num_pairs+1::4] = np.maximum(0, 1.0 - x - buffer)\n    b_ub[num_pairs+2::4] = np.maximum(0, y - buffer)\n    b_ub[num_pairs+3::4] = np.maximum(0, 1.0 - y - buffer)\n        \n    try:\n        # HiGHS solver is efficient and provides sensitivities (marginals)\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            if res.ineqlin.marginals is not None:\n                return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return None, None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles to maximize sum of radii using multi-start and dual-gradient descent.\n    The gradient is derived from the sensitivity of the LP objective to center movements.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Diverse initial layouts to explore different packing topologies\n    inits = []\n    \n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n    \n    # 2: 6x4 Grid with two circles on the side\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx2.ravel(), gy2.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n    \n    # 3: Staggered layers to cover the square densely\n    for layers in [[5, 4, 5, 4, 5, 3], [6, 5, 6, 5, 4], [7, 6, 7, 6], [6, 7, 6, 7], [4, 5, 4, 5, 4, 4]]:\n        c = []\n        for r_idx, n_row in enumerate(layers):\n            for i_idx in range(n_row):\n                c.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n        inits.append(np.array(c)[:n])\n        \n    # 4: Concentric Ring layouts\n    for ring_counts in [[1, 8, 17], [1, 7, 18]]:\n        c_ring = [[0.5, 0.5]]\n        for rad, count in [(0.23, ring_counts[1]), (0.45, ring_counts[2])]:\n            for i in range(count):\n                a = 2 * np.pi * i / count\n                c_ring.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n        inits.append(np.array(c_ring)[:n])\n        \n    # 5: Fibonacci Spiral / Phyllotaxis\n    phi = (1 + 5**0.5) / 2\n    spir = np.array([[0.5 + 0.46 * np.sqrt((i + 0.5) / n) * np.cos(2 * np.pi * i / phi**2),\n                      0.5 + 0.46 * np.sqrt((i + 0.5) / n) * np.sin(2 * np.pi * i / phi**2)] \n                      for i in range(n)])\n    inits.append(spir)\n    \n    # 6: Randomized starts\n    np.random.seed(42)\n    for _ in range(3):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Multi-start optimization loop\n    for c_start in inits:\n        if time.time() - start_time > 560:\n            break\n            \n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.02\n        \n        for step in range(400):\n            # Check for wall-clock time limit inside the iteration loop\n            if step % 20 == 0 and time.time() - start_time > 560:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Use dual variables (marginal sensitivities) to compute gradient\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Gradients from pairwise distance sensitivity (pushing centers apart)\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                # Direction of movement scaled by sensitivity to distance\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (dists[active_p, np.newaxis] + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Gradients from boundary sensitivity (pushing centers away from walls)\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]\n            grad[:, 1] += mus[:, 2] - mus[:, 3]\n            \n            # Apply normalized gradient update for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Keep centers within the square and decay the learning rate\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.995\n            \n    # Final cleanup solve for the absolute best configuration found\n    if best_centers is not None:\n        final_radii, _, _, _, _ = solve_max_radii(best_centers, buffer=1e-11)\n        return best_centers, final_radii, np.sum(final_radii)\n    \n    return np.random.uniform(0.1, 0.9, (n, 2)), np.zeros(n), 0.0\n\ndef run_packing():\n    \"\"\"Standard entry point for circle packing evaluations.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")", "changes_description": null, "language": "python", "parent_id": "7b759b8b-3b78-41a8-b026-31a815a7d012", "generation": 4, "timestamp": 1771871046.1209517, "iteration_found": 96, "metrics": {"validity": 1.0, "sum_radii": 2.5650008129394744, "target_ratio": 0.973434843620294, "combined_score": 0.973434843620294, "radius_variance": 0.008967268765584546, "spatial_spread": 0.16596500618577234, "eval_time": 10.706843137741089}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.542227022812729, "target_ratio": 0.9647920390181136, "combined_score": 0.9647920390181136, "radius_variance": 0.007794240514363774, "spatial_spread": 0.16376926453139745, "eval_time": 4.148847579956055}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.9648\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9842 \u2192 0.9648. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n4.15s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.542227/2.635 = 0.9648\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n### stdout\n```\nExcellent packing! Achieved 96.5% of target value\n```\n\n### radius_stats\n```\nMin: 0.058912, Max: 0.173239, Avg: 0.097778\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.5933, target_ratio: 0.9842, combined_score: 0.9842, radius_variance: 0.0069, spatial_spread: 0.1838, eval_time: 26.6645\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6037, target_ratio: 0.9881, combined_score: 0.9881, radius_variance: 0.0063, spatial_spread: 0.2144, eval_time: 9.8361\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6039, target_ratio: 0.9882, combined_score: 0.9882, radius_variance: 0.0061, spatial_spread: 0.2136, eval_time: 8.2493\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9882)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    Returns optimal radii, dual variables (marginals), and pairwise info.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.sqrt(np.sum(diffs**2, axis=1))\n    num_pairs = len(i_idx)\n    \n    # Combined pairwise and boundary constraints into one A_ub matrix\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    b_ub[:num_pairs] = dists - 1e-11\n        \n    # Boundary constraints: interleaved per circle (x, 1-x, y, 1-y)\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n    \n    x, y = pts[:, 0], pts[:, 1]\n    b_ub[num_pairs::4] = x - 1e-11\n    b_ub[num_pairs+1::4] = 1.0 - x - 1e-11\n    b_ub[num_pairs+2::4] = y - 1e-11\n    b_ub[num_pairs+3::4] = 1.0 - y - 1e-11\n    \n    # Ensure bounds are non-negative for the solver\n    b_ub = np.maximum(b_ub, 0)\n        \n    try:\n        # HiGHS solver is efficient for large sets of constraints\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return None, None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles to maximize sum of radii using multi-start and dual-gradient descent.\n    The gradient is derived from the sensitivity of the LP objective to center movements.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Diverse initial layouts: grids, hexagonal staggered layers, rings, and spirals\n    inits = []\n    \n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n    \n    # 2: Hexagonal Layered (5, 4, 5, 4, 5, 3)\n    c2 = []\n    for r_idx, n_row in enumerate([5, 4, 5, 4, 5, 3]):\n        for i_idx in range(n_row):\n            c2.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c2))\n    \n    # 3: Hexagonal Layered (4, 5, 4, 5, 4, 4)\n    c3 = []\n    for r_idx, n_row in enumerate([4, 5, 4, 5, 4, 4]):\n        for i_idx in range(n_row):\n            c3.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c3))\n\n    # 4: Hexagonal Layered (6, 7, 6, 7)\n    c4 = []\n    for r_idx, n_row in enumerate([6, 7, 6, 7]):\n        for i_idx in range(n_row):\n            c4.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 4])\n    inits.append(np.array(c4))\n\n    # 5: Ring distribution (1 center, 8 middle, 17 outer)\n    c5 = [[0.5, 0.5]]\n    for rad, count in [(0.23, 8), (0.45, 17)]:\n        for i in range(count):\n            angle = 2 * np.pi * i / count\n            c5.append([0.5 + rad * np.cos(angle), 0.5 + rad * np.sin(angle)])\n    inits.append(np.array(c5))\n    \n    # 6: Phyllotaxis Spiral\n    phi = (1 + 5**0.5) / 2\n    c6 = []\n    for i in range(n):\n        radius = 0.46 * np.sqrt((i + 0.5) / n)\n        theta = 2 * np.pi * i / (phi**2)\n        c6.append([0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)])\n    inits.append(np.array(c6))\n\n    # 7: Randomized variations\n    np.random.seed(42)\n    inits.append(np.clip(inits[0] + np.random.normal(0, 0.03, (n, 2)), 0.05, 0.95))\n    inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n    \n    # Multi-start optimization loop\n    for c_start in inits:\n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.015  # Learning rate\n        \n        for step in range(500):\n            # Respect construction time limit\n            if time.time() - start_time > 570:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if radii is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Sensitivity gradient from dual variables\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Influence from touching circles\n            lams_p = lambdas[:num_pairs]\n            diffs = curr_c[i_idx] - curr_c[j_idx]\n            g_vals = lams_p[:, np.newaxis] * diffs / (dists[:, np.newaxis] + 1e-15)\n            np.add.at(grad, i_idx, g_vals)\n            np.add.at(grad, j_idx, -g_vals)\n            \n            # Influence from wall contacts\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]\n            grad[:, 1] += mus[:, 2] - mus[:, 3]\n            \n            # Gradient normalization for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Maintain valid domain and decay step size\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.994\n            \n    # Re-solve one last time for the absolute best centers found\n    final_radii, _, _, _, _ = solve_max_radii(best_centers)\n    return best_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Standard entry point for circle packing evaluations.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6039), Performs well on target_ratio (0.9882), Performs well on combined_score (0.9882), Performs well on radius_variance (0.0061), Performs well on spatial_spread (0.2136), Performs well on eval_time (8.2493)\n\n### Program 2 (Score: 0.9881)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    Returns optimal radii, dual variables (marginals), and pairwise info.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n\n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.sqrt(np.sum(diffs**2, axis=1))\n    num_pairs = len(i_idx)\n\n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n\n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    # Tiny epsilon buffer to ensure strict validity against floating point errors\n    b_ub[:num_pairs] = np.maximum(0, dists - 1e-11)\n\n    # Boundary constraints: interleaved per circle (x, 1-x, y, 1-y)\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n\n    x, y = pts[:, 0], pts[:, 1]\n    b_ub[num_pairs::4] = np.maximum(0, x - 1e-11)\n    b_ub[num_pairs + 1::4] = np.maximum(0, 1.0 - x - 1e-11)\n    b_ub[num_pairs + 2::4] = np.maximum(0, y - 1e-11)\n    b_ub[num_pairs + 3::4] = np.maximum(0, 1.0 - y - 1e-11)\n\n    try:\n        # Use HiGHS solver for speed and access to dual variables (marginals)\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            if res.ineqlin.marginals is not None:\n                return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n\n    return None, None, i_idx, j_idx, dists\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles to maximize sum of radii using multi-start and dual-gradient descent.\n    Sensitivity is derived from LP dual variables, identifying which constraints limit the sum.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    # Multi-start initial layouts: grids, hexagonal layers, rings, and spirals\n    inits = []\n\n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n\n    # 2: Hexagonal Layered (5, 4, 5, 4, 5, 3) = 26\n    c2 = []\n    for r_idx, n_row in enumerate([5, 4, 5, 4, 5, 3]):\n        for i_idx in range(n_row):\n            c2.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c2))\n\n    # 3: Hexagonal Layered (4, 5, 4, 5, 4, 4) = 26\n    c3 = []\n    for r_idx, n_row in enumerate([4, 5, 4, 5, 4, 4]):\n        for i_idx in range(n_row):\n            c3.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c3))\n\n    # 4: Hexagonal Layered (6, 5, 6, 5, 4) = 26\n    c4 = []\n    for r_idx, n_row in enumerate([6, 5, 6, 5, 4]):\n        for i_idx in range(n_row):\n            c4.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 5])\n    inits.append(np.array(c4))\n\n    # 5: Hexagonal Layered (6, 7, 6, 7) = 26\n    c5 = []\n    for r_idx, n_row in enumerate([6, 7, 6, 7]):\n        for i_idx in range(n_row):\n            c5.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 4])\n    inits.append(np.array(c5))\n\n    # 6: Ring distribution (1 center, 8 middle, 17 outer)\n    c6 = [[0.5, 0.5]]\n    for rad, count in [(0.23, 8), (0.45, 17)]:\n        for i in range(count):\n            angle = 2 * np.pi * i / count\n            c6.append([0.5 + rad * np.cos(angle), 0.5 + rad * np.sin(angle)])\n    inits.append(np.array(c6))\n\n    # 7: Ring distribution (1 center, 7 middle, 18 outer)\n    c7 = [[0.5, 0.5]]\n    for rad, count in [(0.22, 7), (0.46, 18)]:\n        for i in range(count):\n            angle = 2 * np.pi * i / count\n            c7.append([0.5 + rad * np.cos(angle), 0.5 + rad * np.sin(angle)])\n    inits.append(np.array(c7))\n\n    # 8: Phyllotaxis Spiral\n    phi = (1 + 5**0.5) / 2\n    c8 = []\n    for i in range(n):\n        radius = 0.46 * np.sqrt((i + 0.5) / n)\n        theta = 2 * np.pi * i / (phi**2)\n        c8.append([0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)])\n    inits.append(np.array(c8))\n\n    # 9: Grid 6x4 with 2 extras\n    gx9, gy9 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx9.ravel(), gy9.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n\n    # Randomized variations\n    np.random.seed(42)\n    inits.append(np.clip(inits[0] + np.random.normal(0, 0.03, (n, 2)), 0.05, 0.95))\n    inits.append(np.clip(inits[1] + np.random.normal(0, 0.02, (n, 2)), 0.05, 0.95))\n    inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Optimization loop for each initialization\n    for c_start in inits:\n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.02  # Initial learning rate\n        \n        # Iterative Dual-Gradient Ascent\n        for step in range(400):\n            # Enforce wall-clock time limit for the constructor\n            if time.time() - start_time > 580:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if radii is None or duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Sensitivity gradient from dual variables\n            # duals represent sensitivities to constraint bounds (dists and wall dists)\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Influence from touching circle pairs: push apart to make room\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                d_vals = dists[active_p, np.newaxis]\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (d_vals + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Influence from wall contacts: push inward to enlarge radii\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]  # r_i <= x_i vs r_i <= 1-x_i\n            grad[:, 1] += mus[:, 2] - mus[:, 3]  # r_i <= y_i vs r_i <= 1-y_i\n            \n            # Gradient normalization for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Maintain valid domain and decay step size\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.995\n\n    # Re-solve one final time for the absolute best configuration found\n    if best_centers is not None:\n        final_radii, _, _, _, _ = solve_max_radii(best_centers)\n        return best_centers, final_radii, np.sum(final_radii)\n    \n    # Fallback to a random valid configuration if all else fails\n    fallback_c = np.random.uniform(0.1, 0.9, (n, 2))\n    fallback_r, _, _, _, _ = solve_max_radii(fallback_c)\n    return fallback_c, fallback_r, np.sum(fallback_r)\n\n\ndef run_packing():\n    \"\"\"Evaluates the circle packing arrangement.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6037), Performs well on target_ratio (0.9881), Performs well on combined_score (0.9881), Performs well on radius_variance (0.0063), Performs well on spatial_spread (0.2144), Performs well on eval_time (9.8361)\n\n### Program 3 (Score: 0.9842)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts, buffer=1e-12):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    Returns optimal radii, dual variables (marginals), and pairwise info.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.hypot(diffs[:, 0], diffs[:, 1])\n    num_pairs = len(i_idx)\n    \n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n (boundary constraints per circle)\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    b_ub[:num_pairs] = dists - buffer\n        \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    x, y = pts[:, 0], pts[:, 1]\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n    \n    b_ub[num_pairs::4] = x - buffer\n    b_ub[num_pairs+1::4] = 1.0 - x - buffer\n    b_ub[num_pairs+2::4] = y - buffer\n    b_ub[num_pairs+3::4] = 1.0 - y - buffer\n    \n    # Ensure bounds are strictly non-negative\n    b_ub = np.maximum(b_ub, 0)\n        \n    try:\n        # Use HiGHS solver for efficiency and access to dual marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return None, None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles to maximize sum of radii using multi-start and dual-gradient descent.\n    The gradient is derived from the sensitivity of the LP objective to center movements.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Diverse initial layouts to explore different topologies\n    inits = []\n    \n    # 1: Grids with various offsets\n    for offset in [[0.5, 0.5], [0.1, 0.1], [0.9, 0.9]]:\n        gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n        inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), offset]))\n    \n    # 2: 6x4 Grid with extras\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx2.ravel(), gy2.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n    \n    # 3: Staggered/Hexagonal layers\n    for layers in [[5, 4, 5, 4, 5, 3], [6, 7, 6, 7], [5, 6, 5, 6, 4], [4, 5, 4, 5, 4, 4], [7, 6, 7, 6]]:\n        c = []\n        for r_idx, n_row in enumerate(layers):\n            for i_idx in range(n_row):\n                c.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n        inits.append(np.array(c)[:n])\n        \n    # 4: Spiral (Phyllotaxis)\n    phi = (1 + 5**0.5) / 2\n    spir = np.array([[0.5 + 0.46 * np.sqrt((i + 0.5) / n) * np.cos(2 * np.pi * i / phi**2),\n                      0.5 + 0.46 * np.sqrt((i + 0.5) / n) * np.sin(2 * np.pi * i / phi**2)] \n                      for i in range(n)])\n    inits.append(spir)\n    \n    # 5: Concentric Ring layouts\n    for ring_counts in [[1, 8, 17], [1, 7, 18]]:\n        c_ring = [[0.5, 0.5]]\n        for rad, count in [(0.23, ring_counts[1]), (0.45, ring_counts[2])]:\n            for i in range(count):\n                a = 2 * np.pi * i / count\n                c_ring.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n        inits.append(np.array(c_ring)[:n])\n        \n    # 6: Randomized starts\n    np.random.seed(42)\n    for _ in range(3):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Optimization loop per start\n    for c_start in inits:\n        if time.time() - start_time > 560:\n            break\n            \n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.02\n        best_sum_this_start = -1.0\n        \n        for step in range(800):\n            if step % 20 == 0 and time.time() - start_time > 560:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if radii is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Use dual variables (marginal sensitivities) to compute gradient\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Gradients from pairwise distance sensitivity\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (dists[active_p, np.newaxis] + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Gradients from boundary sensitivity\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]\n            grad[:, 1] += mus[:, 2] - mus[:, 3]\n            \n            # Apply update with normalized gradient\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Maintain valid domain and decay step size\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.997\n            \n    # Final optimize for the absolute best centers found\n    if best_centers is not None:\n        final_radii, _, _, _, _ = solve_max_radii(best_centers, buffer=1e-12)\n        return best_centers, final_radii, np.sum(final_radii)\n    return np.random.uniform(0.1, 0.9, (n, 2)), np.zeros(n), 0.0\n\ndef run_packing():\n    \"\"\"Standard entry point for circle packing evaluations.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.5933), Performs well on target_ratio (0.9842), Performs well on combined_score (0.9842), Performs well on radius_variance (0.0069), Performs well on spatial_spread (0.1838), Performs well on eval_time (26.6645)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9725)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts, buffer=1e-11):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.hypot(diffs[:, 0], diffs[:, 1])\n    num_pairs = len(i_idx)\n    \n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n (boundary constraints per circle)\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    b_ub[:num_pairs] = dists - buffer\n        \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    x, y = pts[:, 0], pts[:, 1]\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n    \n    b_ub[num_pairs::4] = x - buffer\n    b_ub[num_pairs+1::4] = 1.0 - x - buffer\n    b_ub[num_pairs+2::4] = y - buffer\n    b_ub[num_pairs+3::4] = 1.0 - y - buffer\n    \n    # Ensure bounds are strictly non-negative\n    b_ub = np.maximum(b_ub, 0)\n        \n    try:\n        # Use HiGHS solver for efficiency and access to dual marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return np.zeros(n), None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the arrangement of 26 circles to maximize the sum of their radii.\n    Employs a multi-start strategy with dual-gradient descent. The gradients\n    are derived from the sensitivity of the LP objective to center movements.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Generate diverse initial configurations to explore potential optimal topologies\n    inits = []\n    \n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n    \n    # 2: 6x4 Grid with two circles on the side\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx2.ravel(), gy2.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n    \n    # 3: Staggered layers to cover the square densely\n    for layers in [[5, 4, 5, 4, 5, 3], [6, 5, 6, 5, 4], [7, 6, 7, 6], [5, 5, 5, 5, 6]]:\n        c = []\n        for r_idx, n_row in enumerate(layers):\n            for i_idx in range(n_row):\n                c.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n        inits.append(np.array(c)[:n])\n        \n    # 4: Concentric Ring layouts (Phyllotaxis and manually defined)\n    for ring_counts in [[1, 8, 17], [1, 7, 18]]:\n        c_ring = [[0.5, 0.5]]\n        for rad, count in [(0.22, ring_counts[1]), (0.44, ring_counts[2])]:\n            for i in range(count):\n                a = 2 * np.pi * i / count\n                c_ring.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n        inits.append(np.array(c_ring)[:n])\n        \n    # 5: Fibonacci Spiral / Phyllotaxis\n    phi = (1 + 5**0.5) / 2\n    spir = np.array([[0.5 + 0.45 * np.sqrt((i + 0.5) / n) * np.cos(2 * np.pi * i / phi**2),\n                      0.5 + 0.45 * np.sqrt((i + 0.5) / n) * np.sin(2 * np.pi * i / phi**2)] \n                      for i in range(n)])\n    inits.append(spir)\n    \n    # 6: Pure random starts to cover less structured topologies\n    np.random.seed(1337)\n    for _ in range(4):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Multi-start optimization loop\n    for c_start in inits:\n        # Time limit of 550 seconds for the entire process\n        if time.time() - start_time > 550:\n            break\n            \n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.018  # Learning rate for gradient ascent\n        \n        for step in range(400):\n            # Check for time limit inside the iteration loop\n            if step % 25 == 0 and time.time() - start_time > 550:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Use dual variables (marginal sensitivities) to compute gradient\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Gradients from pairwise distance sensitivity (pushing centers apart)\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                # Normalized directions scaled by sensitivity\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (dists[active_p, np.newaxis] + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Gradients from boundary sensitivity (pushing centers away from walls)\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]\n            grad[:, 1] += mus[:, 2] - mus[:, 3]\n            \n            # Apply normalized gradient update for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-11:\n                curr_c += lr * grad / gnorm\n            \n            # Keep centers within the square and decay the learning rate\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.994\n            \n    # Re-calculate optimal radii for the best centers found across all starts\n    final_radii, _, _, _, _ = solve_max_radii(best_centers, buffer=1e-12)\n    return best_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Standard entry point for circle packing evaluations.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9712)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    \n    Returns:\n        radii: Optimal radii for each center\n        duals: Dual variables (marginals) from the LP\n        i_idx, j_idx: Indices of circle pairs\n        dists: Euclidean distances between centers\n    \"\"\"\n    n = pts.shape[0]\n    # Minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.sqrt(np.sum(diffs**2, axis=1))\n    num_pairs = len(i_idx)\n    \n    # Constraints: pairwise (r_i + r_j <= d_ij) and boundary (r_i <= d_wall)\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    b_ub[:num_pairs] = np.maximum(0, dists - 1e-12)\n    \n    # Boundary constraints: x_i, 1-x_i, y_i, 1-y_i\n    x, y = pts[:, 0], pts[:, 1]\n    for i in range(n):\n        base = num_pairs + 4 * i\n        # r_i <= x[i]\n        A_ub[base, i], b_ub[base] = 1, np.maximum(0, x[i] - 1e-12)\n        # r_i <= 1.0 - x[i]\n        A_ub[base + 1, i], b_ub[base + 1] = 1, np.maximum(0, 1.0 - x[i] - 1e-12)\n        # r_i <= y[i]\n        A_ub[base + 2, i], b_ub[base + 2] = 1, np.maximum(0, y[i] - 1e-12)\n        # r_i <= 1.0 - y[i]\n        A_ub[base + 3, i], b_ub[base + 3] = 1, np.maximum(0, 1.0 - y[i] - 1e-12)\n        \n    try:\n        # Use HiGHS solver for efficiency and access to dual marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return np.zeros(n), None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the arrangement of 26 circles to maximize the sum of their radii.\n    Employs a multi-start strategy with dual-gradient descent. The gradients\n    are derived from the sensitivity of the LP objective to changes in center\n    coordinates (pairwise distances and boundary distances).\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_centers = np.random.uniform(0.1, 0.9, (n, 2))\n    best_radii = np.zeros(n)\n    start_time = time.time()\n    \n    # Diverse initial layouts to explore potential optimal topologies\n    inits = []\n    \n    # 1. Perturbed Grid 5x5 plus one extra circle near center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.505, 0.495]]))\n    \n    # 2. Various staggered/hexagonal layers\n    # Layouts: 5-4-5-4-5-3, 4-5-4-5-4-4, and 6-5-6-5-4\n    for layout in [[5, 4, 5, 4, 5, 3], [4, 5, 4, 5, 4, 4], [6, 5, 6, 5, 4]]:\n        c = []\n        for r_idx, n_row in enumerate(layout):\n            for i_idx in range(n_row):\n                c.append([(i_idx + 0.5) / (n_row + 0.1), (r_idx + 0.5) / (len(layout) + 0.1)])\n        inits.append(np.array(c)[:n])\n        \n    # 3. Phyllotaxis Spiral (efficient natural packing)\n    phi = (1 + 5**0.5) / 2\n    idx_arr = np.arange(n) + 0.5\n    r_spiral = 0.47 * np.sqrt(idx_arr / n)\n    theta = 2 * np.pi * idx_arr / (phi**2)\n    inits.append(np.column_stack([0.5 + r_spiral * np.cos(theta), 0.5 + r_spiral * np.sin(theta)]))\n    \n    # 4. Concentric Rings (1 center, 8 middle, 17 outer)\n    c_rings = [[0.5, 0.5]]\n    for radius, count in [(0.23, 8), (0.45, 17)]:\n        for i in range(count):\n            a = 2 * np.pi * i / count\n            c_rings.append([0.5 + radius * np.cos(a), 0.5 + radius * np.sin(a)])\n    inits.append(np.array(c_rings)[:n])\n    \n    # 5. Random starts with different seeds\n    np.random.seed(1337)\n    for _ in range(4):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n        \n    # Multi-start optimization loop\n    for c_start in inits:\n        # Respect a 540-second execution limit for the whole construction process\n        if time.time() - start_time > 540:\n            break\n            \n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.015  # Initial learning rate\n        \n        for step in range(350):\n            # Frequent time check within the iteration loop\n            if step % 25 == 0 and time.time() - start_time > 540:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if duals is None:\n                break\n                \n            curr_sum = np.sum(radii)\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n                \n            # Compute gradients from dual variables (marginal sensitivities)\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            \n            # Pairwise distance sensitivity: pushes centers apart to enlarge sum(radii)\n            lambdas = np.abs(duals[:num_pairs])\n            active_mask = lambdas > 1e-8\n            if np.any(active_mask):\n                ii = i_idx[active_mask]\n                jj = j_idx[active_mask]\n                lams = lambdas[active_mask][:, np.newaxis]\n                diffs = curr_c[ii] - curr_c[jj]\n                d = dists[active_mask][:, np.newaxis]\n                # Normalized direction vectors scaled by dual importance\n                g_vectors = lams * diffs / (d + 1e-15)\n                np.add.at(grad, ii, g_vectors)\n                np.add.at(grad, jj, -g_vectors)\n                \n            # Boundary sensitivity: pushes centers away from walls\n            mus = np.abs(duals[num_pairs:]).reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]  # x_i and 1-x_i\n            grad[:, 1] += mus[:, 2] - mus[:, 3]  # y_i and 1-y_i\n            \n            # Apply normalized gradient update for numerical stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n                \n            # Keep centers strictly within the unit square square\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            # Gradual learning rate decay to fine-tune final position\n            lr *= 0.995\n            \n    # Re-calculate optimal radii for the best centers found across all starts\n    final_radii, _, _, _, _ = solve_max_radii(best_centers)\n    return best_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Evaluate the packing arrangement for the target number of circles.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9411, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles maximizing the sum of their radii.\nThis implementation uses a dual-gradient optimization approach. For a fixed set of\ncenters, we solve a Linear Programming (LP) problem to find the optimal radii. \nThe dual variables of this LP provide the sensitivity of the sum of radii to the \ndistances between centers and to the distances from the centers to the boundaries.\nThe centers are then updated iteratively in the direction that increases the total sum.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef solve_max_radii_lp(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Returns the LP result, pairwise indices, and the tightest boundary constraints.\n    \"\"\"\n    n = pts.shape[0]\n    # Objective: minimize -sum(radii) to maximize sum(radii)\n    c_obj = -np.ones(n)\n\n    # Inequality constraints: r_i + r_j <= distance(P_i, P_j)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.hypot(diffs[:, 0], diffs[:, 1])\n\n    # A_ub * r <= b_ub\n    a_ub = np.zeros((len(i_idx), n))\n    a_ub[np.arange(len(i_idx)), i_idx] = 1\n    a_ub[np.arange(len(i_idx)), j_idx] = 1\n    b_ub = dists\n\n    # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n    # Ensure pts are within (0, 1) to avoid negative bounds\n    pts_clipped = np.clip(pts, 1e-9, 1 - 1e-9)\n    x = pts_clipped[:, 0]\n    y = pts_clipped[:, 1]\n    b_left = x\n    b_right = 1.0 - x\n    b_bottom = y\n    b_top = 1.0 - y\n\n    # Find which boundary is tightest for each circle\n    max_r_boundary = np.minimum.reduce([b_left, b_right, b_bottom, b_top])\n    bounds_lp = [(0, r) for r in max_r_boundary]\n\n    try:\n        # Highs is efficient and provides marginals (duals)\n        res = linprog(c_obj, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n    except Exception:\n        # Fallback to default if 'highs' is unavailable\n        res = linprog(c_obj, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp)\n\n    return res, i_idx, j_idx, dists, max_r_boundary\n\n\ndef run_packing():\n    \"\"\"\n    Runs the circle packing optimization and returns the best found configuration.\n    \"\"\"\n    n_circles = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Define several starting configurations\n    initial_configs = []\n\n    # Init 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    c1 = np.column_stack([gx.ravel(), gy.ravel()])\n    c1 = np.vstack([c1, [0.5, 0.5]])\n    initial_configs.append(c1)\n\n    # Init 2: Hexagonal-like staggered layers (5, 4, 5, 4, 5, 3) = 26 circles\n    c2 = []\n    layers = [5, 4, 5, 4, 5, 3]\n    for r_idx, n_row in enumerate(layers):\n        y_coord = (r_idx + 0.5) / len(layers)\n        for i_idx in range(n_row):\n            x_coord = (i_idx + 0.5) / n_row\n            c2.append([x_coord, y_coord])\n    initial_configs.append(np.array(c2))\n\n    # Init 3: 6x4 Grid plus 2 extra circles\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    c3 = np.column_stack([gx2.ravel(), gy2.ravel()])\n    c3 = np.vstack([c3, [[0.2, 0.5], [0.8, 0.5]]])\n    initial_configs.append(c3)\n\n    # Optimize each initial configuration\n    for start_c in initial_configs:\n        cur_c = start_c.copy()\n        \n        # Dual-gradient optimization iterations\n        for step in range(150):\n            res, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(cur_c)\n            if not res.success:\n                break\n\n            curr_sum = -res.fun\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_c = cur_c.copy()\n                best_r = res.x\n\n            # Extract dual variables (marginals)\n            lambdas = getattr(getattr(res, 'ineqlin', None), 'marginals', None)\n            mus = getattr(getattr(res, 'upper', None), 'marginals', None)\n\n            if lambdas is not None and mus is not None:\n                grad = np.zeros((n_circles, 2))\n                \n                # Update gradient based on pairwise distance constraints\n                for k in range(len(i_idx)):\n                    lam = abs(lambdas[k])\n                    if lam > 1e-7:\n                        ii, jj = i_idx[k], j_idx[k]\n                        diff = cur_c[ii] - cur_c[jj]\n                        d = dists[k]\n                        if d > 1e-8:\n                            grad[ii] += lam * diff / d\n                            grad[jj] -= lam * diff / d\n\n                # Update gradient based on boundary constraints\n                for i in range(n_circles):\n                    mu = abs(mus[i])\n                    if mu > 1e-7:\n                        xi, yi = cur_c[i]\n                        b_vals = [xi, 1.0 - xi, yi, 1.0 - yi]\n                        tightest = np.argmin(b_vals)\n                        if tightest == 0: grad[i, 0] += mu\n                        elif tightest == 1: grad[i, 0] -= mu\n                        elif tightest == 2: grad[i, 1] += mu\n                        elif tightest == 3: grad[i, 1] -= mu\n\n                # Normalize step for stability and apply update\n                gnorm = np.linalg.norm(grad)\n                if gnorm > 1e-9:\n                    # Decay the step size over time\n                    step_size = 0.006 * (0.99 ** step)\n                    cur_c += step_size * grad / gnorm\n                \n                # Keep centers within the unit square\n                cur_c = np.clip(cur_c, 1e-7, 1.0 - 1e-7)\n            else:\n                break\n\n    # Perform a final rigorous LP solve and validity correction\n    if best_c is None:\n        best_c = initial_configs[1]\n\n    res_final, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(best_c)\n    final_r = res_final.x\n    final_c = best_c\n\n    # Strict geometry enforcement (multi-pass) to ensure zero overlap or boundary violation\n    for _ in range(50):\n        for i in range(n_circles):\n            final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0], \n                             final_c[i, 1], 1.0 - final_c[i, 1])\n            final_r[i] = max(0, final_r[i])\n        for k in range(len(i_idx)):\n            ii, jj = i_idx[k], j_idx[k]\n            d = np.hypot(final_c[ii, 0] - final_c[jj, 0], final_c[ii, 1] - final_c[jj, 1])\n            if final_r[ii] + final_r[jj] > d:\n                overlap = (final_r[ii] + final_r[jj]) - d\n                total_r = final_r[ii] + final_r[jj]\n                if total_r > 0:\n                    final_r[ii] -= overlap * (final_r[ii] / total_r)\n                    final_r[jj] -= overlap * (final_r[jj] / total_r)\n\n    return final_c, final_r, np.sum(final_r)\n\n\ndef construct_packing():\n    \"\"\"Alias for run_packing to match expected constructor interface.\"\"\"\n    return run_packing()\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9881, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    Returns optimal radii, dual variables (marginals), and pairwise info.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n\n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.sqrt(np.sum(diffs**2, axis=1))\n    num_pairs = len(i_idx)\n\n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n\n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    # Tiny epsilon buffer to ensure strict validity against floating point errors\n    b_ub[:num_pairs] = np.maximum(0, dists - 1e-11)\n\n    # Boundary constraints: interleaved per circle (x, 1-x, y, 1-y)\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n\n    x, y = pts[:, 0], pts[:, 1]\n    b_ub[num_pairs::4] = np.maximum(0, x - 1e-11)\n    b_ub[num_pairs + 1::4] = np.maximum(0, 1.0 - x - 1e-11)\n    b_ub[num_pairs + 2::4] = np.maximum(0, y - 1e-11)\n    b_ub[num_pairs + 3::4] = np.maximum(0, 1.0 - y - 1e-11)\n\n    try:\n        # Use HiGHS solver for speed and access to dual variables (marginals)\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            if res.ineqlin.marginals is not None:\n                return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n\n    return None, None, i_idx, j_idx, dists\n\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles to maximize sum of radii using multi-start and dual-gradient descent.\n    Sensitivity is derived from LP dual variables, identifying which constraints limit the sum.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n\n    # Multi-start initial layouts: grids, hexagonal layers, rings, and spirals\n    inits = []\n\n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n\n    # 2: Hexagonal Layered (5, 4, 5, 4, 5, 3) = 26\n    c2 = []\n    for r_idx, n_row in enumerate([5, 4, 5, 4, 5, 3]):\n        for i_idx in range(n_row):\n            c2.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c2))\n\n    # 3: Hexagonal Layered (4, 5, 4, 5, 4, 4) = 26\n    c3 = []\n    for r_idx, n_row in enumerate([4, 5, 4, 5, 4, 4]):\n        for i_idx in range(n_row):\n            c3.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c3))\n\n    # 4: Hexagonal Layered (6, 5, 6, 5, 4) = 26\n    c4 = []\n    for r_idx, n_row in enumerate([6, 5, 6, 5, 4]):\n        for i_idx in range(n_row):\n            c4.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 5])\n    inits.append(np.array(c4))\n\n    # 5: Hexagonal Layered (6, 7, 6, 7) = 26\n    c5 = []\n    for r_idx, n_row in enumerate([6, 7, 6, 7]):\n        for i_idx in range(n_row):\n            c5.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 4])\n    inits.append(np.array(c5))\n\n    # 6: Ring distribution (1 center, 8 middle, 17 outer)\n    c6 = [[0.5, 0.5]]\n    for rad, count in [(0.23, 8), (0.45, 17)]:\n        for i in range(count):\n            angle = 2 * np.pi * i / count\n            c6.append([0.5 + rad * np.cos(angle), 0.5 + rad * np.sin(angle)])\n    inits.append(np.array(c6))\n\n    # 7: Ring distribution (1 center, 7 middle, 18 outer)\n    c7 = [[0.5, 0.5]]\n    for rad, count in [(0.22, 7), (0.46, 18)]:\n        for i in range(count):\n            angle = 2 * np.pi * i / count\n            c7.append([0.5 + rad * np.cos(angle), 0.5 + rad * np.sin(angle)])\n    inits.append(np.array(c7))\n\n    # 8: Phyllotaxis Spiral\n    phi = (1 + 5**0.5) / 2\n    c8 = []\n    for i in range(n):\n        radius = 0.46 * np.sqrt((i + 0.5) / n)\n        theta = 2 * np.pi * i / (phi**2)\n        c8.append([0.5 + radius * np.cos(theta), 0.5 + radius * np.sin(theta)])\n    inits.append(np.array(c8))\n\n    # 9: Grid 6x4 with 2 extras\n    gx9, gy9 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx9.ravel(), gy9.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n\n    # Randomized variations\n    np.random.seed(42)\n    inits.append(np.clip(inits[0] + np.random.normal(0, 0.03, (n, 2)), 0.05, 0.95))\n    inits.append(np.clip(inits[1] + np.random.normal(0, 0.02, (n, 2)), 0.05, 0.95))\n    inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Optimization loop for each initialization\n    for c_start in inits:\n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.02  # Initial learning rate\n        \n        # Iterative Dual-Gradient Ascent\n        for step in range(400):\n            # Enforce wall-clock time limit for the constructor\n            if time.time() - start_time > 580:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if radii is None or duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Sensitivity gradient from dual variables\n            # duals represent sensitivities to constraint bounds (dists and wall dists)\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Influence from touching circle pairs: push apart to make room\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                d_vals = dists[active_p, np.newaxis]\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (d_vals + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Influence from wall contacts: push inward to enlarge radii\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]  # r_i <= x_i vs r_i <= 1-x_i\n            grad[:, 1] += mus[:, 2] - mus[:, 3]  # r_i <= y_i vs r_i <= 1-y_i\n            \n            # Gradient normalization for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Maintain valid domain and decay step size\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.995\n\n    # Re-solve one final time for the absolute best configuration found\n    if best_centers is not None:\n        final_radii, _, _, _, _ = solve_max_radii(best_centers)\n        return best_centers, final_radii, np.sum(final_radii)\n    \n    # Fallback to a random valid configuration if all else fails\n    fallback_c = np.random.uniform(0.1, 0.9, (n, 2))\n    fallback_r, _, _, _, _ = solve_max_radii(fallback_c)\n    return fallback_c, fallback_r, np.sum(fallback_r)\n\n\ndef run_packing():\n    \"\"\"Evaluates the circle packing arrangement.\"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9672, Type: High-Performer)\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= distance to wall.\n    \n    Returns:\n        radii: Optimal radii for each center.\n        duals: Dual variables (marginals) providing sensitivity to center movement.\n        i_idx, j_idx: Indices of circle pairs used for constraints.\n        dists: Euclidean distances between centers.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes the objective function, so we minimize -sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.linalg.norm(diffs, axis=1)\n    num_pairs = len(i_idx)\n    \n    # Combine pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n (boundary constraints per circle)\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    # Small epsilon to ensure strict validity within floating point precision\n    b_ub[:num_pairs] = dists - 1e-11\n        \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    x, y = pts[:, 0], pts[:, 1]\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n    \n    b_ub[num_pairs::4] = x - 1e-11\n    b_ub[num_pairs+1::4] = 1.0 - x - 1e-11\n    b_ub[num_pairs+2::4] = y - 1e-11\n    b_ub[num_pairs+3::4] = 1.0 - y - 1e-11\n    \n    # Correct any negative bounds caused by centers being slightly out of square\n    b_ub = np.maximum(b_ub, 0)\n        \n    try:\n        # Use the HiGHS solver for efficiency and access to marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return None, None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the arrangement of 26 circles to maximize the sum of their radii.\n    Employs a multi-start strategy with dual-gradient descent derived from LP.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    start_time = time.time()\n    \n    # Diverse initial layouts to explore different packing topologies\n    inits = []\n    \n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n    \n    # 2: 5x5 Grid with one circle in the corner\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.05, 0.05]]))\n    \n    # 3: Staggered layers (5, 4, 5, 4, 5, 3) = 26\n    c3 = []\n    for r_idx, n_row in enumerate([5, 4, 5, 4, 5, 3]):\n        for i_idx in range(n_row):\n            c3.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c3))\n    \n    # 4: Staggered layers (4, 5, 4, 5, 4, 4) = 26\n    c4 = []\n    for r_idx, n_row in enumerate([4, 5, 4, 5, 4, 4]):\n        for i_idx in range(n_row):\n            c4.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / 6])\n    inits.append(np.array(c4))\n\n    # 5: Ring distribution (1 center, 8 middle, 17 outer)\n    c5 = [[0.5, 0.5]]\n    for rad, count in [(0.24, 8), (0.46, 17)]:\n        for i in range(count):\n            a = 2 * np.pi * i / count\n            c5.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n    inits.append(np.array(c5))\n    \n    # 6: Fibonacci / Spiral layout\n    c6 = []\n    phi = (1 + 5**0.5) / 2\n    for i in range(n):\n        r_spiral = 0.45 * np.sqrt((i + 0.5) / n)\n        theta = 2 * np.pi * i / (phi**2)\n        c6.append([0.5 + r_spiral * np.cos(theta), 0.5 + r_spiral * np.sin(theta)])\n    inits.append(np.array(c6))\n\n    # 7: Concentric layers (1, 7, 18)\n    c7 = [[0.5, 0.5]]\n    for rad, count in [(0.22, 7), (0.44, 18)]:\n        for i in range(count):\n            a = 2 * np.pi * i / count\n            c7.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n    inits.append(np.array(c7))\n    \n    # 8: Grid 6x4 with 2 extras\n    gx8, gy8 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx8.ravel(), gy8.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n\n    # Optimization loop for each initialization\n    for c_start in inits:\n        if time.time() - start_time > 550:\n            break\n            \n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.015  # Starting learning rate\n        \n        for step in range(300):\n            # Check for early exit based on time\n            if step % 20 == 0 and time.time() - start_time > 550:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Construct gradient based on sensitivity from dual variables\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            # Dual variables indicate the rate of change of the sum w.r.t the constraint bounds\n            # For maximize sum(r_i), we move the centers in directions that increase b_ub\n            lambdas = np.abs(duals)\n            \n            # Gradients from pairwise distances: push centers apart\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                # Normalized direction vectors scaled by dual sensitivity\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (dists[active_p, np.newaxis] + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Gradients from boundary constraints: move centers inward to make room\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]  # Sensitivity for x and 1-x\n            grad[:, 1] += mus[:, 2] - mus[:, 3]  # Sensitivity for y and 1-y\n            \n            # Apply update with normalized gradient for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Keep centers within the unit square and apply decay to step size\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.99\n            \n    # Final cleanup: ensure radii are strictly optimal for the best centers found\n    if best_centers is not None:\n        final_radii, _, _, _, _ = solve_max_radii(best_centers)\n        return best_centers, final_radii, np.sum(final_radii)\n    else:\n        # Fallback in case of failure\n        random_c = np.random.uniform(0.1, 0.9, (n, 2))\n        random_r, _, _, _, _ = solve_max_radii(random_c)\n        return random_c, random_r, np.sum(random_r)\n\ndef run_packing():\n    \"\"\"Main execution function to be called by evaluation scripts.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = run_packing()\n    print(f\"Total sum of radii for n=26: {total_sum:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    Returns optimal radii, dual variables (marginals), and pairwise info.\n    \"\"\"\n    n = pts.shape[0]\n    # Scipy linprog minimizes -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    dists = np.linalg.norm(pts[i_idx] - pts[j_idx], axis=1)\n    num_pairs = len(i_idx)\n    \n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    for k, (i, j) in enumerate(zip(i_idx, j_idx)):\n        A_ub[k, i] = 1\n        A_ub[k, j] = 1\n        b_ub[k] = dists[k] - 1e-11\n        \n    # Boundary constraints: r_i <= x_i, r_i <= 1-x_i, r_i <= y_i, r_i <= 1-y_i\n    x, y = pts[:, 0], pts[:, 1]\n    for i in range(n):\n        base = num_pairs + 4 * i\n        A_ub[base, i], b_ub[base] = 1, x[i] - 1e-11\n        A_ub[base + 1, i], b_ub[base + 1] = 1, 1.0 - x[i] - 1e-11\n        A_ub[base + 2, i], b_ub[base + 2] = 1, y[i] - 1e-11\n        A_ub[base + 3, i], b_ub[base + 3] = 1, 1.0 - y[i] - 1e-11\n        \n    try:\n        # Use HiGHS solver for speed and access to dual marginals\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, None), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return np.zeros(n), None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes the arrangement of 26 circles to maximize the sum of their radii.\n    Utilizes multi-start configurations and dual-gradient descent.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    start_time = time.time()\n    \n    # Diverse initial layouts for multi-start optimization\n    inits = []\n    \n    # Layout 1: 5x5 Grid with one circle near the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    c1 = np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.51, 0.49]])\n    inits.append(c1)\n    \n    # Layout 2: Staggered layers (5, 4, 5, 4, 5, 3) to fill the square\n    c2 = []\n    layers = [5, 4, 5, 4, 5, 3]\n    for r_idx, n_row in enumerate(layers):\n        for i_idx in range(n_row):\n            c2.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n    inits.append(np.array(c2))\n    \n    # Layout 3: Ring distribution (1 center, 8 middle, 17 outer)\n    c3 = [[0.5, 0.5]]\n    for rad, count in [(0.23, 8), (0.45, 17)]:\n        for i in range(count):\n            a = 2 * np.pi * i / count\n            c3.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n    inits.append(np.array(c3))\n\n    # Layout 4: Another staggered layout (4, 5, 4, 5, 4, 4)\n    c4 = []\n    layers4 = [4, 5, 4, 5, 4, 4]\n    for r_idx, n_row in enumerate(layers4):\n        for i_idx in range(n_row):\n            c4.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers4)])\n    inits.append(np.array(c4))\n    \n    # Layout 5: Random distribution\n    np.random.seed(42)\n    inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n    \n    # Optimization loop per initialization\n    for c_start in inits:\n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.008  # Initial learning rate\n        \n        for step in range(350):\n            # Periodically check time limit\n            if time.time() - start_time > 560:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Construct gradient based on dual variables (marginals)\n            # Duals tell us how the sum of radii changes with center positions\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            \n            # Gradients from pairwise distances\n            lambdas = np.abs(duals[:num_pairs])\n            active_mask = lambdas > 1e-8\n            if np.any(active_mask):\n                ii = i_idx[active_mask]\n                jj = j_idx[active_mask]\n                lams = lambdas[active_mask]\n                diffs = curr_c[ii] - curr_c[jj]\n                ds = dists[active_mask][:, np.newaxis]\n                # Direction of movement to increase the distance\n                g_vals = (lams[:, np.newaxis] * diffs / (ds + 1e-12))\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Gradients from boundary constraints\n            # Sensitivity to moving away from the four walls\n            mu0 = np.abs(duals[num_pairs + 4 * np.arange(n)])      # r_i <= x_i\n            mu1 = np.abs(duals[num_pairs + 4 * np.arange(n) + 1])  # r_i <= 1-x_i\n            mu2 = np.abs(duals[num_pairs + 4 * np.arange(n) + 2])  # r_i <= y_i\n            mu3 = np.abs(duals[num_pairs + 4 * np.arange(n) + 3])  # r_i <= 1-y_i\n            grad[:, 0] += mu0 - mu1\n            grad[:, 1] += mu2 - mu3\n            \n            # Apply update with normalized gradient for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-10:\n                curr_c += lr * grad / gnorm\n            \n            # Keep centers within square and decay learning rate\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.995\n            \n    # Final cleanup to ensure radii are optimal for the best centers found\n    final_radii, _, _, _, _ = solve_max_radii(best_centers)\n    return best_centers, final_radii, np.sum(final_radii)\n\ndef run_packing():\n    \"\"\"Entry point for evaluation scripts.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog\nimport time\n\ndef solve_max_radii(pts, buffer=1e-11):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Maximizes sum(r_i) subject to r_i + r_j <= distance(P_i, P_j) and\n    boundary constraints r_i <= wall_distance.\n    \"\"\"\n    n = pts.shape[0]\n    # Minimize -sum(r_i) to maximize sum(r_i)\n    c_lp = -np.ones(n)\n    \n    # Precompute indices for pairwise distance constraints\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.sqrt(np.sum(diffs**2, axis=1))\n    num_pairs = len(i_idx)\n    \n    # Combined pairwise and boundary constraints into one A_ub matrix\n    # Total constraints: num_pairs + 4 * n (boundary constraints per circle)\n    A_ub = np.zeros((num_pairs + 4 * n, n))\n    b_ub = np.zeros(num_pairs + 4 * n)\n    \n    # Pairwise constraints: r_i + r_j <= distance_ij\n    A_ub[np.arange(num_pairs), i_idx] = 1\n    A_ub[np.arange(num_pairs), j_idx] = 1\n    b_ub[:num_pairs] = np.maximum(0, dists - buffer)\n        \n    # Boundary constraints: interleaved per circle (x, 1-x, y, 1-y)\n    row_idx_b = np.arange(num_pairs, num_pairs + 4 * n)\n    col_idx_b = np.repeat(np.arange(n), 4)\n    A_ub[row_idx_b, col_idx_b] = 1\n    \n    x, y = pts[:, 0], pts[:, 1]\n    b_ub[num_pairs::4] = np.maximum(0, x - buffer)\n    b_ub[num_pairs+1::4] = np.maximum(0, 1.0 - x - buffer)\n    b_ub[num_pairs+2::4] = np.maximum(0, y - buffer)\n    b_ub[num_pairs+3::4] = np.maximum(0, 1.0 - y - buffer)\n        \n    try:\n        # HiGHS solver is efficient and provides sensitivities (marginals)\n        res = linprog(c_lp, A_ub=A_ub, b_ub=b_ub, bounds=(0, 1), method='highs')\n        if res.success and hasattr(res, 'ineqlin') and res.ineqlin is not None:\n            if res.ineqlin.marginals is not None:\n                return res.x, res.ineqlin.marginals, i_idx, j_idx, dists\n    except Exception:\n        pass\n        \n    return None, None, i_idx, j_idx, dists\n\ndef construct_packing():\n    \"\"\"\n    Optimizes 26 circles to maximize sum of radii using multi-start and dual-gradient descent.\n    The gradient is derived from the sensitivity of the LP objective to center movements.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    best_sum = -1.0\n    best_centers = None\n    best_radii = None\n    \n    # Diverse initial layouts to explore different packing topologies\n    inits = []\n    \n    # 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    inits.append(np.vstack([np.column_stack([gx.ravel(), gy.ravel()]), [0.5, 0.5]]))\n    \n    # 2: 6x4 Grid with two circles on the side\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    inits.append(np.vstack([np.column_stack([gx2.ravel(), gy2.ravel()]), [[0.2, 0.5], [0.8, 0.5]]]))\n    \n    # 3: Staggered layers to cover the square densely\n    for layers in [[5, 4, 5, 4, 5, 3], [6, 5, 6, 5, 4], [7, 6, 7, 6], [6, 7, 6, 7], [4, 5, 4, 5, 4, 4]]:\n        c = []\n        for r_idx, n_row in enumerate(layers):\n            for i_idx in range(n_row):\n                c.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n        inits.append(np.array(c)[:n])\n        \n    # 4: Concentric Ring layouts\n    for ring_counts in [[1, 8, 17], [1, 7, 18]]:\n        c_ring = [[0.5, 0.5]]\n        for rad, count in [(0.23, ring_counts[1]), (0.45, ring_counts[2])]:\n            for i in range(count):\n                a = 2 * np.pi * i / count\n                c_ring.append([0.5 + rad * np.cos(a), 0.5 + rad * np.sin(a)])\n        inits.append(np.array(c_ring)[:n])\n        \n    # 5: Fibonacci Spiral / Phyllotaxis\n    phi = (1 + 5**0.5) / 2\n    spir = np.array([[0.5 + 0.46 * np.sqrt((i + 0.5) / n) * np.cos(2 * np.pi * i / phi**2),\n                      0.5 + 0.46 * np.sqrt((i + 0.5) / n) * np.sin(2 * np.pi * i / phi**2)] \n                      for i in range(n)])\n    inits.append(spir)\n    \n    # 6: Randomized starts\n    np.random.seed(42)\n    for _ in range(3):\n        inits.append(np.random.uniform(0.1, 0.9, (n, 2)))\n\n    # Multi-start optimization loop\n    for c_start in inits:\n        if time.time() - start_time > 560:\n            break\n            \n        curr_c = np.clip(c_start.copy(), 1e-7, 1.0 - 1e-7)\n        lr = 0.02\n        \n        for step in range(400):\n            # Check for wall-clock time limit inside the iteration loop\n            if step % 20 == 0 and time.time() - start_time > 560:\n                break\n                \n            radii, duals, i_idx, j_idx, dists = solve_max_radii(curr_c)\n            if duals is None:\n                break\n                \n            current_sum = np.sum(radii)\n            if current_sum > best_sum:\n                best_sum = current_sum\n                best_centers = curr_c.copy()\n                best_radii = radii.copy()\n            \n            # Use dual variables (marginal sensitivities) to compute gradient\n            grad = np.zeros((n, 2))\n            num_pairs = len(i_idx)\n            lambdas = np.abs(duals)\n            \n            # Gradients from pairwise distance sensitivity (pushing centers apart)\n            lams_p = lambdas[:num_pairs]\n            active_p = lams_p > 1e-9\n            if np.any(active_p):\n                ii, jj = i_idx[active_p], j_idx[active_p]\n                diffs = curr_c[ii] - curr_c[jj]\n                # Direction of movement scaled by sensitivity to distance\n                g_vals = lams_p[active_p, np.newaxis] * diffs / (dists[active_p, np.newaxis] + 1e-15)\n                np.add.at(grad, ii, g_vals)\n                np.add.at(grad, jj, -g_vals)\n            \n            # Gradients from boundary sensitivity (pushing centers away from walls)\n            mus = lambdas[num_pairs:].reshape((n, 4))\n            grad[:, 0] += mus[:, 0] - mus[:, 1]\n            grad[:, 1] += mus[:, 2] - mus[:, 3]\n            \n            # Apply normalized gradient update for stability\n            gnorm = np.linalg.norm(grad)\n            if gnorm > 1e-12:\n                curr_c += lr * grad / gnorm\n            \n            # Keep centers within the square and decay the learning rate\n            curr_c = np.clip(curr_c, 1e-7, 1.0 - 1e-7)\n            lr *= 0.995\n            \n    # Final cleanup solve for the absolute best configuration found\n    if best_centers is not None:\n        final_radii, _, _, _, _ = solve_max_radii(best_centers, buffer=1e-11)\n        return best_centers, final_radii, np.sum(final_radii)\n    \n    return np.random.uniform(0.1, 0.9, (n, 2)), np.zeros(n), 0.0\n\ndef run_packing():\n    \"\"\"Standard entry point for circle packing evaluations.\"\"\"\n    return construct_packing()\n\nif __name__ == \"__main__\":\n    centers, radii, total_sum = construct_packing()\n    print(f\"Total sum of radii: {total_sum:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"10.71s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.565001/2.635 = 0.9734\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 97.3% of target value\", \"radius_stats\": \"Min: 0.061914, Max: 0.173429, Avg: 0.098654\"}", "artifact_dir": null, "embedding": null}