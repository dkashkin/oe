{"id": "97d33656-3427-4516-b89a-076027f959dc", "code": "# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles maximizing the sum of their radii.\nThis implementation uses a dual-gradient optimization approach. For a fixed set of\ncenters, we solve a Linear Programming (LP) problem to find the optimal radii. \nThe dual variables of this LP provide the sensitivity of the sum of radii to the \ndistances between centers and to the distances from the centers to the boundaries.\nThe centers are then updated iteratively in the direction that increases the total sum.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef solve_max_radii_lp(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Returns the LP result, pairwise indices, and the tightest boundary constraints.\n    \"\"\"\n    n = pts.shape[0]\n    # Objective: minimize -sum(radii) to maximize sum(radii)\n    c_obj = -np.ones(n)\n\n    # Inequality constraints: r_i + r_j <= distance(P_i, P_j)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.hypot(diffs[:, 0], diffs[:, 1])\n\n    # A_ub * r <= b_ub\n    a_ub = np.zeros((len(i_idx), n))\n    a_ub[np.arange(len(i_idx)), i_idx] = 1\n    a_ub[np.arange(len(i_idx)), j_idx] = 1\n    b_ub = dists\n\n    # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n    # Ensure pts are within (0, 1) to avoid negative bounds\n    pts_clipped = np.clip(pts, 1e-9, 1 - 1e-9)\n    x = pts_clipped[:, 0]\n    y = pts_clipped[:, 1]\n    b_left = x\n    b_right = 1.0 - x\n    b_bottom = y\n    b_top = 1.0 - y\n\n    # Find which boundary is tightest for each circle\n    max_r_boundary = np.minimum.reduce([b_left, b_right, b_bottom, b_top])\n    bounds_lp = [(0, r) for r in max_r_boundary]\n\n    try:\n        # Highs is efficient and provides marginals (duals)\n        res = linprog(c_obj, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n    except Exception:\n        # Fallback to default if 'highs' is unavailable\n        res = linprog(c_obj, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp)\n\n    return res, i_idx, j_idx, dists, max_r_boundary\n\n\ndef run_packing():\n    \"\"\"\n    Runs the circle packing optimization and returns the best found configuration.\n    \"\"\"\n    n_circles = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Define several starting configurations\n    initial_configs = []\n\n    # Init 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    c1 = np.column_stack([gx.ravel(), gy.ravel()])\n    c1 = np.vstack([c1, [0.5, 0.5]])\n    initial_configs.append(c1)\n\n    # Init 2: Hexagonal-like staggered layers (5, 4, 5, 4, 5, 3) = 26 circles\n    c2 = []\n    layers = [5, 4, 5, 4, 5, 3]\n    for r_idx, n_row in enumerate(layers):\n        y_coord = (r_idx + 0.5) / len(layers)\n        for i_idx in range(n_row):\n            x_coord = (i_idx + 0.5) / n_row\n            c2.append([x_coord, y_coord])\n    initial_configs.append(np.array(c2))\n\n    # Init 3: 6x4 Grid plus 2 extra circles\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    c3 = np.column_stack([gx2.ravel(), gy2.ravel()])\n    c3 = np.vstack([c3, [[0.2, 0.5], [0.8, 0.5]]])\n    initial_configs.append(c3)\n\n    # Optimize each initial configuration\n    for start_c in initial_configs:\n        cur_c = start_c.copy()\n        \n        # Dual-gradient optimization iterations\n        for step in range(150):\n            res, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(cur_c)\n            if not res.success:\n                break\n\n            curr_sum = -res.fun\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_c = cur_c.copy()\n                best_r = res.x\n\n            # Extract dual variables (marginals)\n            lambdas = getattr(getattr(res, 'ineqlin', None), 'marginals', None)\n            mus = getattr(getattr(res, 'upper', None), 'marginals', None)\n\n            if lambdas is not None and mus is not None:\n                grad = np.zeros((n_circles, 2))\n                \n                # Update gradient based on pairwise distance constraints\n                for k in range(len(i_idx)):\n                    lam = abs(lambdas[k])\n                    if lam > 1e-7:\n                        ii, jj = i_idx[k], j_idx[k]\n                        diff = cur_c[ii] - cur_c[jj]\n                        d = dists[k]\n                        if d > 1e-8:\n                            grad[ii] += lam * diff / d\n                            grad[jj] -= lam * diff / d\n\n                # Update gradient based on boundary constraints\n                for i in range(n_circles):\n                    mu = abs(mus[i])\n                    if mu > 1e-7:\n                        xi, yi = cur_c[i]\n                        b_vals = [xi, 1.0 - xi, yi, 1.0 - yi]\n                        tightest = np.argmin(b_vals)\n                        if tightest == 0: grad[i, 0] += mu\n                        elif tightest == 1: grad[i, 0] -= mu\n                        elif tightest == 2: grad[i, 1] += mu\n                        elif tightest == 3: grad[i, 1] -= mu\n\n                # Normalize step for stability and apply update\n                gnorm = np.linalg.norm(grad)\n                if gnorm > 1e-9:\n                    # Decay the step size over time\n                    step_size = 0.006 * (0.99 ** step)\n                    cur_c += step_size * grad / gnorm\n                \n                # Keep centers within the unit square\n                cur_c = np.clip(cur_c, 1e-7, 1.0 - 1e-7)\n            else:\n                break\n\n    # Perform a final rigorous LP solve and validity correction\n    if best_c is None:\n        best_c = initial_configs[1]\n\n    res_final, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(best_c)\n    final_r = res_final.x\n    final_c = best_c\n\n    # Strict geometry enforcement (multi-pass) to ensure zero overlap or boundary violation\n    for _ in range(50):\n        for i in range(n_circles):\n            final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0], \n                             final_c[i, 1], 1.0 - final_c[i, 1])\n            final_r[i] = max(0, final_r[i])\n        for k in range(len(i_idx)):\n            ii, jj = i_idx[k], j_idx[k]\n            d = np.hypot(final_c[ii, 0] - final_c[jj, 0], final_c[ii, 1] - final_c[jj, 1])\n            if final_r[ii] + final_r[jj] > d:\n                overlap = (final_r[ii] + final_r[jj]) - d\n                total_r = final_r[ii] + final_r[jj]\n                if total_r > 0:\n                    final_r[ii] -= overlap * (final_r[ii] / total_r)\n                    final_r[jj] -= overlap * (final_r[jj] / total_r)\n\n    return final_c, final_r, np.sum(final_r)\n\n\ndef construct_packing():\n    \"\"\"Alias for run_packing to match expected constructor interface.\"\"\"\n    return run_packing()\n# EVOLVE-BLOCK-END", "changes_description": null, "language": "python", "parent_id": "85256b23-7ee8-4b54-a4e1-bfa033f1673d", "generation": 3, "timestamp": 1771869473.1608412, "iteration_found": 29, "metrics": {"validity": 1.0, "sum_radii": 2.4797382079429555, "target_ratio": 0.9410771187639301, "combined_score": 0.9410771187639301, "radius_variance": 0.0033994973812845213, "spatial_spread": 0.19275911129667, "eval_time": 1.2359836101531982}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 3}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/cp_1model_1phase/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/cp_1model_1phase/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef get_exact_radii(centers):\n    \"\"\"\n    Computes the exact maximum valid radii for a given set of centers using Linear Programming.\n    Falls back to a robust geometric projected gradient descent method if scipy is unavailable.\n    \"\"\"\n    n = len(centers)\n    try:\n        from scipy.optimize import linprog\n        c_obj = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n                \n        bounds = []\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            bounds.append((0, max(0, max_r)))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            return res.x\n    except Exception:\n        pass\n        \n    # Fallback to optimization if linprog fails or is unavailable\n    r = np.full(n, 0.05)\n    for _ in range(1000):\n        grad = -np.ones(n)\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            if r[i] > max_r:\n                grad[i] += 100 * (r[i] - max_r)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    grad[i] += 100 * overlap\n                    grad[j] += 100 * overlap\n                    \n        r -= 0.01 * grad\n        r = np.maximum(r, 0)\n    return r\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    B = 50 # Number of parallel batches for optimization\n    \n    # Initialize batch of centers and radii for parallel optimization\n    c = np.random.uniform(0.1, 0.9, (B, n, 2))\n    r = np.full((B, n), 0.05)\n    \n    # Structured initialization to seed optimal topologies\n    # Batch 0: Ring layout 1, 8, 17\n    c[0, 0] = [0.5, 0.5]\n    for i in range(8):\n        a = 2 * np.pi * i / 8\n        c[0, i+1] = [0.5 + 0.2 * np.cos(a), 0.5 + 0.2 * np.sin(a)]\n    for i in range(17):\n        a = 2 * np.pi * i / 17\n        c[0, i+9] = [0.5 + 0.4 * np.cos(a), 0.5 + 0.4 * np.sin(a)]\n\n    # Batch 1: Grid-like 5x5 + 1\n    gx, gy = np.meshgrid(np.linspace(0.15, 0.85, 5), np.linspace(0.15, 0.85, 5))\n    c[1, :25] = np.column_stack([gx.flatten(), gy.flatten()])\n    c[1, 25] = [0.5, 0.5]\n\n    # Batch 2: Another ring layout 1, 6, 19\n    c[2, 0] = [0.5, 0.5]\n    for i in range(6):\n        a = 2 * np.pi * i / 6\n        c[2, i+1] = [0.5 + 0.2 * np.cos(a), 0.5 + 0.2 * np.sin(a)]\n    for i in range(19):\n        a = 2 * np.pi * i / 19\n        c[2, i+7] = [0.5 + 0.4 * np.cos(a), 0.5 + 0.4 * np.sin(a)]\n        \n    # Batch 3: Hexagonalish\n    hex_c = []\n    for i in range(6):\n        for j in range(6):\n            if len(hex_c) < 26:\n                hex_c.append([0.15 + 0.14 * i + (j % 2) * 0.07, 0.15 + 0.14 * j])\n    c[3] = np.array(hex_c)\n\n    # Batch 4: Concentric 4, 9, 13\n    for i in range(4):\n        a = 2 * np.pi * i / 4\n        c[4, i] = [0.5 + 0.1 * np.cos(a), 0.5 + 0.1 * np.sin(a)]\n    for i in range(9):\n        a = 2 * np.pi * i / 9\n        c[4, i+4] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n    for i in range(13):\n        a = 2 * np.pi * i / 13\n        c[4, i+13] = [0.5 + 0.4 * np.cos(a), 0.5 + 0.4 * np.sin(a)]\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    lr_c = 0.005\n    lr_r = 0.005\n    \n    idx_i, idx_j = np.triu_indices(n, k=1)\n    \n    # Main optimization loop\n    for step in range(8000):\n        grad_c = np.zeros_like(c)\n        grad_r = -np.ones_like(r)\n        \n        # Penalties for boundary violations\n        viol_left = np.maximum(0, r - c[:, :, 0])\n        grad_r += 100 * viol_left\n        grad_c[:, :, 0] -= 100 * viol_left\n        \n        viol_right = np.maximum(0, r + c[:, :, 0] - 1)\n        grad_r += 100 * viol_right\n        grad_c[:, :, 0] += 100 * viol_right\n        \n        viol_bottom = np.maximum(0, r - c[:, :, 1])\n        grad_r += 100 * viol_bottom\n        grad_c[:, :, 1] -= 100 * viol_bottom\n        \n        viol_top = np.maximum(0, r + c[:, :, 1] - 1)\n        grad_r += 100 * viol_top\n        grad_c[:, :, 1] += 100 * viol_top\n        \n        # Pairwise overlap penalties\n        c_i = c[:, idx_i, :] \n        c_j = c[:, idx_j, :] \n        r_i = r[:, idx_i]    \n        r_j = r[:, idx_j]    \n        \n        diff = c_i - c_j\n        dist = np.linalg.norm(diff, axis=2) + 1e-10 \n        \n        overlap = np.maximum(0, r_i + r_j - dist) \n        penalty = 200 * overlap \n        \n        dir_ij = diff / dist[:, :, None] \n        force = penalty[:, :, None] * dir_ij \n        \n        for p in range(len(idx_i)):\n            i = idx_i[p]\n            j = idx_j[p]\n            grad_r[:, i] += penalty[:, p]\n            grad_r[:, j] += penalty[:, p]\n            grad_c[:, i, :] -= force[:, p, :]\n            grad_c[:, j, :] += force[:, p, :]\n            \n        # Adam updates\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_c_hat = m_c / (1 - beta1 ** (step + 1))\n        v_c_hat = v_c / (1 - beta2 ** (step + 1))\n        c -= lr_c * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_r_hat = m_r / (1 - beta1 ** (step + 1))\n        v_r_hat = v_r / (1 - beta2 ** (step + 1))\n        r -= lr_r * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        c = np.clip(c, 0, 1)\n        r = np.maximum(r, 0)\n        \n        # Learning rate decay\n        if step % 2000 == 1999:\n            lr_c *= 0.5\n            lr_r *= 0.5\n\n    best_sum = 0\n    best_c = None\n    best_r = None\n    \n    # Evaluate configurations exactingly to ensure 100% validity\n    for b in range(B):\n        cb = c[b]\n        rb = get_exact_radii(cb)\n        \n        # Strict geometry enforcement multiple passes\n        for _ in range(3):\n            for i in range(n):\n                x, y = cb[i]\n                rb[i] = min(rb[i], x, y, 1 - x, 1 - y)\n                rb[i] = max(0, rb[i])\n                \n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(cb[i] - cb[j])\n                    if rb[i] + rb[j] > dist:\n                        scale = (dist - 1e-12) / (rb[i] + rb[j])\n                        rb[i] *= scale\n                        rb[j] *= scale\n                        \n        s = np.sum(rb)\n        if s > best_sum:\n            best_sum = s\n            best_c = cb\n            best_r = rb\n            \n    return best_c, best_r, best_sum\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 2 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles maximizing sum of radii.\"\"\"\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\nimport time\n\ncenters = None\nradii = None\nsum_radii = 0.0\n\ndef solve_max_radii(pts):\n    \"\"\"\n    Computes exact optimal valid radii for fixed circle centers using Highs Linear Programming,\n    guaranteeing strict constraints satisfaction to avoid any floating-point violations.\n    \"\"\"\n    n = len(pts)\n    c = -np.ones(n)\n    \n    # Vectorized computation of pairwise distances\n    i_idx, j_idx = np.triu_indices(n, 1)\n    dx = pts[i_idx, 0] - pts[j_idx, 0]\n    dy = pts[i_idx, 1] - pts[j_idx, 1]\n    dist = np.hypot(dx, dy)\n    \n    # A_ub limits r_i + r_j <= distance_ij\n    A_ub = np.zeros((len(i_idx), n))\n    A_ub[np.arange(len(i_idx)), i_idx] = 1\n    A_ub[np.arange(len(i_idx)), j_idx] = 1\n    b_ub = dist\n    \n    # Bounds restrict each circle fully within the unit square\n    x = pts[:, 0]\n    y = pts[:, 1]\n    max_r = np.clip(np.minimum.reduce([x, y, 1 - x, 1 - y]), 0, None)\n    bounds = [(0, r) for r in max_r]\n    \n    res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    if res.success:\n        r_opt = res.x\n    else:\n        r_opt = np.zeros(n)\n        \n    r_opt = np.clip(r_opt, 0, max_r)\n    \n    # Strict correction pass handling any marginal numerical overlaps safely\n    for _ in range(10):\n        violations = 0\n        for k in range(len(i_idx)):\n            i = i_idx[k]\n            j = j_idx[k]\n            d = dist[k]\n            if r_opt[i] + r_opt[j] > d + 1e-11:\n                scale = (d / (r_opt[i] + r_opt[j])) * 0.999999\n                r_opt[i] *= scale\n                r_opt[j] *= scale\n                violations += 1\n        if violations == 0:\n            break\n            \n    return r_opt\n\ndef _compute():\n    \"\"\"\n    Runs an accelerated multi-start SLSQP search to rapidly explore configurations.\n    Optimizes both coordinates and radii concurrently using precise vectorized Jacobians.\n    \"\"\"\n    n = 26\n    start_time = time.time()\n    max_time = 580.0  # Limits computation below 600s strict timeout\n    \n    best_sum_r = -1\n    best_centers = None\n    best_radii = None\n    \n    def obj(p):\n        return -np.sum(p[2*n\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles maximizing the sum of their radii.\nThis implementation uses a gradient-based optimization on circle centers, where the \nobjective gradient is derived from the dual solution of a Linear Programming (LP) \nproblem that maximizes the sum of radii for fixed centers.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_circles = 26\n\n    def solve_max_radii_lp(pts):\n        \"\"\"\n        Computes optimal radii for fixed centers using Linear Programming.\n        Also returns dual variables used for updating center positions.\n        \"\"\"\n        nc = len(pts)\n        # Minimize -sum(r_i) to maximize sum(r_i)\n        c_lp = -np.ones(nc)\n        \n        # Inequality constraints: r_i + r_j <= distance(P_i, P_j)\n        i_idx, j_idx = np.triu_indices(nc, 1)\n        diff = pts[i_idx] - pts[j_idx]\n        dists = np.sqrt(np.sum(diff**2, axis=1))\n        \n        a_ub = np.zeros((len(i_idx), nc))\n        a_ub[np.arange(len(i_idx)), i_idx] = 1\n        a_ub[np.arange(len(i_idx)), j_idx] = 1\n        b_ub = dists\n        \n        # Constraints: 0 <= r_i <= min(x, 1-x, y, 1-y) to stay within square\n        x = pts[:, 0]\n        y = pts[:, 1]\n        max_r_boundary = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        max_r_boundary = np.maximum(0, max_r_boundary)\n        bounds_lp = [(0, r) for r in max_r_boundary]\n        \n        try:\n            # Use Highs solver for speed and access to dual marginals\n            res_lp = linprog(c_lp, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n        except Exception:\n            # Fallback for older scipy versions\n            res_lp = linprog(c_lp, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp)\n            \n        return res_lp, i_idx, j_idx, dists, max_r_boundary\n\n    # Multiple initializations to explore configuration space\n    initial_set = []\n    \n    # Init 1: 5x5 Grid plus one center circle\n    gx1, gy1 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    c1 = np.column_stack([gx1.ravel(), gy1.ravel()])\n    c1 = np.vstack([c1, [0.5, 0.5]])\n    initial_set.append(c1)\n    \n    # Init 2: Staggered layers (5, 4, 5, 4, 5, 3) to mimic hexagonal density\n    c2 = []\n    layers = [5, 4, 5, 4, 5, 3]\n    for r_idx, n_row in enumerate(layers):\n        for i_idx in range(n_row):\n            c2.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n    initial_set.append(np.array(c2))\n    \n    # Init 3: 4x6 grid plus 2 side circles\n    gx2, gy2 = np.meshgrid(np.linspace(0.12, 0.88, 4), np.linspace(0.1, 0.9, 6))\n    c3 = np.column_stack([gx2.ravel(), gy2.ravel()])\n    c3 = np.vstack([c3, [[0.2, 0.5], [0.8, 0.5]]])\n    initial_set.append(c3)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Optimization Loop\n    for c_start in initial_set:\n        cur_c = c_start.copy()\n        for step in range(120):\n            res, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(cur_c)\n            if not res.success:\n                break\n            \n            curr_sum = -res.fun\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_c = cur_c.copy()\n                best_r = res.x\n            \n            # Use dual variables (marginals) to determine center movement\n            if hasattr(res, 'ineqlin') and res.ineqlin is not None and res.ineqlin.marginals is not None:\n                lambdas = np.abs(res.ineqlin.marginals)\n                mus = np.abs(res.upper.marginals)\n                \n                grad = np.zeros((n_circles, 2))\n                # Gradient component from pairwise distance constraints\n                for k in range(len(i_idx)):\n                    if lambdas[k] > 1e-6:\n                        ii, jj = i_idx[k], j_idx[k]\n                        diff = cur_c[ii] - cur_c[jj]\n                        if dists[k] > 1e-9:\n                            grad[ii] += lambdas[k] * diff / dists[k]\n                            grad[jj] -= lambdas[k] * diff / dists[k]\n                \n                # Gradient component from boundary constraints\n                for i in range(n_circles):\n                    if mus[i] > 1e-6:\n                        xi, yi = cur_c[i]\n                        bounds_vals = [xi, 1 - xi, yi, 1 - yi]\n                        bound_idx = np.argmin(bounds_vals)\n                        if bound_idx == 0: grad[i, 0] += mus[i]\n                        elif bound_idx == 1: grad[i, 0] -= mus[i]\n                        elif bound_idx == 2: grad[i, 1] += mus[i]\n                        elif bound_idx == 3: grad[i, 1] -= mus[i]\n                \n                # Update positions\n                gnorm = np.linalg.norm(grad)\n                if gnorm > 1e-9:\n                    # Normalized step size for stability\n                    cur_c += 0.005 * grad / gnorm\n                cur_c = np.clip(cur_c, 0, 1)\n            else:\n                break\n\n    # Re-verify and Polish best result\n    if best_c is None:\n        best_c = initial_set[1] # Fallback to staggered layout\n    \n    res_fin, i_idx_fin, j_idx_fin, dists_fin, m_r_fin = solve_max_radii_lp(best_c)\n    final_r = res_fin.x\n    final_c = best_c\n    \n    # Strict correction loop to remove potential floating-point overlaps\n    for _ in range(100):\n        for i in range(n_circles):\n            xi, yi = final_c[i]\n            final_r[i] = min(final_r[i], xi, 1 - xi, yi, 1 - yi)\n        for k in range(len(i_idx_fin)):\n            ii, jj = i_idx_fin[k], j_idx_fin[k]\n            d = np.linalg.norm(final_c[ii] - final_c[jj])\n            if final_r[ii] + final_r[jj] > d:\n                overlap = (final_r[ii] + final_r[jj]) - d\n                total_r = final_r[ii] + final_r[jj]\n                if total_r > 0:\n                    final_r[ii] -= overlap * (final_r[ii] / total_r)\n                    final_r[jj] -= overlap * (final_r[jj] / total_r)\n\n    return final_c, final_r, np.sum(final_r)\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_circles = 26\n    num_restarts = 30\n    num_steps = 3000\n\n    np.random.seed(42)\n    B = num_restarts\n    N = n_circles\n\n    # Initialize batch of centers and radii for parallel optimization\n    c = np.random.uniform(0.1, 0.9, (B, N, 2))\n    R = np.full((B, N), 0.05)\n\n    # Structured initialization for first few batches to seed optimal topologies\n    # Batch 0: Grid-ish layout\n    grid_coords = np.linspace(0.15, 0.85, 5)\n    gx, gy = np.meshgrid(grid_coords, grid_coords)\n    grid_pts = np.column_stack((gx.flatten(), gy.flatten()))\n    c[0, :25] = grid_pts\n    c[0, 25] = [0.5, 0.5]\n\n    # Batch 1: Ring layout (mimicking dense known arrangements)\n    c[1, 0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        c[1, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        c[1, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n\n    # Batch 2: Another ring layout with different proportions\n    c[2, 0] = [0.5, 0.5]\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        c[2, i + 1] = [0.5 + 0.2 * np.cos(angle), 0.5 + 0.2 * np.sin(angle)]\n    for i in range(19):\n        angle = 2 * np.pi * i / 19\n        c[2, i + 7] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n\n    lr_c = 0.\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef solve_max_radii(centers):\n    \"\"\"\n    Computes the exact maximum valid radii for a given set of centers using Linear Programming.\n    Falls back to a robust projected gradient descent method if scipy is unavailable.\n    \"\"\"\n    n = len(centers)\n    radii = None\n    \n    try:\n        from scipy.optimize import linprog\n        c = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n                \n        bounds = []\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            bounds.append((0, max_r))\n            \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            radii = res.x\n    except Exception:\n        pass\n        \n    if radii is None:\n        # Fallback to projected gradient descent on constraints\n        radii = np.zeros(n)\n        max_bounds = np.array([min(x, y, 1 - x, 1 - y) for x, y in centers])\n        \n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                dist_matrix[i, j] = d\n                dist_matrix[j, i] = d\n        np.fill_diagonal(dist_matrix, np.inf)\n        \n        lr_fallback = 0.005\n        for _ in range(3000):\n            overlap = np.maximum(0, radii[:, None] + radii[None, :] - dist_matrix)\n            grad = np.ones(n) - 200.0 * np.sum(overlap, axis=1)\n            radii += lr_fallback * grad\n            radii = np.clip(radii, 0, max_bounds)\n            \n    # Strictly enforce constraints to eliminate any floating-point inaccuracies\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n\ndef optimize_packing(n=26, steps=2500):\n    \"\"\"\n    Optimizes the\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef solve_max_radii(centers):\n    \"\"\"\n    Computes the exact maximum valid radii for a given set of centers using Linear Programming.\n    Falls back to a robust projected gradient descent method if scipy is unavailable.\n    \"\"\"\n    n = len(centers)\n    radii = None\n    \n    try:\n        from scipy.optimize import linprog\n        c = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n                \n        bounds = []\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            bounds.append((0, max_r))\n            \n        res = linprog(c, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            radii = res.x\n    except Exception:\n        pass\n        \n    if radii is None:\n        # Fallback to projected gradient descent on constraints\n        radii = np.zeros(n)\n        max_bounds = np.array([min(x, y, 1 - x, 1 - y) for x, y in centers])\n        \n        dist_matrix = np.zeros((n, n))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                dist_matrix[i, j] = d\n                dist_matrix[j, i] = d\n        np.fill_diagonal(dist_matrix, np.inf)\n        \n        lr_fallback = 0.005\n        for _ in range(3000):\n            overlap = np.maximum(0, radii[:, None] + radii[None, :] - dist_matrix)\n            grad = np.ones(n) - 200.0 * np.sum(overlap, axis=1)\n            radii += lr_fallback * grad\n            radii = np.clip(radii, 0, max_bounds)\n            \n    # Strictly enforce constraints to eliminate any floating-point inaccuracies\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(radii[i], x, y, 1 - x, 1 - y)\n        \n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(centers[i] - centers[j])\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return radii\n\n\ndef optimize_packing(n=26, steps=2500):\n    \"\"\"\n    Optimizes the\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_circles = 26\n    num_restarts = 30\n    num_steps = 3000\n\n    np.random.seed(42)\n    B = num_restarts\n    N = n_circles\n\n    # Initialize batch of centers and radii for parallel optimization\n    c = np.random.uniform(0.1, 0.9, (B, N, 2))\n    R = np.full((B, N), 0.05)\n\n    # Structured initialization for first few batches to seed optimal topologies\n    # Batch 0: Grid-ish layout\n    grid_coords = np.linspace(0.15, 0.85, 5)\n    gx, gy = np.meshgrid(grid_coords, grid_coords)\n    grid_pts = np.column_stack((gx.flatten(), gy.flatten()))\n    c[0, :25] = grid_pts\n    c[0, 25] = [0.5, 0.5]\n\n    # Batch 1: Ring layout (mimicking dense known arrangements)\n    c[1, 0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        c[1, i + 1] = [0.5 + 0.25 * np.cos(angle), 0.5 + 0.25 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        c[1, i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n\n    # Batch 2: Another ring layout with different proportions\n    c[2, 0] = [0.5, 0.5]\n    for i in range(6):\n        angle = 2 * np.pi * i / 6\n        c[2, i + 1] = [0.5 + 0.2 * np.cos(angle), 0.5 + 0.2 * np.sin(angle)]\n    for i in range(19):\n        angle = 2 * np.pi * i / 19\n        c[2, i + 7] = [0.5 + 0.4 * np.cos(angle), 0.5 + 0.4 * np.sin(angle)]\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_R = np.zeros_like(R)\n    v_R = np.zeros_like(R)\n\n    lr_c = 0.\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles maximizing the sum of their radii.\nThis implementation uses a gradient-based optimization on circle centers, where the \nobjective gradient is derived from the dual solution of a Linear Programming (LP) \nproblem that maximizes the sum of radii for fixed centers.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square.\n    \n    Returns:\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n_circles = 26\n\n    def solve_max_radii_lp(pts):\n        \"\"\"\n        Computes optimal radii for fixed centers using Linear Programming.\n        Also returns dual variables used for updating center positions.\n        \"\"\"\n        nc = len(pts)\n        # Minimize -sum(r_i) to maximize sum(r_i)\n        c_lp = -np.ones(nc)\n        \n        # Inequality constraints: r_i + r_j <= distance(P_i, P_j)\n        i_idx, j_idx = np.triu_indices(nc, 1)\n        diff = pts[i_idx] - pts[j_idx]\n        dists = np.sqrt(np.sum(diff**2, axis=1))\n        \n        a_ub = np.zeros((len(i_idx), nc))\n        a_ub[np.arange(len(i_idx)), i_idx] = 1\n        a_ub[np.arange(len(i_idx)), j_idx] = 1\n        b_ub = dists\n        \n        # Constraints: 0 <= r_i <= min(x, 1-x, y, 1-y) to stay within square\n        x = pts[:, 0]\n        y = pts[:, 1]\n        max_r_boundary = np.minimum.reduce([x, 1 - x, y, 1 - y])\n        max_r_boundary = np.maximum(0, max_r_boundary)\n        bounds_lp = [(0, r) for r in max_r_boundary]\n        \n        try:\n            # Use Highs solver for speed and access to dual marginals\n            res_lp = linprog(c_lp, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n        except Exception:\n            # Fallback for older scipy versions\n            res_lp = linprog(c_lp, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp)\n            \n        return res_lp, i_idx, j_idx, dists, max_r_boundary\n\n    # Multiple initializations to explore configuration space\n    initial_set = []\n    \n    # Init 1: 5x5 Grid plus one center circle\n    gx1, gy1 = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    c1 = np.column_stack([gx1.ravel(), gy1.ravel()])\n    c1 = np.vstack([c1, [0.5, 0.5]])\n    initial_set.append(c1)\n    \n    # Init 2: Staggered layers (5, 4, 5, 4, 5, 3) to mimic hexagonal density\n    c2 = []\n    layers = [5, 4, 5, 4, 5, 3]\n    for r_idx, n_row in enumerate(layers):\n        for i_idx in range(n_row):\n            c2.append([(i_idx + 0.5) / n_row, (r_idx + 0.5) / len(layers)])\n    initial_set.append(np.array(c2))\n    \n    # Init 3: 4x6 grid plus 2 side circles\n    gx2, gy2 = np.meshgrid(np.linspace(0.12, 0.88, 4), np.linspace(0.1, 0.9, 6))\n    c3 = np.column_stack([gx2.ravel(), gy2.ravel()])\n    c3 = np.vstack([c3, [[0.2, 0.5], [0.8, 0.5]]])\n    initial_set.append(c3)\n\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Optimization Loop\n    for c_start in initial_set:\n        cur_c = c_start.copy()\n        for step in range(120):\n            res, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(cur_c)\n            if not res.success:\n                break\n            \n            curr_sum = -res.fun\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_c = cur_c.copy()\n                best_r = res.x\n            \n            # Use dual variables (marginals) to determine center movement\n            if hasattr(res, 'ineqlin') and res.ineqlin is not None and res.ineqlin.marginals is not None:\n                lambdas = np.abs(res.ineqlin.marginals)\n                mus = np.abs(res.upper.marginals)\n                \n                grad = np.zeros((n_circles, 2))\n                # Gradient component from pairwise distance constraints\n                for k in range(len(i_idx)):\n                    if lambdas[k] > 1e-6:\n                        ii, jj = i_idx[k], j_idx[k]\n                        diff = cur_c[ii] - cur_c[jj]\n                        if dists[k] > 1e-9:\n                            grad[ii] += lambdas[k] * diff / dists[k]\n                            grad[jj] -= lambdas[k] * diff / dists[k]\n                \n                # Gradient component from boundary constraints\n                for i in range(n_circles):\n                    if mus[i] > 1e-6:\n                        xi, yi = cur_c[i]\n                        bounds_vals = [xi, 1 - xi, yi, 1 - yi]\n                        bound_idx = np.argmin(bounds_vals)\n                        if bound_idx == 0: grad[i, 0] += mus[i]\n                        elif bound_idx == 1: grad[i, 0] -= mus[i]\n                        elif bound_idx == 2: grad[i, 1] += mus[i]\n                        elif bound_idx == 3: grad[i, 1] -= mus[i]\n                \n                # Update positions\n                gnorm = np.linalg.norm(grad)\n                if gnorm > 1e-9:\n                    # Normalized step size for stability\n                    cur_c += 0.005 * grad / gnorm\n                cur_c = np.clip(cur_c, 0, 1)\n            else:\n                break\n\n    # Re-verify and Polish best result\n    if best_c is None:\n        best_c = initial_set[1] # Fallback to staggered layout\n    \n    res_fin, i_idx_fin, j_idx_fin, dists_fin, m_r_fin = solve_max_radii_lp(best_c)\n    final_r = res_fin.x\n    final_c = best_c\n    \n    # Strict correction loop to remove potential floating-point overlaps\n    for _ in range(100):\n        for i in range(n_circles):\n            xi, yi = final_c[i]\n            final_r[i] = min(final_r[i], xi, 1 - xi, yi, 1 - yi)\n        for k in range(len(i_idx_fin)):\n            ii, jj = i_idx_fin[k], j_idx_fin[k]\n            d = np.linalg.norm(final_c[ii] - final_c[jj])\n            if final_r[ii] + final_r[jj] > d:\n                overlap = (final_r[ii] + final_r[jj]) - d\n                total_r = final_r[ii] + final_r[jj]\n                if total_r > 0:\n                    final_r[ii] -= overlap * (final_r[ii] / total_r)\n                    final_r[jj] -= overlap * (final_r[jj] / total_r)\n\n    return final_c, final_r, np.sum(final_r)\n# EVOLVE-BLOCK-END\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\nimport numpy as np\n\ndef get_exact_radii(centers):\n    \"\"\"\n    Computes the exact maximum valid radii for a given set of centers using Linear Programming.\n    Falls back to a robust geometric projected gradient descent method if scipy is unavailable.\n    \"\"\"\n    n = len(centers)\n    try:\n        from scipy.optimize import linprog\n        c_obj = -np.ones(n)\n        A_ub = []\n        b_ub = []\n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(dist)\n                \n        bounds = []\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            bounds.append((0, max(0, max_r)))\n            \n        res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds)\n        if res.success:\n            return res.x\n    except Exception:\n        pass\n        \n    # Fallback to optimization if linprog fails or is unavailable\n    r = np.full(n, 0.05)\n    for _ in range(1000):\n        grad = -np.ones(n)\n        for i in range(n):\n            x, y = centers[i]\n            max_r = min(x, y, 1 - x, 1 - y)\n            if r[i] > max_r:\n                grad[i] += 100 * (r[i] - max_r)\n        \n        for i in range(n):\n            for j in range(i + 1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > 0:\n                    grad[i] += 100 * overlap\n                    grad[j] += 100 * overlap\n                    \n        r -= 0.01 * grad\n        r = np.maximum(r, 0)\n    return r\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    B = 50 # Number of parallel batches for optimization\n    \n    # Initialize batch of centers and radii for parallel optimization\n    c = np.random.uniform(0.1, 0.9, (B, n, 2))\n    r = np.full((B, n), 0.05)\n    \n    # Structured initialization to seed optimal topologies\n    # Batch 0: Ring layout 1, 8, 17\n    c[0, 0] = [0.5, 0.5]\n    for i in range(8):\n        a = 2 * np.pi * i / 8\n        c[0, i+1] = [0.5 + 0.2 * np.cos(a), 0.5 + 0.2 * np.sin(a)]\n    for i in range(17):\n        a = 2 * np.pi * i / 17\n        c[0, i+9] = [0.5 + 0.4 * np.cos(a), 0.5 + 0.4 * np.sin(a)]\n\n    # Batch 1: Grid-like 5x5 + 1\n    gx, gy = np.meshgrid(np.linspace(0.15, 0.85, 5), np.linspace(0.15, 0.85, 5))\n    c[1, :25] = np.column_stack([gx.flatten(), gy.flatten()])\n    c[1, 25] = [0.5, 0.5]\n\n    # Batch 2: Another ring layout 1, 6, 19\n    c[2, 0] = [0.5, 0.5]\n    for i in range(6):\n        a = 2 * np.pi * i / 6\n        c[2, i+1] = [0.5 + 0.2 * np.cos(a), 0.5 + 0.2 * np.sin(a)]\n    for i in range(19):\n        a = 2 * np.pi * i / 19\n        c[2, i+7] = [0.5 + 0.4 * np.cos(a), 0.5 + 0.4 * np.sin(a)]\n        \n    # Batch 3: Hexagonalish\n    hex_c = []\n    for i in range(6):\n        for j in range(6):\n            if len(hex_c) < 26:\n                hex_c.append([0.15 + 0.14 * i + (j % 2) * 0.07, 0.15 + 0.14 * j])\n    c[3] = np.array(hex_c)\n\n    # Batch 4: Concentric 4, 9, 13\n    for i in range(4):\n        a = 2 * np.pi * i / 4\n        c[4, i] = [0.5 + 0.1 * np.cos(a), 0.5 + 0.1 * np.sin(a)]\n    for i in range(9):\n        a = 2 * np.pi * i / 9\n        c[4, i+4] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n    for i in range(13):\n        a = 2 * np.pi * i / 13\n        c[4, i+13] = [0.5 + 0.4 * np.cos(a), 0.5 + 0.4 * np.sin(a)]\n\n    # Adam optimizer state\n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    lr_c = 0.005\n    lr_r = 0.005\n    \n    idx_i, idx_j = np.triu_indices(n, k=1)\n    \n    # Main optimization loop\n    for step in range(8000):\n        grad_c = np.zeros_like(c)\n        grad_r = -np.ones_like(r)\n        \n        # Penalties for boundary violations\n        viol_left = np.maximum(0, r - c[:, :, 0])\n        grad_r += 100 * viol_left\n        grad_c[:, :, 0] -= 100 * viol_left\n        \n        viol_right = np.maximum(0, r + c[:, :, 0] - 1)\n        grad_r += 100 * viol_right\n        grad_c[:, :, 0] += 100 * viol_right\n        \n        viol_bottom = np.maximum(0, r - c[:, :, 1])\n        grad_r += 100 * viol_bottom\n        grad_c[:, :, 1] -= 100 * viol_bottom\n        \n        viol_top = np.maximum(0, r + c[:, :, 1] - 1)\n        grad_r += 100 * viol_top\n        grad_c[:, :, 1] += 100 * viol_top\n        \n        # Pairwise overlap penalties\n        c_i = c[:, idx_i, :] \n        c_j = c[:, idx_j, :] \n        r_i = r[:, idx_i]    \n        r_j = r[:, idx_j]    \n        \n        diff = c_i - c_j\n        dist = np.linalg.norm(diff, axis=2) + 1e-10 \n        \n        overlap = np.maximum(0, r_i + r_j - dist) \n        penalty = 200 * overlap \n        \n        dir_ij = diff / dist[:, :, None] \n        force = penalty[:, :, None] * dir_ij \n        \n        for p in range(len(idx_i)):\n            i = idx_i[p]\n            j = idx_j[p]\n            grad_r[:, i] += penalty[:, p]\n            grad_r[:, j] += penalty[:, p]\n            grad_c[:, i, :] -= force[:, p, :]\n            grad_c[:, j, :] += force[:, p, :]\n            \n        # Adam updates\n        m_c = beta1 * m_c + (1 - beta1) * grad_c\n        v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n        m_c_hat = m_c / (1 - beta1 ** (step + 1))\n        v_c_hat = v_c / (1 - beta2 ** (step + 1))\n        c -= lr_c * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        m_r = beta1 * m_r + (1 - beta1) * grad_r\n        v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n        m_r_hat = m_r / (1 - beta1 ** (step + 1))\n        v_r_hat = v_r / (1 - beta2 ** (step + 1))\n        r -= lr_r * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        c = np.clip(c, 0, 1)\n        r = np.maximum(r, 0)\n        \n        # Learning rate decay\n        if step % 2000 == 1999:\n            lr_c *= 0.5\n            lr_r *= 0.5\n\n    best_sum = 0\n    best_c = None\n    best_r = None\n    \n    # Evaluate configurations exactingly to ensure 100% validity\n    for b in range(B):\n        cb = c[b]\n        rb = get_exact_radii(cb)\n        \n        # Strict geometry enforcement multiple passes\n        for _ in range(3):\n            for i in range(n):\n                x, y = cb[i]\n                rb[i] = min(rb[i], x, y, 1 - x, 1 - y)\n                rb[i] = max(0, rb[i])\n                \n            for i in range(n):\n                for j in range(i + 1, n):\n                    dist = np.linalg.norm(cb[i] - cb[j])\n                    if rb[i] + rb[j] > dist:\n                        scale = (dist - 1e-12) / (rb[i] + rb[j])\n                        rb[i] *= scale\n                        rb[j] *= scale\n                        \n        s = np.sum(rb)\n        if s > best_sum:\n            best_sum = s\n            best_c = cb\n            best_r = rb\n            \n    return best_c, best_r, best_sum\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles maximizing the sum of their radii.\nThis implementation uses a dual-gradient optimization approach. For a fixed set of\ncenters, we solve a Linear Programming (LP) problem to find the optimal radii. \nThe dual variables of this LP provide the sensitivity of the sum of radii to the \ndistances between centers and to the distances from the centers to the boundaries.\nThe centers are then updated iteratively in the direction that increases the total sum.\n\"\"\"\n\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef solve_max_radii_lp(pts):\n    \"\"\"\n    Computes optimal radii for fixed centers using Linear Programming.\n    Returns the LP result, pairwise indices, and the tightest boundary constraints.\n    \"\"\"\n    n = pts.shape[0]\n    # Objective: minimize -sum(radii) to maximize sum(radii)\n    c_obj = -np.ones(n)\n\n    # Inequality constraints: r_i + r_j <= distance(P_i, P_j)\n    i_idx, j_idx = np.triu_indices(n, 1)\n    diffs = pts[i_idx] - pts[j_idx]\n    dists = np.hypot(diffs[:, 0], diffs[:, 1])\n\n    # A_ub * r <= b_ub\n    a_ub = np.zeros((len(i_idx), n))\n    a_ub[np.arange(len(i_idx)), i_idx] = 1\n    a_ub[np.arange(len(i_idx)), j_idx] = 1\n    b_ub = dists\n\n    # Boundary constraints: r_i <= min(x, 1-x, y, 1-y)\n    # Ensure pts are within (0, 1) to avoid negative bounds\n    pts_clipped = np.clip(pts, 1e-9, 1 - 1e-9)\n    x = pts_clipped[:, 0]\n    y = pts_clipped[:, 1]\n    b_left = x\n    b_right = 1.0 - x\n    b_bottom = y\n    b_top = 1.0 - y\n\n    # Find which boundary is tightest for each circle\n    max_r_boundary = np.minimum.reduce([b_left, b_right, b_bottom, b_top])\n    bounds_lp = [(0, r) for r in max_r_boundary]\n\n    try:\n        # Highs is efficient and provides marginals (duals)\n        res = linprog(c_obj, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp, method='highs')\n    except Exception:\n        # Fallback to default if 'highs' is unavailable\n        res = linprog(c_obj, A_ub=a_ub, b_ub=b_ub, bounds=bounds_lp)\n\n    return res, i_idx, j_idx, dists, max_r_boundary\n\n\ndef run_packing():\n    \"\"\"\n    Runs the circle packing optimization and returns the best found configuration.\n    \"\"\"\n    n_circles = 26\n    best_sum = -1.0\n    best_c = None\n    best_r = None\n\n    # Define several starting configurations\n    initial_configs = []\n\n    # Init 1: 5x5 Grid with one circle in the center\n    gx, gy = np.meshgrid(np.linspace(0.1, 0.9, 5), np.linspace(0.1, 0.9, 5))\n    c1 = np.column_stack([gx.ravel(), gy.ravel()])\n    c1 = np.vstack([c1, [0.5, 0.5]])\n    initial_configs.append(c1)\n\n    # Init 2: Hexagonal-like staggered layers (5, 4, 5, 4, 5, 3) = 26 circles\n    c2 = []\n    layers = [5, 4, 5, 4, 5, 3]\n    for r_idx, n_row in enumerate(layers):\n        y_coord = (r_idx + 0.5) / len(layers)\n        for i_idx in range(n_row):\n            x_coord = (i_idx + 0.5) / n_row\n            c2.append([x_coord, y_coord])\n    initial_configs.append(np.array(c2))\n\n    # Init 3: 6x4 Grid plus 2 extra circles\n    gx2, gy2 = np.meshgrid(np.linspace(0.1, 0.9, 6), np.linspace(0.1, 0.9, 4))\n    c3 = np.column_stack([gx2.ravel(), gy2.ravel()])\n    c3 = np.vstack([c3, [[0.2, 0.5], [0.8, 0.5]]])\n    initial_configs.append(c3)\n\n    # Optimize each initial configuration\n    for start_c in initial_configs:\n        cur_c = start_c.copy()\n        \n        # Dual-gradient optimization iterations\n        for step in range(150):\n            res, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(cur_c)\n            if not res.success:\n                break\n\n            curr_sum = -res.fun\n            if curr_sum > best_sum:\n                best_sum = curr_sum\n                best_c = cur_c.copy()\n                best_r = res.x\n\n            # Extract dual variables (marginals)\n            lambdas = getattr(getattr(res, 'ineqlin', None), 'marginals', None)\n            mus = getattr(getattr(res, 'upper', None), 'marginals', None)\n\n            if lambdas is not None and mus is not None:\n                grad = np.zeros((n_circles, 2))\n                \n                # Update gradient based on pairwise distance constraints\n                for k in range(len(i_idx)):\n                    lam = abs(lambdas[k])\n                    if lam > 1e-7:\n                        ii, jj = i_idx[k], j_idx[k]\n                        diff = cur_c[ii] - cur_c[jj]\n                        d = dists[k]\n                        if d > 1e-8:\n                            grad[ii] += lam * diff / d\n                            grad[jj] -= lam * diff / d\n\n                # Update gradient based on boundary constraints\n                for i in range(n_circles):\n                    mu = abs(mus[i])\n                    if mu > 1e-7:\n                        xi, yi = cur_c[i]\n                        b_vals = [xi, 1.0 - xi, yi, 1.0 - yi]\n                        tightest = np.argmin(b_vals)\n                        if tightest == 0: grad[i, 0] += mu\n                        elif tightest == 1: grad[i, 0] -= mu\n                        elif tightest == 2: grad[i, 1] += mu\n                        elif tightest == 3: grad[i, 1] -= mu\n\n                # Normalize step for stability and apply update\n                gnorm = np.linalg.norm(grad)\n                if gnorm > 1e-9:\n                    # Decay the step size over time\n                    step_size = 0.006 * (0.99 ** step)\n                    cur_c += step_size * grad / gnorm\n                \n                # Keep centers within the unit square\n                cur_c = np.clip(cur_c, 1e-7, 1.0 - 1e-7)\n            else:\n                break\n\n    # Perform a final rigorous LP solve and validity correction\n    if best_c is None:\n        best_c = initial_configs[1]\n\n    res_final, i_idx, j_idx, dists, max_r_b = solve_max_radii_lp(best_c)\n    final_r = res_final.x\n    final_c = best_c\n\n    # Strict geometry enforcement (multi-pass) to ensure zero overlap or boundary violation\n    for _ in range(50):\n        for i in range(n_circles):\n            final_r[i] = min(final_r[i], final_c[i, 0], 1.0 - final_c[i, 0], \n                             final_c[i, 1], 1.0 - final_c[i, 1])\n            final_r[i] = max(0, final_r[i])\n        for k in range(len(i_idx)):\n            ii, jj = i_idx[k], j_idx[k]\n            d = np.hypot(final_c[ii, 0] - final_c[jj, 0], final_c[ii, 1] - final_c[jj, 1])\n            if final_r[ii] + final_r[jj] > d:\n                overlap = (final_r[ii] + final_r[jj]) - d\n                total_r = final_r[ii] + final_r[jj]\n                if total_r > 0:\n                    final_r[ii] -= overlap * (final_r[ii] / total_r)\n                    final_r[jj] -= overlap * (final_r[jj] / total_r)\n\n    return final_c, final_r, np.sum(final_r)\n\n\ndef construct_packing():\n    \"\"\"Alias for run_packing to match expected constructor interface.\"\"\"\n    return run_packing()\n# EVOLVE-BLOCK-END\n```"]}}, "artifacts_json": "{\"execution_time\": \"1.24s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.479738/2.635 = 0.9411\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}