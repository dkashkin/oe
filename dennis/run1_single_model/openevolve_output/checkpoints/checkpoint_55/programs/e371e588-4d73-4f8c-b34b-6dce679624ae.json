{"id": "e371e588-4d73-4f8c-b34b-6dce679624ae", "code": "import numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square. Uses coordinate descent with a large variety\n    of greedy expansion orders to find the optimal set of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    bounds = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Eye matrix to ignore self-distance in vectorized calculations\n    eye_n = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: geometric sorting and random permutations\n    orders = [\n        np.argsort(bounds),\n        np.argsort(-bounds),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Iterate multiple times to ensure the radii converge to a local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(bounds[i], np.min(dists[i] - radii + eye_n[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter across\n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.218, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(600 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-5-6-5-5 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 5, 6, 5, 5]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n\n            # Add decreasing noise to escape local minima\n            if k < iters * 0.6:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Compute maximized radii for the final centers found in this restart\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")", "changes_description": null, "language": "python", "parent_id": "5fc12833-4f32-4d8f-bdfe-3a64d9ce8a4e", "generation": 2, "timestamp": 1771869751.6297657, "iteration_found": 41, "metrics": {"validity": 1.0, "sum_radii": 2.4780469108384007, "target_ratio": 0.9404352602802281, "combined_score": 0.9404352602802281, "radius_variance": 0.0002183758049328579, "spatial_spread": 0.18821304999822816, "eval_time": 4.484872102737427}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 2.4556500167967377, "target_ratio": 0.9319354902454413, "combined_score": 0.9319354902454413, "radius_variance": 0.00035241760346652073, "spatial_spread": 0.19480923773191144, "eval_time": 0.5164246559143066}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.9319\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.9319\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### execution_time\n```\n0.52s\n```\n\n### stage\n```\nquick_validation\n```\n\n### packing_summary\n```\nSum of radii: 2.455650/2.635 = 0.9319\n```\n\n### validation_report\n```\nValid: True, Violations: 0 boundary, 0 overlaps\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4557, target_ratio: 0.9319, combined_score: 0.9319, radius_variance: 0.0004, spatial_spread: 0.1948, eval_time: 0.5164\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4648, target_ratio: 0.9354, combined_score: 0.9354, radius_variance: 0.0002, spatial_spread: 0.1931, eval_time: 2.4722\n- Outcome: Improvement in all metrics\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4694, target_ratio: 0.9371, combined_score: 0.9371, radius_variance: 0.0011, spatial_spread: 0.1952, eval_time: 2.2235\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9371)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square, ensuring no overlaps and respect for boundaries.\n    Uses coordinate descent with multiple greedy expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several expansion orders to maximize the sum of radii\n    for trial in range(13):\n        radii = np.zeros(n)\n        if trial == 0:\n            order = np.arange(n)\n        elif trial == 1:\n            order = np.argsort(boundary_limits)\n        else:\n            order = np.random.permutation(n)\n\n        # Coordinate descent to solve for optimal radii for fixed centers\n        for _ in range(25):\n            for i in order:\n                # Maximum radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dist_matrix[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter, followed\n    by a greedy radii optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    iters = 1600\n    dt_base = 0.05\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple restarts\n    target_dists = np.linspace(0.198, 0.208, 10)\n    \n    for restart in range(10):\n        # Set seed for reproducibility per restart\n        np.random.seed(200 + restart)\n        target_dist = target_dists[restart]\n        \n        # Initial layout: 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n        \n        # Placement of the 26th circle varies to diversify the search\n        if restart % 3 == 0:\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            centers[25] = [0.05, 0.05]\n        else:\n            centers[25] = [0.95, 0.95]\n            \n        # Add jitter to break initial symmetry and encourage exploration\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            # Magnitude proportional to overlap distance\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with a cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n            \n            # Add small noise early in the simulation to help skip local minima\n            if k < iters * 0.6:\n                noise_mag = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Compute maximized radii for these center positions\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to run the packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4694), Performs well on target_ratio (0.9371), Performs well on combined_score (0.9371), Performs well on radius_variance (0.0011), Performs well on spatial_spread (0.1952), Performs well on eval_time (2.2235)\n\n### Program 2 (Score: 0.9354)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square. Uses iterative coordinate descent with multiple\n    randomized greedy expansion orders to find a near-optimal set of radii.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates.\n\n    Returns:\n        np.array: Optimized radii for each circle.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    bounds = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Identity matrix used to ignore self-distance in vectorized calculations\n    eye_n = np.eye(n) * 1e9\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Try several orders of expansion to explore different configurations\n    for trial in range(120):\n        if trial == 0:\n            # Circles closer to corners/edges expanded first\n            order = np.argsort(bounds)\n        elif trial == 1:\n            # Circles in the center expanded first\n            order = np.argsort(-bounds)\n        else:\n            # Random permutations to diversify the search\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given the fixed centers\n        for _ in range(5):\n            for i in order:\n                # Radius r_i must be <= distance to boundary and <= dist(i,j) - r_j\n                r_i = min(bounds[i], np.min(dists[i] - radii + eye_n[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    multi-restart force-directed physics simulation, followed by\n    greedy radii optimization to maximize the sum of radii.\n\n    Returns:\n        Tuple: (centers, radii, sum_radii)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Use multiple restarts with different target distances and initializations\n    restarts = 14\n    target_dists = np.linspace(0.185, 0.215, restarts)\n\n    for r_idx in range(restarts):\n        np.random.seed(400 + r_idx)\n        target_dist = target_dists[r_idx]\n\n        # Initialization: mix of structured grid and random noise\n        if r_idx % 2 == 0:\n            # Start with a jittered 5x5 grid plus one circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n            centers[25] = [0.5, 0.5]\n            centers += np.random.normal(0, 0.015, (n, 2))\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters\n        dt_base = 0.06\n        iters = 1200\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion between circles based on target distance\n            overlap = np.maximum(0, target_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            # Horizontal boundary forces\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            # Vertical boundary forces\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n\n            # Add decreasing noise to help the simulation escape local minima\n            if k < iters * 0.5:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.5))\n                centers += np.random.normal(0, noise_mag, centers.shape)\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Compute maximized radii for the final center configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    return construct_packing()\n\n\nif __name__ == \"__main__\":\n    # Test execution and performance check\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4648), Performs well on target_ratio (0.9354), Performs well on combined_score (0.9354), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1931), Performs well on eval_time (2.4722)\n\n### Program 3 (Score: 0.9319)\n```python\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using a force-directed\n    simulation and a greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Seed for reproducibility\n    np.random.seed(42)\n\n    # Initial layout: 5x5 grid plus one extra circle\n    centers = np.zeros((n, 2))\n    for i in range(5):\n        for j in range(5):\n            centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n    \n    # Place the 26th circle in the center and add jitter to break symmetry\n    centers[25] = [0.5, 0.5]\n    centers += np.random.uniform(-0.02, 0.02, (n, 2))\n\n    # Force-directed simulation parameters\n    # A target distance of ~0.203 aims for a sum of radii around 2.639\n    iters = 1200\n    dt = 0.05\n    target_dist = 0.203\n    target_radius = target_dist / 2.0\n\n    # Physics simulation loop\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        # Pairwise repulsion between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = (dx * dx + dy * dy)**0.5 + 1e-9\n                if dist < target_dist:\n                    f = (target_dist - dist) / dist\n                    forces[i, 0] += dx * f\n                    forces[i, 1] += dy * f\n                    forces[j, 0] -= dx * f\n                    forces[j, 1] -= dy * f\n        \n        # Repulsion from square boundaries\n        for i in range(n):\n            # Distance to left wall\n            if centers[i, 0] < target_radius:\n                forces[i, 0] += (target_radius - centers[i, 0])\n            # Distance to right wall\n            if centers[i, 0] > 1.0 - target_radius:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - target_radius))\n            # Distance to bottom wall\n            if centers[i, 1] < target_radius:\n                forces[i, 1] += (target_radius - centers[i, 1])\n            # Distance to top wall\n            if centers[i, 1] > 1.0 - target_radius:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - target_radius))\n        \n        # Update centers and constrain within unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final maximized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximize the sum of radii for fixed centers by solving the\n    overlap and boundary constraints iteratively.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii to the distance to the closest boundary\n    for i in range(n):\n        radii[i] = min(centers[i, 0], centers[i, 1], \n                       1.0 - centers[i, 0], 1.0 - centers[i, 1])\n\n    # 2. Proportionally scale down radii to eliminate overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = (dx * dx + dy * dy)**0.5\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j] + 1e-12)\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Iteratively expand circles greedily to maximize the sum of radii\n    # We alternate the order to ensure fair space distribution\n    for it in range(60):\n        order = range(n) if it % 2 == 0 else range(n - 1, -1, -1)\n        for i in order:\n            # Maximum radius is limited by distance to boundaries\n            r_limit = min(centers[i, 0], centers[i, 1], \n                          1.0 - centers[i, 0], 1.0 - centers[i, 1])\n            # And distance to every other already-sized circle\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = (dx * dx + dy * dy)**0.5\n                    r_limit = min(r_limit, dist - radii[j])\n            radii[i] = max(0.0, r_limit)\n\n    return radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4557), Performs well on target_ratio (0.9319), Performs well on combined_score (0.9319), Performs well on radius_variance (0.0004), Performs well on spatial_spread (0.1948), Performs well on eval_time (0.5164)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.8113)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using a \n    force-directed simulation and greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Initial layout: 5x5 grid plus one circle in the middle\n    centers = np.zeros((n, 2))\n    for i in range(25):\n        centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n    centers[25] = [0.5, 0.5]\n\n    # Add small jitter to break symmetry for better packing exploration\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.01, (n, 2))\n\n    # Parameters for the physics-based repulsion simulation\n    # Target distance corresponds to an average radius of ~0.1015\n    iters = 500\n    dt = 0.08\n    target_dist = 0.203\n\n    # Simulation loop: push overlapping circles apart\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = centers[i] - centers[j]\n                dist = np.sqrt(d[0]**2 + d[1]**2)\n                if dist < target_dist:\n                    # Prevent division by zero with small epsilon\n                    if dist < 1e-8:\n                        d = np.array([0.01, 0.0])\n                        dist = 0.01\n                    # Repulsion force proportional to overlap\n                    f = (target_dist - dist) / dist\n                    forces[i] += d * f\n                    forces[j] -= d * f\n        \n        centers += forces * dt\n        # Constrain centers to the unit square\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final optimized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    using proportional scaling followed by iterative greedy refinement.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii based on distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # 2. Proportionally scale radii to remove any circle-circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = np.sqrt(dx*dx + dy*dy)\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Greedy refinement to maximize the sum of radii\n    # In each step, maximize r_i given all other fixed radii\n    for _ in range(20):\n        for i in range(n):\n            # Distance to boundaries\n            m = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            # Distance to all other circles\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = np.sqrt(dx*dx + dy*dy)\n                    if dist - radii[j] < m:\n                        m = dist - radii[j]\n            radii[i] = max(0.0, m)\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.8312)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes the maximum possible radii for each circle position such that\n    no circles overlap and all stay within the unit square. Uses a greedy\n    iterative approach to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Maximum radius for each circle restricted only by the square boundaries\n    boundary_limits = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n    \n    best_radii = np.zeros(n)\n    best_sum = 0\n    \n    # Run multiple trials with different random greedy expansion orders\n    for trial in range(15):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Iteratively maximize each radius given the others\n        for _ in range(25):\n            for i in order:\n                # Radius must satisfy r_i <= boundary_limit and r_i + r_j <= dist_ij\n                limit = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        # Candidate radius given fixed neighbor j\n                        limit = min(limit, dist - radii[j])\n                radii[i] = max(0.0, limit)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize \n    the sum of radii using a force-directed physics simulation.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a structured pattern: 4 rows of 5 and 1 middle row of 6\n    centers_list = []\n    # Top and bottom rows (y=0.1, 0.3, 0.7, 0.9)\n    for y in [0.1, 0.3, 0.7, 0.9]:\n        for x in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            centers_list.append([x, y])\n    # Middle row (y=0.5) with 6 circles\n    for x in np.linspace(0.08, 0.92, 6):\n        centers_list.append([x, 0.5])\n        \n    centers = np.array(centers_list)\n    \n    # Add small jitter to break symmetry\n    centers += np.random.normal(0, 0.005, (n, 2))\n    \n    # Physics parameters: target separation distance and time step\n    dt = 0.1\n    target_dist = 0.203\n    \n    # Simulation loop to optimize center positions\n    for _ in range(3000):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            # Inter-circle repulsion\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d = np.linalg.norm(d_vec)\n                if d < target_dist:\n                    # Prevent division by zero\n                    if d < 1e-9:\n                        d_vec = np.array([0.001, 0.0])\n                        d = 0.001\n                    # Magnitude of repulsion proportional to overlap\n                    f_mag = (target_dist - d) / d\n                    forces[i] += d_vec * f_mag\n                    forces[j] -= d_vec * f_mag\n            \n            # Boundary repulsion: pushes centers away from square edges\n            r_est = target_dist / 2.0\n            if centers[i, 0] < r_est:\n                forces[i, 0] += (r_est - centers[i, 0])\n            elif centers[i, 0] > 1.0 - r_est:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - r_est))\n                \n            if centers[i, 1] < r_est:\n                forces[i, 1] += (r_est - centers[i, 1])\n            elif centers[i, 1] > 1.0 - r_est:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - r_est))\n        \n        # Apply force updates and constrain centers to the unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Annealing the step size\n        dt *= 0.999\n        \n    # Calculate optimal radii for final center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point for evaluating the packing of n=26 circles.\n    Returns (centers, radii, sum_radii).\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.8113, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii using a \n    force-directed simulation and greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Initial layout: 5x5 grid plus one circle in the middle\n    centers = np.zeros((n, 2))\n    for i in range(25):\n        centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n    centers[25] = [0.5, 0.5]\n\n    # Add small jitter to break symmetry for better packing exploration\n    np.random.seed(42)\n    centers += np.random.normal(0, 0.01, (n, 2))\n\n    # Parameters for the physics-based repulsion simulation\n    # Target distance corresponds to an average radius of ~0.1015\n    iters = 500\n    dt = 0.08\n    target_dist = 0.203\n\n    # Simulation loop: push overlapping circles apart\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = centers[i] - centers[j]\n                dist = np.sqrt(d[0]**2 + d[1]**2)\n                if dist < target_dist:\n                    # Prevent division by zero with small epsilon\n                    if dist < 1e-8:\n                        d = np.array([0.01, 0.0])\n                        dist = 0.01\n                    # Repulsion force proportional to overlap\n                    f = (target_dist - dist) / dist\n                    forces[i] += d * f\n                    forces[j] -= d * f\n        \n        centers += forces * dt\n        # Constrain centers to the unit square\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final optimized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    using proportional scaling followed by iterative greedy refinement.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii based on distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # 2. Proportionally scale radii to remove any circle-circle overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = np.sqrt(dx*dx + dy*dy)\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Greedy refinement to maximize the sum of radii\n    # In each step, maximize r_i given all other fixed radii\n    for _ in range(20):\n        for i in range(n):\n            # Distance to boundaries\n            m = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            # Distance to all other circles\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = np.sqrt(dx*dx + dy*dy)\n                    if dist - radii[j] < m:\n                        m = dist - radii[j]\n            radii[i] = max(0.0, m)\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.8312, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Computes the maximum possible radii for each circle position such that\n    no circles overlap and all stay within the unit square. Uses a greedy\n    iterative approach to maximize the sum of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Maximum radius for each circle restricted only by the square boundaries\n    boundary_limits = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n    \n    best_radii = np.zeros(n)\n    best_sum = 0\n    \n    # Run multiple trials with different random greedy expansion orders\n    for trial in range(15):\n        radii = np.zeros(n)\n        order = np.random.permutation(n)\n        \n        # Iteratively maximize each radius given the others\n        for _ in range(25):\n            for i in order:\n                # Radius must satisfy r_i <= boundary_limit and r_i + r_j <= dist_ij\n                limit = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        dist = np.linalg.norm(centers[i] - centers[j])\n                        # Candidate radius given fixed neighbor j\n                        limit = min(limit, dist - radii[j])\n                radii[i] = max(0.0, limit)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs a packing of 26 circles in a unit square to maximize \n    the sum of radii using a force-directed physics simulation.\n    \"\"\"\n    n = 26\n    np.random.seed(42)\n    \n    # Initialize with a structured pattern: 4 rows of 5 and 1 middle row of 6\n    centers_list = []\n    # Top and bottom rows (y=0.1, 0.3, 0.7, 0.9)\n    for y in [0.1, 0.3, 0.7, 0.9]:\n        for x in [0.1, 0.3, 0.5, 0.7, 0.9]:\n            centers_list.append([x, y])\n    # Middle row (y=0.5) with 6 circles\n    for x in np.linspace(0.08, 0.92, 6):\n        centers_list.append([x, 0.5])\n        \n    centers = np.array(centers_list)\n    \n    # Add small jitter to break symmetry\n    centers += np.random.normal(0, 0.005, (n, 2))\n    \n    # Physics parameters: target separation distance and time step\n    dt = 0.1\n    target_dist = 0.203\n    \n    # Simulation loop to optimize center positions\n    for _ in range(3000):\n        forces = np.zeros((n, 2))\n        for i in range(n):\n            # Inter-circle repulsion\n            for j in range(i + 1, n):\n                d_vec = centers[i] - centers[j]\n                d = np.linalg.norm(d_vec)\n                if d < target_dist:\n                    # Prevent division by zero\n                    if d < 1e-9:\n                        d_vec = np.array([0.001, 0.0])\n                        d = 0.001\n                    # Magnitude of repulsion proportional to overlap\n                    f_mag = (target_dist - d) / d\n                    forces[i] += d_vec * f_mag\n                    forces[j] -= d_vec * f_mag\n            \n            # Boundary repulsion: pushes centers away from square edges\n            r_est = target_dist / 2.0\n            if centers[i, 0] < r_est:\n                forces[i, 0] += (r_est - centers[i, 0])\n            elif centers[i, 0] > 1.0 - r_est:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - r_est))\n                \n            if centers[i, 1] < r_est:\n                forces[i, 1] += (r_est - centers[i, 1])\n            elif centers[i, 1] > 1.0 - r_est:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - r_est))\n        \n        # Apply force updates and constrain centers to the unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Annealing the step size\n        dt *= 0.999\n        \n    # Calculate optimal radii for final center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n    \n    return centers, radii, sum_radii\n\n\ndef run_packing():\n    \"\"\"\n    Main entry point for evaluating the packing of n=26 circles.\n    Returns (centers, radii, sum_radii).\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.9371, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square, ensuring no overlaps and respect for boundaries.\n    Uses coordinate descent with multiple greedy expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several expansion orders to maximize the sum of radii\n    for trial in range(13):\n        radii = np.zeros(n)\n        if trial == 0:\n            order = np.arange(n)\n        elif trial == 1:\n            order = np.argsort(boundary_limits)\n        else:\n            order = np.random.permutation(n)\n\n        # Coordinate descent to solve for optimal radii for fixed centers\n        for _ in range(25):\n            for i in order:\n                # Maximum radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dist_matrix[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter, followed\n    by a greedy radii optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    iters = 1600\n    dt_base = 0.05\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple restarts\n    target_dists = np.linspace(0.198, 0.208, 10)\n    \n    for restart in range(10):\n        # Set seed for reproducibility per restart\n        np.random.seed(200 + restart)\n        target_dist = target_dists[restart]\n        \n        # Initial layout: 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n        \n        # Placement of the 26th circle varies to diversify the search\n        if restart % 3 == 0:\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            centers[25] = [0.05, 0.05]\n        else:\n            centers[25] = [0.95, 0.95]\n            \n        # Add jitter to break initial symmetry and encourage exploration\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            # Magnitude proportional to overlap distance\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with a cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n            \n            # Add small noise early in the simulation to help skip local minima\n            if k < iters * 0.6:\n                noise_mag = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Compute maximized radii for these center positions\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to run the packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n\"\"\"Constructor-based circle packing for n=26 circles in a unit square\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that maximizes the sum of their radii using a force-directed\n    simulation and a greedy radius optimization.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    n = 26\n    # Seed for reproducibility\n    np.random.seed(42)\n\n    # Initial layout: 5x5 grid plus one extra circle\n    centers = np.zeros((n, 2))\n    for i in range(5):\n        for j in range(5):\n            centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n    \n    # Place the 26th circle in the center and add jitter to break symmetry\n    centers[25] = [0.5, 0.5]\n    centers += np.random.uniform(-0.02, 0.02, (n, 2))\n\n    # Force-directed simulation parameters\n    # A target distance of ~0.203 aims for a sum of radii around 2.639\n    iters = 1200\n    dt = 0.05\n    target_dist = 0.203\n    target_radius = target_dist / 2.0\n\n    # Physics simulation loop\n    for _ in range(iters):\n        forces = np.zeros((n, 2))\n        # Pairwise repulsion between circles\n        for i in range(n):\n            for j in range(i + 1, n):\n                dx = centers[i, 0] - centers[j, 0]\n                dy = centers[i, 1] - centers[j, 1]\n                dist = (dx * dx + dy * dy)**0.5 + 1e-9\n                if dist < target_dist:\n                    f = (target_dist - dist) / dist\n                    forces[i, 0] += dx * f\n                    forces[i, 1] += dy * f\n                    forces[j, 0] -= dx * f\n                    forces[j, 1] -= dy * f\n        \n        # Repulsion from square boundaries\n        for i in range(n):\n            # Distance to left wall\n            if centers[i, 0] < target_radius:\n                forces[i, 0] += (target_radius - centers[i, 0])\n            # Distance to right wall\n            if centers[i, 0] > 1.0 - target_radius:\n                forces[i, 0] -= (centers[i, 0] - (1.0 - target_radius))\n            # Distance to bottom wall\n            if centers[i, 1] < target_radius:\n                forces[i, 1] += (target_radius - centers[i, 1])\n            # Distance to top wall\n            if centers[i, 1] > 1.0 - target_radius:\n                forces[i, 1] -= (centers[i, 1] - (1.0 - target_radius))\n        \n        # Update centers and constrain within unit square\n        centers += forces * dt\n        centers = np.clip(centers, 0.0, 1.0)\n\n    # Compute final maximized radii for these center positions\n    radii = compute_max_radii(centers)\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximize the sum of radii for fixed centers by solving the\n    overlap and boundary constraints iteratively.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.zeros(n)\n\n    # 1. Initialize radii to the distance to the closest boundary\n    for i in range(n):\n        radii[i] = min(centers[i, 0], centers[i, 1], \n                       1.0 - centers[i, 0], 1.0 - centers[i, 1])\n\n    # 2. Proportionally scale down radii to eliminate overlaps\n    for i in range(n):\n        for j in range(i + 1, n):\n            dx = centers[i, 0] - centers[j, 0]\n            dy = centers[i, 1] - centers[j, 1]\n            dist = (dx * dx + dy * dy)**0.5\n            if radii[i] + radii[j] > dist:\n                scale = dist / (radii[i] + radii[j] + 1e-12)\n                radii[i] *= scale\n                radii[j] *= scale\n\n    # 3. Iteratively expand circles greedily to maximize the sum of radii\n    # We alternate the order to ensure fair space distribution\n    for it in range(60):\n        order = range(n) if it % 2 == 0 else range(n - 1, -1, -1)\n        for i in order:\n            # Maximum radius is limited by distance to boundaries\n            r_limit = min(centers[i, 0], centers[i, 1], \n                          1.0 - centers[i, 0], 1.0 - centers[i, 1])\n            # And distance to every other already-sized circle\n            for j in range(n):\n                if i != j:\n                    dx = centers[i, 0] - centers[j, 0]\n                    dy = centers[i, 1] - centers[j, 1]\n                    dist = (dx * dx + dy * dy)**0.5\n                    r_limit = min(r_limit, dist - radii[j])\n            radii[i] = max(0.0, r_limit)\n\n    return radii\n\n\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square. Uses coordinate descent with a large variety\n    of greedy expansion orders to find the optimal set of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    bounds = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Eye matrix to ignore self-distance in vectorized calculations\n    eye_n = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: geometric sorting and random permutations\n    orders = [\n        np.argsort(bounds),\n        np.argsort(-bounds),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Iterate multiple times to ensure the radii converge to a local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(bounds[i], np.min(dists[i] - radii + eye_n[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter across\n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.218, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(600 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-5-6-5-5 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 5, 6, 5, 5]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n\n            # Add decreasing noise to escape local minima\n            if k < iters * 0.6:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Compute maximized radii for the final centers found in this restart\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```"]}}, "artifacts_json": "{\"execution_time\": \"4.48s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.478047/2.635 = 0.9404\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}