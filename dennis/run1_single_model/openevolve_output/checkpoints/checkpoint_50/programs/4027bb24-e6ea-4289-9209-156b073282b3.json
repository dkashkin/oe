{"id": "4027bb24-e6ea-4289-9209-156b073282b3", "code": "import numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Directly produces an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a multi-stage approach: a physics-inspired \n    optimization phase (Adam) to find robust center locations, followed by \n    Linear Programming to determine the mathematically optimal radii for those \n    centers. Finally, a feasibility check ensures the packing is strictly valid.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialization\n    # Start with a 5x5 grid (25 circles) plus one circle in the center.\n    grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(grid, grid)\n    c = np.column_stack([xv.ravel(), yv.ravel()])\n    c = np.vstack([c, [0.5, 0.5]])\n    \n    # Break symmetry with jitter to avoid local minima and aid the optimizer.\n    np.random.seed(42)\n    c += np.random.normal(0, 0.02, (n, 2))\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initial radii guess\n    r = np.full(n, 0.09)\n    \n    # 2. Optimization Phase (Adam)\n    # This phase moves centers and adjusts radii to reduce overlaps and expand.\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.001\n    \n    iters = 3000\n    for t in range(1, iters + 1):\n        # Gradually increase penalty to transition from soft to hard constraints.\n        penalty_coeff = 2.0 + t * 0.1\n        \n        dc = np.zeros_like(c)\n        dr = -np.ones(n)  # Objective: maximize sum(r_i) -> minimize -sum(r_i)\n        \n        # Boundary constraints: r_i <= distance to nearest edge\n        for i in range(2):  # X and Y dimensions\n            # Low boundary violations (c_i - r_i < 0)\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            dr[mask_low] += 2 * penalty_coeff * v_low[mask_low]\n            dc[mask_low, i] -= 2 * penalty_coeff * v_low[mask_low]\n            \n            # High boundary violations (c_i + r_i > 1)\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            dr[mask_high] += 2 * penalty_coeff * v_high[mask_high]\n            dc[mask_high, i] += 2 * penalty_coeff * v_high[mask_high]\n            \n        # Pairwise overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        for i in range(n):\n            diff = c[i] - c[i + 1:]\n            # Distance with stability constant\n            dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n            sum_r = r[i] + r[i + 1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n            \n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = dists[mask]\n                df = diff[mask]\n                \n                # Update gradients for radii\n                grad_r = 2 * penalty_coeff * ov\n                dr[i] += np.sum(grad_r)\n                dr[idx] += grad_r\n                \n                # Update gradients for centers (moving circles apart)\n                grad_c = (grad_r / di)[:, np.newaxis] * df\n                dc[i] += np.sum(grad_c, axis=0)\n                dc[idx] -= grad_c\n        \n        # Adam step for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam step for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Clip to maintain logical bounds\n        c = np.clip(c, 0.0, 1.0)\n        r = np.clip(r, 1e-5, 0.5)\n\n    # 3. Radius Refinement (Linear Programming)\n    # Fix center locations and find the optimal radii.\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            # Use a tiny safety margin to ensure feasibility under precision\n            b_ub.append(dist - 1e-12)\n    \n    # Boundary bounds for each radius\n    bounds = []\n    for i in range(n):\n        dist_to_edge = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        bounds.append((0, max(0.0, dist_to_edge - 1e-12)))\n    \n    # Solve the maximization problem: min -sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bounds, method='highs')\n    \n    if res_lp.success:\n        r_final = res_lp.x\n    else:\n        r_final = r  # Fallback to the optimized radii\n\n    # 4. Strict Feasibility Check (Post-processing)\n    # Shrink slightly to avoid any potential floating-point violations.\n    r_final *= (1.0 - 1e-11)\n    for i in range(n):\n        r_final[i] = min(r_final[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            if r_final[i] + r_final[j] > dist:\n                overlap = (r_final[i] + r_final[j]) - dist\n                r_final[i] -= overlap * 0.5\n                r_final[j] -= overlap * 0.5\n    \n    r_final = np.maximum(r_final, 0.0)\n    sum_r = np.sum(r_final)\n    \n    return c, r_final, sum_r\n\n\n# Execution to define required output variables\ncenters, radii, sum_radii = run_packing()", "changes_description": null, "language": "python", "parent_id": "19058ac8-49b6-44ea-8ed6-ce5cb45b7120", "generation": 3, "timestamp": 1771869721.1600385, "iteration_found": 40, "metrics": {"validity": 1.0, "sum_radii": 0.5606423362524282, "target_ratio": 0.21276749003887221, "combined_score": 0.21276749003887221, "radius_variance": 0.007796687214665014, "spatial_spread": 0.1784419990140361}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 2}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.0000\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: module 'program' has no attribute 'run_packing'\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/cp_1model_1phase/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/cp_1model_1phase/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: module 'program' has no attribute 'run_packing'\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 0.0000, combined_score: 0.0000, radius_variance: 0.0000, spatial_spread: 0.0000\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef create_packing():\n    \"\"\"\n    Directly produces an arrangement of 26 circles in a unit square.\n    Uses a multi-stage optimization (L-BFGS-B) to find good centers,\n    followed by Linear Programming to find the optimal radii.\n    \"\"\"\n    n = 26\n    # Initial centers: Start with a 5x5 grid (25 circles) and add one more.\n    side = 5\n    grid = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid, grid)\n    c = np.column_stack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at a gap near the edge\n    c = np.vstack([c, [0.95, 0.05]])\n    \n    # Break symmetry with small perturbation to help the optimizer find better local optima\n    np.random.seed(42)\n    c += np.random.normal(0, 0.01, c.shape)\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initial radii guess\n    r = np.ones(n) * 0.08\n    # Flatten parameters for the optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    params = np.concatenate([c.ravel(), r])\n\n    def cost_func(p, C):\n        \"\"\"\n        Penalty-based objective function to maximize the sum of radii.\n        \"\"\"\n        curr_c = p[:2*n].reshape((n, 2))\n        curr_r = p[2*n:]\n        # Goal is maximizing sum(r), so minimizing -sum(r)\n        obj = -np.sum(curr_r)\n        \n        # Boundary constraints: r_i <= c_ix, r_i <= 1-c_ix, etc.\n        # Violations are (r - boundary_dist) > 0\n        b_low = curr_r - curr_c[:, 0]\n        b_high = curr_r - (1.0 - curr_c[:, 0])\n        b_left = curr_r - curr_c[:, 1]\n        b_right = curr_r - (1.0 - curr_c[:, 1])\n        \n        penalty = np.sum(np.maximum(0, b_low)**2) + \\\n                  np.sum(np.maximum(0, b_high)**2) + \\\n                  np.sum(np.maximum(0, b_left)**2) + \\\n                  np.sum(np.maximum(0, b_right)**2)\n        \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # Vectorized calculation for all-pairs distances\n        diff = curr_c[:, np.newaxis, :] - curr_c[np.newaxis, :, :]\n        # Add a tiny constant for numerical stability of the square root\n        dists = np.sqrt(np.sum(diff**2, axis=2) + 1e-12)\n        r_sum = curr_r[:, np.newaxis] + curr_r[np.newaxis, :]\n        overlap = r_sum - dists\n        \n        # Use only the upper triangle of the overlap matrix to avoid double-counting pairs\n        penalty += np.sum(np.maximum(0, np.triu(overlap, k=1))**2)\n        \n        return obj + C * penalty\n\n    # Multi-stage optimization with increasing penalty coefficients (C)\n    # Stage 1: Broad search with low penalty\n    res = minimize(cost_func, params, args=(50.0,), method='L-BFGS-B', options={'maxiter': 800})\n    # Stage 2: Refine with higher penalty\n    res = minimize(cost_func, res.x, args=(500.0,), method='L-BFGS-B', options={'maxiter': 800})\n    # Stage 3: Strict penalty to ensure feasibility\n    res = minimize(cost_func, res.x, args=(2000.0,), method='L-BFGS-B', options={'maxiter': 800})\n    \n    final_params = res.x\n    final_c = final_params[:2*n].reshape((n, 2))\n    final_c = np.clip(final_c, 0.0, 1.0)\n    \n    # Radii Optimization: Fix centers and solve for optimal radii using Linear Programming.\n    # The constraints are linear in r: r_i + r_j <= dist(c_i, c_j) and r_i <= dist_to_edge\n    \n    # Boundary distance for each center\n    b_max = np.minimum(np.minimum(final_c[:, 0], 1.0 - final_c[:, 0]),\n                       np.minimum(final_c[:, 1], 1.0 - final_c[:, 1]))\n    # Set bounds for each r_i, using a tiny safety margin\n    bnds = [(0, max(0.0, b - 1e-10)) for b in b_max]\n    \n    # Construct pairwise overlap constraints for LP\n    A_ub, b_ub = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            # Use a tiny safety margin to ensure strict non-overlap\n            b_ub.append(dist - 1e-10)\n    \n    # Solve LP: Minimize -sum(r) to maximize sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bnds, method='highs')\n    \n    if res_lp.success:\n        return final_c, res_lp.x\n    else:\n        # Fallback to a safe equal-radius packing if LP fails\n        safe_r = np.ones(n) * 0.05\n        return final_c, safe_r\n\n\n# Execute the constructor\ncenters, radii = create_packing()\nsum_radii = np.sum(radii)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 2 (Score: 0.0000)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef create_packing():\n    \"\"\"\n    Produces an arrangement of 26 circles in a unit square to maximize the sum of radii.\n    The method uses a multi-stage L-BFGS-B optimization to place centers and\n    a Linear Programming step to find the mathematically optimal radii for those centers.\n    \"\"\"\n    n = 26\n    # Initialization: A 5x5 grid plus one extra circle near the edge.\n    side = 5\n    grid = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid, grid)\n    c_init = np.column_stack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at a gap\n    c_init = np.vstack([c_init, [0.95, 0.05]])\n    \n    # Break symmetry with jitter to help the optimizer find better local optima\n    np.random.seed(42)\n    c_init += np.random.normal(0, 0.015, (n, 2))\n    c_init = np.clip(c_init, 0.0, 1.0)\n    \n    # Initial radii guess\n    r_init = np.full(n, 0.08)\n    \n    # Combined parameters for the optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    params = np.concatenate([c_init.ravel(), r_init])\n\n    def cost_func(p, penalty_coeff):\n        \"\"\"\n        Penalty-based objective function to maximize the sum of radii.\n        \"\"\"\n        curr_c = p[:2*n].reshape((n, 2))\n        curr_r = p[2*n:]\n        # Goal: maximizing sum(r), so minimizing -sum(r)\n        obj = -np.sum(curr_r)\n        \n        # Boundary constraints: r_i <= c_ix, r_i <= 1-c_ix, etc.\n        # Violations are (r - boundary_dist) > 0\n        b_penalty = np.sum(np.maximum(0, curr_r - curr_c[:, 0])**2) + \\\n                    np.sum(np.maximum(0, curr_r - (1.0 - curr_c[:, 0]))**2) + \\\n                    np.sum(np.maximum(0, curr_r - curr_c[:, 1])**2) + \\\n                    np.sum(np.maximum(0, curr_r - (1.0 - curr_c[:, 1]))**2)\n        \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # Vectorized calculation for all-pairs distances\n        c_diff = curr_c[:, np.newaxis, :] - curr_c[np.newaxis, :, :]\n        # Add a tiny constant for numerical stability\n        dists = np.sqrt(np.sum(c_diff**2, axis=2) + 1e-12)\n        r_sum = curr_r[:, np.newaxis] + curr_r[np.newaxis, :]\n        overlap = r_sum - dists\n        \n        # Avoid double-counting and diagonal (i=j)\n        np.fill_diagonal(overlap, 0)\n        o_penalty = 0.5 * np.sum(np.maximum(0, overlap)**2)\n        \n        return obj + penalty_coeff * (b_penalty + o_penalty)\n\n    # Multi-stage optimization with increasing penalty coefficients to handle constraints\n    bnds_minimize = [(0, 1)] * (2 * n) + [(0.0, 0.5)] * n\n    # Stage 1: Broad search\n    res = minimize(cost_func, params, args=(50.0,), method='L-BFGS-B', \n                   bounds=bnds_minimize, options={'maxiter': 1000})\n    # Stage 2: Refine\n    res = minimize(cost_func, res.x, args=(2000.0,), method='L-BFGS-B', \n                   bounds=bnds_minimize, options={'maxiter': 1000})\n    # Stage 3: Strict penalty\n    res = minimize(cost_func, res.x, args=(100000.0,), method='L-BFGS-B', \n                   bounds=bnds_minimize, options={'maxiter': 1000})\n    \n    final_c = res.x[:2*n].reshape((n, 2))\n    final_c = np.clip(final_c, 0.0, 1.0)\n    \n    # Final Radii Optimization: Fix centers and solve for optimal radii using Linear Programming.\n    # Objective: Minimize -sum(r) to maximize sum(r)\n    \n    # 1. Boundary distance bounds\n    b_max = np.minimum(np.minimum(final_c[:, 0], 1.0 - final_c[:, 0]),\n                       np.minimum(final_c[:, 1], 1.0 - final_c[:, 1]))\n    # Subtract tiny margin to ensure strict non-violation\n    bnds_lp = [(0, max(0.0, b - 1e-10)) for b in b_max]\n    \n    # 2. Pairwise overlap constraints\n    A_ub, b_ub = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            b_ub.append(max(0.0, dist - 1e-10))\n    \n    # Solve LP using the HiGHS method for speed and robustness\n    res_lp = linprog(-np.ones(n), A_ub=A_ub, b_ub=b_ub, bounds=bnds_lp, method='highs')\n    \n    if res_lp.success:\n        return final_c, res_lp.x\n    else:\n        # Fallback to the optimized radii from the penalty stages if LP fails\n        safe_r = np.clip(res.x[2*n:], 0.0, 0.4)\n        return final_c, safe_r\n\n\n# Calculate final arrangement and sum\ncenters, radii = create_packing()\nsum_radii = np.sum(radii)\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n### Program 3 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis script uses a physics-inspired optimization (Adam) to maximize the sum of radii.\nThe initial configuration is a jittered grid, and the radii are refined to ensure \nstrict non-overlap and boundary adherence.\n\"\"\"\nimport numpy as np\n\n\ndef solve_packing():\n    \"\"\"\n    Directly computes an arrangement of 26 circles to maximize the sum of their radii.\n    \"\"\"\n    n = 26\n    # Initialize centers: 5x5 grid plus one additional circle\n    c = []\n    for i in range(5):\n        for j in range(5):\n            c.append([0.1 + 0.8 * i / 4.0, 0.1 + 0.8 * j / 4.0])\n    # Add the 26th circle at a non-overlapping position\n    c.append([0.05, 0.05])\n    c = np.array(c)\n    \n    # Break symmetry with jitter\n    np.random.seed(42)\n    c += np.random.normal(0, 0.015, c.shape)\n    \n    # Initialize radii with a reasonable guess\n    r = np.full(n, 0.1)\n    \n    # Adam optimizer parameters\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.001\n    \n    # Optimization Loop (maximize sum of radii while penalizing violations)\n    iters = 5000\n    for t in range(1, iters + 1):\n        # Penalty increases over time to harden constraints\n        penalty = 5.0 + t * 0.04\n        \n        # Gradients\n        dc = np.zeros_like(c)\n        dr = -np.ones(n)  # Objective: maximize sum(r) -> grad of -sum(r) is -1\n        \n        # Boundary constraints: r_i <= c_i and c_i + r_i <= 1\n        for i in range(2):  # Dimension x and y\n            # Low boundary violations (c_i - r_i < 0)\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            dr[mask_low] += 2 * penalty * v_low[mask_low]\n            dc[mask_low, i] -= 2 * penalty * v_low[mask_low]\n            \n            # High boundary violations (c_i + r_i > 1)\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            dr[mask_high] += 2 * penalty * v_high[mask_high]\n            dc[mask_high, i] += 2 * penalty * v_high[mask_high]\n            \n        # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n        for i in range(n):\n            diff = c[i] - c[i+1:]\n            dists = np.linalg.norm(diff, axis=1)\n            sum_r = r[i] + r[i+1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n            \n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = np.maximum(dists[mask], 1e-9)\n                df = diff[mask]\n                \n                # Penalty gradients for radii\n                dr[i] += 2 * penalty * np.sum(ov)\n                dr[idx] += 2 * penalty * ov\n                \n                # Penalty gradients for centers\n                grad_c = 2 * penalty * (ov / di)[:, np.newaxis] * df\n                dc[i] -= np.sum(grad_c, axis=0)\n                dc[idx] += grad_c\n        \n        # Adam update for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam update for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Keep radii within a valid domain to prevent divergence\n        r = np.clip(r, 0.001, 0.45)\n        \n    # Final Post-Processing to ensure 100% feasibility\n    # 1. Strict Shrinkage\n    for _ in range(1000):\n        # Boundary fit\n        for i in range(n):\n            r[i] = min(r[i], c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        # Overlap fit\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(c[i] - c[j])\n                if r[i] + r[j] > d:\n                    over = r[i] + r[j] - d\n                    # Shrink both circles proportionally\n                    r[i] -= over * 0.5\n                    r[j] -= over * 0.5\n        r = np.maximum(r, 1e-7)\n        \n    # 2. Greedy Growth (expand into remaining gaps)\n    for _ in range(500):\n        for i in range(n):\n            limit = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(c[i] - c[j])\n                limit = min(limit, d - r[j])\n            if limit > r[i]:\n                r[i] = limit\n\n    return c, r, np.sum(r)\n\n\n# Execute the solver and define output variables\ncenters, radii, sum_radii = solve_packing()\n# EVOLVE-BLOCK-END\n```\nKey features: Performs well on validity (0.0000), Performs well on combined_score (0.0000), Performs well on radius_variance (0.0000), Performs well on spatial_spread (0.0000)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.0000)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis implementation uses a hybrid approach:\n1. A physics-inspired Adam optimization phase to position centers.\n2. A Linear Programming phase to determine the optimal radii for those centers.\n3. A robust post-processing phase to ensure strict non-overlap and boundary adherence.\nThe goal is to maximize the sum of radii, aiming to exceed the 2.635 benchmark.\n\"\"\"\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef solve_packing():\n    \"\"\"\n    Computes an arrangement of 26 circles to maximize the sum of their radii.\n    Returns:\n        centers: (26, 2) numpy array of circle centers.\n        radii: (26,) numpy array of circle radii.\n        sum_radii: Float, the sum of all radii.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialize centers using a 5x5 grid plus one additional circle.\n    # A 5x5 grid fills the space systematically with 25 points.\n    c = []\n    for i in range(5):\n        for j in range(5):\n            c.append([0.2 * i + 0.1, 0.2 * j + 0.1])\n    \n    # Place the 26th circle at a central location.\n    c.append([0.5, 0.5])\n    c = np.array(c)\n    \n    # Break symmetry with jitter and ensure initial spread.\n    np.random.seed(42)\n    c += np.random.uniform(-0.05, 0.05, c.shape)\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initialize radii with a reasonable guess for the optimizer.\n    r = np.full(n, 0.09)\n    \n    # 2. Optimization Loop (Adam) to improve center locations.\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.002\n    \n    # Number of iterations should be sufficient to resolve overlaps.\n    for t in range(1, 2001):\n        # The penalty coefficient increases to enforce hard constraints.\n        penalty_scale = 10.0 + t * 0.1\n        \n        # Gradients\n        dc = np.zeros_like(c)\n        dr = -np.ones(n)  # Objective: minimize -sum(r) which is equivalent to maximize sum(r)\n        \n        # Overlap penalties\n        for i in range(n):\n            diffs = c[i] - c[i+1:]\n            dists = np.linalg.norm(diffs, axis=1)\n            # Prevent division by zero errors\n            dists = np.maximum(dists, 1e-9)\n            \n            overlaps = (r[i] + r[i+1:]) - dists\n            mask = overlaps > 0\n            \n            if np.any(mask):\n                neighbor_indices = np.where(mask)[0] + i + 1\n                ov = overlaps[mask]\n                di = dists[mask]\n                df = diffs[mask]\n                \n                # Grad of (penalty_scale * overlap^2)\n                # d/dr_i = 2 * penalty_scale * overlap\n                grad_r = 2 * penalty_scale * ov\n                dr[i] += np.sum(grad_r)\n                dr[neighbor_indices] += grad_r\n                \n                # Grad w.r.t center: - (overlap / distance) * (c_i - c_j)\n                grad_c = (grad_r / di)[:, np.newaxis] * (-df)\n                dc[i] += np.sum(grad_c, axis=0)\n                dc[neighbor_indices] -= grad_c\n        \n        # Boundary penalties\n        for dim in range(2):  # X and Y dimensions\n            # Low boundary: r_i - c_i_dim <= 0\n            low_violation = r - c[:, dim]\n            low_mask = low_violation > 0\n            dr[low_mask] += 2 * penalty_scale * low_violation[low_mask]\n            dc[low_mask, dim] -= 2 * penalty_scale * low_violation[low_mask]\n            \n            # High boundary: c_i_dim + r_i - 1.0 <= 0\n            high_violation = c[:, dim] + r - 1.0\n            high_mask = high_violation > 0\n            dr[high_mask] += 2 * penalty_scale * high_violation[high_mask]\n            dc[high_mask, dim] += 2 * penalty_scale * high_violation[high_mask]\n            \n        # Adam update for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam update for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Projections to keep centers within the unit square and radii positive\n        c = np.clip(c, 0.0, 1.0)\n        r = np.clip(r, 0.001, 0.5)\n\n    # 3. Final Radii Optimization via Linear Programming.\n    # Maximize sum(r_i) for fixed center locations.\n    c_obj = -np.ones(n)\n    A_ub = []\n    b_ub = []\n    \n    # Pairwise distance constraints: r_i + r_j <= distance(c_i, c_j)\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i] = 1.0\n            row[j] = 1.0\n            A_ub.append(row)\n            b_ub.append(d)\n            \n    # Boundary constraints: r_i <= c_ix, r_i <= 1-c_ix, etc.\n    bounds = []\n    for i in range(n):\n        limit = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        bounds.append((0, max(0, limit)))\n        \n    res = linprog(c_obj, A_ub=A_ub, b_ub=b_ub, bounds=bounds, method='highs')\n    \n    if res.success:\n        radii_final = res.x\n    else:\n        # Fallback to current r if LP fails\n        radii_final = r\n\n    # 4. Strict feasibility enforcement (robustness against floating-point errors).\n    # Slightly shrink radii to guarantee valid packing.\n    radii_final *= (1.0 - 1e-10)\n    for i in range(n):\n        # Re-check boundaries\n        radii_final[i] = min(radii_final[i], c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            # Re-check overlaps\n            d = np.linalg.norm(c[i] - c[j])\n            if radii_final[i] + radii_final[j] > d:\n                overlap = (radii_final[i] + radii_final[j] - d)\n                # Proportional reduction\n                total_r = radii_final[i] + radii_final[j]\n                if total_r > 0:\n                    radii_final[i] -= overlap * (radii_final[i] / total_r) + 1e-13\n                    radii_final[j] -= overlap * (radii_final[j] / total_r) + 1e-13\n                else:\n                    radii_final[i] = 0\n                    radii_final[j] = 0\n    \n    # Final non-negativity check\n    radii_final = np.maximum(radii_final, 0.0)\n    \n    return c, radii_final, np.sum(radii_final)\n\n\n# Execute the construction\ncenters, radii, sum_radii = solve_packing()\n# EVOLVE-BLOCK-END\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n### Program D2 (Score: 0.0000)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef get_loss_and_grads(c, r, C):\n    \"\"\"\n    Compute the penalty-based loss and its gradients w.r.t centers and radii.\n    We maximize sum(r) subject to non-overlap and boundary constraints.\n    \"\"\"\n    n = len(r)\n    # Objective: maximize sum of radii -> minimize -sum(r)\n    loss = -np.sum(r)\n    dc = np.zeros_like(c)\n    dr = -np.ones_like(r)\n    \n    # 1. Boundary violations\n    # Left boundary: r_i - c_{i,x} <= 0\n    v = r - c[:, 0]\n    mask = v > 0\n    loss += C * np.sum(v[mask]**2)\n    dr[mask] += 2 * C * v[mask]\n    dc[mask, 0] -= 2 * C * v[mask]\n    \n    # Right boundary: c_{i,x} + r_i - 1 <= 0\n    v = c[:, 0] + r - 1.0\n    mask = v > 0\n    loss += C * np.sum(v[mask]**2)\n    dr[mask] += 2 * C * v[mask]\n    dc[mask, 0] += 2 * C * v[mask]\n    \n    # Bottom boundary: r_i - c_{i,y} <= 0\n    v = r - c[:, 1]\n    mask = v > 0\n    loss += C * np.sum(v[mask]**2)\n    dr[mask] += 2 * C * v[mask]\n    dc[mask, 1] -= 2 * C * v[mask]\n    \n    # Top boundary: c_{i,y} + r_i - 1 <= 0\n    v = c[:, 1] + r - 1.0\n    mask = v > 0\n    loss += C * np.sum(v[mask]**2)\n    dr[mask] += 2 * C * v[mask]\n    dc[mask, 1] += 2 * C * v[mask]\n    \n    # 2. Overlap violations\n    # r_i + r_j - ||c_i - c_j|| <= 0\n    c_diff = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n    dist = np.linalg.norm(c_diff, axis=2)\n    dist = np.maximum(dist, 1e-9)\n    np.fill_diagonal(dist, 1.0)\n    \n    r_sum = r[:, np.newaxis] + r[np.newaxis, :]\n    v = r_sum - dist\n    np.fill_diagonal(v, 0)\n    \n    mask = v > 0\n    loss += C * 0.5 * np.sum(v[mask]**2)\n    dr += C * np.sum(v * mask, axis=1)\n    \n    factor = C * (v * mask) / dist\n    dc -= np.einsum('ij,ijk->ik', factor, c_diff)\n    \n    return loss, dc, dr\n\n\ndef adam_optimizer(c_init, r_init, iters=1200):\n    \"\"\"\n    Optimize centers and radii using a custom Adam optimizer\n    with a continuous penalty method.\n    \"\"\"\n    c = c_init.copy()\n    r = r_init.copy()\n    \n    # Add tiny noise to avoid exact center overlap singularities\n    c += np.random.normal(0, 1e-5, c.shape)\n    \n    m_c = np.zeros_like(c)\n    v_c = np.zeros_like(c)\n    m_r = np.zeros_like(r)\n    v_r = np.zeros_like(r)\n    \n    beta1 = 0.9\n    beta2 = 0.999\n    eps = 1e-8\n    \n    # Schedules for penalty coefficient (C) and learning rate (lr)\n    C_start = 10.0\n    C_end = 10000.0\n    C_factor = (C_end / C_start) ** (1.0 / iters)\n    \n    lr_start = 0.01\n    lr_end = 0.0001\n    lr_factor = (lr_end / lr_start) ** (1.0 / iters)\n    \n    C = C_start\n    lr = lr_start\n    \n    for t in range(1, iters + 1):\n        loss, dc, dr = get_loss_and_grads(c, r, C)\n        \n        # Adam updates for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 -\n```\nKey features: Alternative approach to validity, Alternative approach to combined_score\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef create_packing():\n    \"\"\"\n    Produces an arrangement of 26 circles in a unit square to maximize the sum of radii.\n    The method uses a multi-stage L-BFGS-B optimization to place centers and\n    a Linear Programming step to find the mathematically optimal radii for those centers.\n    \"\"\"\n    n = 26\n    # Initialization: A 5x5 grid plus one extra circle near the edge.\n    side = 5\n    grid = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid, grid)\n    c_init = np.column_stack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at a gap\n    c_init = np.vstack([c_init, [0.95, 0.05]])\n    \n    # Break symmetry with jitter to help the optimizer find better local optima\n    np.random.seed(42)\n    c_init += np.random.normal(0, 0.015, (n, 2))\n    c_init = np.clip(c_init, 0.0, 1.0)\n    \n    # Initial radii guess\n    r_init = np.full(n, 0.08)\n    \n    # Combined parameters for the optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    params = np.concatenate([c_init.ravel(), r_init])\n\n    def cost_func(p, penalty_coeff):\n        \"\"\"\n        Penalty-based objective function to maximize the sum of radii.\n        \"\"\"\n        curr_c = p[:2*n].reshape((n, 2))\n        curr_r = p[2*n:]\n        # Goal: maximizing sum(r), so minimizing -sum(r)\n        obj = -np.sum(curr_r)\n        \n        # Boundary constraints: r_i <= c_ix, r_i <= 1-c_ix, etc.\n        # Violations are (r - boundary_dist) > 0\n        b_penalty = np.sum(np.maximum(0, curr_r - curr_c[:, 0])**2) + \\\n                    np.sum(np.maximum(0, curr_r - (1.0 - curr_c[:, 0]))**2) + \\\n                    np.sum(np.maximum(0, curr_r - curr_c[:, 1])**2) + \\\n                    np.sum(np.maximum(0, curr_r - (1.0 - curr_c[:, 1]))**2)\n        \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # Vectorized calculation for all-pairs distances\n        c_diff = curr_c[:, np.newaxis, :] - curr_c[np.newaxis, :, :]\n        # Add a tiny constant for numerical stability\n        dists = np.sqrt(np.sum(c_diff**2, axis=2) + 1e-12)\n        r_sum = curr_r[:, np.newaxis] + curr_r[np.newaxis, :]\n        overlap = r_sum - dists\n        \n        # Avoid double-counting and diagonal (i=j)\n        np.fill_diagonal(overlap, 0)\n        o_penalty = 0.5 * np.sum(np.maximum(0, overlap)**2)\n        \n        return obj + penalty_coeff * (b_penalty + o_penalty)\n\n    # Multi-stage optimization with increasing penalty coefficients to handle constraints\n    bnds_minimize = [(0, 1)] * (2 * n) + [(0.0, 0.5)] * n\n    # Stage 1: Broad search\n    res = minimize(cost_func, params, args=(50.0,), method='L-BFGS-B', \n                   bounds=bnds_minimize, options={'maxiter': 1000})\n    # Stage 2: Refine\n    res = minimize(cost_func, res.x, args=(2000.0,), method='L-BFGS-B', \n                   bounds=bnds_minimize, options={'maxiter': 1000})\n    # Stage 3: Strict penalty\n    res = minimize(cost_func, res.x, args=(100000.0,), method='L-BFGS-B', \n                   bounds=bnds_minimize, options={'maxiter': 1000})\n    \n    final_c = res.x[:2*n].reshape((n, 2))\n    final_c = np.clip(final_c, 0.0, 1.0)\n    \n    # Final Radii Optimization: Fix centers and solve for optimal radii using Linear Programming.\n    # Objective: Minimize -sum(r) to maximize sum(r)\n    \n    # 1. Boundary distance bounds\n    b_max = np.minimum(np.minimum(final_c[:, 0], 1.0 - final_c[:, 0]),\n                       np.minimum(final_c[:, 1], 1.0 - final_c[:, 1]))\n    # Subtract tiny margin to ensure strict non-violation\n    bnds_lp = [(0, max(0.0, b - 1e-10)) for b in b_max]\n    \n    # 2. Pairwise overlap constraints\n    A_ub, b_ub = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            b_ub.append(max(0.0, dist - 1e-10))\n    \n    # Solve LP using the HiGHS method for speed and robustness\n    res_lp = linprog(-np.ones(n), A_ub=A_ub, b_ub=b_ub, bounds=bnds_lp, method='highs')\n    \n    if res_lp.success:\n        return final_c, res_lp.x\n    else:\n        # Fallback to the optimized radii from the penalty stages if LP fails\n        safe_r = np.clip(res.x[2*n:], 0.0, 0.4)\n        return final_c, safe_r\n\n\n# Calculate final arrangement and sum\ncenters, radii = create_packing()\nsum_radii = np.sum(radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\nimport numpy as np\nfrom scipy.optimize import minimize, linprog\n\n\ndef create_packing():\n    \"\"\"\n    Directly produces an arrangement of 26 circles in a unit square.\n    Uses a multi-stage optimization (L-BFGS-B) to find good centers,\n    followed by Linear Programming to find the optimal radii.\n    \"\"\"\n    n = 26\n    # Initial centers: Start with a 5x5 grid (25 circles) and add one more.\n    side = 5\n    grid = np.linspace(0.1, 0.9, side)\n    xv, yv = np.meshgrid(grid, grid)\n    c = np.column_stack([xv.ravel(), yv.ravel()])\n    # Add the 26th circle at a gap near the edge\n    c = np.vstack([c, [0.95, 0.05]])\n    \n    # Break symmetry with small perturbation to help the optimizer find better local optima\n    np.random.seed(42)\n    c += np.random.normal(0, 0.01, c.shape)\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initial radii guess\n    r = np.ones(n) * 0.08\n    # Flatten parameters for the optimizer: [x1, y1, ..., xn, yn, r1, ..., rn]\n    params = np.concatenate([c.ravel(), r])\n\n    def cost_func(p, C):\n        \"\"\"\n        Penalty-based objective function to maximize the sum of radii.\n        \"\"\"\n        curr_c = p[:2*n].reshape((n, 2))\n        curr_r = p[2*n:]\n        # Goal is maximizing sum(r), so minimizing -sum(r)\n        obj = -np.sum(curr_r)\n        \n        # Boundary constraints: r_i <= c_ix, r_i <= 1-c_ix, etc.\n        # Violations are (r - boundary_dist) > 0\n        b_low = curr_r - curr_c[:, 0]\n        b_high = curr_r - (1.0 - curr_c[:, 0])\n        b_left = curr_r - curr_c[:, 1]\n        b_right = curr_r - (1.0 - curr_c[:, 1])\n        \n        penalty = np.sum(np.maximum(0, b_low)**2) + \\\n                  np.sum(np.maximum(0, b_high)**2) + \\\n                  np.sum(np.maximum(0, b_left)**2) + \\\n                  np.sum(np.maximum(0, b_right)**2)\n        \n        # Overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        # Vectorized calculation for all-pairs distances\n        diff = curr_c[:, np.newaxis, :] - curr_c[np.newaxis, :, :]\n        # Add a tiny constant for numerical stability of the square root\n        dists = np.sqrt(np.sum(diff**2, axis=2) + 1e-12)\n        r_sum = curr_r[:, np.newaxis] + curr_r[np.newaxis, :]\n        overlap = r_sum - dists\n        \n        # Use only the upper triangle of the overlap matrix to avoid double-counting pairs\n        penalty += np.sum(np.maximum(0, np.triu(overlap, k=1))**2)\n        \n        return obj + C * penalty\n\n    # Multi-stage optimization with increasing penalty coefficients (C)\n    # Stage 1: Broad search with low penalty\n    res = minimize(cost_func, params, args=(50.0,), method='L-BFGS-B', options={'maxiter': 800})\n    # Stage 2: Refine with higher penalty\n    res = minimize(cost_func, res.x, args=(500.0,), method='L-BFGS-B', options={'maxiter': 800})\n    # Stage 3: Strict penalty to ensure feasibility\n    res = minimize(cost_func, res.x, args=(2000.0,), method='L-BFGS-B', options={'maxiter': 800})\n    \n    final_params = res.x\n    final_c = final_params[:2*n].reshape((n, 2))\n    final_c = np.clip(final_c, 0.0, 1.0)\n    \n    # Radii Optimization: Fix centers and solve for optimal radii using Linear Programming.\n    # The constraints are linear in r: r_i + r_j <= dist(c_i, c_j) and r_i <= dist_to_edge\n    \n    # Boundary distance for each center\n    b_max = np.minimum(np.minimum(final_c[:, 0], 1.0 - final_c[:, 0]),\n                       np.minimum(final_c[:, 1], 1.0 - final_c[:, 1]))\n    # Set bounds for each r_i, using a tiny safety margin\n    bnds = [(0, max(0.0, b - 1e-10)) for b in b_max]\n    \n    # Construct pairwise overlap constraints for LP\n    A_ub, b_ub = [], []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(final_c[i] - final_c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            # Use a tiny safety margin to ensure strict non-overlap\n            b_ub.append(dist - 1e-10)\n    \n    # Solve LP: Minimize -sum(r) to maximize sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bnds, method='highs')\n    \n    if res_lp.success:\n        return final_c, res_lp.x\n    else:\n        # Fallback to a safe equal-radius packing if LP fails\n        safe_r = np.ones(n) * 0.05\n        return final_c, safe_r\n\n\n# Execute the constructor\ncenters, radii = create_packing()\nsum_radii = np.sum(radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.0000, Type: Exploratory)\n```python\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\ndef compute_max_radii_linprog(centers):\n    \"\"\"Attempt to find mathematically optimal radii using linear programming\"\"\"\n    try:\n        from scipy.optimize import linprog\n        n = centers.shape[0]\n        # Maximize sum of radii -> minimize negative sum\n        c_obj = -np.ones(n)\n        \n        A_ub = []\n        b_ub = []\n        \n        # Pairwise distance constraints\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(centers[i] - centers[j])\n                row = np.zeros(n)\n                row[i] = 1\n                row[j] = 1\n                A_ub.append(row)\n                b_ub.append(d)\n                \n        # Boundary constraints\n        bounds = []\n        for i in range(n):\n            max_r = min(centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n            bounds.append((0, max_r))\n            \n        # method 'highs' is fast and robust\n        res = linprog(c_obj, A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bounds, method='highs')\n        if res.success:\n            # Scale slightly to ensure strict validity against floating point errors\n            return np.maximum(res.x * 0.999999, 0)\n    except Exception:\n        pass\n    return None\n\ndef compute_max_radii_iterative(centers, initial_radii):\n    \"\"\"Fallback method iteratively resolving overlaps if scipy is not available\"\"\"\n    n = centers.shape[0]\n    r = initial_radii.copy()\n    \n    # Strictly enforce boundary constraints\n    for i in range(n):\n        r[i] = min(r[i], centers[i, 0], centers[i, 1], 1 - centers[i, 0], 1 - centers[i, 1])\n        \n    # Iteratively resolve overlaps by shrinking the overlapping circles\n    for _ in range(3000):\n        max_overlap = 0\n        best_pair = None\n        \n        for i in range(n):\n            for j in range(i+1, n):\n                dist = np.linalg.norm(centers[i] - centers[j])\n                overlap = r[i] + r[j] - dist\n                if overlap > max_overlap:\n                    max_overlap = overlap\n                    best_pair = (i, j)\n                    \n        if max_overlap <= 1e-9:\n            break\n            \n        i, j = best_pair\n        total_r = r[i] + r[j]\n        ratio_i = r[i] / total_r if total_r > 0 else 0.5\n        ratio_j = 1.0 - ratio_i\n        \n        r[i] -= max_overlap * ratio_i + 1e-9\n        r[j] -= max_overlap * ratio_j + 1e-9\n        \n    r = np.maximum(r, 0)\n    \n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis script uses a physics-inspired optimization (Adam) to maximize the sum of radii.\nThe initial configuration is a jittered grid, and the radii are refined to ensure \nstrict non-overlap and boundary adherence.\n\"\"\"\nimport numpy as np\n\n\ndef solve_packing():\n    \"\"\"\n    Directly computes an arrangement of 26 circles to maximize the sum of their radii.\n    \"\"\"\n    n = 26\n    # Initialize centers: 5x5 grid plus one additional circle\n    c = []\n    for i in range(5):\n        for j in range(5):\n            c.append([0.1 + 0.8 * i / 4.0, 0.1 + 0.8 * j / 4.0])\n    # Add the 26th circle at a non-overlapping position\n    c.append([0.05, 0.05])\n    c = np.array(c)\n    \n    # Break symmetry with jitter\n    np.random.seed(42)\n    c += np.random.normal(0, 0.015, c.shape)\n    \n    # Initialize radii with a reasonable guess\n    r = np.full(n, 0.1)\n    \n    # Adam optimizer parameters\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.001\n    \n    # Optimization Loop (maximize sum of radii while penalizing violations)\n    iters = 5000\n    for t in range(1, iters + 1):\n        # Penalty increases over time to harden constraints\n        penalty = 5.0 + t * 0.04\n        \n        # Gradients\n        dc = np.zeros_like(c)\n        dr = -np.ones(n)  # Objective: maximize sum(r) -> grad of -sum(r) is -1\n        \n        # Boundary constraints: r_i <= c_i and c_i + r_i <= 1\n        for i in range(2):  # Dimension x and y\n            # Low boundary violations (c_i - r_i < 0)\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            dr[mask_low] += 2 * penalty * v_low[mask_low]\n            dc[mask_low, i] -= 2 * penalty * v_low[mask_low]\n            \n            # High boundary violations (c_i + r_i > 1)\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            dr[mask_high] += 2 * penalty * v_high[mask_high]\n            dc[mask_high, i] += 2 * penalty * v_high[mask_high]\n            \n        # Pairwise distance constraints: r_i + r_j <= dist(c_i, c_j)\n        for i in range(n):\n            diff = c[i] - c[i+1:]\n            dists = np.linalg.norm(diff, axis=1)\n            sum_r = r[i] + r[i+1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n            \n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = np.maximum(dists[mask], 1e-9)\n                df = diff[mask]\n                \n                # Penalty gradients for radii\n                dr[i] += 2 * penalty * np.sum(ov)\n                dr[idx] += 2 * penalty * ov\n                \n                # Penalty gradients for centers\n                grad_c = 2 * penalty * (ov / di)[:, np.newaxis] * df\n                dc[i] -= np.sum(grad_c, axis=0)\n                dc[idx] += grad_c\n        \n        # Adam update for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam update for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Keep radii within a valid domain to prevent divergence\n        r = np.clip(r, 0.001, 0.45)\n        \n    # Final Post-Processing to ensure 100% feasibility\n    # 1. Strict Shrinkage\n    for _ in range(1000):\n        # Boundary fit\n        for i in range(n):\n            r[i] = min(r[i], c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n        # Overlap fit\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(c[i] - c[j])\n                if r[i] + r[j] > d:\n                    over = r[i] + r[j] - d\n                    # Shrink both circles proportionally\n                    r[i] -= over * 0.5\n                    r[j] -= over * 0.5\n        r = np.maximum(r, 1e-7)\n        \n    # 2. Greedy Growth (expand into remaining gaps)\n    for _ in range(500):\n        for i in range(n):\n            limit = min(c[i, 0], 1 - c[i, 0], c[i, 1], 1 - c[i, 1])\n            for j in range(n):\n                if i == j:\n                    continue\n                d = np.linalg.norm(c[i] - c[j])\n                limit = min(limit, d - r[j])\n            if limit > r[i]:\n                r[i] = limit\n\n    return c, r, np.sum(r)\n\n\n# Execute the solver and define output variables\ncenters, radii, sum_radii = solve_packing()\n# EVOLVE-BLOCK-END\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\nfrom scipy.optimize import linprog\n\n\ndef run_packing():\n    \"\"\"\n    Directly produces an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a multi-stage approach: a physics-inspired \n    optimization phase (Adam) to find robust center locations, followed by \n    Linear Programming to determine the mathematically optimal radii for those \n    centers. Finally, a feasibility check ensures the packing is strictly valid.\n    \"\"\"\n    n = 26\n    \n    # 1. Initialization\n    # Start with a 5x5 grid (25 circles) plus one circle in the center.\n    grid = np.linspace(0.1, 0.9, 5)\n    xv, yv = np.meshgrid(grid, grid)\n    c = np.column_stack([xv.ravel(), yv.ravel()])\n    c = np.vstack([c, [0.5, 0.5]])\n    \n    # Break symmetry with jitter to avoid local minima and aid the optimizer.\n    np.random.seed(42)\n    c += np.random.normal(0, 0.02, (n, 2))\n    c = np.clip(c, 0.05, 0.95)\n    \n    # Initial radii guess\n    r = np.full(n, 0.09)\n    \n    # 2. Optimization Phase (Adam)\n    # This phase moves centers and adjusts radii to reduce overlaps and expand.\n    m_c, v_c = np.zeros_like(c), np.zeros_like(c)\n    m_r, v_r = np.zeros_like(r), np.zeros_like(r)\n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    lr = 0.001\n    \n    iters = 3000\n    for t in range(1, iters + 1):\n        # Gradually increase penalty to transition from soft to hard constraints.\n        penalty_coeff = 2.0 + t * 0.1\n        \n        dc = np.zeros_like(c)\n        dr = -np.ones(n)  # Objective: maximize sum(r_i) -> minimize -sum(r_i)\n        \n        # Boundary constraints: r_i <= distance to nearest edge\n        for i in range(2):  # X and Y dimensions\n            # Low boundary violations (c_i - r_i < 0)\n            v_low = r - c[:, i]\n            mask_low = v_low > 0\n            dr[mask_low] += 2 * penalty_coeff * v_low[mask_low]\n            dc[mask_low, i] -= 2 * penalty_coeff * v_low[mask_low]\n            \n            # High boundary violations (c_i + r_i > 1)\n            v_high = c[:, i] + r - 1.0\n            mask_high = v_high > 0\n            dr[mask_high] += 2 * penalty_coeff * v_high[mask_high]\n            dc[mask_high, i] += 2 * penalty_coeff * v_high[mask_high]\n            \n        # Pairwise overlap constraints: r_i + r_j <= dist(c_i, c_j)\n        for i in range(n):\n            diff = c[i] - c[i + 1:]\n            # Distance with stability constant\n            dists = np.sqrt(np.sum(diff**2, axis=1) + 1e-12)\n            sum_r = r[i] + r[i + 1:]\n            overlap = sum_r - dists\n            mask = overlap > 0\n            \n            if np.any(mask):\n                idx = np.where(mask)[0] + i + 1\n                ov = overlap[mask]\n                di = dists[mask]\n                df = diff[mask]\n                \n                # Update gradients for radii\n                grad_r = 2 * penalty_coeff * ov\n                dr[i] += np.sum(grad_r)\n                dr[idx] += grad_r\n                \n                # Update gradients for centers (moving circles apart)\n                grad_c = (grad_r / di)[:, np.newaxis] * df\n                dc[i] += np.sum(grad_c, axis=0)\n                dc[idx] -= grad_c\n        \n        # Adam step for centers\n        m_c = beta1 * m_c + (1 - beta1) * dc\n        v_c = beta2 * v_c + (1 - beta2) * (dc**2)\n        m_c_hat = m_c / (1 - beta1**t)\n        v_c_hat = v_c / (1 - beta2**t)\n        c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n        \n        # Adam step for radii\n        m_r = beta1 * m_r + (1 - beta1) * dr\n        v_r = beta2 * v_r + (1 - beta2) * (dr**2)\n        m_r_hat = m_r / (1 - beta1**t)\n        v_r_hat = v_r / (1 - beta2**t)\n        r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n        \n        # Clip to maintain logical bounds\n        c = np.clip(c, 0.0, 1.0)\n        r = np.clip(r, 1e-5, 0.5)\n\n    # 3. Radius Refinement (Linear Programming)\n    # Fix center locations and find the optimal radii.\n    A_ub = []\n    b_ub = []\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            row = np.zeros(n)\n            row[i], row[j] = 1.0, 1.0\n            A_ub.append(row)\n            # Use a tiny safety margin to ensure feasibility under precision\n            b_ub.append(dist - 1e-12)\n    \n    # Boundary bounds for each radius\n    bounds = []\n    for i in range(n):\n        dist_to_edge = min(c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n        bounds.append((0, max(0.0, dist_to_edge - 1e-12)))\n    \n    # Solve the maximization problem: min -sum(r)\n    res_lp = linprog(-np.ones(n), A_ub=np.array(A_ub), b_ub=np.array(b_ub), \n                     bounds=bounds, method='highs')\n    \n    if res_lp.success:\n        r_final = res_lp.x\n    else:\n        r_final = r  # Fallback to the optimized radii\n\n    # 4. Strict Feasibility Check (Post-processing)\n    # Shrink slightly to avoid any potential floating-point violations.\n    r_final *= (1.0 - 1e-11)\n    for i in range(n):\n        r_final[i] = min(r_final[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1])\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.linalg.norm(c[i] - c[j])\n            if r_final[i] + r_final[j] > dist:\n                overlap = (r_final[i] + r_final[j]) - dist\n                r_final[i] -= overlap * 0.5\n                r_final[j] -= overlap * 0.5\n    \n    r_final = np.maximum(r_final, 0.0)\n    sum_r = np.sum(r_final)\n    \n    return c, r_final, sum_r\n\n\n# Execution to define required output variables\ncenters, radii, sum_radii = run_packing()\n```"]}}, "artifacts_json": "{\"execution_time\": \"4.82s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum: 0.560642, Ratio: 0.2128\"}", "artifact_dir": null, "embedding": null}