{"id": "bb4fa79a-215a-45dc-bf5e-a189f0f50022", "code": "import numpy as np\n\n\ndef compute_max_radii(centers, trials=180):\n    \"\"\"\n    Given a fixed set of center positions, this function determines the \n    radii that maximize the total sum of radii subject to no overlaps \n    and boundary constraints. It uses a coordinate descent approach \n    with multiple randomized greedy expansion orders.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        np.ndarray: (n,) array of optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders: boundary proximity, coordinate-based, and center-based\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Two passes of greedy expansion to ensure stability\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a force-directed physics \n    simulation with cooling and restarts. Each configuration is then \n    optimized for the maximum sum of radii.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    # This helps find different packing topologies (e.g., staggered rows)\n    target_dists = np.linspace(0.198, 0.218, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Set seed per restart for reproducible diversity\n        np.random.seed(42 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based or random\n        if restart == 0:\n            # 5x5 grid plus one circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Row-based staggered initialization\n            centers = []\n            rows = [5, 6, 5, 6, 4]\n            for r_idx, num_circles in enumerate(rows):\n                for c_idx in range(num_circles):\n                    centers.append([(c_idx + 0.5) / num_circles, (r_idx + 0.5) / 5])\n            centers = np.array(centers[:n])\n        else:\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        # Physics simulation: particles repel each other and square boundaries\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion force\n            overlap = np.maximum(0, t_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Boundary repulsion forces\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add decreasing noise early in the simulation\n            if k < iters * 0.6:\n                noise_scale = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process centers to solve for optimal radii\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Keep the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")", "changes_description": null, "language": "python", "parent_id": "8256545b-9d23-44cd-9a1d-eecf18adc167", "generation": 3, "timestamp": 1771870088.4978812, "iteration_found": 60, "metrics": {"validity": 1.0, "sum_radii": 2.4891878869538298, "target_ratio": 0.9446633347073359, "combined_score": 0.9446633347073359, "radius_variance": 0.0008352981731878473, "spatial_spread": 0.18410208787120672, "eval_time": 3.1321585178375244}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 0.0, "combined_score": 0.0, "radius_variance": 0.0, "spatial_spread": 0.0}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician specializing in circle packing problems and computational geometry. \nYour task is to improve a constructor function that directly produces a specific arrangement of 26 circles in a unit square, maximizing the sum of their radii. \nTry to improve the results reported in the AlphaEvolve paper which achieved a sum of 2.635 for n=26.\n\nKey insights:\n- The optimization routine is critically important - simple physics-based models with carefully tuned parameters\n- Consider strategic placement of circles at square corners and edges\n- Adjusting the pattern to place larger circles at the center and smaller at the edges\n- Similar radius circles often form regular patterns, while varied radii allow better space utilization\n- Perfect symmetry may not yield the optimal packing due to edge effects\n\nMake sure that your codecod is syntactically perfect, strictly adheres to PEP 8 indentation, and contains no ellipses, comments-as-placeholders, or unclosed structures.\n", "user": "# Current Program Information\n- Fitness: 0.0000\n- Feature coordinates: \n- Focus areas: - Fitness declined: 0.9371 \u2192 0.0000. Consider revising recent changes.\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n## Last Execution Output\n\n### stderr\n```\nStage 1 evaluation failed: Program execution failed: invalid syntax (tmp6z1goyzx.py, line 1)\n```\n\n### traceback\n```\nTraceback (most recent call last):\n  File \"/home/jupyter/Code/oe/dennis/cp_1model_1phase/evaluator.py\", line 384, in evaluate_stage1\n    centers, radii, sum_radii = run_with_timeout(program_path, timeout_seconds=600)\n  File \"/home/jupyter/Code/oe/dennis/cp_1model_1phase/evaluator.py\", line 172, in run_with_timeout\n    raise RuntimeError(f\"Program execution failed: {results['error']}\")\nRuntimeError: Program execution failed: invalid syntax (tmp6z1goyzx.py, line 1)\n\n```\n\n### failure_stage\n```\nstage1_execution\n```\n\n### suggestion\n```\nCheck basic syntax and imports before attempting full evaluation\n```\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4694, target_ratio: 0.9371, combined_score: 0.9371, radius_variance: 0.0011, spatial_spread: 0.1952, eval_time: 2.2235\n- Outcome: Mixed results\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4764, target_ratio: 0.9398, combined_score: 0.9398, radius_variance: 0.0002, spatial_spread: 0.1883, eval_time: 2.6045\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.4780, target_ratio: 0.9404, combined_score: 0.9404, radius_variance: 0.0002, spatial_spread: 0.1882, eval_time: 4.4849\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9404)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square. Uses coordinate descent with a large variety\n    of greedy expansion orders to find the optimal set of radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    bounds = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Eye matrix to ignore self-distance in vectorized calculations\n    eye_n = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Diversity of expansion orders: geometric sorting and random permutations\n    orders = [\n        np.argsort(bounds),\n        np.argsort(-bounds),\n        np.argsort(centers[:, 0]),\n        np.argsort(-centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(-centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Add many random permutations to explore the space of radii assignments\n    for _ in range(112):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        # Iterate multiple times to ensure the radii converge to a local maximum\n        for _ in range(15):\n            for i in order:\n                # Radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = min(bounds[i], np.min(dists[i] - radii + eye_n[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter across\n    multiple restarts, followed by a robust radii optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Range of target distances to explore across multiple restarts\n    # This helps find different topological configurations\n    target_dists = np.linspace(0.192, 0.218, 12)\n\n    for restart, target_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(600 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # 5-5-6-5-5 row pattern\n            centers = []\n            for r_idx, num in enumerate([5, 5, 6, 5, 5]):\n                y = 0.1 + r_idx * 0.2\n                for c_idx in range(num):\n                    centers.append([(c_idx + 0.5) / num, y])\n            centers = np.array(centers)\n        elif restart < 6:\n            # Jittered grid initialization\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.uniform(0.1, 0.9, 2)\n        else:\n            # Purely random initial positions\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Add initial jitter to break symmetry\n        centers += np.random.normal(0, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters\n        iters = 1800\n        dt_base = 0.05\n\n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n\n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n\n            # Add decreasing noise to escape local minima\n            if k < iters * 0.6:\n                noise_mag = 0.003 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Compute maximized radii for the final centers found in this restart\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Track the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4780), Performs well on target_ratio (0.9404), Performs well on combined_score (0.9404), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1882), Performs well on eval_time (4.4849)\n\n### Program 2 (Score: 0.9398)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=160):\n    \"\"\"\n    Maximizes the sum of radii for a given set of centers within a unit square.\n    Uses greedy coordinate expansion with multiple randomized search orders\n    to find a high-performing radii distribution for fixed center positions.\n    \"\"\"\n    n = centers.shape[0]\n    # Distance to the nearest boundary for each center (x, y, 1-x, 1-y)\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Vectorized pairwise distance calculation\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e10)\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic strategies followed by random permutations to explore expansion orders\n    for t in range(trials):\n        if t == 0:\n            order = np.argsort(b_limits)\n        elif t == 1:\n            order = np.argsort(-b_limits)\n        elif t < 12:\n            # Sort by distance from the center of the square to prioritize middle or edge circles\n            d_center = np.sum((centers - 0.5)**2, axis=1)\n            order = np.argsort(d_center) if t % 2 == 0 else np.argsort(-d_center)\n        else:\n            order = np.random.permutation(n)\n\n        radii = np.zeros(n)\n        for i in order:\n            # The radius r_i is limited by its distance to walls and already set radii of neighbors\n            r_i = min(b_limits[i], np.min(dists[i] - radii))\n            radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize the \n    total sum of radii using a force-directed physics simulation with \n    multiple restarts, diverse initial layouts, and annealing noise.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances to find different packing topologies\n    target_dists = np.linspace(0.192, 0.218, 14)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Seed for reproducibility per restart\n        np.random.seed(1337 + restart)\n        r_target = t_dist / 2.0\n\n        # Diversify initial center positions across restarts to explore the solution space\n        if restart == 0:\n            # Standard 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Hexagonal-style staggered row pattern (5-6-5-6-4)\n            centers = []\n            for row_idx, num_cols in enumerate([5, 6, 5, 6, 4]):\n                y = 0.1 + row_idx * 0.2\n                for col_idx in range(num_cols):\n                    centers.append([(col_idx + 0.5) / num_cols, y])\n            centers = np.array(centers)\n        elif restart < 9:\n            # Jittered grid initialization to break symmetry early\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = np.random.rand(2)\n            centers += np.random.normal(0, 0.045, (n, 2))\n        else:\n            # Purely random initialization to find unconventional configurations\n            centers = np.random.rand(n, 2)\n\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Force-directed simulation parameters\n        iters = 2000\n        dt_base = 0.055\n\n        for k in range(iters):\n            # Calculate pairwise displacement vectors and distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            dist_safe = dists + 1e-12\n            # Avoid self-interaction division errors\n            np.fill_diagonal(dists, 1.0)\n\n            # Inter-circle repulsion forces proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist_safe\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Boundary repulsion forces to keep centers within viable packing regions\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update positions with power-based cooling schedule\n            cooling = (1.0 - k / iters)**1.15\n            centers += (forces + b_forces) * (dt_base * cooling)\n\n            # Stochastic jitter (simulated annealing) to escape local minima\n            if k < iters * 0.6:\n                noise_mag = 0.0028 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Optimize radii for the current resulting center configuration\n        radii, current_sum = compute_max_radii(centers)\n\n        # Update global best result if the current configuration is superior\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4764), Performs well on target_ratio (0.9398), Performs well on combined_score (0.9398), Performs well on radius_variance (0.0002), Performs well on spatial_spread (0.1883), Performs well on eval_time (2.6045)\n\n### Program 3 (Score: 0.9371)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a given set of center coordinates\n    within a unit square, ensuring no overlaps and respect for boundaries.\n    Uses coordinate descent with multiple greedy expansion orders.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and boundary limits\n    diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diff**2, axis=-1))\n    # Distance to the nearest boundary for each center\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Try several expansion orders to maximize the sum of radii\n    for trial in range(13):\n        radii = np.zeros(n)\n        if trial == 0:\n            order = np.arange(n)\n        elif trial == 1:\n            order = np.argsort(boundary_limits)\n        else:\n            order = np.random.permutation(n)\n\n        # Coordinate descent to solve for optimal radii for fixed centers\n        for _ in range(25):\n            for i in order:\n                # Maximum radius r_i is limited by boundary and dist(i,j) - r_j\n                r_i = boundary_limits[i]\n                for j in range(n):\n                    if i != j:\n                        r_i = min(r_i, dist_matrix[i, j] - radii[j])\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    force-directed physics simulation with cooling and jitter, followed\n    by a greedy radii optimization to maximize the sum of radii.\n    \"\"\"\n    n = 26\n    iters = 1600\n    dt_base = 0.05\n    \n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target distances to explore across multiple restarts\n    target_dists = np.linspace(0.198, 0.208, 10)\n    \n    for restart in range(10):\n        # Set seed for reproducibility per restart\n        np.random.seed(200 + restart)\n        target_dist = target_dists[restart]\n        \n        # Initial layout: 5x5 grid plus one extra circle\n        centers = np.zeros((n, 2))\n        for i in range(5):\n            for j in range(5):\n                centers[i * 5 + j] = [0.2 * i + 0.1, 0.2 * j + 0.1]\n        \n        # Placement of the 26th circle varies to diversify the search\n        if restart % 3 == 0:\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            centers[25] = [0.05, 0.05]\n        else:\n            centers[25] = [0.95, 0.95]\n            \n        # Add jitter to break initial symmetry and encourage exploration\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Physics simulation loop\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion between circles\n            overlap = np.maximum(0, target_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            # Magnitude proportional to overlap distance\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Repulsion from square boundaries\n            r_target = target_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Update center positions with a cooling schedule\n            dt = dt_base * (1.0 - 0.9 * k / iters)\n            centers += forces * dt\n            \n            # Add small noise early in the simulation to help skip local minima\n            if k < iters * 0.6:\n                noise_mag = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_mag, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Compute maximized radii for these center positions\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Maintain the best configuration found across all restarts\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to run the packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.4694), Performs well on target_ratio (0.9371), Performs well on combined_score (0.9371), Performs well on radius_variance (0.0011), Performs well on spatial_spread (0.1952), Performs well on eval_time (2.2235)\n\n\n\n## Diverse Programs\n\n### Program D1 (Score: 0.9362)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=40):\n    \"\"\"\n    Given a fixed set of center positions, this function finds the radii\n    that maximize the total sum of radii subject to no overlaps and\n    boundary constraints. It uses coordinate descent with multiple\n    randomized expansion orders to explore local optima.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized greedy trials.\n\n    Returns:\n        tuple: (radii, sum_radii) where radii is an (n,) array.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Distance to the nearest wall for each center [x, y, 1-x, 1-y]\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    for trial in range(trials):\n        # Specific heuristic orderings followed by random permutations\n        if trial == 0:\n            order = np.argsort(b_limits)\n        elif trial == 1:\n            order = np.argsort(-b_limits)\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Iterative coordinate descent to grow each circle maximally\n        for _ in range(6):\n            for i in order:\n                # Calculate maximum possible radius r_i given current r_j\n                mask = np.ones(n, dtype=bool)\n                mask[i] = False\n                # r_i must be <= distance to wall and <= dist(i,j) - r_j\n                r_i = min(b_limits[i], np.min(dists[i, mask] - radii[mask]))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii, best_sum\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square to maximize \n    the sum of their radii. Uses a force-directed physics simulation \n    with varying target distances and jitter across multiple restarts.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n    \n    # Range of target diameters to explore across multiple restarts\n    target_dists = [0.198, 0.201, 0.204, 0.207, 0.210, 0.213, 0.216, 0.219]\n    \n    for restart, t_dist in enumerate(target_dists):\n        # Reproducible search per restart\n        np.random.seed(600 + restart)\n        r_target = t_dist / 2.0\n        \n        # Initial layout: 5x5 grid plus one circle in the center\n        centers = np.zeros((n, 2))\n        for i in range(25):\n            centers[i] = [0.1 + (i % 5) * 0.2, 0.1 + (i // 5) * 0.2]\n        centers[25] = [0.5, 0.5]\n        \n        # Jitter helps break grid symmetry and escape local minima\n        centers += np.random.uniform(-0.02, 0.02, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n        \n        # Simulation parameters\n        iters = 1600\n        dt_base = 0.05\n        \n        for k in range(iters):\n            # Vectorized pairwise repulsion forces\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=2))\n            np.fill_diagonal(dists, 1.0) # Avoid self-interaction\n            \n            # Repulsion proportional to overlap distance\n            f_mag = np.maximum(0, t_dist - dists) / (dists + 1e-10)\n            np.fill_diagonal(f_mag, 0)\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n            \n            # Repulsion from square boundaries\n            b_forces = np.zeros((n, 2))\n            b_forces[:, 0] = np.maximum(0, r_target - centers[:, 0]) - \\\n                             np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            b_forces[:, 1] = np.maximum(0, r_target - centers[:, 1]) - \\\n                             np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Cooling schedule for simulation convergence\n            cooling = (1.0 - k / iters)**1.5\n            centers += (forces + b_forces) * (dt_base * cooling)\n            \n            # Stochastic noise (annealing) to encourage exploration early on\n            if k < iters * 0.5:\n                noise_scale = 0.001 * (1.0 - k / (iters * 0.5))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n            \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Optimize radii for these center positions\n        radii, current_sum = compute_max_radii(centers)\n        \n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n### Program D2 (Score: 0.9368)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center coordinates within a unit square.\n    Uses coordinate descent with various greedy expansion orders and multiple trials\n    to find an optimal set of radii that satisfy all non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Vectorized precomputation of pairwise distances and boundary limits\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Boundary limits for each center: dist to nearest square edge\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Mask to ignore self-distance in calculations\n    mask = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic and random permutations to explore the space of radii assignments\n    orders = [\n        np.argsort(boundary_limits),\n        np.argsort(-boundary_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Append random permutations for diversity in the greedy search\n    for _ in range(95):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        for _ in range(12):\n            for i in order:\n                # Radius r_i is limited by the square boundary and distances to neighbors\n                r_i = min(boundary_limits[i], np.min(dist_matrix[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a multi-start\n    force-directed simulation combined with a robust greedy radius optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    target_distances = np.linspace(0.194, 0.215, 12)\n\n    for restart, t_dist in enumerate(target_distances):\n        # Set seed for reproducibility per restart\n        np.random.seed(1234 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart % 3 == 0:\n            # Shifted 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            # 4x6 grid with two extra circles\n            centers = np.zeros((n, 2))\n            for i in range(4):\n                for j in range(6):\n                    centers[i * 6 + j] = [0.12 + 0.25 * i, 0.08 + 0.16 * j]\n            centers[24] = np.random.rand(2)\n            centers[25] = np.random.rand(2)\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        # Break initial symmetry with jitter and ensure centers are within the square\n        centers += np.random.normal(0, 0.025, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters: iterations and initial step size\n        iters = 1800\n        dt_base = 0.06\n\n        # Physics simulation loop\n        for k in range(iters):\n            # Calculate pairwise vectors and distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion magnitude proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Square boundary repulsion forces\n            r_target = t_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with a linear cooling schedule\n            cooling = 1.0 - k / iters\n            dt = dt_base * cooling\n            centers += forces * dt\n\n            # Add decreasing stochastic noise to skip local minima\n            if k < iters * 0.7:\n                noise_mag = 0.0025 * cooling\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Final greedy radius maximization for the current center configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Maintain the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nKey features: Alternative approach to validity, Alternative approach to sum_radii\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9368, Type: High-Performer)\n```python\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for a fixed set of center coordinates within a unit square.\n    Uses coordinate descent with various greedy expansion orders and multiple trials\n    to find an optimal set of radii that satisfy all non-overlap and boundary constraints.\n    \"\"\"\n    n = centers.shape[0]\n    # Vectorized precomputation of pairwise distances and boundary limits\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dist_matrix = np.sqrt(np.sum(diffs**2, axis=-1))\n    # Boundary limits for each center: dist to nearest square edge\n    boundary_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Mask to ignore self-distance in calculations\n    mask = np.eye(n) * 1e12\n\n    best_sum = -1.0\n    best_radii = np.zeros(n)\n\n    # Heuristic and random permutations to explore the space of radii assignments\n    orders = [\n        np.argsort(boundary_limits),\n        np.argsort(-boundary_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(centers[:, 0] + centers[:, 1]),\n        np.argsort(-(centers[:, 0] + centers[:, 1]))\n    ]\n    # Append random permutations for diversity in the greedy search\n    for _ in range(95):\n        orders.append(np.random.permutation(n))\n\n    for order in orders:\n        radii = np.zeros(n)\n        # Coordinate descent to solve for optimal radii given fixed centers\n        for _ in range(12):\n            for i in order:\n                # Radius r_i is limited by the square boundary and distances to neighbors\n                r_i = min(boundary_limits[i], np.min(dist_matrix[i] - radii + mask[i]))\n                radii[i] = max(0.0, r_i)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a multi-start\n    force-directed simulation combined with a robust greedy radius optimization.\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    target_distances = np.linspace(0.194, 0.215, 12)\n\n    for restart, t_dist in enumerate(target_distances):\n        # Set seed for reproducibility per restart\n        np.random.seed(1234 + restart)\n\n        # Diverse initial layouts: grids, patterns, and random placements\n        if restart % 3 == 0:\n            # Shifted 5x5 grid with one center circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart % 3 == 1:\n            # 4x6 grid with two extra circles\n            centers = np.zeros((n, 2))\n            for i in range(4):\n                for j in range(6):\n                    centers[i * 6 + j] = [0.12 + 0.25 * i, 0.08 + 0.16 * j]\n            centers[24] = np.random.rand(2)\n            centers[25] = np.random.rand(2)\n        else:\n            # Purely random initialization\n            centers = np.random.rand(n, 2)\n\n        # Break initial symmetry with jitter and ensure centers are within the square\n        centers += np.random.normal(0, 0.025, (n, 2))\n        centers = np.clip(centers, 0.0, 1.0)\n\n        # Simulation parameters: iterations and initial step size\n        iters = 1800\n        dt_base = 0.06\n\n        # Physics simulation loop\n        for k in range(iters):\n            # Calculate pairwise vectors and distances\n            diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dists = np.sqrt(np.sum(diffs**2, axis=-1)) + 1e-10\n\n            # Pairwise repulsion magnitude proportional to overlap\n            overlap = np.maximum(0, t_dist - dists)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dists\n            forces = np.sum(f_mag[:, :, np.newaxis] * diffs, axis=1)\n\n            # Square boundary repulsion forces\n            r_target = t_dist / 2.0\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n\n            # Update center positions with a linear cooling schedule\n            cooling = 1.0 - k / iters\n            dt = dt_base * cooling\n            centers += forces * dt\n\n            # Add decreasing stochastic noise to skip local minima\n            if k < iters * 0.7:\n                noise_mag = 0.0025 * cooling\n                centers += np.random.normal(0, noise_mag, (n, 2))\n\n            centers = np.clip(centers, 0.0, 1.0)\n\n        # Final greedy radius maximization for the current center configuration\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n\n        # Maintain the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n\n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test execution\n    centers, radii, sum_radii = run_packing()\n    print(f\"Number of circles: {len(radii)}\")\n    print(f\"Sum of radii: {sum_radii:.6f}\")\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.0000, Type: Exploratory)\n```python\ndef compute_max_radii(centers):\n        n = centers.shape[0]\n        radii = np.zeros(n)\n        for i in range(n):\n            x, y = centers[i]\n            radii[i] = min(x, y, 1 - x, 1 - y)\n        for _ in range(100):\n            for i in range(n):\n                for j in range(i + 1, n):\n                    d = np.linalg.norm(centers[i] - centers[j])\n                    if radii[i] + radii[j] > d:\n                        scale = d / (radii[i] + radii[j])\n                        radii[i] *= scale\n                        radii[j] *= scale\n        return radii\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 3 (Score: 0.3642, Type: Exploratory)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nUnique approach: [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n```python\n\"\"\"\nConstructor-based circle packing for n=26 circles in a unit square.\nThis implementation uses a force-directed physics simulation with annealing\nand a randomized greedy optimization to maximize the sum of radii.\n\"\"\"\n\nimport numpy as np\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Maximizes the sum of radii for fixed center positions by using multiple\n    trials of randomized greedy expansion.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates.\n\n    Returns:\n        np.array of shape (n) with the radius of each circle.\n    \"\"\"\n    n = centers.shape[0]\n    # Precompute pairwise distances and distance-to-boundary limits\n    d_mat = np.sqrt(np.sum((centers[:, None, :] - centers[None, :, :])**2, axis=-1))\n    b_lim = np.array([min(c[0], c[1], 1.0 - c[0], 1.0 - c[1]) for c in centers])\n\n    best_radii = np.zeros(n)\n    best_sum = 0\n\n    # Try different expansion orders to explore the feasible space of radii\n    for _ in range(500):\n        order = np.random.permutation(n)\n        radii = np.zeros(n)\n        # Greedily expand each circle to its maximum available space\n        for i in order:\n            r = b_lim[i]\n            # Must satisfy r_i + r_j <= dist_ij for all circles\n            for j in range(n):\n                if i != j:\n                    r = min(r, d_mat[i, j] - radii[j])\n            radii[i] = max(0.0, r)\n\n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n\n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Constructs an arrangement of 26 circles in a unit square using a\n    vectorized force-directed simulation to maximize the sum of radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    # Seed for reproducibility\n    np.random.seed(42)\n\n    # Initial layout: 5x5 grid plus one circle in the center\n    centers = np.zeros((n, 2))\n    for i in range(5):\n        for j in range(5):\n            centers[i * 5 + j] = [0.1 + i * 0.2, 0.1 + j * 0.2]\n    centers[25] = [0.5, 0.5]\n\n    # Jitter to break initial grid symmetry\n    centers += np.random.normal(0, 0.01, (n, 2))\n    centers = np.clip(centers, 0.0, 1.0)\n\n    # Simulation parameters\n    dt = 0.05\n    iters = 3000\n    target_dist = 0.204\n    r_proxy = target_dist / 2.0\n\n    # Force-directed simulation loop\n    for step in range(iters):\n        # Calculate pairwise displacement vectors and distances\n        diff = centers[:, None, :] - centers[None, :, :]\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["```python\nimport numpy as np\n\n\ndef compute_max_radii(centers, trials=180):\n    \"\"\"\n    Given a fixed set of center positions, this function determines the \n    radii that maximize the total sum of radii subject to no overlaps \n    and boundary constraints. It uses a coordinate descent approach \n    with multiple randomized greedy expansion orders.\n\n    Args:\n        centers (np.ndarray): (n, 2) array of circle center coordinates.\n        trials (int): Number of randomized ordering trials to explore.\n\n    Returns:\n        np.ndarray: (n,) array of optimal radii.\n    \"\"\"\n    n = centers.shape[0]\n    # Calculate distance to nearest boundary for each center\n    b_limits = np.min(np.concatenate([centers, 1.0 - centers], axis=1), axis=1)\n    # Precompute pairwise distances between all centers\n    diffs = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n    dists = np.sqrt(np.sum(diffs**2, axis=2))\n    # Fill diagonal to avoid self-overlap constraints\n    np.fill_diagonal(dists, 1e12)\n\n    best_radii = np.zeros(n)\n    best_sum = -1.0\n\n    # Heuristic orders: boundary proximity, coordinate-based, and center-based\n    seed_orders = [\n        np.argsort(b_limits),\n        np.argsort(-b_limits),\n        np.argsort(centers[:, 0]),\n        np.argsort(centers[:, 1]),\n        np.argsort(np.sum((centers - 0.5)**2, axis=1)),\n        np.argsort(-np.sum((centers - 0.5)**2, axis=1))\n    ]\n\n    for trial in range(trials):\n        if trial < len(seed_orders):\n            order = seed_orders[trial]\n        else:\n            order = np.random.permutation(n)\n        \n        radii = np.zeros(n)\n        # Two passes of greedy expansion to ensure stability\n        for _ in range(2):\n            for i in order:\n                # Max radius r_i = min(dist_to_wall, dist(i,j) - r_j)\n                r_i = min(b_limits[i], np.min(dists[i] - radii))\n                radii[i] = max(0.0, r_i)\n        \n        current_sum = np.sum(radii)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_radii = radii.copy()\n            \n    return best_radii\n\n\ndef construct_packing():\n    \"\"\"\n    Arranges 26 circles in a unit square using a force-directed physics \n    simulation with cooling and restarts. Each configuration is then \n    optimized for the maximum sum of radii.\n\n    Returns:\n        tuple: (best_centers, best_radii, best_overall_sum)\n    \"\"\"\n    n = 26\n    best_overall_sum = -1.0\n    best_overall_centers = None\n    best_overall_radii = None\n\n    # Explore a range of target separation distances across multiple restarts\n    # This helps find different packing topologies (e.g., staggered rows)\n    target_dists = np.linspace(0.198, 0.218, 15)\n\n    for restart, t_dist in enumerate(target_dists):\n        # Set seed per restart for reproducible diversity\n        np.random.seed(42 + restart)\n        r_target = t_dist / 2.0\n        \n        # Diversify initial layouts: grid-based or random\n        if restart == 0:\n            # 5x5 grid plus one circle\n            centers = np.zeros((n, 2))\n            for i in range(5):\n                for j in range(5):\n                    centers[i * 5 + j] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n            centers[25] = [0.5, 0.5]\n        elif restart == 1:\n            # Row-based staggered initialization\n            centers = []\n            rows = [5, 6, 5, 6, 4]\n            for r_idx, num_circles in enumerate(rows):\n                for c_idx in range(num_circles):\n                    centers.append([(c_idx + 0.5) / num_circles, (r_idx + 0.5) / 5])\n            centers = np.array(centers[:n])\n        else:\n            centers = np.random.uniform(0.1, 0.9, (n, 2))\n\n        # Simulation parameters\n        iters = 2000\n        dt_base = 0.05\n        \n        # Physics simulation: particles repel each other and square boundaries\n        for k in range(iters):\n            diff = centers[:, np.newaxis, :] - centers[np.newaxis, :, :]\n            dist = np.sqrt(np.sum(diff**2, axis=-1)) + 1e-10\n            \n            # Pairwise repulsion force\n            overlap = np.maximum(0, t_dist - dist)\n            np.fill_diagonal(overlap, 0)\n            f_mag = overlap / dist\n            forces = np.sum(f_mag[:, :, np.newaxis] * diff, axis=1)\n            \n            # Boundary repulsion forces\n            forces[:, 0] += np.maximum(0, r_target - centers[:, 0])\n            forces[:, 0] -= np.maximum(0, centers[:, 0] - (1.0 - r_target))\n            forces[:, 1] += np.maximum(0, r_target - centers[:, 1])\n            forces[:, 1] -= np.maximum(0, centers[:, 1] - (1.0 - r_target))\n            \n            # Step with cooling schedule\n            cooling = (1.0 - k / iters)\n            centers += forces * (dt_base * cooling)\n            \n            # Simulated annealing: add decreasing noise early in the simulation\n            if k < iters * 0.6:\n                noise_scale = 0.002 * (1.0 - k / (iters * 0.6))\n                centers += np.random.normal(0, noise_scale, (n, 2))\n                \n            centers = np.clip(centers, 0.0, 1.0)\n            \n        # Post-process centers to solve for optimal radii\n        radii = compute_max_radii(centers)\n        current_sum = np.sum(radii)\n        \n        # Keep the best configuration found globally\n        if current_sum > best_overall_sum:\n            best_overall_sum = current_sum\n            best_overall_centers = centers.copy()\n            best_overall_radii = radii.copy()\n            \n    return best_overall_centers, best_overall_radii, best_overall_sum\n\n\ndef run_packing():\n    \"\"\"\n    Standard entry point to execute the circle packing algorithm for 26 circles.\n    Returns: (centers, radii, sum_radii)\n    \"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\nif __name__ == \"__main__\":\n    # Test script for local evaluation\n    c, r, s = run_packing()\n    print(f\"Number of circles: {len(r)}\")\n    print(f\"Sum of radii: {s:.6f}\")\n    print(f\"Average radius: {s/len(r):.6f}\")\n\n```"]}}, "artifacts_json": "{\"execution_time\": \"3.13s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.489188/2.635 = 0.9447\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\"}", "artifact_dir": null, "embedding": null}