{"id": "28e89992-7a7a-4c74-86c8-e5033d087176", "code": "# EVOLVE-BLOCK-START\n\"\"\"Constructor-based iterative physics circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef make_valid(centers, radii):\n    \"\"\"\n    Ensure the configuration mathematically correctly satisfies\n    box limits and inter-circle overlap non-interception bounds.\n    \"\"\"\n    n = len(radii)\n    r = radii.copy()\n    c = centers.copy()\n    \n    # 1. Swift wall boundary clamp pass mapping safe coordinates identically\n    for i in range(n):\n        r[i] = max(0.0, min(r[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1]))\n    \n    # 2. Iterate inter-circle intersections smoothly settling boundaries strictly\n    for _ in range(500):\n        violation = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(c[i] - c[j])\n                if r[i] + r[j] > d + 1e-12:\n                    violation = True\n                    diff = r[i] + r[j] - d\n                    sum_r = r[i] + r[j]\n                    if sum_r > 0:\n                        r[i] = max(0.0, r[i] - diff * (r[i] / sum_r) - 1e-12)\n                        r[j] = max(0.0, r[j] - diff * (r[j] / sum_r) - 1e-12)\n        if not violation:\n            break\n            \n    # 3. Final safety scaling proportion guarantees perfectly float precision overlaps missing mapped bounds mapped safe perfectly \n    for i in range(n):\n        r[i] = max(0.0, min(r[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1]))\n        for j in range(i + 1, n):\n            d = np.linalg.norm(c[i] - c[j])\n            if r[i] + r[j] > d:\n                sum_r = r[i] + r[j]\n                if sum_r > 0:\n                    scale = (d / sum_r) * 0.9999999\n                    r[i] *= scale\n                    r[j] *= scale\n    return r\n\n\ndef solve_radii(centers, r_fallback):\n    \"\"\"\n    Compute exactly best maximal bounding radii scaling sizes safely perfectly linearly.\n    \"\"\"\n    n = len(centers)\n    try:\n        import warnings\n        from scipy.optimize import linprog\n        \n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            \n            c_obj = -np.ones(n)\n            A_ub = []\n            b_ub = []\n            \n            # Map edge boundaries structurally reliably perfectly cleanly perfectly directly\n            for i in range(n):\n                for _ in range(4):\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    A_ub.append(row)\n                \n                b_ub.append(float(centers[i, 0]))\n                b_ub.append(float(1.0 - centers[i, 0]))\n                b_ub.append(float(centers[i, 1]))\n                b_ub.append(float(1.0 - centers[i, 1]))\n                \n            # Maps circles interactions cleanly without crossing lines \n            for i in range(n):\n                for j in range(i + 1, n):\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    dist = float(np.linalg.norm(centers[i] - centers[j]))\n                    A_ub.append(row)\n                    b_ub.append(dist)\n                    \n            res = linprog(c_obj, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=(0.0, None))\n            if res.success:\n                return make_valid(centers, res.x)\n    except Exception:\n        pass\n    \n    return make_valid(centers, r_fallback)\n\n\ndef get_seeds(n=26):\n    \"\"\"Generates heuristically highly optimized distributions biasing centers & margins perfectly optimally\"\"\"\n    seeds = []\n    np.random.seed(4242)\n    \n    # Grid Pattern (Central Bias Offset)\n    c1 = np.zeros((n, 2))\n    idx = 0\n    for i in np.linspace(0.1, 0.9, 5):\n        for j in np.linspace(0.1, 0.9, 5):\n            if idx < n: \n                c1[idx] = [i, j]; idx += 1\n    if idx < n: c1[idx] = [0.5, 0.5]\n    seeds.append((c1, np.ones(n) * 0.04))\n    \n    # Dynamic Concentric Distribution (8 Inner & 17 Margins rings)\n    c2 = np.zeros((n, 2))\n    c2[0] = [0.5, 0.5]\n    for i in range(1, 9):\n        a = i * 2 * np.pi / 8 + 0.1\n        c2[i] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n    for i in range(9, n):\n        a = i * 2 * np.pi / 17 + 0.05\n        c2[i] = [0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)]\n    seeds.append((c2, np.ones(n) * 0.03))\n    \n    # Boundary Frame Constraints Logic mapping explicitly correctly appropriately smoothly reliably \n    c3 = np.zeros((n, 2))\n    idx = 0\n    vals = np.linspace(0.05, 0.95, 8)\n    for x in vals:\n        if idx < n: c3[idx] = [x, 0.05]; idx += 1\n        if idx < n: c3[idx] = [x, 0.95]; idx += 1\n    for y in vals[1:-1]:\n        if idx < n: c3[idx] = [0.05, y]; idx += 1\n        if idx < n: c3[idx] = [0.95, y]; idx += 1\n    while idx < n:\n        c3[idx] = [0.5 + 0.3 * np.random.randn(), 0.5 + 0.3 * np.random.randn()]\n        c3[idx] = np.clip(c3[idx], 0.2, 0.8)\n        idx += 1\n    seeds.append((c3, np.ones(n) * 0.03))\n    \n    # Density Randomized Placements logic \n    for _ in range(2):\n        c4 = np.random.rand(n, 2) * 0.8 + 0.1\n        c4 = np.clip(c4, 0.05, 0.95)\n        dists = np.linalg.norm(c4 - np.array([0.5, 0.5]), axis=1)\n        r4 = 0.08 - 0.05 * dists\n        r4 = np.clip(r4, 0.01, 0.2)\n        seeds.append((c4, r4))\n\n    # Incorporate noise perturbations strictly ensuring perfectly optimally bounds exactly accurately \n    final_seeds = []\n    for (c, r) in seeds:\n        for jitter in [1e-4, 0.02, 0.05]:\n            cj = c.copy() + np.random.randn(n, 2) * jitter\n            cj = np.clip(cj, 0.01, 0.99)\n            final_seeds.append((cj, r.copy()))\n\n    return final_seeds\n\n\ndef optimize(c_init, r_init, steps=3000):\n    \"\"\"\n    Physical layout Adam iterative bounding box resolving layout optimizations optimally reliably explicitly safely completely structurally cleanly.\n    \"\"\"\n    n = len(c_init)\n    c = c_init.copy()\n    r = r_init.copy()\n    \n    mc = np.zeros_like(c)\n    vc = np.zeros_like(c)\n    mr = np.zeros_like(r)\n    vr = np.zeros_like(r)\n    \n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    \n    for t in range(1, steps + 1):\n        progress = t / steps\n        lr = 0.01 * 0.5 * (1.0 + np.cos(np.pi * progress))\n        lr = max(lr, 1e-5)\n        penalty = 10 ** (6 * progress)\n        \n        # Continuous active symmetry-breaking optimally mapping reliably smartly\n        if progress < 0.5:\n            c += np.random.normal(0, 0.001 * (0.5 - progress), c.shape)\n            c = np.clip(c, 0.001, 0.999)\n            \n        diff = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        dist_safe = np.where(dist < 1e-12, 1e-12, dist)\n        \n        sum_r = r[:, np.newaxis] + r[np.newaxis, :]\n        overlap = sum_r - dist_safe\n        \n        mask = np.triu(overlap > 0, k=1)\n        active = overlap * mask\n        \n        # Drive global maximizing volumes linearly cleanly smoothly smoothly uniformly dynamically efficiently precisely optimally elegantly appropriately smoothly\n        grad_r = -1.0 * np.ones_like(r)\n        \n        # Exact gradients correctly aggregating structurally seamlessly beautifully\n        force_r = 2 * penalty * active\n        grad_r += np.sum(force_r, axis=1) + np.sum(force_r, axis=0)\n        \n        force_c = (force_r / dist_safe)[:, :, np.newaxis] * diff\n        grad_c = np.zeros_like(c)\n        grad_c -= np.sum(force_c, axis=1)\n        grad_c += np.sum(force_c, axis=0)\n        \n        # Apply strict exact identical cleanly mappings elegantly dynamically mathematically bounding boundaries exactly purely explicitly strictly exactly structurally correctly identically properly cleanly cleanly perfectly reliably cleanly identically\n        v_x0 = np.maximum(0, r - c[:, 0])\n        grad_r += 2 * penalty * v_x0\n        grad_c[:, 0] -= 2 * penalty * v_x0\n        \n        v_x1 = np.maximum(0, r - (1.0 - c[:, 0]))\n        grad_r += 2 * penalty * v_x1\n        grad_c[:, 0] += 2 * penalty * v_x1\n        \n        v_y0 = np.maximum(0, r - c[:, 1])\n        grad_r += 2 * penalty * v_y0\n        grad_c[:, 1] -= 2 * penalty * v_y0\n        \n        v_y1 = np.maximum(0, r - (1.0 - c[:, 1]))\n        grad_r += 2 * penalty * v_y1\n        grad_c[:, 1] += 2 * penalty * v_y1\n        \n        # Adaptive optimizer step integration\n        mc = beta1 * mc + (1 - beta1) * grad_c\n        vc = beta2 * vc + (1 - beta2) * (grad_c ** 2)\n        mch = mc / (1 - beta1 ** t)\n        vch = vc / (1 - beta2 ** t)\n        c -= lr * mch / (np.sqrt(vch) + eps)\n        \n        mr = beta1 * mr + (1 - beta1) * grad_r\n        vr = beta2 * vr + (1 - beta2) * (grad_r ** 2)\n        mrh = mr / (1 - beta1 ** t)\n        vrh = vr / (1 - beta2 ** t)\n        r -= lr * mrh / (np.sqrt(vrh) + eps)\n        \n        r = np.maximum(r, 0.0)\n        c = np.clip(c, 0.001, 0.999)\n        \n    return c, r\n\n\ndef construct_packing():\n    \"\"\"\n    Orchestrate physics model optimization exactly generating highly balanced dynamically scaled architectures efficiently structurally efficiently securely optimally reliably mathematically correctly perfectly exactly explicitly directly safely explicitly seamlessly securely reliably natively explicitly elegantly\n    \"\"\"\n    n = 26\n    best_sum = 0.0\n    best_c = None\n    best_r = None\n    \n    seeds = get_seeds(n)\n    \n    for i, (c_init, r_init) in enumerate(seeds):\n        c, r = optimize(c_init, r_init, steps=2500)\n        r_final = solve_radii(c, r)\n        \n        current_sum = np.sum(r_final)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c.copy()\n            best_r = r_final.copy()\n            \n    return best_c, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)", "changes_description": null, "language": "python", "parent_id": "7f276fde-011e-4b00-b551-7bc8c2aaff80", "generation": 1, "timestamp": 1771996956.9638674, "iteration_found": 12, "metrics": {"validity": 1.0, "sum_radii": 2.582719403058585, "target_ratio": 0.9801591662461424, "combined_score": 0.9801591662461424, "radius_variance": 0.004216466093147277, "spatial_spread": 0.19345801643847704, "eval_time": 6.310303449630737}, "complexity": 0.0, "diversity": 0.0, "metadata": {"changes": "Full rewrite", "parent_metrics": {"validity": 1.0, "sum_radii": 0.9597642169962064, "target_ratio": 0.36423689449571406, "combined_score": 0.36423689449571406, "radius_variance": 0.026599407523434117, "spatial_spread": 0.23809223949931868}, "island": 0}, "prompts": {"full_rewrite_user": {"system": "You are an expert mathematician and Python developer specializing in computational geometry and circle packing optimization.\nYour task is to improve the given Python algorithm for finding a highly optimized arrangement of 26 circles within a 1x1 unit square. The objective is to maximize the sum of their radii without any of the circles overlapping or extending outside the boundaries of the square.\nInstead of hardcoding a direct arrangement, implement an iterative optimization algorithm to find the solution.\nWhen designing the optimization routine, incorporate the following geometric heuristics:\n* Seed initial positions strategically: Bias initial placements toward corners and edges to maximize space utilization.\n* Break perfect symmetry: Introduce slight random perturbations during the optimization to escape local maxima caused by edge constraints.\n* Tune optimization parameters: Ensure your physics model uses a decaying learning rate or simulated annealing approach to smoothly settle into the tightest possible packing.\n* Placement by size: consider placing larger circles toward the center and smaller circles into the corners and interstitial gaps.\n\nCode Requirements:\n* Completeness: You MUST provide a fully runnable script. Do not use ellipses (`...`), comments-as-placeholders, or unclosed structures.\n* Style: Ensure the code is syntactically perfect and strictly adheres to PEP 8 formatting.\n* Code review: doublecheck your code to make sure it will not bump into any runtime exceptions.\n* Response Format: response in plain text, without wrapping the code into a Markdown codeblock.\n", "user": "# Current Program Information\n- Fitness: 0.3642\n- Feature coordinates: \n- Focus areas: - Fitness unchanged at 0.3642\n- No feature coordinates\n- Consider simplifying - code length exceeds 500 characters\n\n\n\n# Program Evolution History\n## Previous Attempts\n\n### Attempt 3\n- Changes: Unknown changes\n- Metrics: validity: 1.0000, sum_radii: 0.9598, target_ratio: 0.3642, combined_score: 0.3642, radius_variance: 0.0266, spatial_spread: 0.2381\n- Outcome: Improvement in all metrics\n\n### Attempt 2\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6002, target_ratio: 0.9868, combined_score: 0.9868, radius_variance: 0.0045, spatial_spread: 0.1910, eval_time: 4.3336\n- Outcome: Mixed results\n\n### Attempt 1\n- Changes: Full rewrite\n- Metrics: validity: 1.0000, sum_radii: 2.6227, target_ratio: 0.9953, combined_score: 0.9953, radius_variance: 0.0053, spatial_spread: 0.1918, eval_time: 6.4371\n- Outcome: Mixed results\n\n## Top Performing Programs\n\n### Program 1 (Score: 0.9953)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based iterative physics circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_seeds(n=26):\n    \"\"\"\n    Generate diverse initial configurations of circles biased to heuristics:\n    rings, boundary alignment, grid spread, and weighted center distributions.\n    \"\"\"\n    seeds = []\n    np.random.seed(42)  # Maintain deterministic stability per run\n\n    # Strategy 1: Ring Structured Placement\n    C_rings = np.zeros((n, 2))\n    C_rings[0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        C_rings[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        C_rings[i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n    seeds.append((C_rings, np.ones(n) * 0.03))\n\n    # Strategy 2: Heuristic Boundary + Corner + Fill Placement\n    C_edge = np.zeros((n, 2))\n    idx = 0\n    # Add rigid corners and side blocks for max space\n    for cx in [0.05, 0.95]:\n        for cy in [0.05, 0.95]:\n            if idx < n: \n                C_edge[idx] = [cx, cy]\n                idx += 1\n    for step in [0.3, 0.5, 0.7]:\n        for cx in [0.05, 0.95]:\n            if idx < n: \n                C_edge[idx] = [cx, step]\n                idx += 1\n        for cy in [0.3, 0.5, 0.7]:\n            if idx < n: \n                C_edge[idx] = [step, cy]\n                idx += 1\n    # Randomly scatter remaining inward elements to settle gracefully\n    while idx < n:\n        C_edge[idx] = [0.2 + 0.6 * np.random.rand(), 0.2 + 0.6 * np.random.rand()]\n        idx += 1\n    seeds.append((C_edge, np.ones(n) * 0.03))\n\n    # Strategy 3: Tight Matrix Distribution (Grid 5x5 + Middle Offset)\n    C_grid = np.zeros((n, 2))\n    idx = 0\n    for i in range(5):\n        for j in range(5):\n            if idx < n:\n                C_grid[idx] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n                idx += 1\n    if idx < n:\n        C_grid[idx] = [0.5, 0.5]\n    seeds.append((C_grid, np.ones(n) * 0.02))\n\n    # Strategy 4: High Density Pseudorandom Seeds prioritizing center mass \n    # Simulated radial decay sizing encourages optimization flow where the inner space fits large disks\n    for _ in range(8):\n        C_rand_weight = np.random.rand(n, 2)\n        dists = np.sqrt((C_rand_weight[:, 0] - 0.5)**2 + (C_rand_weight[:, 1] - 0.5)**2)\n        r_rand = 0.05 + 0.05 * (1.0 - dists / (np.max(dists) + 1e-5))\n        seeds.append((C_rand_weight, r_rand))\n        \n        # Base Random \n        C_uni = np.random.rand(n, 2) * 0.9 + 0.05\n        seeds.append((C_uni, np.ones(n) * 0.04))\n        \n    return seeds\n\n\ndef optimize_seed(init_C, init_R, steps=2500):\n    \"\"\"\n    Execute mathematical particle optimization pushing toward max boundary space while averting intercepts.\n    Incorporates an adaptive barrier penalty method synced closely with simulated geometric forces.\n    \"\"\"\n    n = len(init_R)\n    params = np.concatenate([init_C.flatten(), init_R])\n    \n    # Mathematical tuning hyperparams (Adam + Learning Scheduling + Temperature scaling)\n    lr = 0.02\n    beta1 = 0.9\n    beta2 = 0.999\n    epsilon = 1e-8\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    penalty_weight = 5.0\n    eye_mat = np.eye(n)\n    \n    # Annealed physics simulation\n    for t in range(1, steps + 1):\n        if t % 500 == 0:\n            penalty_weight *= 3.0  # Steepen repulsive walls to strictly settle elements safely\n            \n        C = params[:n*2].reshape(n, 2)\n        R = params[n*2:]\n        \n        grad_C = np.zeros_like(C)\n        grad_R = np.zeros_like(R)\n        \n        # Penalties: Exceeding boundary box walls [0, 1]\n        left = np.maximum(0, R - C[:, 0])\n        right = np.maximum(0, R - (1 - C[:, 0]))\n        bottom = np.maximum(0, R - C[:, 1])\n        top = np.maximum(0, R - (1 - C[:, 1]))\n        \n        grad_R += penalty_weight * 2 * (left + right + bottom + top)\n        grad_C[:, 0] += penalty_weight * 2 * (-left + right)\n        grad_C[:, 1] += penalty_weight * 2 * (-bottom + top)\n        \n        # Penalties: Distance interference overlaps \n        diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye_mat + 1e-12)\n        \n        R_sum = R[:, np.newaxis] + R[np.newaxis, :]\n        overlap = np.maximum(0, R_sum - dist)\n        np.fill_diagonal(overlap, 0)\n        \n        grad_R += penalty_weight * 2 * np.sum(overlap, axis=1)\n        \n        dir_vectors = diff / dist[:, :, np.newaxis]\n        force = 2 * overlap[:, :, np.newaxis] * (-dir_vectors)\n        grad_C += penalty_weight * np.sum(force, axis=1)\n        \n        # Symmetry-breaking jitter enabling escape from tightly symmetric minima loops\n        noise_scale = 0.02 * max(0, 1.0 - t / (steps * 0.5))\n        if noise_scale > 0:\n            grad_C += np.random.normal(0, noise_scale, grad_C.shape)\n        \n        # Maximize global volume\n        grad_R -= 1.0 \n        \n        # Synchronize forces\n        grad_params = np.concatenate([grad_C.flatten(), grad_R])\n        \n        # Optimizer moments integration\n        m = beta1 * m + (1 - beta1) * grad_params\n        v = beta2 * v + (1 - beta2) * (grad_params ** 2)\n        \n        m_hat = m / (1 - beta1 ** t)\n        v_hat = v / (1 - beta2 ** t)\n        \n        # Soft descent into optimal coordinates mapping cleanly to parameter shifts\n        current_lr = lr * np.exp(-4.0 * t / steps) + 0.0001\n        \n        params -= current_lr * m_hat / (np.sqrt(v_hat) + epsilon)\n        \n        C_temp = params[:n*2].reshape(n, 2)\n        C_temp = np.clip(C_temp, 0.0, 1.0)\n        params[:n*2] = C_temp.flatten()\n        params[n*2:] = np.maximum(params[n*2:], 1e-4)\n\n    final_C = params[:n*2].reshape(n, 2)\n    final_R = params[n*2:]\n    \n    # ---------------------------------------------\n    # Precision enforcement pass guarantees mathematically zero intercepts.\n    # ---------------------------------------------\n    left_b = final_C[:, 0]\n    right_b = 1.0 - final_C[:, 0]\n    bottom_b = final_C[:, 1]\n    top_b = 1.0 - final_C[:, 1]\n    R_exact = np.min([left_b, right_b, bottom_b, top_b], axis=0)\n    R_exact = np.minimum(R_exact, final_R)\n    \n    diff = final_C[:, np.newaxis, :] - final_C[np.newaxis, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    \n    # Iterative proportionate shrinkage eliminating macro-errors precisely mapped to their origins\n    for _ in range(300):\n        R_sum = R_exact[:, np.newaxis] + R_exact[np.newaxis, :]\n        np.fill_diagonal(R_sum, 0)\n        overlaps = np.maximum(0, R_sum - dist)\n        np.fill_diagonal(overlaps, 0)\n        \n        if np.max(overlaps) < 1e-7:\n            break\n            \n        shrinkage = np.zeros(n)\n        for i in range(n):\n            for j in range(n):\n                if overlaps[i, j] > 0:\n                    needed = overlaps[i, j] * (R_exact[i] / (R_exact[i] + R_exact[j] + 1e-9))\n                    if needed > shrinkage[i]:\n                        shrinkage[i] = needed\n        R_exact -= shrinkage * 1.01\n        R_exact = np.maximum(R_exact, 0.0)\n        \n    # Rigid evaluation safe fallback mapping identical checking limits applied externally \n    radii = R_exact.copy()\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = dist[i, j]\n            if radii[i] + radii[j] > d:\n                # Modifying factor of ~1 mathematically avoids testing floating edge conflicts forever\n                scale = (d / (radii[i] + radii[j])) * 0.9999999\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return final_C, radii, np.sum(radii)\n\n\ndef construct_packing():\n    \"\"\"\n    Discover best 26 circle architecture balancing physics optimizations\n    from heuristic start vectors heavily biasing density capabilities.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_C = None\n    best_R = None\n    \n    seeds = generate_seeds(n)\n    for C_init, R_init in seeds:\n        final_C, final_R, final_sum = optimize_seed(C_init, R_init)\n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_C = final_C\n            best_R = final_R\n            \n    return best_C, best_R, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6227), Performs well on target_ratio (0.9953), Performs well on combined_score (0.9953), Performs well on radius_variance (0.0053), Performs well on spatial_spread (0.1918), Performs well on eval_time (6.4371)\n\n### Program 2 (Score: 0.9868)\n```python\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\nimport warnings\n\ndef make_strictly_valid_fallback(c, r):\n    \"\"\"\n    Ensure the configuration of circles mathematically strictly satisfies\n    bounds and non-overlap constraints without exceptions.\n    \"\"\"\n    r_valid = np.copy(r)\n    n = len(c)\n    \n    # 1. Strict boundary check clipping\n    for i in range(n):\n        r_valid[i] = max(0.0, min(r_valid[i], c[i, 0], 1.0-c[i, 0], c[i, 1], 1.0-c[i, 1]))\n        \n    # 2. Iterative pairwise constraint satisfaction to push circles inward away from overlap\n    for _ in range(1000):\n        violated = False\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(c[i] - c[j])\n                if r_valid[i] + r_valid[j] > d + 1e-11:\n                    violated = True\n                    excess = (r_valid[i] + r_valid[j]) - d\n                    sum_r = r_valid[i] + r_valid[j]\n                    if sum_r > 0:\n                        r_valid[i] = max(0.0, r_valid[i] - excess * (r_valid[i] / sum_r) - 1e-11)\n                        r_valid[j] = max(0.0, r_valid[j] - excess * (r_valid[j] / sum_r) - 1e-11)\n        if not violated:\n            break\n            \n    # 3. Final safety deterministic proportional pass (avoids precise float misses)\n    for i in range(n):\n        r_valid[i] = max(0.0, min(r_valid[i], c[i, 0], 1.0-c[i, 0], c[i, 1], 1.0-c[i, 1]))\n        for j in range(i+1, n):\n            d = np.linalg.norm(c[i] - c[j])\n            if r_valid[i] + r_valid[j] > d:\n                sum_r = r_valid[i] + r_valid[j]\n                if sum_r > 0:\n                    scale = d / sum_r\n                    r_valid[i] *= scale\n                    r_valid[j] *= scale\n                    \n    return r_valid\n\ndef compute_max_radii(centers, r_guess=None):\n    \"\"\"\n    Compute optimal possible radii for each circle position without overlaps.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        r_guess: Optional starting array of target radii for fallback cases\n    \"\"\"\n    n = centers.shape[0]\n    if r_guess is None:\n        r_guess = np.ones(n) * 0.05\n\n    try:\n        from scipy.optimize import linprog\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            c_obj = -np.ones(n)\n            A_ub = []\n            b_ub = []\n            \n            # Boundary rules\n            for i in range(n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                \n                A_ub.append(row.copy()); b_ub.append(float(centers[i, 0]))\n                A_ub.append(row.copy()); b_ub.append(float(1.0 - centers[i, 0]))\n                A_ub.append(row.copy()); b_ub.append(float(centers[i, 1]))\n                A_ub.append(row.copy()); b_ub.append(float(1.0 - centers[i, 1]))\n                \n            # Inter-circle boundary collision\n            for i in range(n):\n                for j in range(i+1, n):\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    d = float(np.linalg.norm(centers[i] - centers[j]))\n                    A_ub.append(row)\n                    b_ub.append(d)\n                    \n            res = linprog(c_obj, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=(0.0, None))\n            if res.success:\n                return make_strictly_valid_fallback(centers, res.x)\n    except Exception:\n        pass\n        \n    return make_strictly_valid_fallback(centers, r_guess)\n\ndef get_initial_state(n, seed_idx):\n    \"\"\"Generates a heuristically robust randomized starting configuration.\"\"\"\n    np.random.seed(42 + seed_idx * 13)\n    c = np.zeros((n, 2))\n    topology = seed_idx % 4\n    \n    if topology == 0:\n        c[0] = [0.5, 0.5]\n        for i in range(1, 9):\n            a = i * 2 * np.pi / 8 + np.random.rand() * 0.1\n            c[i] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n        for i in range(9, 26):\n            a = i * 2 * np.pi / 17 + np.random.rand() * 0.1\n            c[i] = [0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)]\n    elif topology == 1:\n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        for i in range(4): c[i] = corners[i]\n        c[4:] = np.random.rand(n-4, 2) * 0.8 + 0.1\n    elif topology == 2:\n        idx = 0\n        for x in np.linspace(0.1, 0.9, 5):\n            for y in np.linspace(0.1, 0.9, 5):\n                if idx < 25:\n                    c[idx] = [x + np.random.randn() * 0.02, y + np.random.randn() * 0.02]\n                    idx += 1\n        c[25] = [0.5, 0.5]\n    else:\n        idx = 0\n        for t in np.linspace(0, 1, 9)[:-1]:\n            if idx < n: c[idx] = [t, 0.05]; idx += 1\n            if idx < n: c[idx] = [t, 0.95]; idx += 1\n            if idx < n: c[idx] = [0.05, t]; idx += 1\n            if idx < n: c[idx] = [0.95, t]; idx += 1\n        while idx < n:\n            c[idx] = [0.3 + np.random.rand() * 0.4, 0.3 + np.random.rand() * 0.4]\n            idx += 1\n\n    c += np.random.randn(n, 2) * 0.015\n    c = np.clip(c, 0.02, 0.98)\n    \n    dist_to_center = np.linalg.norm(c - np.array([0.5, 0.5]), axis=1)\n    if seed_idx % 2 == 0:\n        r = 0.08 - 0.04 * dist_to_center\n    else:\n        r = np.random.rand(n) * 0.05 + 0.03\n        \n    r = np.clip(r, 0.01, 0.2)\n    return c, r\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement utilizing vectorized physical relaxation mechanics,\n    with an adaptive Adam optimizer that progressively punishes overlap / out-of-bounds traits.\n\n    Returns: Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    best_sum = 0.0\n    best_c = None\n    best_r = None\n    \n    num_restarts = 8\n    num_steps = 3000\n    \n    for restart in range(num_restarts):\n        c, r = get_initial_state(n, restart)\n        \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        step_num = 1\n        \n        # Adaptive optimizer annealing with decaying boundaries parameter logic\n        for step in range(num_steps):\n            progress = step / float(num_steps)\n            lr = 0.01 * 0.5 * (1.0 + np.cos(np.pi * progress))\n            if lr < 1e-5: lr = 1e-5\n            \n            penalty = 10 ** (6 * progress)\n            \n            diff = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            dist_safe = np.where(dist < 1e-12, 1e-12, dist)\n            \n            sum_r = r[:, np.newaxis] + r[np.newaxis, :]\n            overlap = sum_r - dist_safe\n            mask = np.triu(overlap > 0, k=1)\n            active_overlaps = overlap * mask\n            \n            # Radii target\n            grad_r = -1.0 * np.ones_like(r)\n            overlap_grad_r = 2 * active_overlaps * penalty\n            grad_r += np.sum(overlap_grad_r, axis=1)\n            grad_r += np.sum(overlap_grad_r, axis=0)\n            \n            # Repulsive alignment updates mapping gradients over positions explicitly mapping space bounds\n            force = (2 * penalty * active_overlaps / dist_safe)[:, :, np.newaxis] * diff\n            grad_c = np.zeros_like(c)\n            grad_c -= np.sum(force, axis=1)\n            grad_c += np.sum(force, axis=0)\n            \n            v_x0 = np.maximum(0, r - c[:, 0])\n            grad_r += 2 * v_x0 * penalty\n            grad_c[:, 0] -= 2 * v_x0 * penalty\n            \n            v_x1 = np.maximum(0, r - (1 - c[:, 0]))\n            grad_r += 2 * v_x1 * penalty\n            grad_c[:, 0] += 2 * v_x1 * penalty\n            \n            v_y0 = np.maximum(0, r - c[:, 1])\n            grad_r += 2 * v_y0 * penalty\n            grad_c[:, 1] -= 2 * v_y0 * penalty\n            \n            v_y1 = np.maximum(0, r - (1 - c[:, 1]))\n            grad_r += 2 * v_y1 * penalty\n            grad_c[:, 1] += 2 * v_y1 * penalty\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** step_num)\n            v_c_hat = v_c / (1 - beta2 ** step_num)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** step_num)\n            v_r_hat = v_r / (1 - beta2 ** step_num)\n            \n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            r = np.maximum(r, 0.0)\n            c = np.clip(c, 0.001, 0.999)\n            \n            step_num += 1\n            \n        r_final = compute_max_radii(c, r)\n        current_sum = np.sum(r_final)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c.copy()\n            best_r = r_final.copy()\n            \n    return best_c, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (2.6002), Performs well on target_ratio (0.9868), Performs well on combined_score (0.9868), Performs well on radius_variance (0.0045), Performs well on spatial_spread (0.1910), Performs well on eval_time (4.3336)\n\n### Program 3 (Score: 0.3642)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\nKey features: Performs well on validity (1.0000), Performs well on sum_radii (0.9598), Performs well on target_ratio (0.3642), Performs well on combined_score (0.3642), Performs well on radius_variance (0.0266), Performs well on spatial_spread (0.2381)\n\n## Inspiration Programs\n\nThese programs represent diverse approaches and creative solutions that may inspire new ideas:\n\n### Inspiration 1 (Score: 0.9953, Type: High-Performer)\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based iterative physics circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef generate_seeds(n=26):\n    \"\"\"\n    Generate diverse initial configurations of circles biased to heuristics:\n    rings, boundary alignment, grid spread, and weighted center distributions.\n    \"\"\"\n    seeds = []\n    np.random.seed(42)  # Maintain deterministic stability per run\n\n    # Strategy 1: Ring Structured Placement\n    C_rings = np.zeros((n, 2))\n    C_rings[0] = [0.5, 0.5]\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        C_rings[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n    for i in range(17):\n        angle = 2 * np.pi * i / 17\n        C_rings[i + 9] = [0.5 + 0.45 * np.cos(angle), 0.5 + 0.45 * np.sin(angle)]\n    seeds.append((C_rings, np.ones(n) * 0.03))\n\n    # Strategy 2: Heuristic Boundary + Corner + Fill Placement\n    C_edge = np.zeros((n, 2))\n    idx = 0\n    # Add rigid corners and side blocks for max space\n    for cx in [0.05, 0.95]:\n        for cy in [0.05, 0.95]:\n            if idx < n: \n                C_edge[idx] = [cx, cy]\n                idx += 1\n    for step in [0.3, 0.5, 0.7]:\n        for cx in [0.05, 0.95]:\n            if idx < n: \n                C_edge[idx] = [cx, step]\n                idx += 1\n        for cy in [0.3, 0.5, 0.7]:\n            if idx < n: \n                C_edge[idx] = [step, cy]\n                idx += 1\n    # Randomly scatter remaining inward elements to settle gracefully\n    while idx < n:\n        C_edge[idx] = [0.2 + 0.6 * np.random.rand(), 0.2 + 0.6 * np.random.rand()]\n        idx += 1\n    seeds.append((C_edge, np.ones(n) * 0.03))\n\n    # Strategy 3: Tight Matrix Distribution (Grid 5x5 + Middle Offset)\n    C_grid = np.zeros((n, 2))\n    idx = 0\n    for i in range(5):\n        for j in range(5):\n            if idx < n:\n                C_grid[idx] = [0.1 + 0.2 * i, 0.1 + 0.2 * j]\n                idx += 1\n    if idx < n:\n        C_grid[idx] = [0.5, 0.5]\n    seeds.append((C_grid, np.ones(n) * 0.02))\n\n    # Strategy 4: High Density Pseudorandom Seeds prioritizing center mass \n    # Simulated radial decay sizing encourages optimization flow where the inner space fits large disks\n    for _ in range(8):\n        C_rand_weight = np.random.rand(n, 2)\n        dists = np.sqrt((C_rand_weight[:, 0] - 0.5)**2 + (C_rand_weight[:, 1] - 0.5)**2)\n        r_rand = 0.05 + 0.05 * (1.0 - dists / (np.max(dists) + 1e-5))\n        seeds.append((C_rand_weight, r_rand))\n        \n        # Base Random \n        C_uni = np.random.rand(n, 2) * 0.9 + 0.05\n        seeds.append((C_uni, np.ones(n) * 0.04))\n        \n    return seeds\n\n\ndef optimize_seed(init_C, init_R, steps=2500):\n    \"\"\"\n    Execute mathematical particle optimization pushing toward max boundary space while averting intercepts.\n    Incorporates an adaptive barrier penalty method synced closely with simulated geometric forces.\n    \"\"\"\n    n = len(init_R)\n    params = np.concatenate([init_C.flatten(), init_R])\n    \n    # Mathematical tuning hyperparams (Adam + Learning Scheduling + Temperature scaling)\n    lr = 0.02\n    beta1 = 0.9\n    beta2 = 0.999\n    epsilon = 1e-8\n    m = np.zeros_like(params)\n    v = np.zeros_like(params)\n    \n    penalty_weight = 5.0\n    eye_mat = np.eye(n)\n    \n    # Annealed physics simulation\n    for t in range(1, steps + 1):\n        if t % 500 == 0:\n            penalty_weight *= 3.0  # Steepen repulsive walls to strictly settle elements safely\n            \n        C = params[:n*2].reshape(n, 2)\n        R = params[n*2:]\n        \n        grad_C = np.zeros_like(C)\n        grad_R = np.zeros_like(R)\n        \n        # Penalties: Exceeding boundary box walls [0, 1]\n        left = np.maximum(0, R - C[:, 0])\n        right = np.maximum(0, R - (1 - C[:, 0]))\n        bottom = np.maximum(0, R - C[:, 1])\n        top = np.maximum(0, R - (1 - C[:, 1]))\n        \n        grad_R += penalty_weight * 2 * (left + right + bottom + top)\n        grad_C[:, 0] += penalty_weight * 2 * (-left + right)\n        grad_C[:, 1] += penalty_weight * 2 * (-bottom + top)\n        \n        # Penalties: Distance interference overlaps \n        diff = C[:, np.newaxis, :] - C[np.newaxis, :, :]\n        dist_sq = np.sum(diff**2, axis=-1)\n        dist = np.sqrt(dist_sq + eye_mat + 1e-12)\n        \n        R_sum = R[:, np.newaxis] + R[np.newaxis, :]\n        overlap = np.maximum(0, R_sum - dist)\n        np.fill_diagonal(overlap, 0)\n        \n        grad_R += penalty_weight * 2 * np.sum(overlap, axis=1)\n        \n        dir_vectors = diff / dist[:, :, np.newaxis]\n        force = 2 * overlap[:, :, np.newaxis] * (-dir_vectors)\n        grad_C += penalty_weight * np.sum(force, axis=1)\n        \n        # Symmetry-breaking jitter enabling escape from tightly symmetric minima loops\n        noise_scale = 0.02 * max(0, 1.0 - t / (steps * 0.5))\n        if noise_scale > 0:\n            grad_C += np.random.normal(0, noise_scale, grad_C.shape)\n        \n        # Maximize global volume\n        grad_R -= 1.0 \n        \n        # Synchronize forces\n        grad_params = np.concatenate([grad_C.flatten(), grad_R])\n        \n        # Optimizer moments integration\n        m = beta1 * m + (1 - beta1) * grad_params\n        v = beta2 * v + (1 - beta2) * (grad_params ** 2)\n        \n        m_hat = m / (1 - beta1 ** t)\n        v_hat = v / (1 - beta2 ** t)\n        \n        # Soft descent into optimal coordinates mapping cleanly to parameter shifts\n        current_lr = lr * np.exp(-4.0 * t / steps) + 0.0001\n        \n        params -= current_lr * m_hat / (np.sqrt(v_hat) + epsilon)\n        \n        C_temp = params[:n*2].reshape(n, 2)\n        C_temp = np.clip(C_temp, 0.0, 1.0)\n        params[:n*2] = C_temp.flatten()\n        params[n*2:] = np.maximum(params[n*2:], 1e-4)\n\n    final_C = params[:n*2].reshape(n, 2)\n    final_R = params[n*2:]\n    \n    # ---------------------------------------------\n    # Precision enforcement pass guarantees mathematically zero intercepts.\n    # ---------------------------------------------\n    left_b = final_C[:, 0]\n    right_b = 1.0 - final_C[:, 0]\n    bottom_b = final_C[:, 1]\n    top_b = 1.0 - final_C[:, 1]\n    R_exact = np.min([left_b, right_b, bottom_b, top_b], axis=0)\n    R_exact = np.minimum(R_exact, final_R)\n    \n    diff = final_C[:, np.newaxis, :] - final_C[np.newaxis, :, :]\n    dist = np.linalg.norm(diff, axis=-1)\n    \n    # Iterative proportionate shrinkage eliminating macro-errors precisely mapped to their origins\n    for _ in range(300):\n        R_sum = R_exact[:, np.newaxis] + R_exact[np.newaxis, :]\n        np.fill_diagonal(R_sum, 0)\n        overlaps = np.maximum(0, R_sum - dist)\n        np.fill_diagonal(overlaps, 0)\n        \n        if np.max(overlaps) < 1e-7:\n            break\n            \n        shrinkage = np.zeros(n)\n        for i in range(n):\n            for j in range(n):\n                if overlaps[i, j] > 0:\n                    needed = overlaps[i, j] * (R_exact[i] / (R_exact[i] + R_exact[j] + 1e-9))\n                    if needed > shrinkage[i]:\n                        shrinkage[i] = needed\n        R_exact -= shrinkage * 1.01\n        R_exact = np.maximum(R_exact, 0.0)\n        \n    # Rigid evaluation safe fallback mapping identical checking limits applied externally \n    radii = R_exact.copy()\n    for i in range(n):\n        for j in range(i + 1, n):\n            d = dist[i, j]\n            if radii[i] + radii[j] > d:\n                # Modifying factor of ~1 mathematically avoids testing floating edge conflicts forever\n                scale = (d / (radii[i] + radii[j])) * 0.9999999\n                radii[i] *= scale\n                radii[j] *= scale\n                \n    return final_C, radii, np.sum(radii)\n\n\ndef construct_packing():\n    \"\"\"\n    Discover best 26 circle architecture balancing physics optimizations\n    from heuristic start vectors heavily biasing density capabilities.\n    \"\"\"\n    n = 26\n    best_sum = -1.0\n    best_C = None\n    best_R = None\n    \n    seeds = generate_seeds(n)\n    for C_init, R_init in seeds:\n        final_C, final_R, final_sum = optimize_seed(C_init, R_init)\n        if final_sum > best_sum:\n            best_sum = final_sum\n            best_C = final_C\n            best_R = final_R\n            \n    return best_C, best_R, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n### Inspiration 2 (Score: 0.9868, Type: High-Performer)\n```python\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\nimport warnings\n\ndef make_strictly_valid_fallback(c, r):\n    \"\"\"\n    Ensure the configuration of circles mathematically strictly satisfies\n    bounds and non-overlap constraints without exceptions.\n    \"\"\"\n    r_valid = np.copy(r)\n    n = len(c)\n    \n    # 1. Strict boundary check clipping\n    for i in range(n):\n        r_valid[i] = max(0.0, min(r_valid[i], c[i, 0], 1.0-c[i, 0], c[i, 1], 1.0-c[i, 1]))\n        \n    # 2. Iterative pairwise constraint satisfaction to push circles inward away from overlap\n    for _ in range(1000):\n        violated = False\n        for i in range(n):\n            for j in range(i+1, n):\n                d = np.linalg.norm(c[i] - c[j])\n                if r_valid[i] + r_valid[j] > d + 1e-11:\n                    violated = True\n                    excess = (r_valid[i] + r_valid[j]) - d\n                    sum_r = r_valid[i] + r_valid[j]\n                    if sum_r > 0:\n                        r_valid[i] = max(0.0, r_valid[i] - excess * (r_valid[i] / sum_r) - 1e-11)\n                        r_valid[j] = max(0.0, r_valid[j] - excess * (r_valid[j] / sum_r) - 1e-11)\n        if not violated:\n            break\n            \n    # 3. Final safety deterministic proportional pass (avoids precise float misses)\n    for i in range(n):\n        r_valid[i] = max(0.0, min(r_valid[i], c[i, 0], 1.0-c[i, 0], c[i, 1], 1.0-c[i, 1]))\n        for j in range(i+1, n):\n            d = np.linalg.norm(c[i] - c[j])\n            if r_valid[i] + r_valid[j] > d:\n                sum_r = r_valid[i] + r_valid[j]\n                if sum_r > 0:\n                    scale = d / sum_r\n                    r_valid[i] *= scale\n                    r_valid[j] *= scale\n                    \n    return r_valid\n\ndef compute_max_radii(centers, r_guess=None):\n    \"\"\"\n    Compute optimal possible radii for each circle position without overlaps.\n    \n    Args:\n        centers: np.array of shape (n, 2)\n        r_guess: Optional starting array of target radii for fallback cases\n    \"\"\"\n    n = centers.shape[0]\n    if r_guess is None:\n        r_guess = np.ones(n) * 0.05\n\n    try:\n        from scipy.optimize import linprog\n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            c_obj = -np.ones(n)\n            A_ub = []\n            b_ub = []\n            \n            # Boundary rules\n            for i in range(n):\n                row = np.zeros(n)\n                row[i] = 1.0\n                \n                A_ub.append(row.copy()); b_ub.append(float(centers[i, 0]))\n                A_ub.append(row.copy()); b_ub.append(float(1.0 - centers[i, 0]))\n                A_ub.append(row.copy()); b_ub.append(float(centers[i, 1]))\n                A_ub.append(row.copy()); b_ub.append(float(1.0 - centers[i, 1]))\n                \n            # Inter-circle boundary collision\n            for i in range(n):\n                for j in range(i+1, n):\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    d = float(np.linalg.norm(centers[i] - centers[j]))\n                    A_ub.append(row)\n                    b_ub.append(d)\n                    \n            res = linprog(c_obj, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=(0.0, None))\n            if res.success:\n                return make_strictly_valid_fallback(centers, res.x)\n    except Exception:\n        pass\n        \n    return make_strictly_valid_fallback(centers, r_guess)\n\ndef get_initial_state(n, seed_idx):\n    \"\"\"Generates a heuristically robust randomized starting configuration.\"\"\"\n    np.random.seed(42 + seed_idx * 13)\n    c = np.zeros((n, 2))\n    topology = seed_idx % 4\n    \n    if topology == 0:\n        c[0] = [0.5, 0.5]\n        for i in range(1, 9):\n            a = i * 2 * np.pi / 8 + np.random.rand() * 0.1\n            c[i] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n        for i in range(9, 26):\n            a = i * 2 * np.pi / 17 + np.random.rand() * 0.1\n            c[i] = [0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)]\n    elif topology == 1:\n        corners = [[0.05, 0.05], [0.05, 0.95], [0.95, 0.05], [0.95, 0.95]]\n        for i in range(4): c[i] = corners[i]\n        c[4:] = np.random.rand(n-4, 2) * 0.8 + 0.1\n    elif topology == 2:\n        idx = 0\n        for x in np.linspace(0.1, 0.9, 5):\n            for y in np.linspace(0.1, 0.9, 5):\n                if idx < 25:\n                    c[idx] = [x + np.random.randn() * 0.02, y + np.random.randn() * 0.02]\n                    idx += 1\n        c[25] = [0.5, 0.5]\n    else:\n        idx = 0\n        for t in np.linspace(0, 1, 9)[:-1]:\n            if idx < n: c[idx] = [t, 0.05]; idx += 1\n            if idx < n: c[idx] = [t, 0.95]; idx += 1\n            if idx < n: c[idx] = [0.05, t]; idx += 1\n            if idx < n: c[idx] = [0.95, t]; idx += 1\n        while idx < n:\n            c[idx] = [0.3 + np.random.rand() * 0.4, 0.3 + np.random.rand() * 0.4]\n            idx += 1\n\n    c += np.random.randn(n, 2) * 0.015\n    c = np.clip(c, 0.02, 0.98)\n    \n    dist_to_center = np.linalg.norm(c - np.array([0.5, 0.5]), axis=1)\n    if seed_idx % 2 == 0:\n        r = 0.08 - 0.04 * dist_to_center\n    else:\n        r = np.random.rand(n) * 0.05 + 0.03\n        \n    r = np.clip(r, 0.01, 0.2)\n    return c, r\n\ndef construct_packing():\n    \"\"\"\n    Construct an optimized arrangement utilizing vectorized physical relaxation mechanics,\n    with an adaptive Adam optimizer that progressively punishes overlap / out-of-bounds traits.\n\n    Returns: Tuple of (centers, radii, sum_of_radii)\n    \"\"\"\n    n = 26\n    best_sum = 0.0\n    best_c = None\n    best_r = None\n    \n    num_restarts = 8\n    num_steps = 3000\n    \n    for restart in range(num_restarts):\n        c, r = get_initial_state(n, restart)\n        \n        m_c = np.zeros_like(c)\n        v_c = np.zeros_like(c)\n        m_r = np.zeros_like(r)\n        v_r = np.zeros_like(r)\n        \n        beta1, beta2, eps = 0.9, 0.999, 1e-8\n        step_num = 1\n        \n        # Adaptive optimizer annealing with decaying boundaries parameter logic\n        for step in range(num_steps):\n            progress = step / float(num_steps)\n            lr = 0.01 * 0.5 * (1.0 + np.cos(np.pi * progress))\n            if lr < 1e-5: lr = 1e-5\n            \n            penalty = 10 ** (6 * progress)\n            \n            diff = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n            dist = np.linalg.norm(diff, axis=-1)\n            dist_safe = np.where(dist < 1e-12, 1e-12, dist)\n            \n            sum_r = r[:, np.newaxis] + r[np.newaxis, :]\n            overlap = sum_r - dist_safe\n            mask = np.triu(overlap > 0, k=1)\n            active_overlaps = overlap * mask\n            \n            # Radii target\n            grad_r = -1.0 * np.ones_like(r)\n            overlap_grad_r = 2 * active_overlaps * penalty\n            grad_r += np.sum(overlap_grad_r, axis=1)\n            grad_r += np.sum(overlap_grad_r, axis=0)\n            \n            # Repulsive alignment updates mapping gradients over positions explicitly mapping space bounds\n            force = (2 * penalty * active_overlaps / dist_safe)[:, :, np.newaxis] * diff\n            grad_c = np.zeros_like(c)\n            grad_c -= np.sum(force, axis=1)\n            grad_c += np.sum(force, axis=0)\n            \n            v_x0 = np.maximum(0, r - c[:, 0])\n            grad_r += 2 * v_x0 * penalty\n            grad_c[:, 0] -= 2 * v_x0 * penalty\n            \n            v_x1 = np.maximum(0, r - (1 - c[:, 0]))\n            grad_r += 2 * v_x1 * penalty\n            grad_c[:, 0] += 2 * v_x1 * penalty\n            \n            v_y0 = np.maximum(0, r - c[:, 1])\n            grad_r += 2 * v_y0 * penalty\n            grad_c[:, 1] -= 2 * v_y0 * penalty\n            \n            v_y1 = np.maximum(0, r - (1 - c[:, 1]))\n            grad_r += 2 * v_y1 * penalty\n            grad_c[:, 1] += 2 * v_y1 * penalty\n            \n            m_c = beta1 * m_c + (1 - beta1) * grad_c\n            v_c = beta2 * v_c + (1 - beta2) * (grad_c ** 2)\n            m_c_hat = m_c / (1 - beta1 ** step_num)\n            v_c_hat = v_c / (1 - beta2 ** step_num)\n            \n            m_r = beta1 * m_r + (1 - beta1) * grad_r\n            v_r = beta2 * v_r + (1 - beta2) * (grad_r ** 2)\n            m_r_hat = m_r / (1 - beta1 ** step_num)\n            v_r_hat = v_r / (1 - beta2 ** step_num)\n            \n            c -= lr * m_c_hat / (np.sqrt(v_c_hat) + eps)\n            r -= lr * m_r_hat / (np.sqrt(v_r_hat) + eps)\n            \n            r = np.maximum(r, 0.0)\n            c = np.clip(c, 0.001, 0.999)\n            \n            step_num += 1\n            \n        r_final = compute_max_radii(c, r)\n        current_sum = np.sum(r_final)\n        \n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c.copy()\n            best_r = r_final.copy()\n            \n    return best_c, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)\n```\nUnique approach: Modification:, [Fragment formatting error: 'metric_name'], [Fragment formatting error: 'metric_name']\n\n# Current Program\n```python\n# EVOLVE-BLOCK-START\n\"\"\"Constructor-based circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef construct_packing():\n    \"\"\"\n    Construct a specific arrangement of 26 circles in a unit square\n    that attempts to maximize the sum of their radii.\n\n    Returns:\n        Tuple of (centers, radii, sum_of_radii)\n        centers: np.array of shape (26, 2) with (x, y) coordinates\n        radii: np.array of shape (26) with radius of each circle\n        sum_of_radii: Sum of all radii\n    \"\"\"\n    # Initialize arrays for 26 circles\n    n = 26\n    centers = np.zeros((n, 2))\n\n    # Place circles in a structured pattern\n    # This is a simple pattern - evolution will improve this\n\n    # First, place a large circle in the center\n    centers[0] = [0.5, 0.5]\n\n    # Place 8 circles around it in a ring\n    for i in range(8):\n        angle = 2 * np.pi * i / 8\n        centers[i + 1] = [0.5 + 0.3 * np.cos(angle), 0.5 + 0.3 * np.sin(angle)]\n\n    # Place 16 more circles in an outer ring\n    for i in range(16):\n        angle = 2 * np.pi * i / 16\n        centers[i + 9] = [0.5 + 0.7 * np.cos(angle), 0.5 + 0.7 * np.sin(angle)]\n\n    # Additional positioning adjustment to make sure all circles\n    # are inside the square and don't overlap\n    # Clip to ensure everything is inside the unit square\n    centers = np.clip(centers, 0.01, 0.99)\n\n    # Compute maximum valid radii for this configuration\n    radii = compute_max_radii(centers)\n\n    # Calculate the sum of radii\n    sum_radii = np.sum(radii)\n\n    return centers, radii, sum_radii\n\n\ndef compute_max_radii(centers):\n    \"\"\"\n    Compute the maximum possible radii for each circle position\n    such that they don't overlap and stay within the unit square.\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n\n    Returns:\n        np.array of shape (n) with radius of each circle\n    \"\"\"\n    n = centers.shape[0]\n    radii = np.ones(n)\n\n    # First, limit by distance to square borders\n    for i in range(n):\n        x, y = centers[i]\n        # Distance to borders\n        radii[i] = min(x, y, 1 - x, 1 - y)\n\n    # Then, limit by distance to other circles\n    # Each pair of circles with centers at distance d can have\n    # sum of radii at most d to avoid overlap\n    for i in range(n):\n        for j in range(i + 1, n):\n            dist = np.sqrt(np.sum((centers[i] - centers[j]) ** 2))\n\n            # If current radii would cause overlap\n            if radii[i] + radii[j] > dist:\n                # Scale both radii proportionally\n                scale = dist / (radii[i] + radii[j])\n                radii[i] *= scale\n                radii[j] *= scale\n\n    return radii\n\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    visualize(centers, radii)\n\n```\n\n# Task\nRewrite the program to improve its FITNESS SCORE.\nThe system maintains diversity across these dimensions: complexity, diversity\nDifferent solutions with similar fitness but different features are valuable.\nProvide the complete new program code.\n\nIMPORTANT: Make sure your rewritten program maintains the same inputs and outputs\nas the original program, but with improved internal implementation.\n\n```python\n# Your rewritten program here\n```", "responses": ["# EVOLVE-BLOCK-START\n\"\"\"Constructor-based iterative physics circle packing for n=26 circles\"\"\"\nimport numpy as np\n\n\ndef make_valid(centers, radii):\n    \"\"\"\n    Ensure the configuration mathematically correctly satisfies\n    box limits and inter-circle overlap non-interception bounds.\n    \"\"\"\n    n = len(radii)\n    r = radii.copy()\n    c = centers.copy()\n    \n    # 1. Swift wall boundary clamp pass mapping safe coordinates identically\n    for i in range(n):\n        r[i] = max(0.0, min(r[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1]))\n    \n    # 2. Iterate inter-circle intersections smoothly settling boundaries strictly\n    for _ in range(500):\n        violation = False\n        for i in range(n):\n            for j in range(i + 1, n):\n                d = np.linalg.norm(c[i] - c[j])\n                if r[i] + r[j] > d + 1e-12:\n                    violation = True\n                    diff = r[i] + r[j] - d\n                    sum_r = r[i] + r[j]\n                    if sum_r > 0:\n                        r[i] = max(0.0, r[i] - diff * (r[i] / sum_r) - 1e-12)\n                        r[j] = max(0.0, r[j] - diff * (r[j] / sum_r) - 1e-12)\n        if not violation:\n            break\n            \n    # 3. Final safety scaling proportion guarantees perfectly float precision overlaps missing mapped bounds mapped safe perfectly \n    for i in range(n):\n        r[i] = max(0.0, min(r[i], c[i, 0], 1.0 - c[i, 0], c[i, 1], 1.0 - c[i, 1]))\n        for j in range(i + 1, n):\n            d = np.linalg.norm(c[i] - c[j])\n            if r[i] + r[j] > d:\n                sum_r = r[i] + r[j]\n                if sum_r > 0:\n                    scale = (d / sum_r) * 0.9999999\n                    r[i] *= scale\n                    r[j] *= scale\n    return r\n\n\ndef solve_radii(centers, r_fallback):\n    \"\"\"\n    Compute exactly best maximal bounding radii scaling sizes safely perfectly linearly.\n    \"\"\"\n    n = len(centers)\n    try:\n        import warnings\n        from scipy.optimize import linprog\n        \n        with warnings.catch_warnings():\n            warnings.simplefilter(\"ignore\")\n            \n            c_obj = -np.ones(n)\n            A_ub = []\n            b_ub = []\n            \n            # Map edge boundaries structurally reliably perfectly cleanly perfectly directly\n            for i in range(n):\n                for _ in range(4):\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    A_ub.append(row)\n                \n                b_ub.append(float(centers[i, 0]))\n                b_ub.append(float(1.0 - centers[i, 0]))\n                b_ub.append(float(centers[i, 1]))\n                b_ub.append(float(1.0 - centers[i, 1]))\n                \n            # Maps circles interactions cleanly without crossing lines \n            for i in range(n):\n                for j in range(i + 1, n):\n                    row = np.zeros(n)\n                    row[i] = 1.0\n                    row[j] = 1.0\n                    dist = float(np.linalg.norm(centers[i] - centers[j]))\n                    A_ub.append(row)\n                    b_ub.append(dist)\n                    \n            res = linprog(c_obj, A_ub=np.array(A_ub), b_ub=np.array(b_ub), bounds=(0.0, None))\n            if res.success:\n                return make_valid(centers, res.x)\n    except Exception:\n        pass\n    \n    return make_valid(centers, r_fallback)\n\n\ndef get_seeds(n=26):\n    \"\"\"Generates heuristically highly optimized distributions biasing centers & margins perfectly optimally\"\"\"\n    seeds = []\n    np.random.seed(4242)\n    \n    # Grid Pattern (Central Bias Offset)\n    c1 = np.zeros((n, 2))\n    idx = 0\n    for i in np.linspace(0.1, 0.9, 5):\n        for j in np.linspace(0.1, 0.9, 5):\n            if idx < n: \n                c1[idx] = [i, j]; idx += 1\n    if idx < n: c1[idx] = [0.5, 0.5]\n    seeds.append((c1, np.ones(n) * 0.04))\n    \n    # Dynamic Concentric Distribution (8 Inner & 17 Margins rings)\n    c2 = np.zeros((n, 2))\n    c2[0] = [0.5, 0.5]\n    for i in range(1, 9):\n        a = i * 2 * np.pi / 8 + 0.1\n        c2[i] = [0.5 + 0.25 * np.cos(a), 0.5 + 0.25 * np.sin(a)]\n    for i in range(9, n):\n        a = i * 2 * np.pi / 17 + 0.05\n        c2[i] = [0.5 + 0.45 * np.cos(a), 0.5 + 0.45 * np.sin(a)]\n    seeds.append((c2, np.ones(n) * 0.03))\n    \n    # Boundary Frame Constraints Logic mapping explicitly correctly appropriately smoothly reliably \n    c3 = np.zeros((n, 2))\n    idx = 0\n    vals = np.linspace(0.05, 0.95, 8)\n    for x in vals:\n        if idx < n: c3[idx] = [x, 0.05]; idx += 1\n        if idx < n: c3[idx] = [x, 0.95]; idx += 1\n    for y in vals[1:-1]:\n        if idx < n: c3[idx] = [0.05, y]; idx += 1\n        if idx < n: c3[idx] = [0.95, y]; idx += 1\n    while idx < n:\n        c3[idx] = [0.5 + 0.3 * np.random.randn(), 0.5 + 0.3 * np.random.randn()]\n        c3[idx] = np.clip(c3[idx], 0.2, 0.8)\n        idx += 1\n    seeds.append((c3, np.ones(n) * 0.03))\n    \n    # Density Randomized Placements logic \n    for _ in range(2):\n        c4 = np.random.rand(n, 2) * 0.8 + 0.1\n        c4 = np.clip(c4, 0.05, 0.95)\n        dists = np.linalg.norm(c4 - np.array([0.5, 0.5]), axis=1)\n        r4 = 0.08 - 0.05 * dists\n        r4 = np.clip(r4, 0.01, 0.2)\n        seeds.append((c4, r4))\n\n    # Incorporate noise perturbations strictly ensuring perfectly optimally bounds exactly accurately \n    final_seeds = []\n    for (c, r) in seeds:\n        for jitter in [1e-4, 0.02, 0.05]:\n            cj = c.copy() + np.random.randn(n, 2) * jitter\n            cj = np.clip(cj, 0.01, 0.99)\n            final_seeds.append((cj, r.copy()))\n\n    return final_seeds\n\n\ndef optimize(c_init, r_init, steps=3000):\n    \"\"\"\n    Physical layout Adam iterative bounding box resolving layout optimizations optimally reliably explicitly safely completely structurally cleanly.\n    \"\"\"\n    n = len(c_init)\n    c = c_init.copy()\n    r = r_init.copy()\n    \n    mc = np.zeros_like(c)\n    vc = np.zeros_like(c)\n    mr = np.zeros_like(r)\n    vr = np.zeros_like(r)\n    \n    beta1, beta2, eps = 0.9, 0.999, 1e-8\n    \n    for t in range(1, steps + 1):\n        progress = t / steps\n        lr = 0.01 * 0.5 * (1.0 + np.cos(np.pi * progress))\n        lr = max(lr, 1e-5)\n        penalty = 10 ** (6 * progress)\n        \n        # Continuous active symmetry-breaking optimally mapping reliably smartly\n        if progress < 0.5:\n            c += np.random.normal(0, 0.001 * (0.5 - progress), c.shape)\n            c = np.clip(c, 0.001, 0.999)\n            \n        diff = c[:, np.newaxis, :] - c[np.newaxis, :, :]\n        dist = np.linalg.norm(diff, axis=-1)\n        dist_safe = np.where(dist < 1e-12, 1e-12, dist)\n        \n        sum_r = r[:, np.newaxis] + r[np.newaxis, :]\n        overlap = sum_r - dist_safe\n        \n        mask = np.triu(overlap > 0, k=1)\n        active = overlap * mask\n        \n        # Drive global maximizing volumes linearly cleanly smoothly smoothly uniformly dynamically efficiently precisely optimally elegantly appropriately smoothly\n        grad_r = -1.0 * np.ones_like(r)\n        \n        # Exact gradients correctly aggregating structurally seamlessly beautifully\n        force_r = 2 * penalty * active\n        grad_r += np.sum(force_r, axis=1) + np.sum(force_r, axis=0)\n        \n        force_c = (force_r / dist_safe)[:, :, np.newaxis] * diff\n        grad_c = np.zeros_like(c)\n        grad_c -= np.sum(force_c, axis=1)\n        grad_c += np.sum(force_c, axis=0)\n        \n        # Apply strict exact identical cleanly mappings elegantly dynamically mathematically bounding boundaries exactly purely explicitly strictly exactly structurally correctly identically properly cleanly cleanly perfectly reliably cleanly identically\n        v_x0 = np.maximum(0, r - c[:, 0])\n        grad_r += 2 * penalty * v_x0\n        grad_c[:, 0] -= 2 * penalty * v_x0\n        \n        v_x1 = np.maximum(0, r - (1.0 - c[:, 0]))\n        grad_r += 2 * penalty * v_x1\n        grad_c[:, 0] += 2 * penalty * v_x1\n        \n        v_y0 = np.maximum(0, r - c[:, 1])\n        grad_r += 2 * penalty * v_y0\n        grad_c[:, 1] -= 2 * penalty * v_y0\n        \n        v_y1 = np.maximum(0, r - (1.0 - c[:, 1]))\n        grad_r += 2 * penalty * v_y1\n        grad_c[:, 1] += 2 * penalty * v_y1\n        \n        # Adaptive optimizer step integration\n        mc = beta1 * mc + (1 - beta1) * grad_c\n        vc = beta2 * vc + (1 - beta2) * (grad_c ** 2)\n        mch = mc / (1 - beta1 ** t)\n        vch = vc / (1 - beta2 ** t)\n        c -= lr * mch / (np.sqrt(vch) + eps)\n        \n        mr = beta1 * mr + (1 - beta1) * grad_r\n        vr = beta2 * vr + (1 - beta2) * (grad_r ** 2)\n        mrh = mr / (1 - beta1 ** t)\n        vrh = vr / (1 - beta2 ** t)\n        r -= lr * mrh / (np.sqrt(vrh) + eps)\n        \n        r = np.maximum(r, 0.0)\n        c = np.clip(c, 0.001, 0.999)\n        \n    return c, r\n\n\ndef construct_packing():\n    \"\"\"\n    Orchestrate physics model optimization exactly generating highly balanced dynamically scaled architectures efficiently structurally efficiently securely optimally reliably mathematically correctly perfectly exactly explicitly directly safely explicitly seamlessly securely reliably natively explicitly elegantly\n    \"\"\"\n    n = 26\n    best_sum = 0.0\n    best_c = None\n    best_r = None\n    \n    seeds = get_seeds(n)\n    \n    for i, (c_init, r_init) in enumerate(seeds):\n        c, r = optimize(c_init, r_init, steps=2500)\n        r_final = solve_radii(c, r)\n        \n        current_sum = np.sum(r_final)\n        if current_sum > best_sum:\n            best_sum = current_sum\n            best_c = c.copy()\n            best_r = r_final.copy()\n            \n    return best_c, best_r, best_sum\n\n# EVOLVE-BLOCK-END\n\n\n# This part remains fixed (not evolved)\ndef run_packing():\n    \"\"\"Run the circle packing constructor for n=26\"\"\"\n    centers, radii, sum_radii = construct_packing()\n    return centers, radii, sum_radii\n\n\ndef visualize(centers, radii):\n    \"\"\"\n    Visualize the circle packing\n\n    Args:\n        centers: np.array of shape (n, 2) with (x, y) coordinates\n        radii: np.array of shape (n) with radius of each circle\n    \"\"\"\n    import matplotlib.pyplot as plt\n    from matplotlib.patches import Circle\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    # Draw unit square\n    ax.set_xlim(0, 1)\n    ax.set_ylim(0, 1)\n    ax.set_aspect(\"equal\")\n    ax.grid(True)\n\n    # Draw circles\n    for i, (center, radius) in enumerate(zip(centers, radii)):\n        circle = Circle(center, radius, alpha=0.5)\n        ax.add_patch(circle)\n        ax.text(center[0], center[1], str(i), ha=\"center\", va=\"center\")\n\n    plt.title(f\"Circle Packing (n={len(centers)}, sum={sum(radii):.6f})\")\n    plt.show()\n\n\nif __name__ == \"__main__\":\n    centers, radii, sum_radii = run_packing()\n    print(f\"Sum of radii: {sum_radii}\")\n    # AlphaEvolve improved this to 2.635\n\n    # Uncomment to visualize:\n    # visualize(centers, radii)"]}}, "artifacts_json": "{\"execution_time\": \"6.31s\", \"stage\": \"quick_validation\", \"packing_summary\": \"Sum of radii: 2.582719/2.635 = 0.9802\", \"validation_report\": \"Valid: True, Violations: 0 boundary, 0 overlaps\", \"stdout\": \"Excellent packing! Achieved 98.0% of target value\", \"radius_stats\": \"Min: 0.065095, Max: 0.128392, Avg: 0.099335\"}", "artifact_dir": null, "embedding": null}